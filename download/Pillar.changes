----QUIT----2023-09-15T14:43:37.295888+02:00 Pharo11-SNAPSHOT-64bit-ea9092e.image priorSource: 0!----QUIT----2023-09-15T14:44:15.282742+02:00 Pharo11-SNAPSHOT-64bit-ea9092e.image priorSource: 0!!BaselineOfPillarApp methodsFor: 'baselines'!baseline: spec	<baseline>	spec for: #common do: [		self			chrysal: spec;			containersPropertyEnvironment: spec;			microdown: spec;			mustache: spec;			petitParser2: spec.		spec			package: 'Pillar-MicrodownToPillarConverter' with: [ spec requires: #( 'Pillar-Core' 'Microdown' ) ];			package: 'Pillar-Microdown'			with: [ spec requires: #( 'Pillar-MicrodownToPillarConverter' 'Pillar-Model' 'Pillar-ExporterCore' 'Pillar-Tests-ExporterCore' ) ];			package: 'Pillar-ExporterMicrodown' with: [ spec requires: #( 'Microdown' 'Pillar-PetitPillar' 'Pillar-ExporterCore' ) ];			package: 'Pillar-Core';			package: 'Pillar-Tests-Core' with: [ spec requires: #( 'Pillar-Core' 'Pillar-ExporterText' 'Pillar-ExporterPillar' 'Pillar-PetitPillar' ) ];			package: 'Pillar-Model' with: [ spec requires: #( 'Pillar-Core' ) ];			package: 'Pillar-Chrysal-Generator' with: [ spec requires: #( 'Chrysal' ) ];			package: 'Pillar-Cli' with: [ spec requires: #( 'Pillar-ExporterCore' 'Pillar-Chrysal' ) ];			package: 'Pillar-Chrysal' with: [ spec requires: #( 'Pillar-ExporterCore' ) ];			package: 'Pillar-ExporterAsciiDoc' with: [ spec requires: #( 'Pillar-ExporterCore' ) ];			package: 'Pillar-ExporterBeamer' with: [ spec requires: #( 'Pillar-ExporterLaTeX' ) ];			package: 'Pillar-ExporterCore' with: [ spec requires: #( 'Pillar-Model' 'ContainersPropertyEnvironment' ) ];			package: 'Pillar-ExporterDeckJS' with: [ spec requires: #( 'Pillar-ExporterHTML' ) ];			package: 'Pillar-ExporterEPub' with: [ spec requires: #( 'Pillar-ExporterCore' 'Pillar-ExporterHTML' ) ];			package: 'Pillar-Tests-ExporterEPub' with: [ spec requires: #( 'Pillar-ExporterEPub' 'Pillar-Tests-ExporterCore' 'Pillar-Tests-ExporterHTML' ) ];			package: 'Pillar-ExporterHTML' with: [ spec requires: #( 'Pillar-ExporterCore' ) ];			package: 'Pillar-ExporterLaTeX' with: [ spec requires: #( 'Pillar-ExporterCore' 'Pillar-ExporterPillar' ) ];			package: 'Pillar-ExporterMarkdown' with: [ spec requires: #( 'Pillar-ExporterCore' 'Pillar-ExporterHTML' ) ];			package: 'Pillar-ExporterPillar' with: [ spec requires: #( 'Pillar-ExporterCore' 'Pillar-PetitPillar' ) ];			package: 'Pillar-ExporterText' with: [ spec requires: #( 'Pillar-ExporterCore' ) ];			package: 'Pillar-CodeBlockEvaluator' with: [ spec requires: #( 'Pillar-Core' ) ];			package: 'Pillar-PetitPillar' with: [ spec requires: #( 'PetitParser2Core' 'Pillar-Model' ) ];			package: 'Pillar-Pharo-Tools' with: [ spec requires: #( 'Pillar-Model' 'All exporters' ) ];			package: 'Pillar-Project' with: [ spec requires: #( 'Pillar-Model' 'All exporters' ) ];			package: 'Pillar-BookTester' with: [ spec requires: #( 'Pillar-Project' ) ];			package: 'Pillar-Tests-Cli' with: [ spec requires: #( 'Pillar-Cli' ) ];			package: 'Pillar-Tests-ExporterAsciiDoc' with: [ spec requires: #( 'Pillar-ExporterAsciiDoc' 'Pillar-Tests-ExporterCore' ) ];			package: 'Pillar-Tests-ExporterBeamer' with: [ spec requires: #( 'Pillar-ExporterBeamer' 'Pillar-Tests-ExporterLaTeX' ) ];			package: 'Pillar-Tests-ExporterCore' with: [ spec requires: #( 'Pillar-Tests-Model' 'Pillar-ExporterCore' ) ];			package: 'Pillar-Tests-ExporterDeckJS' with: [ spec requires: #( 'Pillar-ExporterDeckJS' 'Pillar-Tests-ExporterHTML' ) ];			package: 'Pillar-Tests-ExporterHTML' with: [ spec requires: #( 'Pillar-ExporterHTML' 'Pillar-Tests-ExporterCore' ) ];			package: 'Pillar-Tests-ExporterLaTeX' with: [ spec requires: #( 'Pillar-ExporterLaTeX' 'Pillar-Tests-ExporterCore' ) ];			package: 'Pillar-Tests-ExporterMarkdown' with: [ spec requires: #( 'Pillar-ExporterMarkdown' 'Pillar-Tests-ExporterCore' 'Pillar-Tests-ExporterHTML' ) ];			package: 'Pillar-Tests-ExporterPillar' with: [ spec requires: #( 'Pillar-ExporterPillar' 'Pillar-Tests-ExporterCore' ) ];			package: 'Pillar-Tests-ExporterText' with: [ spec requires: #( 'Pillar-ExporterText' 'Pillar-Tests-ExporterCore' ) ];			package: 'Pillar-Tests-Model'			with: [ spec requires: #( 'Pillar-Model' 'Pillar-ExporterPillar' 'Pillar-ExporterText' 'Pillar-Core' 'Pillar-Tests-PetitPillar' ) ];			package: 'Pillar-Tests-Model-PetitPillar'			with: [ spec requires: #( 'Pillar-Core' 'Pillar-Tests-Core' 'Pillar-Tests-Model' 'Pillar-PetitPillar' 'Pillar-Model' 'Pillar-Tests-PetitPillar' ) ];			package: 'Pillar-Tests-Model-ExporterText' with: [ spec requires: #( 'Pillar-Core' 'Pillar-PetitPillar' 'Pillar-Tests-ExporterText' ) ];			package: 'Pillar-Tests-Model-ExporterPillar' with: [ spec requires: #( 'Pillar-Model' 'Pillar-PetitPillar' 'Pillar-Tests-ExporterPillar' ) ];			package: 'Pillar-Tests-PetitPillar' with: [ spec requires: #( 'PetitParser2Core' 'Pillar-PetitPillar' ) ];			package: 'Pillar-Tests-BookTester' with: [ spec requires: #( 'Pillar-BookTester' ) ];			package: 'Pillar-Tests-Project' with: [ spec requires: #( 'Pillar-Project' ) ];			package: 'Pillar-Tests-Integration' with: [ spec requires: #( 'Pillar-Project' ) ].		spec			group: 'ALL' with: #( 'All tests' 'All but tests' );			group: 'All but tests'			with: #( 'All exporters' 'Pillar-Cli' 'Pillar-Pharo-Tools' 'parser' 'Pillar-Project' 'Pillar-BookTester' 'Pillar-CodeBlockEvaluator' );			group: 'All exporter tests'			with: #( 'html exporter tests' 'latex exporter tests' 'beamer exporter tests' 'deckjs exporter tests' 'markdown exporter tests' 'pillar exporter tests'				   'text exporter tests' 'asciidoc exporter tests' 'ePub exporter tests' );			group: 'All exporters'			with: #( 'html exporter' 'latex exporter' 'beamer exporter' 'deckjs exporter' 'markdown exporter' 'pillar exporter' 'text exporter' 'asciidoc exporter'				   'ePub exporter' );			group: 'All tests'			with:				#( 'All exporter tests' 'Pillar-Tests-Model' 'Pillar-Tests-ExporterCore' #'Pillar-Tests-Cli' 'parser tests' 'Pillar-Tests-Project' 'Pillar-Tests-Integration' );			group: 'asciidoc exporter' with: #( #'Pillar-ExporterAsciiDoc' );			group: 'asciidoc exporter tests' with: #( #'Pillar-Tests-ExporterAsciiDoc' 'ePub exporter' );			group: 'beamer exporter' with: #( 'Pillar-ExporterBeamer' );			group: 'beamer exporter tests' with: #( 'Pillar-Tests-ExporterBeamer' );			group: 'deckjs exporter' with: #( 'Pillar-ExporterDeckJS' );			group: 'deckjs exporter tests' with: #( 'Pillar-Tests-ExporterDeckJS' );			group: 'ePub exporter' with: #( #'Pillar-ExporterEPub' );			group: 'ePub exporter tests' with: #( #'Pillar-Tests-ExporterEPub' );			group: 'html exporter' with: #( 'Pillar-ExporterHTML' );			group: 'html exporter tests' with: #( 'Pillar-Tests-ExporterHTML' );			group: 'booktester' with: #( 'Pillar-BookTester' );			group: 'booktester tests' with: #( 'Pillar-Tests-BookTester' );			group: 'latex exporter' with: #( 'Pillar-ExporterLaTeX' );			group: 'latex exporter tests' with: #( 'Pillar-Tests-ExporterLaTeX' );			group: 'markdown exporter' with: #( 'Pillar-ExporterMarkdown' 'parser' );			group: 'markdown exporter tests' with: #( 'Pillar-Tests-ExporterMarkdown' );			group: 'parser' with: #( 'Pillar-PetitPillar' );			group: 'parser tests' with: #( 'Pillar-Tests-PetitPillar' );			group: 'pillar exporter' with: #( 'Pillar-ExporterPillar' );			group: 'pillar exporter tests' with: #( 'Pillar-Tests-ExporterPillar' );			group: 'text exporter' with: #( 'Pillar-ExporterText' );			group: 'text exporter tests' with: #( 'Pillar-Tests-ExporterText' ) ].	spec for: #windows do: [		self processWrapper: spec.		spec package: 'Pillar-Project' with: [ spec requires: 'ProcessWrapper' ] ].	spec for: #( unix osx ) do: [		self osSubProcess: spec.		spec package: 'Pillar-Project' with: [ spec requires: 'OSSubprocess' ] ]! !!BaselineOfPillarApp methodsFor: 'dependencies'!chrysal: spec	spec baseline: 'Chrysal' with: [ spec repository: 'github://Ducasse/Chrysal:v1.0.0/src' ]! !!BaselineOfPillarApp methodsFor: 'dependencies'!containersPropertyEnvironment: spec	spec baseline: 'ContainersPropertyEnvironment' with: [ spec repository: 'github://Ducasse/Containers-PropertyEnvironment:v1.0.0' ]! !!BaselineOfPillarApp methodsFor: 'baselines'!customProjectAttributes    "Edit to return a collection of any custom attributes e.g. for conditional loading: Array with: #'Condition1' with: #'Condition2.	For more information see: http://code.google.com/p/metacello/wiki/CustomProjectAttrributes "	| attributes |	attributes := OrderedCollection new.	OSPlatform current isWindows ifTrue: [ attributes add: #windows ].	OSPlatform current isUnix    ifTrue: [ attributes add: #unix ].	OSPlatform current isMacOS   ifTrue: [ attributes add: #osx ].	^ attributes asArray! !!BaselineOfPillarApp methodsFor: 'dependencies'!microdown: spec	spec baseline: 'Microdown' with: [ spec repository: 'github://pillar-markup/Microdown:v2.3.1/src' ]! !!BaselineOfPillarApp methodsFor: 'dependencies'!mustache: spec	spec baseline: 'Mustache' with: [		spec			repository: 'github://noha/mustache:v1.0/repository';			loads: #( 'Core' 'Tests' ) ]! !!BaselineOfPillarApp methodsFor: 'dependencies'!osSubProcess: spec	spec baseline: 'OSSubprocess' with: [ spec repository: 'github://pharo-contributions/OSSubprocess:v1.4.0/repository' ]! !!BaselineOfPillarApp methodsFor: 'dependencies'!petitParser2: spec	spec baseline: 'PetitParser2Core' with: [ spec repository: 'github://kursjan/petitparser2' ]! !!BaselineOfPillarApp methodsFor: 'dependencies'!processWrapper: spec	spec configuration: 'ProcessWrapper' with: [		spec			versionString: '1.2';			repository: 'http://smalltalkhub.com/mc/hernan/ProcessWrapper/main' ]! !"BaselineOfPillarApp"!!BaselineOfOSSubprocess commentStamp: '' prior: 0!I am a baseline of OSSubprocess. OSSubprocess is a software project that allows the user to spawn Operatying System processes from within Pharo language. The main usage of forking external OS processes is to be able to execute OS commands (.e.g cat, ls, ps, cp, etc) as well as arbitrary shell scripts (.e.g /etc/myShellScript.sh) from Pharo.An important part of OSSubprocess is how to manage standard streams (stdin, stdout and stderr) and how to provide an API for reading and writing from them at the language level.For more details see: https://github.com/marianopeck/OSSubprocess!!BaselineOfOSSubprocess methodsFor: 'baseline'!baseline: spec	<baseline>	spec		for: #pharo		do: [							spec				package: 'OldFileStream';				package: 'OSSubprocess' with: [ spec requires: #('FFICHeaderExtractor' 'OldFileStream') ];				package: 'OSSubprocess-Tests-Unit' with: [ spec requires: #('OSSubprocess' 'Unicode') ];				package: 'OSSubprocess-Tests-Stress' with: [ spec requires: 'OSSubprocess-Tests-Unit' ].			spec baseline: 'FFICHeaderExtractor' with: [    			spec repository: 'github://pharo-contributions/FFICHeaderExtractor:v1.0.2/repository' ].			spec baseline: 'Unicode' with: [				spec repository: 'github://pharo-contributions/pharo-unicode:v1.1.0/src' ].			spec				group: 'Core' with: #( 'OSSubprocess' );				group: 'Tests' with: #( 'OSSubprocess-Tests-Unit' 'OSSubprocess-Tests-Stress' ).		]! !"BaselineOfOSSubprocess"!!ManifestBaselineOfPetitParserCore commentStamp: '' prior: 0!Baseline with minimal viable dependencies.!!BaselineOfPetitParser2Core methodsFor: 'baselines'!baseline: spec	<baseline>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec description: 'PetitParser2Core'.		spec 			package: 'PetitParser2';			package: 'PetitParser2-Tests' with: [ 				spec requires: #('PetitParser2') ];			package: 'PetitParser2-Validation' with: [ 				spec requires: #('PetitParser2') ];			package: 'PetitParser2-Validation-Tests' with: [ 				spec requires: #('PetitParser2-Validation' 'PetitParser2-Tests') ];			package: 'PetitParser2-Benchmarks' with: [ 				spec requires: #('PetitParser2' 'PetitParser2-Validation') ]	]! !"BaselineOfPetitParser2Core"!!BaselineOfMicrodown methodsFor: 'baselines' prior: 18219792!baseline: spec	<baseline>	spec for: #common do: [				self xmlParserHtml: spec.						spec			package: #Microdown;			package: #'Microdown-Tests'				with: [ spec requires: #( #Microdown ) ];					package: #'Microdown-Pharo-Tools'				with: [ spec requires: #( #Microdown ) ];							package: #'Microdown-RichTextComposer'				with: [ spec requires: #( #Microdown ) ];			package: #'Microdown-RichTextComposer-Tests'				with: [ spec requires: #( #'Microdown-RichTextComposer' ) ];			package: #'Microdown-MathFlaky-Tests'				with: [ spec requires: #( #'Microdown-RichTextComposer-Tests' ) ];			package: #'Microdown-RichTextPresenter'				with: [ spec requires: #( #Microdown ) ];			package: #'Microdown-RichTextPresenter-Tests'				with: [ spec requires: #( #'Microdown-RichTextPresenter' ) ];							package: #'Microdown-DocumentBrowser'				with: [ spec requires: #( #Microdown #'Microdown-RichTextPresenter') ];			package: #'Microdown-DocumentBrowser-Tests'				with: [ spec requires: #( #'Microdown-DocumentBrowser' ) ];			package: #'Microdown-Transformer'				with: [ spec requires: #( #Microdown ) ];			package: #'Microdown-Transformer-Tests'				with: [ spec requires: #( #'Microdown-Transformer' ) ];			package: #'Microdown-Evaluator'				with: [ spec requires: #( #'Microdown-Transformer' ) ];			package: #'Microdown-Evaluator-Tests'				with: [ spec requires: #( #'Microdown-Evaluator') ];						package: #'Microdown-HTMLExporter'				with: [ spec requires: #( #Microdown #'Microdown-LaTeXExporter') ];			package: #'Microdown-HTMLExporter-Tests'				with: [ spec requires: #( #'Microdown-HTMLExporter' 'Microdown-Tests' 'XMLParserHTML') ];									package: #'Microdown-LaTeXExporter'				with: [ spec requires: #( #Microdown ) ];							package: #'Microdown-LaTeXExporter-Tests'				with: [ spec requires: #( #'Microdown-LaTeXExporter' #'Microdown-Tests') ];			package: #'Microdown-BeamerExporter'				with: [ spec requires: #( #'Microdown-LaTeXExporter' ) ];							package: #'Microdown-BeamerExporter-Tests'				with: [ spec requires: #( #'Microdown-LaTeXExporter-Tests') ];			package: #'Microdown-PrettyPrinter'				with: [ spec requires: #( #Microdown ) ];						package: #'Microdown-PrettyPrinter-Tests'				with: [ spec requires: #( #'Microdown-PrettyPrinter' #'Microdown-Tests') ].							"I do not want group without tests for now"		spec			group: 'Core' with: #('Microdown');			group: 'Tests' with: #('Core' 'Microdown-Tests');			group: 'RichText' with: #('Core' 'Microdown-RichTextComposer' );			group: 'Extensions' with: #(				#'Microdown-RichTextPresenter'				#'Microdown-RichTextPresenter-Tests'				#'Microdown-DocumentBrowser'				#'Microdown-DocumentBrowser-Tests' 				#'Microdown-Evaluator'				#'Microdown-Evaluator-Tests'				#'Microdown-PrettyPrinter'				#'Microdown-PrettyPrinter-Tests'				#'Microdown-HTMLExporter'				#'Microdown-HTMLExporter-Tests'								#'Microdown-LaTeXExporter'				#'Microdown-LaTeXExporter-Tests'				#'Microdown-Transformer'				#'Microdown-Transformer-Tests');			group: 'All' with: #('Core' 'Tests' 'Extensions' 'Microdown-Pharo-Tools' 'RichText') ]! !"BaselineOfMicrodown"!!BaselineOfMustache methodsFor: 'baselines' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!baseline: spec	<baseline>	spec for: #'common' do: [		spec project: 'JSON' with: [				spec					className: #ConfigurationOfJSON;					versionString: #'stable';					loads: #('default' );					repository: 'http://smalltalkhub.com/mc/PharoExtras/JSON/main/' ].		spec 			package: 'Mustache-Core';			package: 'Mustache-Tests' with: [				spec requires: #('Mustache-Core' ). ];			package: #'Mustache-Cli' with: [				spec requires: #('JSON' ). ].		spec 			group: 'Core' with: #('Mustache-Core' );			group: 'Tests' with: #('Mustache-Tests' );			group: 'default' with: #('Core' 'Tests' #'Mustache-Cli' ). ].! !"BaselineOfMustache"!!BaselineOfChrysal commentStamp: '' prior: 0!Now introduce Chrysal-Runtime package containing a simple class whose other configurations will be subclass of. !!BaselineOfChrysal methodsFor: 'baselines'!baseline: spec	<baseline>	spec		baseline: 'ContainersPropertyEnvironment'		with: [ spec repository: 'github://Ducasse/Containers-PropertyEnvironment:v1.0.0' ].	spec		for: #pharo		do: [ 			spec				package: 'Chrysal-Runtime' with: [ spec requires: #('ContainersPropertyEnvironment') ].			spec				package: 'Chrysal-Tests'				with: [ spec requires: #('Chrysal-Runtime' 'Chrysal') ].			spec				package: 'Chrysal'				with: [ spec requires: #('Chrysal-Runtime') ] ]! !"BaselineOfChrysal"!!BaselineOfContainersPropertyEnvironment methodsFor: 'baselines'!baseline: spec	<baseline>	spec for: #pharo do: [				spec 			package: 'Containers-PropertyEnvironment'.		]! !"BaselineOfContainersPropertyEnvironment"!!BaselineOfXMLParserHTML commentStamp: '' prior: 0!Baseline for Parsers for HTML that convert possibly malformed HTML into well-formed XML (see https://github.com/pharo-contributions/XML-XMLParserHTML)!!BaselineOfXMLParserHTML methodsFor: 'baseline'!baselineOf: spec	<baseline>	spec		for: #common		do: [						self xmlParserOn: spec.								"Packages"			spec 				package: 'XML-ParserHTML-Core' with: [ spec requires: #('XMLParser') ];				package: 'XML-ParserHTML-Tests' with: [ spec requires: #('XMLParser Tests' 'XML-ParserHTML-Core') ].						"Groups"			spec				group: 'Core' with: #('XML-ParserHTML-Core');				group: 'Tools' with: #('XMLParser Tools'); 				group: 'Tests' with: #('XML-ParserHTML-Tests');					group: 'all' with: #('Core' 'Tools' 'Tests');				group: 'default' with: #('all')		]! !!BaselineOfXMLParserHTML methodsFor: 'baseline'!xmlParserOn: spec	spec		baseline: 'XMLParser'      with: [ 			spec				loads: #('Core');				repository: 'github://pharo-contributions/XML-XMLParser:3.5.x/src' ]. 					spec 		project: 'XMLParser Tests' copyFrom: 'XMLParser' with: [ spec loads: #('Tests') ]; 			project: 'XMLParser Tools' copyFrom: 'XMLParser' with: [ spec loads: #('Tools') ] ! !"BaselineOfXMLParserHTML"!!BaselineOfXMLParser commentStamp: '' prior: 0!Baseline for XML Parser (https://github.com/pharo-contributions/XML-XMLParser)!!BaselineOfXMLParser methodsFor: 'baselines'!baselineOf: spec	<baseline>	spec		for: #common		do: [						self 				bitmapCharacterSetOn: spec;				orderPreservingDictionaryOn: spec;				xmlWriterOn: spec.								"Packages"			spec 				package: 'XML-Parser' with: [ spec requires: #('OrderPreservingDictionary' 'BitmapCharacterSet') ];				package: 'XML-Parser-Tests' with: [ spec requires: #('XML-Parser' 'OrderPreservingDictionary Tests' 'BitmapCharacterSet Tests') ];				package: 'XML-Parser-Tests-Conformance' with: [ spec requires: #('XML-Parser' 'XMLWriter Tests' 'XML-Parser-Tests') ];				package: 'XML-Parser-GTExtensions' with: [ spec requires: #('XML-Parser') ].						"Groups"			spec				group: 'Core' with: #('XML-Parser');				group: 'Tools' with: #(OrderPreservingDictionary Tools 'XMLWriter Tools' 'XML-Parser-GTExtensions'); 				group: 'Tests' with: #('XML-Parser-Tests' 'XML-Parser-Tests-Conformance');					group: 'all' with: #('Core' 'Tools' 'Tests');				group: 'default' with: #('all')		]! !!BaselineOfXMLParser methodsFor: 'prerequisites '!bitmapCharacterSetOn: spec				spec		baseline: 'BitmapCharacterSet'      with: [ 			spec				loads: #('Core');				repository: 'github://pharo-contributions/BitmapCharacterSet:1.2.x/src' ]. 					spec project: 'BitmapCharacterSet Tests' copyFrom: 'BitmapCharacterSet' with: [ spec loads: #('Tests') ] 										! !!BaselineOfXMLParser methodsFor: 'prerequisites '!orderPreservingDictionaryOn: spec	spec		baseline: 'OrderPreservingDictionary'      with: [ 			spec				loads: #('Core');				repository: 'github://pharo-contributions/OrderPreservingDictionary:1.5.x/src' ]. 					spec 		project: 'OrderPreservingDictionary Tests' copyFrom: 'OrderPreservingDictionary' with: [ spec loads: #('Tests') ];					project: 'OrderPreservingDictionary Tools' copyFrom: 'OrderPreservingDictionary' with: [ spec loads: #('Tools') ]! !!BaselineOfXMLParser methodsFor: 'prerequisites '!xmlWriterOn: spec	spec		baseline: 'XMLWriter'      with: [ 			spec				loads: #('Core');				repository: 'github://pharo-contributions/XML-XMLWriter:2.9.x/src' ]. 					spec 		project: 'XMLWriter Tests' copyFrom: 'XMLWriter' with: [ spec loads: #('Tests') ]; 			project: 'XMLWriter Tools' copyFrom: 'XMLWriter' with: [ spec loads: #('Tools') ] ! !"BaselineOfXMLParser"!!BaselineOfBitmapCharacterSet commentStamp: '' prior: 0!A baseline for https://github.com/pharo-contributions/BitmapCharacterSet!!BaselineOfBitmapCharacterSet methodsFor: 'baselines'!baseline: spec	<baseline>		spec for: #common do: [ 		"Packages and Dependencies"		spec 			package: 'Collections-BitmapCharacterSet';			package: 'Collections-BitmapCharacterSet-Tests' with: [ spec requires: 'Collections-BitmapCharacterSet' ].					"Groups"			spec								group: 'Core' with: #('Collections-BitmapCharacterSet');				group: 'Tests' with: #('Collections-BitmapCharacterSet-Tests');				group: 'all' with: #('Core' 'Tests');				group: 'default' with: #('all')		]! !"BaselineOfBitmapCharacterSet"!!BaselineOfOrderPreservingDictionary commentStamp: '' prior: 0!A baseline for an order preserving dictionary (https://github.com/pharo-contributions/OrderPreservingDictionary)!!BaselineOfOrderPreservingDictionary methodsFor: 'baselines'!baseline: spec	<baseline>	spec		for: #common		do: [ 			"Packages"			spec package: 'Collections-OrderPreservingDictionary';				  package: 'Collections-OrderPreservingDictionary-Tests' with: [ spec requires: #('Collections-OrderPreservingDictionary') ];				  package: 'Collections-OrderPreservingDictionary-GTExtensions' with: [ spec requires: #('Collections-OrderPreservingDictionary') ].							"Groups"				spec				group: 'Core' with: #('Collections-OrderPreservingDictionary');				group: 'Tests' with: #('Collections-OrderPreservingDictionary-Tests');				group: 'Tools' with: #('Collections-OrderPreservingDictionary-GTExtensions');				group: 'all' with: #('Core' 'Tools' 'Tests');				group: 'default' with: #('all') ].	spec		for: #gemstone		do: [ 			spec package: 'Collections-OrderPreservingDictionary' with: [ spec includes: 'Collections-OrderPreservingDictionary-GemstoneCompatibility' ].			spec package: 'Collections-OrderPreservingDictionary-GemstoneCompatibility' with: [ spec requires: 'Collections-OrderPreservingDictionary' ]].! !!BaselineOfOrderPreservingDictionary methodsFor: 'accessing'!customProjectAttributes	"Edit to return a collection of any custom attributes e.g. for conditional loading: Array with: #'Condition1' with: #'Condition2.	For more information see: http://code.google.com/p/metacello/wiki/CustomProjectAttributes "	(Smalltalk globals includesKey: #GTInspector)		ifTrue: [ ^ #(gt) ]		ifFalse: [ ^ #() ]! !"BaselineOfOrderPreservingDictionary"!!BaselineOfUnicode methodsFor: 'baselines'!baseline: spec 	<baseline>	spec for: #common do: [		spec 			package: 'Unicode-Character-Data';			package: 'Unicode-Stream-Support';			package: 'Unicode-Casing' with: [ 				spec requires: #('Unicode-Character-Data' 'Unicode-Stream-Support') ];			package: 'Unicode-Normalization' with: [ 				spec requires: #('Unicode-Character-Data' 'Unicode-Stream-Support') ];			package: 'Unicode-Collate' with: [ 				spec requires: #('Unicode-Normalization') ];			package: 'Unicode-Tests-Character-Data' with: [ 				spec requires: 'Unicode-Character-Data' ];			package: 'Unicode-Tests-Casing' with: [ 				spec requires: 'Unicode-Casing' ];			package: 'Unicode-Tests-Normalization' with: [ 				spec requires: 'Unicode-Normalization' ];			package: 'Unicode-Tests-Collate' with: [ 				spec requires: 'Unicode-Collate' ];			group: 'default' with: #('Core' 'Tests');						group: 'Core' with: #(				'Unicode-Character-Data' 'Unicode-Casing' 'Unicode-Stream-Support' 'Unicode-Normalization');			group: 'Tests' with: #(				'Unicode-Tests-Character-Data' 'Unicode-Tests-Casing' 'Unicode-Tests-Normalization');			group: 'Collate' with: #(				'Unicode-Collate' 'Unicode-Tests-Collate') ]! !"BaselineOfUnicode"!!BaselineOfFFICHeaderExtractor commentStamp: '' prior: 0!For more details see https://github.com/marianopeck/FFICHeaderExtractorIn short, FFICHeaderExtractor is a program to extract information (e.g. constants) from C headers and integrate that into Smalltalk SharedPools.When we use FFI to call a certain library, it's quite common that we need to pass specific constants (for example, SIGKILL to kill()). These constants are defined in C header files and can even change their values in different paltforms. Sometimes, these constants also are defined by the C preprocessor and so there is not way to get those values from FFI. If you don't have the value of those constants, you cannot make the FFI call. In other words, if I cannot know that the value of SIGKILL is 9, how do I call kill() from FFI?This tool allows the developers of a FFI tool (any project which uses FFI to call a certain library), to automatically create a C program that writes all the user-defined constants values, compile it, run it, and create a Smalltalk init method which initializes the shared pool constants based on C program output. This autogenerated init method can then be distributed with the rest of the FFI tool. FFICHeaderExtractor will also automatically initialize (searching and executing the previously autogenerated init method for the current platform) a SharedPool upon system startup.!!BaselineOfFFICHeaderExtractor methodsFor: 'baseline'!baseline: spec	<baseline>	spec		for: #common		do: [ 			spec				package: 'FFICHeaderExtractor';				package: 'FFICHeaderExtractor-Tests' with: [ spec requires: 'FFICHeaderExtractor' ];				package: 'FFICHeaderExtractor-LibC' with: [ spec requires: 'FFICHeaderExtractor' ].				]! !"BaselineOfFFICHeaderExtractor"!!CTEnvironment commentStamp: '' prior: 0!I'm a kind of dictionary with optional lookup in my parent. I'm an environment of properties with values (binding key -> value). I may have an ancestor chain (father, grand-father...) in which I look for my properties when I do not define them. Users should pay attention than getting keys is not the same as iterating on keys since a parent may have the same keys than a child. Therefore the iteration will iterate all the keys/values while getting the keys will return a set of the unique keys and not an array with potential duplicates because from the client of a child it is not possible to access a shadowed keys in a parent.Implementation notes.For the moment keysDo: do not garantee any order. A possible improvement would be to use an orderedUniqueCollection to keep the keys. !!CTEnvironmentTest methodsFor: 'accessing'!childEnvironment	^ childEnvironment! !!CTEnvironmentTest methodsFor: 'accessing'!childEnvironment: anObject	childEnvironment := anObject! !!CTEnvironmentTest methodsFor: 'helpers'!connectChildParent	self childEnvironment parent: self potentialParentEnvironment! !!CTEnvironmentTest methodsFor: 'resources'!environmentClass	^ CTEnvironment! !!CTEnvironmentTest methodsFor: 'accessing'!potentialParentEnvironment	^ potentialParentEnvironment! !!CTEnvironmentTest methodsFor: 'accessing'!potentialParentEnvironment: anObject	potentialParentEnvironment := anObject! !!CTEnvironmentTest methodsFor: 'resources'!setUp	self childEnvironment: self environmentClass new.	self childEnvironment propertyAt: #P1inChildren put: 12.	self childEnvironment propertyAt: #P2inChildren put: 13.	self potentialParentEnvironment: self environmentClass new.	self potentialParentEnvironment propertyAt: #P1inChildren put: 24.	self potentialParentEnvironment propertyAt: #P0inParent put: 50! !!CTEnvironmentTest methodsFor: 'tests-properties'!testAllPropertiesInPresenceOfParent	| allP |	self connectChildParent.	allP := self childEnvironment allProperties keys.	allP		do: [ :each | 			self				assert:					(#(#P0inParent #P1inChildren #P2inChildren #configurations)						includes: each) ].	allP := self potentialParentEnvironment allProperties keys.	allP		do: [ :each | 			self assert: (#(#P0inParent #P1inChildren #configurations) includes: each) ]! !!CTEnvironmentTest methodsFor: 'tests-properties'!testAllPropertiesWithoutInheritance	| allP |	allP := self childEnvironment allProperties keys.	allP do: [ :each | self assert: (#(#P2inChildren #P1inChildren #configurations) includes: each) ].	allP := self potentialParentEnvironment allProperties keys.	allP do: [ :each | self assert: (#(#P0inParent #P1inChildren #configurations) includes: each) ]! !!CTEnvironmentTest methodsFor: 'tests-lookup-dictionary'!testAt	self childEnvironment at: #foo put: 'bar'.	self assert: (self childEnvironment at: #foo) equals: 'bar'.	self childEnvironment at: #foo put: 'baz'.	self assert: (self childEnvironment at: #foo) equals: 'baz'.	! !!CTEnvironmentTest methodsFor: 'tests-lookup-dictionary'!testAtAlsoLooksUpInParent	self connectChildParent.	self		assert: (self childEnvironment at: #P0inParent)		equals: 50! !!CTEnvironmentTest methodsFor: 'tests-lookup-dictionary'!testAtIfAbsent	self assert: (self childEnvironment at: #foo put: 'bar') equals: 'bar'.	self assert: (self childEnvironment at: #foo ifAbsent: [ 'baz' ]) equals: 'bar'.	self assert: (self childEnvironment at: #bar ifAbsent: [ 'baz' ]) equals: 'baz'! !!CTEnvironmentTest methodsFor: 'tests-lookup-dictionary'!testAtIfAbsentDoesNotUseIfAbsentWhenPropertyIsDefinedInParent	self connectChildParent.	"since the property P0inParent is defined in parent do not execute the ifAbsent: clause."	self		assert: (self childEnvironment at: #P0inParent ifAbsent: [ false ])		equals: 50.	self assert: (self childEnvironment at: #Zork ifAbsent: [ true ])! !!CTEnvironmentTest methodsFor: 'tests-lookup-dictionary'!testAtIfAbsentPut		self assert: (self childEnvironment at: #foo put: 'bar') equals: 'bar'.	self assert: (self childEnvironment at: #foo) equals: 'bar'.		self assert: (self childEnvironment at: #foo ifAbsentPut: [ 'baz' ]) equals: 'bar'.	"ifAbsentPut: set the property with the put value"	self assert: (self childEnvironment at: #bar ifAbsentPut: [ 'baz' ]) equals: 'baz'.	self assert: (self childEnvironment at: #bar) equals: 'baz'! !!CTEnvironmentTest methodsFor: 'tests-lookup-dictionary'!testAtIfAbsentPutDoesNotUsePutWhenPropertyIsDefinedInParent	self connectChildParent.	self		assert: (self childEnvironment at: #P0inParent ifAbsentPut: [ false ])		equals: 50.	self		assert: (self childEnvironment at: #Zork ifAbsentPut: [ true ]).	self assert: (self childEnvironment at: #Zork) equals: true.	self assert: (self childEnvironment includesLocalKey: #Zork).	self deny: (self potentialParentEnvironment includesLocalKey: #Zork)! !!CTEnvironmentTest methodsFor: 'tests-lookup-dictionary'!testAtIfPresentIfAbsent	self assert: (self childEnvironment at: #foo put: 'bar') equals: 'bar'.	self		assert:			(self childEnvironment				at: #foo				ifPresent: [ :smth | true ]				ifAbsent: [ false ]).	self		deny:			(self childEnvironment				at: #foo2				ifPresent: [ :smth | true ]				ifAbsent: [ false ])! !!CTEnvironmentTest methodsFor: 'tests-lookup-dictionary'!testAtIfPresentIfAbsentInParent	self connectChildParent.	self deny: (self childEnvironment includesLocalKey: #P0inParent).	self assert: (self childEnvironment parent includesLocalKey: #P0inParent).	self		assert:			(self childEnvironment				at: #P0inParent				ifPresent: [ :smth | true ]				ifAbsent: [ false ])! !!CTEnvironmentTest methodsFor: 'tests-lookup-dictionary'!testAtPutDoesNotCannonizeKeyToBeASymbol	self childEnvironment at: #foo put: 'bar'.	self assert: (self childEnvironment at: #foo) equals: 'bar'.	self childEnvironment at: #foo put: 'baz'.	self assert: (self childEnvironment at: #foo) equals: 'baz'.		self childEnvironment at: 'foo2String' put: 'bar'.	self assert: (self childEnvironment at: 'foo2String') equals: 'bar'.		self childEnvironment at: 'foo3String' put: 'bar'.	self assert: (self childEnvironment at: #'foo3String') equals: 'bar'.! !!CTEnvironmentTest methodsFor: 'tests-lookup-dictionary'!testChildrenAtOverridesParent	self connectChildParent.	self		assert: (self childEnvironment at: #P0inParent)		equals: 50.	self		assert: (self childEnvironment at: #P1inChildren)		equals: 12.	self		assert: (self childEnvironment parent at: #P1inChildren)		equals: 24! !!CTEnvironmentTest methodsFor: 'tests-lookup-properties'!testChildrenPropertyAtOverridesParent	self connectChildParent.	self		assert: (self childEnvironment propertyAt: #P0inParent)		equals: 50.	self		assert: (self childEnvironment propertyAt: #P1inChildren)		equals: 12.	self		assert: (self childEnvironment parent propertyAt: #P1inChildren)		equals: 24! !!CTEnvironmentTest methodsFor: 'tests-lookup-properties'!testChildrenPropertyOverridesParent	self connectChildParent.	self		assert: (self childEnvironment propertyAt: #P0inParent)		equals: 50.	self		assert: (self childEnvironment propertyAt: #P1inChildren)		equals: 12.	self		assert: (self childEnvironment parent propertyAt: #P1inChildren)		equals: 24! !!CTEnvironmentTest methodsFor: 'tests-copy'!testCopyProperties	"I'm here to test if postCopy is right."	| config |	config := self environmentClass new.	self deny: config properties == config copy properties! !!CTEnvironmentTest methodsFor: 'tests-iteration'!testDoWhenNoParent	| sum |	sum := 0. 	self potentialParentEnvironment do: [ :e | sum := e + sum ].	self assert: sum equals: 74.	sum := 0. 	self childEnvironment do: [ :e | sum := e + sum ].	self assert: sum equals: 25.! !!CTEnvironmentTest methodsFor: 'tests-iteration'!testDoWhenParent		| sum |	self connectChildParent.	sum := 0. 	self potentialParentEnvironment do: [ :e | sum := e + sum ].	self assert: sum equals: 74.	sum := 0. 	self childEnvironment do: [ :e | sum := e + sum ].	self assert: sum equals: 25 + 74! !!CTEnvironmentTest methodsFor: 'tests-properties'!testFromDictionary	| dict env |	dict := Dictionary new 		at: #first put: 1;		at: #second put: 2;		yourself.		env := CTEnvironment fromDictionary: dict. 		self assert: (env at: #first) equals: 1.	self assert: (env at: #second) equals: 2.	self deny: env hasParent.! !!CTEnvironmentTest methodsFor: 'tests-testing'!testHasLocalProperty	self deny: (self childEnvironment hasLocalProperty: #foo).	self childEnvironment propertyAt: #foo put: 'bar'.	self assert: (self childEnvironment hasLocalProperty: #foo).	self deny: (self childEnvironment hasLocalProperty: #bar).	self deny: (self childEnvironment hasLocalProperty: #P0inParent).	self assert: (self potentialParentEnvironment hasLocalProperty: #P0inParent).! !!CTEnvironmentTest methodsFor: 'tests-testing'!testHasParent	self connectChildParent.	self deny: self potentialParentEnvironment hasParent.	self assert: self childEnvironment hasParent! !!CTEnvironmentTest methodsFor: 'tests-testing'!testHasProperty	self connectChildParent.	self assert: (self childEnvironment hasProperty: #P0inParent).	self assert: (self childEnvironment hasProperty: #P1inChildren)! !!CTEnvironmentTest methodsFor: 'tests-lookup-properties'!testHasPropertyOnlyTestLocalProperties	self deny: (self childEnvironment hasLocalProperty: #foo).	self childEnvironment propertyAt: #foo put: 'bar'.	self assert: (self childEnvironment hasLocalProperty: #foo).	self deny: (self childEnvironment hasLocalProperty: #bar).	self deny: (self childEnvironment hasLocalProperty: #P0inParent).	self assert: (self potentialParentEnvironment hasLocalProperty: #P0inParent).! !!CTEnvironmentTest methodsFor: 'tests-lookup-dictionary'!testIncludeKeyOnlyTestLocalProperties	self deny: (self childEnvironment includesLocalKey: #foo).	self childEnvironment at: #foo put: 'bar'.	self assert: (self childEnvironment includesLocalKey: #foo).	self deny: (self childEnvironment includesLocalKey: #bar).	self deny: (self childEnvironment includesLocalKey: #P0inParent).	self assert: (self potentialParentEnvironment includesLocalKey: #P0inParent).! !!CTEnvironmentTest methodsFor: 'tests-testing-dictionary'!testIncludesKey	self connectChildParent.	self assert: (self childEnvironment includesKey: #P0inParent).	self assert: (self childEnvironment includesKey: #P1inChildren)! !!CTEnvironmentTest methodsFor: 'tests-testing-dictionary'!testIncludesLocalKey	self deny: (self childEnvironment includesLocalKey: #foo).	self childEnvironment propertyAt: #foo put: 'bar'.	self assert: (self childEnvironment includesLocalKey: #foo).	self deny: (self childEnvironment includesLocalKey: #bar).	self deny: (self childEnvironment includesLocalKey: #P0inParent).	self assert: (self potentialParentEnvironment includesLocalKey: #P0inParent).! !!CTEnvironmentTest methodsFor: 'tests-iteration'!testKeysAndValuesDoWhenNoParent		| sum keys |	sum := 0. 	keys := Set new.	self potentialParentEnvironment keysAndValuesDo: [ :k :v | sum := v + sum. keys add: k ].	self assert: sum equals: 74.	self assert: keys size equals: 2.	self assert: (keys includes: #P0inParent).	self assert: (keys includes: #P1inChildren).	sum := 0. 	keys := Set new.	self childEnvironment keysAndValuesDo: [ :k :v | sum := v + sum. keys add: k ].	self assert: sum equals: 25.	self assert: keys size equals: 2.	self assert: (keys includes: #P2inChildren).	self assert: (keys includes: #P1inChildren).! !!CTEnvironmentTest methodsFor: 'tests-iteration'!testKeysAndValuesDoWhenParent		| sum keys |	self connectChildParent.	sum := 0. 	keys := Set new.	self potentialParentEnvironment keysAndValuesDo: [ :k :v | sum := v + sum. keys add: k ].	self assert: sum equals: 74.	self assert: keys size equals: 2.	self assert: (keys includes: #P0inParent).	self assert: (keys includes: #P1inChildren).	sum := 0. 	keys := Set new.	self childEnvironment keysAndValuesDo: [ :k :v | sum := v + sum. keys add: k ].	self assert: sum equals: 25 + 74.	self assert: keys size equals: 3.	self assert: (keys includes: #P2inChildren).	self assert: (keys includes: #P1inChildren).	self assert: (keys includes: #P0inParent).! !!CTEnvironmentTest methodsFor: 'tests-iteration'!testKeysWhenNoParent	self assert: (self childEnvironment keys includes: #P1inChildren).	self assert: (self childEnvironment keys includes: #P2inChildren).	self assert: self childEnvironment keys size equals: 2! !!CTEnvironmentTest methodsFor: 'tests-iteration'!testKeysWhenParent	"Keys of the parent should be returned too but without duplicates."	self connectChildParent.	self assert: (self childEnvironment keys includes: #P1inChildren).	self assert: (self childEnvironment keys includes: #P2inChildren).	self assert: (self childEnvironment keys includes: #P0inParent).	self assert: self childEnvironment keys size equals: 3! !!CTEnvironmentTest methodsFor: 'tests-properties'!testPropertiesIsNotNil	self assert: self childEnvironment  properties notNil! !!CTEnvironmentTest methodsFor: 'tests-lookup-properties'!testPropertyAt	self childEnvironment  propertyAt: #foo put: 'bar'.	self assert: (self childEnvironment propertyAt: #foo) equals: 'bar'.	self childEnvironment propertyAt: #foo put: 'baz'.	self assert: (self childEnvironment propertyAt: #foo) equals: 'baz'.	! !!CTEnvironmentTest methodsFor: 'tests-lookup-properties'!testPropertyAtAlsoLooksUpInParent	self connectChildParent.	self		assert: (self childEnvironment propertyAt: #P0inParent)		equals: 50! !!CTEnvironmentTest methodsFor: 'tests-lookup-properties'!testPropertyAtIfAbsent	self assert: (self childEnvironment propertyAt: #foo put: 'bar') equals: 'bar'.	self assert: (self childEnvironment propertyAt: #foo ifAbsent: [ 'baz' ]) equals: 'bar'.	self assert: (self childEnvironment propertyAt: #bar ifAbsent: [ 'baz' ]) equals: 'baz'! !!CTEnvironmentTest methodsFor: 'tests-lookup-properties'!testPropertyAtIfAbsentDoesNotUseIfAbsentWhenPropertyIsDefinedInParent	self connectChildParent.	"since the property P0inParent is defined in parent do not execute the ifAbsent: clause."	self		assert: (self childEnvironment propertyAt: #P0inParent ifAbsent: [ false ])		equals: 50.	self assert: (self childEnvironment propertyAt: #Zork ifAbsent: [ true ])! !!CTEnvironmentTest methodsFor: 'tests-lookup-properties'!testPropertyAtIfAbsentPut		self assert: (self childEnvironment propertyAt: #foo put: 'bar') equals: 'bar'.	self assert: (self childEnvironment propertyAt: #foo) equals: 'bar'.		self assert: (self childEnvironment propertyAt: #foo ifAbsentPut: [ 'baz' ]) equals: 'bar'.	"ifAbsentPut: set the property with the put value"	self assert: (self childEnvironment propertyAt: #bar ifAbsentPut: [ 'baz' ]) = 'baz'.	self assert: (self childEnvironment propertyAt: #bar) = 'baz'! !!CTEnvironmentTest methodsFor: 'tests-lookup-properties'!testPropertyAtIfAbsentPutDoesNotUsePutWhenPropertyIsDefinedInParent	self connectChildParent.	self		assert: (self childEnvironment propertyAt: #P0inParent ifAbsentPut: [ false ])		equals: 50.	self		assert: (self childEnvironment propertyAt: #Zork ifAbsentPut: [ true ]).	self assert: (self childEnvironment propertyAt: #Zork) equals: true.	self assert: (self childEnvironment hasLocalProperty: #Zork).	self deny: (self potentialParentEnvironment hasLocalProperty: #Zork)! !!CTEnvironmentTest methodsFor: 'tests-lookup-properties'!testPropertyAtIfPresentIfAbsent	self assert: (self childEnvironment propertyAt: #foo put: 'bar') equals: 'bar'.	self		assert:			(self childEnvironment				propertyAt: #foo				ifPresent: [ :smth | true ]				ifAbsent: [ false ]).	self		deny:			(self childEnvironment				propertyAt: #foo2				ifPresent: [ :smth | true ]				ifAbsent: [ false ])! !!CTEnvironmentTest methodsFor: 'tests-lookup-properties'!testPropertyAtIfPresentIfAbsentInParent	self connectChildParent.	self deny: (self childEnvironment hasLocalProperty: #P0inParent).	self assert: (self childEnvironment parent hasLocalProperty: #P0inParent).	self		assert:			(self childEnvironment				propertyAt: #P0inParent				ifPresent: [ :smth | true ]				ifAbsent: [ false ])! !!CTEnvironmentTest methodsFor: 'tests-lookup-properties'!testPropertyAtPutDoesNotCannonizeKeyToBeASymbol	self childEnvironment propertyAt: #foo put: 'bar'.	self assert: (self childEnvironment propertyAt: #foo) equals: 'bar'.	self childEnvironment propertyAt: #foo put: 'baz'.	self assert: (self childEnvironment propertyAt: #foo) equals: 'baz'.		self childEnvironment propertyAt: 'foo2String' put: 'bar'.	self assert: (self childEnvironment propertyAt: 'foo2String') equals: 'bar'.		self childEnvironment propertyAt: 'foo3String' put: 'bar'.	self assert: (self childEnvironment propertyAt: #'foo3String') equals: 'bar'.! !!CTEnvironmentTest methodsFor: 'tests-iteration'!testValuesDoWhenNoParent	| sum |	sum := 0. 	self potentialParentEnvironment valuesDo: [ :e | sum := e + sum ].	self assert: sum equals: 74.	sum := 0. 	self childEnvironment valuesDo: [ :e | sum := e + sum ].	self assert: sum equals: 25.! !!CTEnvironmentTest methodsFor: 'tests-iteration'!testValuesDoWhenParent		| sum |	self connectChildParent.	sum := 0. 	self potentialParentEnvironment valuesDo: [ :e | sum := e + sum ].	self assert: sum equals: 74.	sum := 0. 	self childEnvironment valuesDo: [ :e | sum := e + sum ].	self assert: sum equals: 25 + 74! !!CTEnvironment class methodsFor: 'examples'!childEnvironmentExample	<sampleInstance>	^ self new		propertyAt: #P1inChildren put: 12;		propertyAt: #P2inChildren put: 13; yourself! !!CTEnvironment class methodsFor: 'examples'!childEnvironmentWithParentExample	<sampleInstance>	^ self childEnvironmentExample parent: self parentEnvironmentExample ; yourself! !!CTEnvironment class methodsFor: 'instance creation'!fromDictionary: aDictionary	| inst |	inst := self new. 	aDictionary keysAndValuesDo: [ :k :v | inst at: k put: v ].	^ inst	! !!CTEnvironment class methodsFor: 'examples'!parentEnvironmentExample	<sampleInstance>	^ self new		propertyAt: #P1inChildren put: 24;		propertyAt: #P0inParent put: 50 ; yourself! !!CTEnvironment methodsFor: 'conversion'!allProperties	"Answer all properties of the receiver and its parents."	"This method should be removed.... or at least should return a CTEnvironment"	| parentProperties |	parentProperties := self hasParent		ifTrue: [ parent allProperties ]		ifFalse: [ Dictionary new ].	parentProperties addAll: self properties.	"addAll: is not in the current API of environment"	^ parentProperties! !!CTEnvironment methodsFor: 'conversion'!asFlatDictionary	"Answer a new  of the receiver and its parents."	^ self flattenIn: Dictionary new! !!CTEnvironment methodsFor: 'accessing - dictionary'!at: aKey	"Answer the value of the property ==aKey==, potentially looking in the parent, raises an error if the property doesn't exist."	^ properties		at: aKey asSymbol		ifAbsent: [ self hasParent				ifTrue: [ parent at: aKey ]				ifFalse: [ self errorPropertyNotFound: aKey ] ]! !!CTEnvironment methodsFor: 'accessing - dictionary'!at: aKey ifAbsent: aBlock	"Answer the value of the property ==aKey==, potentially looking in parents, or the result of ==aBlock== if the property doesn't exist."	^ properties		at: aKey asSymbol		ifAbsent: [ self hasParent				ifTrue: [ parent at: aKey ifAbsent: aBlock ]				ifFalse: aBlock ]! !!CTEnvironment methodsFor: 'accessing - dictionary'!at: aKey ifAbsentPut: aBlock	"Answer the value of the property ==aKey==, potentially defined in parents, or if the property doesn't exist adds and answers the result of evaluating ==aBlock==."	"We look up first to know and once we know if the property is not defined somewhere, then we set it. We do it like that to avoid to execute the put block on the parent because the put should be executed on the child."	^ (self hasProperty: aKey)			ifTrue: [ self at: aKey ]			ifFalse: [ self at: aKey put: aBlock value ]! !!CTEnvironment methodsFor: 'accessing - dictionary'!at: aKey ifPresent: presentBlock ifAbsent: absentBlock	"Answer the result of ==presentBlock== if I have the property ==aKey==, in the receiver or its parents or the result of ==absentBlock==."	^ (self hasProperty: aKey)			ifTrue: [ presentBlock value: (self at: aKey) ]			ifFalse: [ absentBlock value ]! !!CTEnvironment methodsFor: 'accessing - dictionary'!at: aKey put: aValue	"Adds or replaces the property ==aKey== with ==aValue== in the receiver."	^ properties at: aKey asSymbol put: aValue! !!CTEnvironment methodsFor: 'iteration'!do: aBlock 	"Evaluate aBlock for each of the receiver's values, starting from the receiver and going up in its parent chain if any."	self valuesDo: aBlock! !!CTEnvironment methodsFor: 'error'!errorPropertyNotFound: aKey 	KeyNotFound signal: aKey! !!CTEnvironment methodsFor: 'conversion'!flattenIn: aDictionable	"Answer a new aDictionable of the receiver and its parents."	self hasParent		ifTrue: [ parent flattenIn: aDictionable ].	aDictionable addAll: properties.	^ aDictionable! !!CTEnvironment methodsFor: 'testing'!hasLocalProperty: aKey	"Test if the property ==aKey== is defined within the receiver, not checking potential parent."	^ properties includesKey: aKey asSymbol! !!CTEnvironment methodsFor: 'testing'!hasParent	^ parent notNil! !!CTEnvironment methodsFor: 'testing'!hasProperty: aKey	"Answer true iff I (or one of my ancestors) contain a property named ==aKey==."	^ properties		at: aKey asSymbol		ifPresent: [ :value | true ]		ifAbsent: [ self hasParent				ifTrue: [ parent hasProperty: aKey ]				ifFalse: [ false ] ]! !!CTEnvironment methodsFor: 'testing-dictionary'!includesKey: aKey	"Answer true iff I (or one of my ancestors) contain a property named ==aKey==."	^ properties		at: aKey asSymbol		ifPresent: [ :value | true ]		ifAbsent: [ self hasParent				ifTrue: [ parent includesKey: aKey ]				ifFalse: [ false ] ]! !!CTEnvironment methodsFor: 'testing-dictionary'!includesLocalKey: aKey	"Test if the property ==aKey== is defined within the receiver, not checking potential parent."	^ properties includesKey: aKey asSymbol! !!CTEnvironment methodsFor: 'initialization'!initialize	super initialize.	properties := OrderedDictionary new.! !!CTEnvironment methodsFor: 'accessing'!keys	"Answer a Set containing the receiver's keys."	| s |	s := Set new. 	"we use a set and not an array because we should go over potential parent keys and the intersection between parent and children keys may not be empty. So we should not report duplicates."	self keysDo: [ :k | s add: k ].	^ s ! !!CTEnvironment methodsFor: 'iteration'!keysAndValuesDo: aBlock 	"Evaluate aBlock for each of the receiver's keys and values, starting from the receiver and going up in its parent chain if any."	properties keysAndValuesDo: aBlock.	self hasParent ifTrue: [ parent keysAndValuesDo: aBlock ]	! !!CTEnvironment methodsFor: 'iteration'!keysDo: aBlock 	"Evaluate aBlock for each of the receiver's keys, starting from the receiver and going up in its parent chain if any."	properties keysDo: aBlock.	self hasParent ifTrue: [ parent keysDo: aBlock ]	! !!CTEnvironment methodsFor: 'accessing'!parent	"A parent is a Configuration I extends"		^ parent! !!CTEnvironment methodsFor: 'accessing'!parent: anEnvironment	parent := anEnvironment! !!CTEnvironment methodsFor: 'copying'!postCopy	"Make sure that properties are properly copied, but not the parent."	super postCopy.	properties := properties copy.! !!CTEnvironment methodsFor: 'private'!properties	^ properties! !!CTEnvironment methodsFor: 'accessing - properties'!propertyAt: aKey	"Answer the value of the property ==aKey==, potentially looking in the parent, raises an error if the property doesn't exist."	^ self at: aKey! !!CTEnvironment methodsFor: 'accessing - properties'!propertyAt: aKey ifAbsent: aBlock	"Answer the value of the property ==aKey==, potentially looking in parents, or the result of ==aBlock== if the property doesn't exist."	^ self at: aKey ifAbsent: aBlock! !!CTEnvironment methodsFor: 'accessing - properties'!propertyAt: aKey ifAbsentPut: aBlock	"Answer the value of the property ==aKey==, potentially defined in parents, or if the property doesn't exist adds and answers the result of evaluating ==aBlock==."	"We look up first to know and once we know if the property is not defined somewhere, then we set it. We do it like that to avoid to execute the put block on the parent because the put should be executed on the child."	^ self at: aKey ifAbsentPut: aBlock! !!CTEnvironment methodsFor: 'accessing - properties'!propertyAt: aKey ifPresent: presentBlock ifAbsent: absentBlock	"Answer the result of ==presentBlock== if I have the property ==aKey==, in the receiver or its parents or the result of ==absentBlock==."	^ self at: aKey ifPresent: presentBlock ifAbsent: absentBlock! !!CTEnvironment methodsFor: 'accessing - properties'!propertyAt: aKey put: aValue	"Adds or replaces the property ==aKey== with ==aValue== in the receiver."	^ self at: aKey put: aValue! !!CTEnvironment methodsFor: 'iteration'!valuesDo: aBlock	"Evaluate aBlock for each of the receiver's values, starting from the receiver and going up in its parent chain if any."		properties valuesDo: aBlock.	self hasParent ifTrue: [ parent valuesDo: aBlock ]	! !"Containers-PropertyEnvironment"!!ChrysalConfiguration commentStamp: '' prior: 0!I'm the superclass of the generated configuration classes. I'm needed because I define some behavior for the creation of instances of such generated classes. I also make sure that conversion methods are invoked when creating instances of such subclasses. I'm packaged in the Chrysal-Runtime package because users of Chrysal may want to package their configuration without the full Chrysal builder. !!ChrysalConfiguration class methodsFor: 'instance creation others'!newFromConvertedDictionary: aDictionary	"Assuming that aDictionary contains values which are already objects (i.e., false and not 'false') create a configuration based on this dictionary"		| conf |	conf := self new.	aDictionary associations do: [ :aBinding | conf propertyAt: aBinding key asSymbol  put: aBinding value ].	^ conf! !!ChrysalConfiguration class methodsFor: 'instance creation'!newFromDictionary: stonDictionary	"It seems that pillar cocoon configuration semantics is to consider the argument as a ston dictionary, i.e., with strings and not objects as values."		^ self newFromSTONDictionary: stonDictionary! !!ChrysalConfiguration class methodsFor: 'compatible with pillar'!newFromDictionary: aSTONDictionary extendedWith: anotherDictionary	| configuration |	configuration :=  self newFromSTONDictionary: aSTONDictionary.	anotherDictionary associations do: [ :aBinding | configuration propertyAt: aBinding key put: aBinding value].	^ configuration! !!ChrysalConfiguration class methodsFor: 'instance creation'!newFromFile: aFile		^ aFile readStreamDo: [ :input | self newFromStream: input ]! !!ChrysalConfiguration class methodsFor: 'compatible with pillar'!newFromFile: aFile extendedWith: anotherDictionary	^ aFile readStreamDo: [ :input | self newFromStream: input extendedWith: anotherDictionary ]! !!ChrysalConfiguration class methodsFor: 'instance creation others'!newFromSTONDictionary: stonDictionary	"Create a configuration based on a dictionary with the objects as defined in STON. 'string' for files and not files. Now pay attention since some literal objects such as true, numbers are not represented as string in STON."		| conf |	conf := self new.	stonDictionary associations do: [ :aBinding | conf setConvertedValueOf: aBinding ].	conf postTreat.	^ conf! !!ChrysalConfiguration class methodsFor: 'instance creation'!newFromStream: aStream	"Create a new configuration from the stream, values are converted accordingly to the properties.	i.e., a string 'false' will be turned into a false object in the resulting configuration."	^ self newFromDictionary: (STON fromStream: aStream)! !!ChrysalConfiguration class methodsFor: 'compatible with pillar'!newFromStream: aStream extendedWith: anotherDictionary	^ self newFromDictionary: (STON fromStream: aStream) extendedWith: anotherDictionary 			! !!ChrysalConfiguration class methodsFor: 'instance creation'!newFromString: aString	^ self newFromStream: aString readStream! !!ChrysalConfiguration class methodsFor: 'compatible with pillar'!newFromString: aString extendedWith: anotherDictionary	^ self newFromStream: aString readStream extendedWith: anotherDictionary! !!ChrysalConfiguration methodsFor: 'conversion'!declaredItems	^ #()! !!ChrysalConfiguration methodsFor: 'post hooks'!postTreat	"I'm a hook so that my subclasses can perform some actions once a configuration is created."! !!ChrysalConfiguration methodsFor: 'conversion'!setConvertedValueOf: aBinding	"Set the converted value of aBinding value in the correct property of the receiver. aBinding should be property and a raw value as written in the configuration"	(self declaredItems includes: aBinding key asSymbol)		ifTrue: [ self setConvertedValueOfDeclaredProperty: aBinding ]		ifFalse: [ self perform: #propertyAt:put: 								with: aBinding key asSymbol 								with: aBinding value ]	! !!ChrysalConfiguration methodsFor: 'conversion'!setConvertedValueOfDeclaredProperty: aBinding	"Set the converted value of aBinding value in the correct property of the receiver. 	aBinding should be property and a raw value as written in the configuration"	| setter converted |	setter := aBinding key capitalized , ':'.	converted := self perform: (#convert , setter) asSymbol with: aBinding value.	converted ifNil: [ self error: 'aBinding is not correctly spelt ' , aBinding ].	self perform: setter uncapitalized asSymbol with: converted! !"Chrysal-Runtime"!!ChrysalConfigurationBuilder commentStamp: '' prior: 0!I generate a configuration class independent from Chrysal objects (check itemDescriptionForXX for a sample of such description objects), but based on them. I'm like a macro expansion.The generated configuration classes knows how to - access properties it stores- convert values from the external world (in terms of STON) to Pharo objects.Since we are using STON as an external format, the following objects are considered as literals and as such we do not convert them since they get converted by STON reader for us:  number, true, false, symbol and string.The generated Chrysal configuration classes still needs to be subclass of ChrysalConfiguration class to reuse some of the behavior to create instances.!!!! APIThere are two ways of specify the configuration class: either using ==configurationClass:== or ==defineConfigurationClassNamed:packagedIn:==	The main public API is the method ==withDescriptionItems:==Here are some typical usecases. [[[ChrysalConfigurationBuilder new 	configurationRootClass: ConfigurationRootForXX;	defineConfigurationClassNamed: #ConfigurationForXX packagedIn: 'Chrysal-Tests'; 	withDescriptionItems: ConfigurationDescriptionForXX itemDescriptionForXX]]][[[ChrysalConfigurationBuilder new 	defineConfigurationClassNamed: #ConfigurationForXX packagedIn: 'Chrysal-Tests'; 	withDescriptionItems: ConfigurationDescriptionForXX itemDescriptionForXX]]][[[	ChrysalConfigurationBuilder new 	configurationClass: ConfigurationForXX;	withDescriptionItems: ConfigurationDescriptionForXX itemDescriptionForXX]]]	A ConfigurationItem can be an elementary element such as Number, String, Symbol, NewLine, File or Folder, but also a composite one. In case of composite, for now the composite are not converted using Chrysal but are plain STON values. !!!! Note for the chrysal extenderSTON configurations consider the following as literals and not strings: number true false symbol string. Therefore the conversion is not needed. !!ChrysalItem commentStamp: '' prior: 0!A chrysalItem is a description object responsible for generating statically a configuration class able to represent, convert, and manage default value of various configuration properties. A configuration is expressed as STON file on disk and the strings contained in the configuration should be converted to Pharo objects. For example files, folder, newline conventions. An item has basically a propertyName, an explanation string, a default value. Now care must be taken because item are compiled time objects and they should return string representations that will be used to generate the actual configuration class representing the configuration. For example NewLineConfigurationItem>> domainValueConversionStringis a good example. It returns a mapping that will be used to map configuration properties to Pharo objects.NewLineConfigurationItem>> domainValueConversionString	"Returns a string converting a string as written by in the configuration file to a pharo object. 	Note that this method is like the body of a macro that will be expanded in the configuration class: 	here aValue is the name of the parameter of the generated method.	"	^ '(Dictionary			newFrom:				{(#cr -> String cr).				(#lf -> UnixPlatform new lineEnding).				(#crlf -> Win32Platform new lineEnding).				(#unix -> UnixPlatform new lineEnding).				(#mac -> UnixPlatform new lineEnding).				(#dos -> Win32Platform new lineEnding)}) at: aValue'Applications may extend or add new subclasses to manage specific property.Known limitations:Note that for now, I do not manage the fact that the user could define a default value when he does not specify a given value for a property. For example, the following configuration methoddefaultScriptLanguage	"generated code"	^ self propertyAt: #defaultScriptLanguage ifAbsent: [(PRRealScriptLanguage for: 'smalltalk')]is generated and we cannot simply let the user define that the default language could be something else than 'smalltalk'. Of course, he just has to specify a value for defaultScriptLanguage to do it - but we are talking about the default case specification. STON toStringPretty: ConfigurationDescriptionForXX new items '[	StringConfigurationItem {		#propertyName : ''title'',		#default : ''my super cool book''	},	BooleanConfigurationItem {		#propertyName : ''verbose'',		#default : ''true''	},	StringConfigurationItem {		#propertyName : ''attribution'',		#default : ''me, myself and I''	},	StringConfigurationItem {		#propertyName : ''series'',		#default : ''Square Bracket Associate Collection''	},	StringConfigurationItem {		#propertyName : ''keywords'',		#default : ''Pharo''	},	FolderConfigurationItem {		#propertyName : ''outputDirectory'',		#default : ''build''	},	FileConfigurationItem {		#propertyName : ''mainDocument'',		#default : ''book''	},	FileConfigurationItem {		#propertyName : ''latexTemplate'',		#default : ''_support/templates/main.latex.mustache''	},	FileConfigurationItem {		#propertyName : ''latexChapterTemplate'',		#default : ''_support/templates/chapter.latex.mustache''	},	FileConfigurationItem {		#propertyName : ''htmlTemplate'',		#default : ''_support/templates/html.mustache''	},	FileConfigurationItem {		#propertyName : ''htmlChapterTemplate'',		#default : ''_support/templates/html.mustache''	},	NewLineConfigurationItem {		#propertyName : ''newLine'',		#defaultKey : #unix	},	SymbolConfigurationItem {		#propertyName : ''latexWriter'',		#default : #''latex:sbabook''	}]'!!BooleanConfigurationItem commentStamp: '' prior: 0!To describe boolean items.Literal in STON.(BooleanConfigurationItem new		propertyName: 'verbose';		beTrueAsDefault;		yourself).!!CompositeConfigurationItem commentStamp: '' prior: 0!I'm an item composed of other items. Here is an example how to define a CompositeConfigurationItem.[[[(CompositeConfigurationItem new		propertyName: 'printerComposite';		default: #ChrysalCompositeDomain;		fields: #(level renderAs capitalization numbering headerSize);		yourself)]]]It says that the composite will an instance of ChrysalCompositeDomain and that only these fields will be considered and only the ones described by other items will be converted during the conversion. Right now, the value of such fields are not converted using Chrysal. We just get the STON elements. !!FileConfigurationItem commentStamp: '' prior: 0!To describe file items.(FileConfigurationItem new		propertyName: 'mainDocument';		default: 'book').(FileConfigurationItem new		propertyName: 'latexChapterTemplate';		default: '_support/templates/chapter.latex.mustache').!!FolderConfigurationItem commentStamp: '' prior: 0!To describe folder items.(FolderConfigurationItem new		propertyName: 'outputDirectory';		default: 'build').!!ListConfigurationItem commentStamp: '' prior: 0!I represent an item holding a list of other elements. (ListConfigurationItem new		propertyName: 'levels';		default: #OrderedCollection;		element: #printerComposite;		yourself)			I handle the following {''levels'' : [		[    ''level'' : 1,			''renderAs'' : ''letter'',			''capitalization'' : ''uppercase'',			''numbering'' : true,			''size'' : 2		],		[	''level'' : 2,			''renderAs'' : ''number'',			''capitalization'' : ''uppercase'',			''numbering'' : true,			''size'' : 3		]	]}!!NewLineConfigurationItem commentStamp: '' prior: 0!To describe new lines.(NewLineConfigurationItem new		propertyName: 'newLine';		defaultIsUnix).!!NumberConfigurationItem commentStamp: '' prior: 0!To describe number items.Literal in STON.(NumberConfigurationItem new		propertyName: 'headingLevelOffset';		default: 0;		yourself)!!PathConfigurationItem commentStamp: '' prior: 0!To describe path items.(PathConfigurationItem new	propertyName: 'outputDirectoryPath';	default: 'build').!!StringConfigurationItem commentStamp: '' prior: 0!To describe string items.Literal in STON.[[[StringConfigurationItem new		propertyName: 'title';		default: 'my super cool book';		yourself]]]!!SymbolConfigurationItem commentStamp: '' prior: 0!To describe symbol items.Literal in STON.(SymbolConfigurationItem new		propertyName: 'latexWriter';		default: #latex:sbabook;		yourself)!!ChrysalConfigurationBuilder methodsFor: 'add configuration accessors'!accessorGenerationForItem: anItem	"self new accessorGenerationForItem: BooleanConfigurationItem example"	"self new accessorGenerationForItem: NewLineConfigurationItem example"	"self new accessorGenerationForItem: FolderConfigurationItem example"	"self new accessorGenerationForItem: FileConfigurationItem example"		^ String		streamContents: [ :str | 			str nextPutAll: anItem propertyName.			str cr; tab.			str nextPutAll: '"generated code"'.			str cr; tab.			str nextPutAll:					'^ self propertyAt: #' , anItem propertyName , ' ifAbsent: ['						, anItem defaultDomainValueString , ']' ]! !!ChrysalConfigurationBuilder methodsFor: 'add configuration accessors'!addAccessorsAndConversionMethodsFrom: descriptionItems	descriptionItems		do: [ :each | 			self configurationClass				compile: (self accessorGenerationForItem: each)				classified: 'accessing'.			self configurationClass				compile: (self setterGenerationForItem: each)				classified: 'accessing'.			self configurationClass				compile: (self conversionGenerationForItem: each)				classified: 'conversion'			 ]! !!ChrysalConfigurationBuilder methodsFor: 'add configuration accessors'!addDeclaredItemsMethodFrom: descriptionItems	self configurationClass		compile: (self declaredItems: descriptionItems)		classified: 'declared items'! !!ChrysalConfigurationBuilder methodsFor: 'add description'!addDescription: descriptionItems	self configurationClass class 		compile: (self descriptionMethodFrom: descriptionItems) 		classified: 'description'! !!ChrysalConfigurationBuilder methodsFor: 'add description'!addDescriptionBodyIn: aStream forItems: descriptionItems	aStream print: (STON toStringPretty: descriptionItems)! !!ChrysalConfigurationBuilder methodsFor: 'accessing'!configurationClass	^ configurationClass! !!ChrysalConfigurationBuilder methodsFor: 'public api'!configurationClass: aClass	configurationClass := aClass! !!ChrysalConfigurationBuilder methodsFor: 'accessing'!configurationRootClass	^ configurationRootClass ifNil: [ configurationRootClass := self defaultChrysalConfigurationClass ]! !!ChrysalConfigurationBuilder methodsFor: 'public api'!configurationRootClass: aClass	"to define a different superclass than ChrysalConfiguration (a subclass of it to store specific behavior for example"	 configurationRootClass := aClass! !!ChrysalConfigurationBuilder methodsFor: 'add configuration accessors'!conversionGenerationForItem: anItem	"self new accessorGenerationForItem: FileConfigurationItem example"	^ String		streamContents: [ :str | 			str nextPutAll: 'convert', (anItem propertyName) capitalized, ': aValue'.			"pay attention aValue is a special argument that domainValueString can use to manipulate the parameter 			during conversion"			str cr; tab.			str nextPutAll: '"generated code"'.			str cr; tab.			str nextPutAll: ( anItem domainValueConversionString ) ]! !!ChrysalConfigurationBuilder methodsFor: 'add configuration accessors'!declaredItems: descriptionItems		^ String		streamContents: [ :str | 			str nextPutAll: 'declaredItems'.			str cr; tab.			str nextPutAll: '"generated code"'.			str cr; tab.			str nextPutAll: '^ #( '.			descriptionItems				do: [:each | str nextPutAll: '#', each propertyName]				separatedBy: [str space].			str nextPutAll: ' )' ]! !!ChrysalConfigurationBuilder methodsFor: 'add class definition'!defaultChrysalConfigurationClass	^ ChrysalConfiguration 	! !!ChrysalConfigurationBuilder methodsFor: 'add class definition'!defineConfigurationClassNamed: aString packagedIn: packageName	self configurationRootClass 		subclass: aString asSymbol		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		package: packageName.	self configurationClass: (self class environment at: aString asSymbol).	(self class environment at: aString asSymbol)	comment: 'I''m a generated class that manages the conversion of configuration items written in STON format to Pharo objects. I''m used for example in Pillar to manage ''Pillar.conf'' file.  I was generated by the ChrysalConfigurationBuilder based on a list of item descriptions (instances of subclasses of ChrysalItem).To help you remember from which configuration items I was generated from, I have a class side method which when executed in presence of the generating package will return a list of items. Note that such items only exist at compile time. Therefore executing this method with only the runtime does not make any sense.chrysalDescriptions ^ STON fromString: ''[	StringConfigurationItem {		#propertyName : #title,		#default : ''my super cool book'',		#noDefault : false	}, ... ]''Now to exist and be used I do not need the full Chrysal package, just the runtime containing the ChrysalConfiguration class. Note that I may inherit from one of its subclasses to support better customisation. 				Chrysal is hosted at: github.com/Ducasse/Chrysal					To generate me, a code snippet similar to the following one was executed: 				ChrysalConfigurationBuilder new 			configurationRootClass: ', self configurationRootClass name, ';			defineConfigurationClassNamed: #', aString asSymbol, 			' packagedIn: ', packageName, ';',			' 			withDescriptionItems: ConfigurationDescriptionForXX itemDescriptionForXX '.			! !!ChrysalConfigurationBuilder methodsFor: 'add description'!descriptionMethodFrom: descriptionItems	"self new descriptionMethodFrom: ConfigurationDescriptionForXX itemDescriptionForXX "	^ String		streamContents: [ :s | 			s nextPutAll: 'chrysalDescriptions'; cr.			s tab; nextPutAll: '"I''m a generated method. I''m just here to help remembering how the class was generated. I should only be executed in presence of the configurationBuilder contained in the Chrysal package. Indeed the item objects only exist at compile-time and STON will recreate them."'.			s cr.			s tab; nextPutAll: ' ^ STON fromString: '.			self addDescriptionBodyIn: s forItems: descriptionItems ]! !!ChrysalConfigurationBuilder methodsFor: 'private'!descriptionNamed: aName	^ items at: aName asSymbol! !!ChrysalConfigurationBuilder methodsFor: 'public api'!initializeDescription: descriptionItems	items := Dictionary new.	descriptionItems		do: [ :each | items at: each propertyName asSymbol put: each ]! !!ChrysalConfigurationBuilder methodsFor: 'private'!isPropertyDefined: aName	^ items keys includes: aName asSymbol! !!ChrysalConfigurationBuilder methodsFor: 'add configuration accessors'!setterGenerationForItem: anItem		^ String		streamContents: [ :str | 			str nextPutAll: anItem propertyName, ': aValue'.			str cr; tab.			str nextPutAll: '"generated code"'.			str cr; tab.			str nextPutAll:					'^ self propertyAt: #' , anItem propertyName , ' put: aValue' ]! !!ChrysalConfigurationBuilder methodsFor: 'public api'!withDescriptionItems: descriptionItems	"self new with: ConfigurationDescriptionForXX new items"	self initializeDescription: descriptionItems.	self addAccessorsAndConversionMethodsFrom: descriptionItems.	self addDeclaredItemsMethodFrom: descriptionItems.	self addDescription: descriptionItems! !!BooleanConfigurationItem class methodsFor: 'example'!example	<sampleInstance>	^ self new		propertyName: #separateOutputFiles;		beTrueAsDefault! !!BooleanConfigurationItem methodsFor: 'public API'!beFalseAsDefault	default := 'false'! !!BooleanConfigurationItem methodsFor: 'public API'!beTrueAsDefault	default := 'true'! !!BooleanConfigurationItem methodsFor: 'accessing'!defaultDomainValueString	"Returns a string representing the default value but as an object once imported in Pharo and not a string used by the writer of a configuration."	^ self defaultValue! !!BooleanConfigurationItem methodsFor: 'public API'!defaultValue	"Default value is the default value of an item in the domain of the configuration writer and not in the Pharo world."	^ default! !!BooleanConfigurationItem methodsFor: 'accessing'!domainValueConversionString	"Returns a string representing the conversion of a value from the configuration writer world to Pharo. aValue is the parameter representing the object to be converted"	^ '^ aValue '! !!BooleanConfigurationItem methodsFor: 'unused'!possibleValuesString	^ #('true' 'false')	! !!ChrysalItem methodsFor: 'accessing'!default	^ default ifNil: [ default := self defaultValue ]! !!ChrysalItem methodsFor: 'accessing'!default: aString 	default := aString! !!ChrysalItem methodsFor: 'accessing'!defaultDomainValueString	"Returns a string representing the default value but as an object once imported in Pharo and not a string used by the writer of a configuration."	^ self subclassResponsibility! !!ChrysalItem methodsFor: 'accessing'!defaultValue	"Default value is the default value of an item in the domain of the configuration writer and not in the Pharo world."	^ 'defaultValue'! !!ChrysalItem methodsFor: 'accessing'!domainValueConversionString	"Returns a string converting a string as written in the configuration file to a pharo object. 	Note that this method is like the body of a macro that will be expanded in the configuration class: here aValue is the name of the parameter of the generated method.		For example for fileConfigurationItem (inputFile), 	the result of the method will be used in the body of the following generated method 		convertInputFile: aValue	      ^ (FileSystem workingDirectory / aValue)		 Parameter of the item like baseline should be accessed via self nameOfProperty"	^ '^ aValue'! !!ChrysalItem methodsFor: 'accessing'!explanation	^ explanation! !!ChrysalItem methodsFor: 'accessing'!explanation: aString	explanation := aString! !!ChrysalItem methodsFor: 'unused'!possibleValuesString	^ ''! !!ChrysalItem methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: ' (' , propertyName printString;		nextPutAll: ' ' , self default printString , ')'! !!ChrysalItem methodsFor: 'accessing'!propertyName	^ propertyName! !!ChrysalItem methodsFor: 'accessing'!propertyName: aSymbol	"property name"	propertyName := aSymbol asSymbol! !!CompositeConfigurationItem class methodsFor: 'example'!example 	<sampleInstance>		^ (CompositeConfigurationItem new		propertyName: #printerComposite;		default: #ChrysalCompositeDomain;		fields: #(level renderAs capitalization numbering headerSize);		yourself)! !!CompositeConfigurationItem methodsFor: 'accessing'!defaultDomainValueString	"Returns a string representing the default value but as an object once imported in Pharo and not a string used by the writer of a configuration."	^ ' {1} new ' format: {self default asString}! !!CompositeConfigurationItem methodsFor: 'accessing'!domainValueConversionString	"Returns a string converting a string as written in the configuration file to a pharo object. 	Note that this method is like the body of a macro that will be expanded in the configuration class: here aValue is the name of the parameter of the generated method.		For example for fileConfigurationItem (inputFile), 	the result of the method will be used in the body of the following generated method 		convertInputFile: aValue	      ^ (FileSystem workingDirectory / aValue)			 Parameter of the item like baseline should be accessed via self nameOfProperty"	^ '| composite |	composite := {1} new.	aValue do: [:v | 		    "We ignore undeclared fields"			({2} includes: v key asSymbol)				ifTrue: [ 					| value |					"if the element has been described we convert"					(self declaredItems includes: v key asSymbol)						ifTrue: [ value := self perform: (#convert, v key capitalized, '':'') asSymbol with: v value ]						ifFalse: [ value := v value ].							composite 								perform:  (v key, '':'') asSymbol 								with: value].		].	^ composite' format: {self default asString . fields}! !!CompositeConfigurationItem methodsFor: 'accessing'!fields: aCollection 	fields := aCollection! !!CompositeConfigurationItem methodsFor: 'initialization'!initialize	super initialize.	fields := #()! !!FileConfigurationItem class methodsFor: 'example'!example	<sampleInstance>		^ FileConfigurationItem new		propertyName: #mainDocument ;		default: 'book'! !!FileConfigurationItem methodsFor: 'accessing'!defaultDomainValueString	"Returns a string representing the default value but as an object once imported in Pharo and not a string used by the writer of a configuration."	^ '(FileSystem workingDirectory / ''{1}'')' format: {self default}! !!FileConfigurationItem methodsFor: 'accessing'!defaultValue	^ 'bookDefaultName'! !!FileConfigurationItem methodsFor: 'accessing'!domainValueConversionString	"Returns a string converting a string as written in the configuration file to a pharo object. Note that this method is like the body of a macro that will be expanded in the configuration class: here aValue is the name of the parameter of the generated method.		The result of the method will be used in the body of the following generated method (for the inputFile property)		convertInputFile: aValue	      ^ (FileSystem workingDirectory / aValue)			 Parameter of the item like baseline should be accessed via self nameOfProperty"	^ '^ (FileSystem workingDirectory / aValue)' ! !!FileConfigurationItem methodsFor: 'unused'!possibleValuesString	"to be filled up with default value at compilation time."	^ '(FileSystem workingDirectory / {1})'! !!FolderConfigurationItem class methodsFor: 'example'!example	<sampleInstance>	^ FolderConfigurationItem new		propertyName: #outputDirectory;		default: 'build'! !!FolderConfigurationItem methodsFor: 'accessing'!defaultDomainValueString	"Returns a string representing the default value but as an object once imported in Pharo and not a string used by the writer of a configuration."	^ '(FileSystem workingDirectory / ''{1}'')' format: {self default}! !!FolderConfigurationItem methodsFor: 'accessing'!defaultValue	"in the context of the configuration writer!!"	^ 'build'! !!FolderConfigurationItem methodsFor: 'conversion'!domainValueConversionString	"Returns a string converting a string as written by in the configuration file to a pharo object. 	Note that this method is like the body of a macro that will be expanded in the configuration class: here aValue is the name of the parameter of the generated method.		 Parameter of the item like baseline should be accessed via self nameOfProperty"	^ '^ (FileSystem workingDirectory / aValue)' ! !!FolderConfigurationItem methodsFor: 'unused'!possibleValuesString	"to be filled up with default value at compilation time."	^ '(FileSystem workingDirectory / {1})'! !!ListConfigurationItem methodsFor: 'accessing'!defaultDomainValueString	"Returns a string representing the default value but as an object once imported in Pharo and not a string used by the writer of a configuration."	^ ' {1} new ' format: {self default asString}! !!ListConfigurationItem methodsFor: 'accessing'!domainValueConversionString	"Returns a string converting a string as written in the configuration file to a pharo object. 	Note that this method is like the body of a macro that will be expanded in the configuration class: here aValue is the name of the parameter of the generated method.	"	^ '| elements |	elements := {1} new.	aValue do: [:v | 		 elements add: (self convert{2}: v ) ].	^ elements' format: {self default asString . element capitalized}! !!ListConfigurationItem methodsFor: 'accessing'!element: aCollection 	element := aCollection! !!NewLineConfigurationItem class methodsFor: 'example'!example	<sampleInstance>		^ NewLineConfigurationItem new		propertyName: #newline ;		defaultIsUnix! !!NewLineConfigurationItem methodsFor: 'accessing'!defaultDomainValueString	"Returns a string representing the default value but as an object once imported in Pharo and not a string used by the writer of a configuration."	^ self mapperFromUserToDomainRepresentations at: self default! !!NewLineConfigurationItem methodsFor: 'public api'!defaultIsPlatform	defaultKey := #platform! !!NewLineConfigurationItem methodsFor: 'public api'!defaultIsUnix	defaultKey := #unix.	! !!NewLineConfigurationItem methodsFor: 'accessing'!defaultValue	^ #platform! !!NewLineConfigurationItem methodsFor: 'conversion'!domainValueConversionString	"Returns a string converting a string as written by in the configuration file to a pharo object. 	Note that this method is like the body of a macro that will be expanded in the configuration class: 	here aValue is the name of the parameter of the generated method.	"	^ '^ (Dictionary			newFrom:				{(#cr -> String cr).				(#lf -> UnixPlatform new lineEnding).				(#crlf -> Win32Platform new lineEnding).				(#unix -> UnixPlatform new lineEnding).				(#mac -> UnixPlatform new lineEnding).				(#dos -> Win32Platform new lineEnding)}) at: aValue'! !!NewLineConfigurationItem methodsFor: 'initialization'!initialize	super initialize.	explanation := 'The string that separates lines in the exported document. This is often either LF or CR\+LF but any string is possible. Values are '		, self possibleValuesString! !!NewLineConfigurationItem methodsFor: 'mapping logic'!mapperFromUserToDomainRepresentations	"coded this way because we may inline it in configuration class."	^ Dictionary		newFrom:			{(#cr -> 'String cr').			(#lf -> 'UnixPlatform new lineEnding').			(#crlf -> 'Win32Platform new lineEnding').			(#unix -> 'UnixPlatform new lineEnding').			(#mac -> 'UnixPlatform new lineEnding').			(#dos -> 'Win32Platform new lineEnding').			(#platform -> 'Smalltalk os lineEnding')}! !!NewLineConfigurationItem methodsFor: 'initialization'!possibleValuesString	^ #(#cr #lf #crlf #unix #mac #dos #platform) asString! !!NumberConfigurationItem methodsFor: 'accessing'!defaultDomainValueString	"Returns a string representing the default value but as an object once imported in Pharo and not a string used by the writer of a configuration."	^ self default asString! !!NumberConfigurationItem methodsFor: 'accessing'!domainValueConversionString	"Returns a string representing the conversion of a value from the configuration writer world to Pharo. aValue is the parameter representing the object to be converted"	^ '^ aValue'! !!PathConfigurationItem methodsFor: 'accessing'!defaultDomainValueString	"Returns a string representing the default value but as an object once imported in Pharo and not a string used by the writer of a configuration.		Should generate somethin like:			Path from: '.'	"	^ self pathCreationStringWithArgument: ('''{1}''' format: {self default})! !!PathConfigurationItem methodsFor: 'accessing'!defaultValue	"The default value is the working directory, represented as a dot"	^ '.'! !!PathConfigurationItem methodsFor: 'accessing'!domainValueConversionString	"Returns a string converting a string as written in the configuration file to a pharo object. Note that this method is like the body of a macro that will be expanded in the configuration class: here aValue is the name of the parameter of the generated method.		The result of the method will be used in the body of the following generated method (for the inputFile property)		convertInputPath: aValue	      ^ Path from: aValue		 Parameter of the item like baseline should be accessed via self nameOfProperty"	^ '^ ', (self pathCreationStringWithArgument: 'aValue')! !!PathConfigurationItem methodsFor: 'accessing'!pathCreationStringWithArgument: argument	^ 'Path from: {1}' format: { argument }! !!StringConfigurationItem class methodsFor: 'example'!example	<sampleInstance>		^ StringConfigurationItem new		propertyName: #title;		default: 'my super cool book';		yourself.! !!StringConfigurationItem methodsFor: 'accessing'!defaultDomainValueString	"Returns a string representing the default value but as an object once imported in Pharo and not a string used by the writer of a configuration."	^ '''', self default, ''''! !!StringConfigurationItem methodsFor: 'accessing'!defaultValue	"default value for the default value of the item expressed in the domain of the configuration writer"	^ 'default value for ' , self propertyName! !!StringConfigurationItem methodsFor: 'conversion'!domainValueConversionString	"Returns a string converting a string as written by in the configuration file to a pharo object. 	Note that this method is like the body of a macro that will be expanded in the configuration class: 	here aValue is the name of the parameter of the generated method.	"		^ '^ aValue'! !!SymbolConfigurationItem methodsFor: 'accessing'!defaultDomainValueString	"Returns a string representing the default value but as an object once imported in Pharo and not a string used by the writer of a configuration."	^ '#' , self default! !!SymbolConfigurationItem methodsFor: 'accessing'!defaultValue	"default value for the default value of the item expressed in the domain of the configuration writer"	^ 'default value for ' , self propertyName! !!SymbolConfigurationItem methodsFor: 'conversion'!domainValueConversionString	"Returns a string converting a string as written by in the configuration file to a pharo object. 	Note that this method is like the body of a macro that will be expanded in the configuration class: 	here aValue is the name of the parameter of the generated method.	"	^ '^ aValue'! !"Chrysal"!!ChrysalConfigurationForXXTest commentStamp: '' prior: 0!Check ChrysalConfigurationBuilder >> #itemDescriptionForXX for the definition of the description items. ChrysalConfigurationBuilder new 	configurationRootClass: ConfigurationRootForXX;	defineConfigurationClassNamed: #ConfigurationForXX 	packagedIn: 'Chrysal-Tests'; 	withDescriptionItems: ChrysalConfigurationBuilder itemDescriptionForXX!!ChrysalCompositeDomain commentStamp: '' prior: 0!I'm a dummy class just for the compositeConfigurationItem test. I represent a composite domain object.!!ConfigurationDescriptionForXX commentStamp: '' prior: 0!Empty class only used to hold on list of items. ChrysalConfigurationBuilder new				configurationRootClass: ConfigurationRootForXX;				defineConfigurationClassNamed: #ConfigurationForXX packagedIn: 'Chrysal-Tests';				withDescriptionItems: ConfigurationDescriptionForXX itemDescriptionForXX!!ConfigurationRootForXX commentStamp: '' prior: 0!ChrysalConfigurationBuilder new 	configurationRootClass: ConfigurationRootForXX;	defineConfigurationClassNamed: #ConfigurationForXX 	packagedIn: 'Chrysal-Tests'; 	withDescriptionItems: ChrysalConfigurationBuilder itemDescriptionForXX!!ChrysalConfigurationForXXTest class methodsFor: 'files'!config	"self config"		^ (Smalltalk globals at: #ConfigurationForXX) fromString: self configFileContentsForTest! !!ChrysalConfigurationForXXTest class methodsFor: 'files'!configFileContentsForTest	^ '{	''verbose'': true,	''printerComposite'' : 		[ 		''level'' : 1,		''renderAs'' : ''letter'',		''capitalization'' : ''uppercase'',		''numbering'' : true,		''headerSize'' : 2		]	}'! !!ChrysalConfigurationForXXTest class methodsFor: 'files'!configFileNameForTest	^ 'pillar.conf'! !!ChrysalConfigurationForXXTest class methodsFor: 'accessing'!resources   "Associate the resource with this class of test cases"   ^ { ChrysalTestResource }! !!ChrysalConfigurationForXXTest methodsFor: 'hooks'!configurationClass	^ ConfigurationBuilderTest ensureConfigurationForXXExist! !!ChrysalConfigurationForXXTest methodsFor: 'resources'!listSample	^  '{  "title": "A Little Scheme in Pharo",  ''printer'' : [		[    ''level'' : 1,			''renderAs'' : ''letter'',			''capitalization'' : ''uppercase'',			''numbering'' : true,			''size'' : 2		],		[	''level'' : 2,			''renderAs'' : ''number'',			''capitalization'' : ''uppercase'',			''numbering'' : true,			''size'' : 3		]	]}'! !!ChrysalConfigurationForXXTest methodsFor: 'resources'!sample	^  '{  "title": "A Little Scheme in Pharo",  "verbose":true,  "attribution": "Stéphane Ducasse with Guillermo Polito",  "series": "Square Bracket tutorials",  "keywords": "project template, Pillar, Pharo, Smalltalk",  "outputDirectory": "build",  "mainDocument": "book",  "latexTemplate": "_support/templates/main.latex.mustache",  "latexChapterTemplate": "_support/templates/chapter.latex.mustache",  "htmlTemplate": "_support/templates/html.mustache",  "htmlChapterTemplate": "_support/templates/html.mustache",  "newLine": #unix,  "latexWriter": #''latex:sbabook''}'! !!ChrysalConfigurationForXXTest methodsFor: 'running'!setUp	super setUp.		"	testingWorkingDirectory := FileSystem memory workingDirectory.	(testingWorkingDirectory / self class configFileNameForTest)		writeStreamDo: [ :stream | 			stream nextPutAll: self class configFileContentsForTest ]	"! !!ChrysalConfigurationForXXTest methodsFor: 'tests - creation from ston'!testAbsoluteComplexPath	| config |	config := self configurationClass new.	self assert: config absoluteComplex isAbsolute.	self assert: config absoluteComplex equals: (Path from: '/simple/simple1')! !!ChrysalConfigurationForXXTest methodsFor: 'tests - creation from ston'!testAbsoluteSimplePath	| config |	config := self configurationClass new.	self assert: config absoluteSimple isAbsolute.	self assert: config absoluteSimple equals: (Path from: '/simple')! !!ChrysalConfigurationForXXTest methodsFor: 'tests - composite'!testComposite	|  config composite |	config := self configurationClass newFromDictionary:  (STON fromString: '{	''printerComposite'' : 		[ 		''level'' : 1,		''renderAs'' : ''letter'',		''capitalization'' : ''uppercase'',		''numbering'' : true,		''headerSize'' : 2		]	}').	composite := config propertyAt: 'printerComposite'. 	self assert: composite capitalization equals: 'uppercase'.	self assert: composite level equals: 1.	self assert: composite numbering.	self assert: composite headerSize equals: 2.		! !!ChrysalConfigurationForXXTest methodsFor: 'tests - composite'!testCompositeDiscardUndeclaredField	|  config composite |	config := self configurationClass newFromDictionary:  (STON fromString: '{	''printerComposite'' : 		[ 		''level'' : 1,		''renderAs'' : ''letter'',		''capitalization'' : ''uppercase'',		''numbering'' : true,		''headerSize'' : 2,		"undeclaredField": true		]	}').	composite := config propertyAt: 'printerComposite'. 	self assert: composite capitalization equals: 'uppercase'.	self assert: composite level equals: 1.	self assert: composite numbering.	self assert: composite headerSize equals: 2.		! !!ChrysalConfigurationForXXTest methodsFor: 'tests - composite'!testConvertingComposite	|  config composite |	config := self configurationClass  newFromDictionary:  (STON fromString: '{		"convertedComposite": [			"title": "supercool book",			"htmlTemplate": "_support/templates/html.mustache",			"newLine":#unix,			"undeclared":"true" ]		}').	composite :=config propertyAt: 'convertedComposite'. 	self assert: composite title equals: 'supercool book'.	self assert: composite htmlTemplate class equals: FileReference.	self assert: composite newLine equals: UnixPlatform new lineEnding		! !!ChrysalConfigurationForXXTest methodsFor: 'tests - creation from ston'!testImportFromDictionaryWithConversion	| conf | 	conf := self configurationClass newFromSTONDictionary: {('verbose' -> true) . ( 'htmlChapterTemplate' -> '_support/templates/html.mustache')} asDictionary.	self assert: (conf propertyAt: 'verbose') equals: true	" and not 'true' ".	self assert: (conf propertyAt: 'htmlChapterTemplate') class equals: FileReference! !!ChrysalConfigurationForXXTest methodsFor: 'tests - creation from ston'!testImportFromFile	| config fileSystem |	fileSystem := FileSystem memory root.	fileSystem / 'test.conf'		writeStreamDo: [ :st | st nextPutAll: self sample ].	config := self configurationClass		newFromFile: fileSystem / 'test.conf'.	self assert: (config propertyAt: 'verbose')! !!ChrysalConfigurationForXXTest methodsFor: 'tests - creation from pharo'!testImportFromPharoDictionary	| conf | 	conf := self configurationClass		newFromConvertedDictionary:			{('array' -> #()).			('verbose' -> true).			('title' -> 'supercool book').			('authors' -> 'stef zegreat')} asDictionary.	self assert: (conf propertyAt: 'title') equals: 'supercool book'.	self assert: (conf propertyAt: 'array') equals: #().	self assert: (conf propertyAt: 'authors') equals: 'stef zegreat'.	self assert: conf verbose.		conf :=  self configurationClass		newFromConvertedDictionary:			{('array' -> #()).			('verbose' -> 'true' ) } asDictionary.	self assert: conf verbose equals: 'true'	! !!ChrysalConfigurationForXXTest methodsFor: 'tests - creation from ston'!testImportFromRelativePath	| config fileSystem |	fileSystem := FileSystem memory root.	fileSystem / 'test.conf'		writeStreamDo: [ :st | st nextPutAll: self sample ].	config := self configurationClass		newFromFile: fileSystem / 'test.conf'.	self assert: (config propertyAt: 'verbose')! !!ChrysalConfigurationForXXTest methodsFor: 'tests - creation from ston'!testImportFromSTONDictionary		| conf | 	conf := self configurationClass		newFromSTONDictionary:			{('verbose' -> true).			('title' -> 'supercool book').			('authors' -> 'stef zegreat')} asDictionary.	self assert: (conf propertyAt: 'title') equals: 'supercool book'.	self assert: (conf propertyAt: 'authors') equals: 'stef zegreat'.	self assert: conf verbose! !!ChrysalConfigurationForXXTest methodsFor: 'tests - creation from ston'!testImportFromSTONDictionaryWithExtended		| conf | 	conf := self configurationClass 				newFromDictionary:  {('verbose' -> true). ('title' -> 'supercool book') } asDictionary				extendedWith: {('authors' -> 'stef zegreat')} asDictionary.	self assert: (conf propertyAt: 'title') equals: 'supercool book'.	self assert: (conf propertyAt: 'authors') equals: 'stef zegreat'.	self assert: conf verbose! !!ChrysalConfigurationForXXTest methodsFor: 'tests - value types'!testImportFromString	| ston conf |	ston := '{	      "verbose": true,		"undeclaredBoolean":"true",		"title": "supercool book",		"headingLevelOffset":3,		"outputDirectory": "build",		"htmlChapterTemplate": "_support/templates/html.mustache",		"newLine":#unix		}}'.	conf := self configurationClass newFromString: ston.	self assert: conf verbose.	self assert: (conf propertyAt: 'undeclaredBoolean') equals: 'true'.	self assert: conf headingLevelOffset equals: 3.	self assert: conf title equals: 'supercool book'.	self assert: conf outputDirectory class equals: FileReference.	self assert: conf htmlChapterTemplate class equals: FileReference.	self assert: conf newLine equals: UnixPlatform new lineEnding! !!ChrysalConfigurationForXXTest methodsFor: 'tests - composite'!testList	|  config list |	config := self configurationClass newFromDictionary:  (STON fromString: '  { ''levels'' : [		[    ''level'' : 1,			''renderAs'' : ''letter'',			''capitalization'' : ''uppercase'',			''numbering'' : true,			''headerSize'' : 2		],		[	''level'' : 2,			''renderAs'' : ''number'',			''capitalization'' : ''uppercase'',			''numbering'' : true,			''headerSize'' : 3		]	]}').	list := config propertyAt: 'levels'. 	self assert: list size equals: 2.	self assert: list first class equals: ChrysalCompositeDomain.	self assert: list first capitalization equals: 'uppercase'.	self assert: list first level equals: 1.	self assert: list first numbering.	self assert: list first headerSize equals: 2.		! !!ChrysalConfigurationForXXTest methodsFor: 'tests - creation from ston'!testNewFromStream	| conf |	conf := self configurationClass newFromStream: self sample readStream.	self assert: conf verbose! !!ChrysalConfigurationForXXTest methodsFor: 'tests - composite'!testPostTreat	|  config list |	config := self configurationClass newFromDictionary:  (STON fromString: '  { ''levels'' : [		[    ''level'' : 1,			''renderAs'' : ''letter'',			''capitalization'' : ''uppercase'',			''numbering'' : true,			''headerSize'' : 2		],		[	''level'' : 2,			''renderAs'' : ''number'',			''capitalization'' : ''uppercase'',			''numbering'' : true,			''headerSize'' : 3		]	]}').	list := config propertyAt: 'levels'. 	self assert: (config  hasProperty: #newLevels).	self assert: (config propertyAt: #newLevels) size equals: 2! !!ChrysalConfigurationForXXTest methodsFor: 'tests - creation from ston'!testRelativeComplexPath	| config |	config := self configurationClass new.	self assert: config relativeComplex isRelative.	self assert: config relativeComplex equals: (Path from: 'simple/simple1')! !!ChrysalConfigurationForXXTest methodsFor: 'tests - creation from ston'!testRelativePath	| config |	config := self configurationClass new.	self assert: config relativeSimple isRelative.	self assert: config relativeSimple equals: (Path from: 'simple')! !!ChrysalConfigurationForXXTest methodsFor: 'tests - composite'!testSetConvertedValueOf	| conf |	conf := self configurationClass newFromStream: self sample readStream.	conf setConvertedValueOf: 'outputDirectory' -> 'build'.	self assert: conf outputDirectory class equals: FileReference.	self assert: conf verbose class equals: True! !!ConfigurationBuilderTest class methodsFor: 'tests'!ensureConfigurationForXXExist	"Smalltalk globals at: #ConfigurationForXX ifAbsent: [  		ChrysalConfigurationBuilder new			configurationRootClass: ConfigurationRootForXX;			defineConfigurationClassNamed: #ConfigurationForXX packagedIn: 'Chrysal-Tests';			withDescriptionItems: ConfigurationDescriptionForXX itemDescriptionForXX ]."	^ Smalltalk globals at: #ConfigurationForXX! !!ConfigurationBuilderTest class methodsFor: 'accessing'!resources   "Associate the resource with this class of test cases"   ^ { ChrysalTestResource }! !!ConfigurationBuilderTest methodsFor: 'tests'!ensureConfigurationForXXExist	^ self class ensureConfigurationForXXExist! !!ConfigurationBuilderTest methodsFor: 'tests'!testBuilder	"this should be probably turned into a resources"	self assert: (self ensureConfigurationForXXExist selectors includes: #convertAttribution:).	self assert: (self ensureConfigurationForXXExist selectors includes: #attribution:).	self assert: (self ensureConfigurationForXXExist selectors includes: #attribution).	self		assert: (self ensureConfigurationForXXExist >> #attribution) sourceCode		equals:			'attribution	"generated code"	^ self propertyAt: #attribution ifAbsent: [''me, myself and I'']'.	self		assert: (self ensureConfigurationForXXExist >> #latexWriter) sourceCode		equals:			'latexWriter	"generated code"	^ self propertyAt: #latexWriter ifAbsent: [#latex:sbabook]'! !!ConfigurationBuilderTest methodsFor: 'tests'!testDescriptionBuilder		| builder string items |	builder := ChrysalConfigurationBuilder new.	items := ConfigurationDescriptionForXX itemDescriptionForXX.	self assert: items size equals: 21.	string := String		streamContents: [ :s |  builder 										addDescriptionBodyIn: s 										forItems:  items ].	self 		assert: (STON fromString: (self class evaluate: string)) size 		equals: items size! !!ConfigurationItemTest methodsFor: 'tests'!testDefaultBoolean	| item |	item := BooleanConfigurationItem new		propertyName: #separateOutputFiles;		yourself.	self assert: item default equals: item defaultValue! !!ConfigurationItemTest methodsFor: 'tests'!testDefaultBooleanIsAReallyBoolean	| item |	item := BooleanConfigurationItem new		propertyName: #separateOutputFiles;		beFalseAsDefault;		yourself.	self assert: item default equals: 'false'.	"this is super strange to say that it should be a boolean and to test in fact a string 	but this is because the default value is a string that will be used to generate the ifAbsent: [ false ]"	self assert: item defaultDomainValueString equals: 'false'.	! !!ConfigurationItemTest methodsFor: 'tests'!testDefaultFile	| item |	item := FileConfigurationItem new		propertyName: #mainDocument;		yourself.	self assert: item default equals: item defaultValue! !!ConfigurationItemTest methodsFor: 'tests'!testDefaultString	| item |	item := StringConfigurationItem new propertyName: #title ; yourself.	self assert: item default equals: item defaultValue	! !!ConfigurationItemTest methodsFor: 'tests'!testDefaultString2	| item |	item :=	(StringConfigurationItem new		propertyName: #latexWriter;		default: 'latex:sbabook';		yourself).	self assert: item defaultDomainValueString equals: '''latex:sbabook'''	! !!ConfigurationItemTest methodsFor: 'tests'!testDefaultSymbol	| item |	item := SymbolConfigurationItem new		propertyName: #latexWriter;		default: #latex:sbabook;		yourself.	self assert: item defaultDomainValueString equals: '#latex:sbabook'! !!ConfigurationItemTest methodsFor: 'tests'!testNewLineConversion	| item |	item := NewLineConfigurationItem new		propertyName: #newLine;		yourself.	self assert: item default equals: #platform! !!ConfigurationItemTest methodsFor: 'tests'!testNumber	| item |	item := NumberConfigurationItem new		propertyName: #headerLevel;		default: 3;		yourself.	self assert: item default equals: 3! !!ConfigurationItemTest methodsFor: 'tests'!testSettingDefaultAbsolutePath	| item |	item := PathConfigurationItem new		propertyName: #title;		default: '/build';		yourself.	self assert: item default equals: '/build'! !!ConfigurationItemTest methodsFor: 'tests'!testSettingDefaultBoolean	| item |	item := BooleanConfigurationItem new		propertyName: #separateOutputFiles;		default: 'false';		yourself.	self assert: item default equals: 'false'! !!ConfigurationItemTest methodsFor: 'tests'!testSettingDefaultComplexPath	| item |	item := PathConfigurationItem new		propertyName: #title;		default: 'path/to/build';		yourself.	self assert: item default equals: 'path/to/build'! !!ConfigurationItemTest methodsFor: 'tests'!testSettingDefaultFile	| item |	item := FileConfigurationItem new		propertyName: #mainDocument;		default: 'myfile.pillar';		yourself.	self assert: item default equals: 'myfile.pillar'! !!ConfigurationItemTest methodsFor: 'tests'!testSettingDefaultPath	| item |	item := PathConfigurationItem new		propertyName: #title;		default: 'build';		yourself.	self assert: item default equals: 'build'! !!ConfigurationItemTest methodsFor: 'tests'!testSettingDefaultString	| item |	item := StringConfigurationItem new		propertyName: #title;		default: 'my super cool book';		yourself.	self assert: item default equals: 'my super cool book' ! !!ChrysalCompositeDomain methodsFor: 'accessing'!autoAnchor 	^ autoAnchor! !!ChrysalCompositeDomain methodsFor: 'accessing'!autoAnchor: aBoolean	autoAnchor := aBoolean! !!ChrysalCompositeDomain methodsFor: 'accessing'!capitalization	^ capitalization! !!ChrysalCompositeDomain methodsFor: 'accessing'!capitalization: anObject	capitalization := anObject! !!ChrysalCompositeDomain methodsFor: 'accessing'!headerSize	^ headerSize! !!ChrysalCompositeDomain methodsFor: 'accessing'!headerSize: anObject	headerSize := anObject! !!ChrysalCompositeDomain methodsFor: 'initialization'!initialize	super initialize. 	level := 99. 	capitalization := 'raw'.	numbering := false.	renderAs := 'letter'.	headerSize := 25! !!ChrysalCompositeDomain methodsFor: 'accessing'!level	^ level! !!ChrysalCompositeDomain methodsFor: 'accessing'!level: anObject	level := anObject! !!ChrysalCompositeDomain methodsFor: 'accessing'!numbering	^ numbering! !!ChrysalCompositeDomain methodsFor: 'accessing'!numbering: anObject	numbering := anObject! !!ChrysalCompositeDomain methodsFor: 'accessing'!renderAs	^ renderAs! !!ChrysalCompositeDomain methodsFor: 'accessing'!renderAs: anObject	renderAs := anObject! !!ChrysalCompositeDomain methodsFor: 'accessing'!size	^ self headerSize! !!ChrysalCompositeDomain methodsFor: 'accessing'!size: anInteger	self headerSize: anInteger! !!ChrysalConvertedCompositeDomain methodsFor: 'accessing'!htmlTemplate	^ htmlTemplate! !!ChrysalConvertedCompositeDomain methodsFor: 'accessing'!htmlTemplate: anObject	htmlTemplate := anObject! !!ChrysalConvertedCompositeDomain methodsFor: 'accessing'!newLine	^ newLine! !!ChrysalConvertedCompositeDomain methodsFor: 'accessing'!newLine: anObject	newLine := anObject! !!ChrysalConvertedCompositeDomain methodsFor: 'accessing'!title	^ title! !!ChrysalConvertedCompositeDomain methodsFor: 'accessing'!title: anObject	title := anObject! !!ConfigurationDescriptionForXX class methodsFor: 'for test and documentation'!itemDescriptionForXX	"just a simple description of items for the tests"		^ {(StringConfigurationItem new		propertyName: #title;		default: 'my super cool book';		yourself).	(NumberConfigurationItem new		propertyName: #headingLevelOffset;		default: 0;		yourself).	(BooleanConfigurationItem new		propertyName: #verbose;		beTrueAsDefault;		yourself).	(StringConfigurationItem new		propertyName: #attribution;		default: 'me, myself and I';		yourself).	(StringConfigurationItem new		propertyName: #series;		default: 'Square Bracket Associate Collection';		yourself).	(StringConfigurationItem new		propertyName: #keywords;		default: 'Pharo';		yourself).	(FolderConfigurationItem new		propertyName: #outputDirectory;		default: 'build').	(FileConfigurationItem new		propertyName: #mainDocument;		default: 'book').	(FileConfigurationItem new		propertyName: #latexTemplate;		default: '_support/templates/main.latex.mustache').	(FileConfigurationItem new		propertyName: #latexChapterTemplate;		default: '_support/templates/chapter.latex.mustache').	(FileConfigurationItem new		propertyName: #htmlTemplate;		default: '_support/templates/html.mustache').	(FileConfigurationItem new		propertyName: #htmlChapterTemplate;		default: '_support/templates/html.mustache').	(NewLineConfigurationItem new		propertyName: #newLine;		defaultIsUnix).	(SymbolConfigurationItem new		propertyName: #latexWriter;		default: #latex:sbabook;		yourself)	"may be we should turn it into a Pillar specific item that convert to a specific class".	(CompositeConfigurationItem new		propertyName: #printerComposite;		default: #ChrysalCompositeDomain;		fields: #(level renderAs capitalization numbering headerSize);		yourself).	(CompositeConfigurationItem new		propertyName: #convertedComposite;		default: #ChrysalConvertedCompositeDomain;		fields: #(newLine htmlTemplate title);		yourself).	(ListConfigurationItem new		propertyName: #levels;		default: #OrderedCollection;		element: 'printerComposite';		yourself).	(PathConfigurationItem new		propertyName: #relativeSimple;		default: 'simple';		yourself).	(PathConfigurationItem new		propertyName: #relativeComplex;		default: 'simple/simple1';		yourself).	(PathConfigurationItem new		propertyName: #absoluteSimple;		default: '/simple';		yourself).		(PathConfigurationItem new		propertyName: #absoluteComplex;		default: '/simple/simple1';		yourself)	}! !!ChrysalTestResource methodsFor: 'running'!setUp	Transcript show: 'Resources SetUp'.	Smalltalk globals at: #ConfigurationForXX ifAbsent: [  		ChrysalConfigurationBuilder new			configurationRootClass: ConfigurationRootForXX;			defineConfigurationClassNamed: #ConfigurationForXX packagedIn: 'Chrysal-Tests';			withDescriptionItems: ConfigurationDescriptionForXX itemDescriptionForXX ].	^ Smalltalk globals at: #ConfigurationForXX! !!ChrysalTestResource methodsFor: 'running'!tearDown	| forXXClass |	forXXClass := Smalltalk globals at: #ConfigurationForXX ifAbsent: [ ^ self ].	forXXClass removeFromSystem! !!ConfigurationRootForXX methodsFor: 'post hooks'!postTreat	self propertyAt: #newLevels put: self levels! !"Chrysal-Tests"!!BitmapCharacterSet commentStamp: '' prior: 0!This class implements a set of Character objects similar to CharacterSet and WideCharacterSet, but it uses a bitmap internally to test if wide (multibyte) characters belong to it rather than using a Dictionary like WideCharacterSet does. For byte characters, a simple 256-element Array is used, the same as with CharacterSet, which is faster but uses more memory.(Used by and heavily optimized for XMLParser; please refactor carefully)!!BitmapCharacterSet class methodsFor: 'inspecting'!inspectorClass	"does not use Set class>>inspectorClass because it is incompatible"	^ Smalltalk tools inspectorClass! !!BitmapCharacterSet class methodsFor: 'instance creation'!new	^ self new: 256! !!BitmapCharacterSet class methodsFor: 'instance creation'!new: aCapacity	^ self basicNew initialize: aCapacity! !!BitmapCharacterSet class methodsFor: 'instance creation'!newFrom: aCollection	"for GS portability"	^ self new		addAll: aCollection;		yourself	! !!BitmapCharacterSet methodsFor: 'copying'!, aCollection	"GS doesn't define #, for non-Sequenceable collections"	^ self copy		addAll: aCollection;		yourself! !!BitmapCharacterSet methodsFor: 'comparing'!= anObject	self == anObject		ifTrue: [^ true].	(self species == anObject species		and: [self size = anObject size])		ifFalse: [^ false].	self do: [:each |		(anObject includes: each)			ifFalse: [^ false]].	^ true.! !!BitmapCharacterSet methodsFor: 'adding'!add: aCharacter	| asciiValue |	"optimized for speed with inlining; do not refactor"	(asciiValue := aCharacter asciiValue) < 256		ifTrue: [			(byteCharacters at: asciiValue + 1)				ifFalse: [tally := tally + 1].			byteCharacters				at: asciiValue + 1				put: true]		ifFalse: [| byteIndex byte bitmask |			"256 // 8 - 31 = 1 (first index), (256 + 8) // 8 - 31 = 2 (second), etc			(with 'bitShift: -3' used over '// 8' for speed)"			byteIndex := (asciiValue bitShift: -3) - 31.			(wideCharacters == nil				or: [byteIndex > wideCharacters size])				ifTrue: [self growWideCharacterBitmapTo: (byteIndex * 1.5) asInteger].			"raises an error if asciiValue > 16r10FFFF"			byte := wideCharacters at: byteIndex.			"for the byte bitmask, left shift 1 by 7 - (asciiValue \\ 8)			(with 'bitAnd: 7' used over '\\ 8' for speed)"			bitmask := 1 bitShift: 7 - (asciiValue bitAnd: 7).						"increment the tally if the character is not already present"			(byte bitAnd: bitmask) == 0				ifTrue: [tally := tally + 1].			wideCharacters				at: byteIndex				put: (byte bitOr: bitmask)].	^ aCharacter.! !!BitmapCharacterSet methodsFor: 'adding'!addRangeFrom: aStartCharacter to: aStopCharacter	"Adds character range from aStartCharacter to aStopCharacter inclusive	or none if aStartCharacter > aStopCharacter. Returns self to avoid	creating a temp collection of the added characters."	"chars don't support to:do: (compiled inline) and using to: and do:	separately needlessly creates a (possibly large) temp array"	aStartCharacter asciiValue		to: aStopCharacter asciiValue		do: [:i | self add: (Character value: i)]! !!BitmapCharacterSet methodsFor: 'private'!byteCharacters	^ byteCharacters! !!BitmapCharacterSet methodsFor: 'enumerating'!byteCharactersDo: aBlock	1 to: byteCharacters size do: [:i |		(byteCharacters at: i)			ifTrue: [aBlock value: (Character value: i - 1)]]! !!BitmapCharacterSet methodsFor: 'accessing'!capacity	^ byteCharacters size +		(wideCharacters			ifNil: [0]			ifNotNil: [wideCharacters size * 8]).! !!BitmapCharacterSet methodsFor: 'converting'!complement	| copy |	copy := self copyEmpty.	0 to: 16r10FFFF do: [:i | | character |		character := (Character value: i).		(self includes: character)			ifFalse: [copy add: character]].	^ copy.! !!BitmapCharacterSet methodsFor: 'copying'!copyEmpty	"reimplemented for GS and Squeak compatibility"	^ self species new: self capacity! !!BitmapCharacterSet methodsFor: 'enumerating'!do: aBlock	self		byteCharactersDo: aBlock;		wideCharactersDo: aBlock! !!BitmapCharacterSet methodsFor: 'private'!growWideCharacterBitmapTo: aSizeInBytes	| newSize |	newSize := aSizeInBytes min: self maxWideCharactersSize.	wideCharacters		ifNil: [wideCharacters := ByteArray new: newSize]		ifNotNil: [			wideCharacters :=				(ByteArray new: newSize)					replaceFrom: 1					to: wideCharacters size					with: wideCharacters					startingAt: 1].! !!BitmapCharacterSet methodsFor: 'testing'!hasWideCharacters	self wideCharactersDo: [:each | ^ true].	^ false.! !!BitmapCharacterSet methodsFor: 'comparing'!hash	| hash |	hash := self species hash.	self byteCharactersDo: [:each |		hash := hash bitXor: each hash].	^ hash bitXor: self size hash.! !!BitmapCharacterSet methodsFor: 'testing'!includes: aCharacter	| asciiValue |	"optimized for speed with inlining; do not refactor"	(asciiValue := aCharacter asciiValue) < 256		ifTrue: [^ byteCharacters at: asciiValue + 1]		ifFalse: [| byteIndex |			wideCharacters				ifNil: [^ false].			"256 // 8 - 31 = 1 (first index), (256 + 8) // 8 - 31 = 2 (second), etc			(with 'bitShift: -3' used over '// 8' for speed)"			(byteIndex := (asciiValue bitShift: -3) - 31) > wideCharacters size				ifTrue: [^ false].			"for the byte bitmask, left shift 1 by 7 - (asciiValue \\ 8)			(with 'bitAnd: 7' used over '\\ 8' for speed)"			^ ((wideCharacters at: byteIndex) bitAnd:				(1 bitShift: 7 - (asciiValue bitAnd: 7))) > 0]! !!BitmapCharacterSet methodsFor: 'testing'!includesRangeFrom: aStartCharacter to: aStopCharacter	"Tests for character range from aStartCharacter to aStopCharacter	inclusive. Always returns true if aStartCharacter > aStopCharacter."	"chars don't support to:do: (compiled inline) and using to: and do:	separately needlessly creates a (possibly large) temp array"	aStartCharacter asciiValue		to: aStopCharacter asciiValue		do: [:i |			(self includes: (Character value: i))				ifFalse: [^ false]].	^ true.! !!BitmapCharacterSet methodsFor: 'initialization'!initialize: aCapacity	byteCharacters := Array new: 256 withAll: false.	aCapacity > 256		ifTrue: [			"(257 - 1) // 8 - 31 = 1 (first byte),			(257 + 8 - 1) // 8 - 31 = 2 (second byte), etc			(with 'bitShift: -3' used over '// 8' for speed)"			self growWideCharacterBitmapTo: ((aCapacity - 1) bitShift: -3) - 31].	tally := 0.! !!BitmapCharacterSet methodsFor: 'testing'!isEmpty	"Squeak's Collection>>#isEmpty is inefficient"	^ self size = 0! !!BitmapCharacterSet methodsFor: 'private'!maxWideCharactersSize	^ 139232 "(16r10FFFF bitShift: -3) - 31"! !!BitmapCharacterSet methodsFor: 'copying'!postCopy	byteCharacters := byteCharacters copy.	wideCharacters		ifNotNil: [wideCharacters := wideCharacters copy].! !!BitmapCharacterSet methodsFor: 'removing'!remove: aCharacter ifAbsent: aBlock	| asciiValue |	"optimized for speed with inlining; do not refactor"	(asciiValue := aCharacter asciiValue) < 256		ifTrue: [			(byteCharacters at: asciiValue + 1)				ifFalse: [^ aBlock value].			byteCharacters				at: asciiValue + 1				put: false]		ifFalse: [| byteIndex byte bitmask |			wideCharacters				ifNil: [^ aBlock value].				"256 // 8 - 31 = 1 (first index), (256 + 8) // 8 - 31 = 2 (second), etc			(with 'bitShift: -3' used over '// 8' for speed)"			(byteIndex := (asciiValue bitShift: -3) - 31) > wideCharacters size				ifTrue: [^ aBlock value].			"for the byte bitmask, left shift 1 by 7 - (asciiValue \\ 8)			(with 'bitAnd: 7' used over '\\ 8' for speed)"			bitmask := 1 bitShift: 7 - (asciiValue bitAnd: 7).			((byte := wideCharacters at: byteIndex) bitAnd: bitmask) == 0				ifTrue: [^ aBlock value].			wideCharacters				at: byteIndex				put: (byte bitAnd: bitmask bitInvert)].	tally := tally - 1.	^ aCharacter.! !!BitmapCharacterSet methodsFor: 'removing'!removeAll	"empties but preserves the capacity"	1 to: byteCharacters size do: [:i |		byteCharacters			at: i			put: false].	wideCharacters		ifNotNil: [			1 to: wideCharacters size do: [:i |				wideCharacters					at: i					put: 0]].	tally := 0.! !!BitmapCharacterSet methodsFor: 'removing'!removeRangeFrom: aStartCharacter to: aStopCharacter	"Removes character range from aStartCharacter to aStopCharacter inclusive	or none if aStartCharacter > aStopCharacter. Returns self to avoid	creating a temp collection of the removed characters."	"chars don't support to:do: (compiled inline) and using to: and do:	separately needlessly creates a (possibly large) temp array"	aStartCharacter asciiValue		to: aStopCharacter asciiValue		do: [:i | self remove: (Character value: i)]! !!BitmapCharacterSet methodsFor: 'accessing'!size	^ tally! !!BitmapCharacterSet methodsFor: 'private'!wideCharacters	^ wideCharacters! !!BitmapCharacterSet methodsFor: 'enumerating'!wideCharactersDo: aBlock	"optimized for speed with to:do: and inlining; do not refactor"	| baseValue |	wideCharacters		ifNil: [^ self].	baseValue := 256.	1 to: wideCharacters size do: [:byteIndex | | byte |		(byte := wideCharacters at: byteIndex) == 0			ifFalse: [				0 to: 7 do: [:shiftIndex |					(byte bitAnd: (1 bitShift: 7 - shiftIndex)) == 0						ifFalse: [							aBlock value:								(Character value: baseValue + shiftIndex)]]].		baseValue := baseValue + 8].! !"Collections-BitmapCharacterSet"!!StandardOrderedDictionary commentStamp: '' prior: 0!This class is a dictionary that uses key insertion order when enumerating, printing, or returing collections of keys/values/associations, but not when testing for equality.Insertion, updating, and inclusion testing have O(1) complexity while removing has O(n) worst-case.!!OrderPreservingDictionary commentStamp: '' prior: 0!An order-preserving dictionary that returns a configurable default value (nil by default) when an absent key or value is requested from it rather than raising an exception.!!OrderPreservingIdentityDictionary commentStamp: '' prior: 0!An IdentityDictionary version that uses == instead of = for key comparing.!!OrderPreservingStringDictionary commentStamp: '' prior: 0!An order-preserving dictionary for strings that returns empty strings instead of raising errors when absent keys/values are accessed.!!OrderPreservingIdentityStringDictionary commentStamp: '' prior: 0!An IdentityDictionary version that uses == instead of = for key comparing.!!StandardOrderedIdentityDictionary commentStamp: '' prior: 0!An IdentityDictionary version that uses == instead of = for key comparing.!!OrderPreservingDictionary class methodsFor: 'instance creation'!defaultValue: aDefaultValue	^ self new defaultValue: aDefaultValue! !!OrderPreservingDictionary class methodsFor: 'instance creation'!new: aCapacity withDefaultValue: aDefaultValue	^ self basicNew		initialize: aCapacity		withDefaultValue: aDefaultValue! !!OrderPreservingDictionary class methodsFor: 'instance creation'!newFrom: anAssociationCollection	| newDictionary |	newDictionary := super newFrom: anAssociationCollection.	(anAssociationCollection respondsTo: #defaultValue)		ifTrue: [newDictionary defaultValue: anAssociationCollection defaultValue].	^ newDictionary.! !!OrderPreservingDictionary methodsFor: 'accessing'!associationAt: aKey	^ self		associationAt: aKey		ifAbsent: [nil]! !!OrderPreservingDictionary methodsFor: 'accessing'!at: aKey	^ self		at: aKey		ifAbsent: [defaultValue]! !!OrderPreservingDictionary methodsFor: 'copying'!copyEmpty	^ self species defaultValue: defaultValue! !!OrderPreservingDictionary methodsFor: 'accessing'!defaultValue	^ defaultValue! !!OrderPreservingDictionary methodsFor: 'accessing'!defaultValue: aDefaultValue	defaultValue := aDefaultValue! !!OrderPreservingDictionary methodsFor: 'initialization'!initialize: aCapacity withDefaultValue: aDefaultValue	self initialize: aCapacity.	defaultValue := aDefaultValue.! !!OrderPreservingDictionary methodsFor: 'accessing'!keyAtIdentityValue: aValue	^ self		keyAtIdentityValue: aValue		ifAbsent: [defaultValue]! !!OrderPreservingDictionary methodsFor: 'accessing'!keyAtIndex: anIndex	^ self		keyAtIndex: anIndex		ifAbsent: [defaultValue]! !!OrderPreservingDictionary methodsFor: 'accessing'!keyAtValue: aValue	^ self		keyAtValue: aValue		ifAbsent: [defaultValue]! !!OrderPreservingDictionary methodsFor: 'removing'!removeKey: aKey	^ self		removeKey: aKey		ifAbsent: [defaultValue]! !!OrderPreservingDictionary methodsFor: 'private'!speciesNewFrom: anAssociationCollection	^ (self species newFrom: anAssociationCollection)		defaultValue: defaultValue! !!OrderPreservingIdentityDictionary methodsFor: 'accessing'!dictionaryClass	^ IdentityDictionary! !!OrderPreservingIdentityDictionary methodsFor: 'accessing'!indexOfKey: aKey ifAbsent: aBlock	^ self		identityIndexOfKey: aKey		ifAbsent: aBlock! !!OrderPreservingIdentityDictionary methodsFor: 'testing'!isIdentityDictionary	^ true! !!OrderPreservingIdentityDictionary methodsFor: 'private'!orderedKeysIndexOf: aKey	^ self orderedKeysIdentityIndexOf: aKey! !!OrderPreservingIdentityStringDictionary methodsFor: 'accessing'!dictionaryClass	^ IdentityDictionary! !!OrderPreservingIdentityStringDictionary methodsFor: 'accessing'!indexOfKey: aKey ifAbsent: aBlock	^ self		identityIndexOfKey: aKey		ifAbsent: aBlock! !!OrderPreservingIdentityStringDictionary methodsFor: 'testing'!isIdentityDictionary	^ true! !!OrderPreservingIdentityStringDictionary methodsFor: 'private'!orderedKeysIndexOf: aKey	^ self orderedKeysIdentityIndexOf: aKey! !!OrderPreservingStringDictionary methodsFor: 'accessing'!associationAt: aKey	^ self		associationAt: aKey		ifAbsent: [nil]! !!OrderPreservingStringDictionary methodsFor: 'accessing'!at: aKey	^ self		at: aKey		ifAbsent: ['']! !!OrderPreservingStringDictionary methodsFor: 'accessing'!keyAtIdentityValue: aValue	^ self		keyAtIdentityValue: aValue		ifAbsent: ['']! !!OrderPreservingStringDictionary methodsFor: 'accessing'!keyAtIndex: anIndex	^ self		keyAtIndex: anIndex		ifAbsent: ['']! !!OrderPreservingStringDictionary methodsFor: 'accessing'!keyAtValue: aValue	^ self		keyAtValue: aValue		ifAbsent: ['']! !!OrderPreservingStringDictionary methodsFor: 'removing'!removeKey: aKey	^ self		removeKey: aKey		ifAbsent: ['']! !!StandardOrderedDictionary class methodsFor: 'inspecting'!inspectorClass	^ Dictionary inspectorClass! !!StandardOrderedDictionary class methodsFor: 'instance creation'!new	^ self new: 10! !!StandardOrderedDictionary class methodsFor: 'instance creation'!new: aCapacity	^ self basicNew initialize: aCapacity! !!StandardOrderedDictionary class methodsFor: 'instance creation'!newFrom: anAssociationCollection	| newDictionary |	newDictionary := self new: anAssociationCollection size.	anAssociationCollection associationsDo: [:each |		newDictionary			at: each key			put: each value].	^ newDictionary.! !!StandardOrderedDictionary class methodsFor: 'instance creation'!newFromPairs: aSequenceableCollection	| newDictionary |	newDictionary := self new: (aSequenceableCollection size / 2) floor.	1 to: aSequenceableCollection size - 1 by: 2 do: [:i |		newDictionary			at: (aSequenceableCollection at: i)			put: (aSequenceableCollection at: i + 1)].	^ newDictionary.! !!StandardOrderedDictionary methodsFor: 'comparing'!= anObject	"Returns true if the receiver and argument are identical, or if they	are both some kind of order-preserving dictionary and if they have	the same associations regardless of order."	self == anObject		ifTrue: [^ true].	(anObject isOrderPreservingDictionary		and: [self isIdentityDictionary = anObject isIdentityDictionary			and: [self size = anObject size]])		ifFalse: [^ false].	dictionary associationsDo: [:each |		(anObject at: each key ifAbsent: [^ false]) = each value			ifFalse: [^ false]].	^ true.! !!StandardOrderedDictionary methodsFor: 'adding'!add: anAssociation	| oldSize |	oldSize := dictionary size.	dictionary add: anAssociation.	dictionary size > oldSize		ifTrue: [			orderedKeys size > oldSize				ifFalse: [self growOrderedKeys].			orderedKeys at: oldSize + 1 put: anAssociation key].	^ anAssociation.! !!StandardOrderedDictionary methodsFor: 'adding'!addAll: anAssociationCollection	"Since Collection implements #associationsDo:, this method can accept	any collection of associations including Arrays and OrderedCollections"	anAssociationCollection associationsDo: [:each | self add: each].	^ anAssociationCollection.! !!StandardOrderedDictionary methodsFor: 'accessing'!associationAt: aKey	^ dictionary associationAt: aKey! !!StandardOrderedDictionary methodsFor: 'accessing'!associationAt: aKey ifAbsent: aBlock	^ dictionary		associationAt: aKey		ifAbsent: aBlock! !!StandardOrderedDictionary methodsFor: 'accessing'!associationAt: aKey ifPresent: aBlock	"Squeak and GS do not have #associationAt:ifPresent: so it	is reimplemented for portability"	^ aBlock cull:		(dictionary			associationAt: aKey			ifAbsent: [^ nil])! !!StandardOrderedDictionary methodsFor: 'accessing'!associations	| associations i |	associations := Array new: self size.	i := 1.	self associationsDo: [:each |		associations at: i put: each.		i := i + 1].	^ associations.! !!StandardOrderedDictionary methodsFor: 'enumerating'!associationsDo: aBlock	self keysDo: [:each |		aBlock value: (self associationAt: each)]! !!StandardOrderedDictionary methodsFor: 'enumerating'!associationsSelect: aBlock	^ self speciesNewFrom: (self associations select: aBlock)! !!StandardOrderedDictionary methodsFor: 'accessing'!at: aKey	^ dictionary at: aKey! !!StandardOrderedDictionary methodsFor: 'accessing'!at: aKey ifAbsent: aBlock	^ dictionary		at: aKey		ifAbsent: aBlock! !!StandardOrderedDictionary methodsFor: 'accessing'!at: aKey ifAbsentPut: aBlock	^ self		at: aKey		ifAbsent: [			self				at: aKey				put: aBlock value]! !!StandardOrderedDictionary methodsFor: 'accessing'!at: aKey ifPresent: aBlock	"Squeak and GS don't use #cull: for the ifPresent:	block, so it is reimplemented for portability"	^ aBlock cull:		(self			at: aKey			ifAbsent: [^ nil])! !!StandardOrderedDictionary methodsFor: 'accessing'!at: aKey ifPresent: aPresentBlock ifAbsent: anAbsentBlock	"Squeak and GS don't use #cull: for the ifPresent:	block, so it is reimplemented for portability"	self		at: aKey		ifPresent: [:value | ^ aPresentBlock cull: value].	^ anAbsentBlock value.! !!StandardOrderedDictionary methodsFor: 'accessing'!at: aKey put: aValue	| oldSize |	oldSize := dictionary size.	dictionary		at: aKey		put: aValue.	dictionary size > oldSize		ifTrue: [			orderedKeys size > oldSize				ifFalse: [self growOrderedKeys].			orderedKeys at: oldSize + 1 put: aKey].	^ aValue.! !!StandardOrderedDictionary methodsFor: 'accessing'!capacity	^ dictionary capacity! !!StandardOrderedDictionary methodsFor: 'enumerating'!collect: aBlock	^ self speciesNewFrom:		(self associations collect: [:each |			each key -> (aBlock value: each value)])! !!StandardOrderedDictionary methodsFor: 'copying'!copyEmpty	"Squeak and GS don't have Collection>>#copyEmpty:, so it is	reimplemented for portability"	^ self species new! !!StandardOrderedDictionary methodsFor: 'private'!dictionary	^ dictionary! !!StandardOrderedDictionary methodsFor: 'accessing'!dictionaryClass	^ Dictionary! !!StandardOrderedDictionary methodsFor: 'enumerating'!do: aBlock	self valuesDo: aBlock! !!StandardOrderedDictionary methodsFor: 'private'!errorInvalidIndex: anIndex	"Squeak and GS do not have SubscriptOutOfBounds, so Error is used	for portability"	Error signal: 'Invalid index: ', anIndex printString! !!StandardOrderedDictionary methodsFor: 'private'!errorValueNotFound: aValue	"Squeak and GS do not have ValueNotFound, so Error is used	for portability"	Error signal: 'Value not found'! !!StandardOrderedDictionary methodsFor: 'private'!growOrderedKeys	orderedKeys :=		(Array new: ((orderedKeys size * 1.5) asInteger max: 10))			replaceFrom: 1			to: orderedKeys size			with: orderedKeys			startingAt: 1.! !!StandardOrderedDictionary methodsFor: 'comparing'!hash	^ dictionary hash! !!StandardOrderedDictionary methodsFor: 'accessing'!identityIndexOfKey: aKey	^ self		identityIndexOfKey: aKey		ifAbsent: [0]! !!StandardOrderedDictionary methodsFor: 'accessing'!identityIndexOfKey: aKey ifAbsent: aBlock	1 to: self size do: [:i |		(orderedKeys at: i) == aKey			ifTrue: [^ i]].	^ aBlock value.! !!StandardOrderedDictionary methodsFor: 'testing'!includes: anObject	^ dictionary includes: anObject! !!StandardOrderedDictionary methodsFor: 'testing'!includesAssociation: anAssociation	"IndentityDictionary>>includesAssociation: works differently on GS	testing both key and value identity, so it is reimplemented here	to behave like Pharo/Squeak"	^ (dictionary		at: anAssociation key		ifAbsent: [^ false]) = anAssociation value! !!StandardOrderedDictionary methodsFor: 'testing'!includesIdentity: anObject	"GS does not have includesIdentity:"	self valuesDo: [:each |		each == anObject			ifTrue: [^ true]].	^ false.! !!StandardOrderedDictionary methodsFor: 'testing'!includesKey: aKey	^ dictionary includesKey: aKey! !!StandardOrderedDictionary methodsFor: 'accessing'!indexOfKey: aKey	^ self		indexOfKey: aKey		ifAbsent: [0]! !!StandardOrderedDictionary methodsFor: 'accessing'!indexOfKey: aKey ifAbsent: aBlock	1 to: self size do: [:i |		(orderedKeys at: i) = aKey			ifTrue: [^ i]].	^ aBlock value.! !!StandardOrderedDictionary methodsFor: 'initialization'!initialize: aCapacity	dictionary := self dictionaryClass new: aCapacity.	orderedKeys := Array new: aCapacity.! !!StandardOrderedDictionary methodsFor: 'testing'!isDictionary	^ true! !!StandardOrderedDictionary methodsFor: 'testing'!isEmpty	"Squeak's Collection>>#isEmpty is inefficient"	^ self size = 0! !!StandardOrderedDictionary methodsFor: 'testing'!isIdentityDictionary	^ false! !!StandardOrderedDictionary methodsFor: 'testing'!isOrderPreservingDictionary	^ true! !!StandardOrderedDictionary methodsFor: 'accessing'!keyAtIdentityValue: aValue	^ self		keyAtIdentityValue: aValue		ifAbsent: [self errorValueNotFound: aValue]! !!StandardOrderedDictionary methodsFor: 'accessing'!keyAtIdentityValue: aValue ifAbsent: aBlock	"GS does not have keyAtIdentityValue:ifAbsent:"	self keysAndValuesDo: [:key :value |		value == aValue			ifTrue: [^ key]].	^ aBlock value.! !!StandardOrderedDictionary methodsFor: 'accessing'!keyAtIndex: anIndex	^ self		keyAtIndex: anIndex		ifAbsent: [self errorInvalidIndex: anIndex]! !!StandardOrderedDictionary methodsFor: 'accessing'!keyAtIndex: anIndex ifAbsent: aBlock	(anIndex > 0 and: [anIndex <= self size])		ifTrue: [^ orderedKeys at: anIndex]		ifFalse: [^ aBlock value]! !!StandardOrderedDictionary methodsFor: 'accessing'!keyAtValue: aValue	^ dictionary keyAtValue: aValue! !!StandardOrderedDictionary methodsFor: 'accessing'!keyAtValue: aValue ifAbsent: aBlock	^ dictionary		keyAtValue: aValue		ifAbsent: aBlock! !!StandardOrderedDictionary methodsFor: 'accessing'!keyForIdentity: anObject	"reimplemented for portability"	self keysAndValuesDo: [:key :value |		value == anObject			ifTrue: [^ key]].	^ nil.! !!StandardOrderedDictionary methodsFor: 'accessing'!keys	^ orderedKeys		copyFrom: 1		to: self size! !!StandardOrderedDictionary methodsFor: 'enumerating'!keysAndValuesDo: aBlock	self keysDo: [:each |		aBlock			value: each			value: (self at: each)]! !!StandardOrderedDictionary methodsFor: 'removing'!keysAndValuesRemove: aTwoArgumentBlock	| removedAssociations |	removedAssociations := OrderedCollection new.	self associationsDo: [:each |		(aTwoArgumentBlock			value: each key			value: each value)			ifTrue: [removedAssociations add: each]].	removedAssociations do: [:each | self removeKey: each key].! !!StandardOrderedDictionary methodsFor: 'enumerating'!keysDo: aBlock	"use to:do: for speed"	1 to: self size do: [:i |		aBlock value: (orderedKeys at: i)]! !!StandardOrderedDictionary methodsFor: 'accessing'!keysSortedSafely	"GS's #keysSortedSafely returns a SortedCollection instead of	an Array, so this is reimplemented directly for portability, and	'self keys' is used instead of 'dictionary keys', because GS's	#keys returns a Set which can't be sorted"	^ self keys sort! !!StandardOrderedDictionary methodsFor: 'private'!orderedKeys	^ orderedKeys! !!StandardOrderedDictionary methodsFor: 'private'!orderedKeysIdentityIndexOf: aKey	"GS does not have #identityIndexOf:"	1 to: orderedKeys size do: [:i |		(orderedKeys at: i) == aKey			ifTrue: [^ i]].	^ 0.! !!StandardOrderedDictionary methodsFor: 'private'!orderedKeysIndexOf: aKey	^ orderedKeys indexOf: aKey! !!StandardOrderedDictionary methodsFor: 'private'!orderedKeysRemove: aRemovedKey	| index |	index := self orderedKeysIndexOf: aRemovedKey.	"shift every remaining key after to the left by one"	orderedKeys		replaceFrom: index		to: self size		with: orderedKeys		startingAt: index + 1.	"one key was removed and the rest shifted, so nil what was the last	key slot before removing and shifting"	orderedKeys		at: self size + 1		put: nil.! !!StandardOrderedDictionary methodsFor: 'copying'!postCopy	orderedKeys := orderedKeys copy.	dictionary := dictionary copy.! !!StandardOrderedDictionary methodsFor: 'printing'!printElementsOn: aStream	aStream nextPut: $(.	self size > 100		ifTrue: [			aStream nextPutAll: 'size '.			self size printOn: aStream]		ifFalse: [			self associations withIndexDo: [:each :i |				aStream					print: each key;					nextPutAll: '->';					print: each value.				(i < self size)					ifTrue: [aStream space]]].	aStream nextPut: $).! !!StandardOrderedDictionary methodsFor: 'removing'!remove: anObject ifAbsent: aBlock	self shouldNotImplement! !!StandardOrderedDictionary methodsFor: 'removing'!removeAll	1 to: self size do: [:i |		orderedKeys			at: i			put: nil].	dictionary removeAll.! !!StandardOrderedDictionary methodsFor: 'removing'!removeKey: aKey	| value |	value := dictionary removeKey: aKey.	self orderedKeysRemove: aKey.	^ value.! !!StandardOrderedDictionary methodsFor: 'removing'!removeKey: aKey ifAbsent: aBlock	| oldSize value |	oldSize := dictionary size.	value :=		dictionary			removeKey: aKey			ifAbsent: aBlock.	dictionary size < oldSize		ifTrue: [self orderedKeysRemove: aKey].	^ value.! !!StandardOrderedDictionary methodsFor: 'removing'!removeKeys: aKeyCollection	"Fast removal of multiple keys; returns self to avoid	having to create a removed value collection and does not	raise errors."	aKeyCollection	size > 1		ifTrue: [| oldSize newOrderedKeys newOrderedKeysIndex |			oldSize := self size.			aKeyCollection do: [:each |				dictionary					removeKey: each					ifAbsent: [nil]].			newOrderedKeys := Array new: oldSize.			newOrderedKeysIndex := 0.			1 to: oldSize do: [:i | | key |				(dictionary includesKey: (key := orderedKeys at: i))					ifTrue: [						newOrderedKeys							at: (newOrderedKeysIndex := newOrderedKeysIndex + 1)							put: key]].			orderedKeys := newOrderedKeys]		ifFalse: [			aKeyCollection size = 1				ifTrue: [					"use #anyOne, because it can be a Set"					self						removeKey: aKeyCollection anyOne						ifAbsent: [nil]]]! !!StandardOrderedDictionary methodsFor: 'enumerating'!select: aBlock	^ self speciesNewFrom:		(self associations select: [:each | aBlock value: each value])! !!StandardOrderedDictionary methodsFor: 'accessing'!size	^ dictionary size! !!StandardOrderedDictionary methodsFor: 'private'!speciesNewFrom: anAssociationCollection	^ self species newFrom: anAssociationCollection! !!StandardOrderedDictionary methodsFor: 'accessing'!values	^ self associations collect: [:each | each value]! !!StandardOrderedDictionary methodsFor: 'enumerating'!valuesDo: aBlock	self keysDo: [:each |		aBlock value: (self at: each)]! !!StandardOrderedIdentityDictionary methodsFor: 'accessing'!dictionaryClass	^ IdentityDictionary! !!StandardOrderedIdentityDictionary methodsFor: 'accessing'!indexOfKey: aKey ifAbsent: aBlock	^ self		identityIndexOfKey: aKey		ifAbsent: aBlock! !!StandardOrderedIdentityDictionary methodsFor: 'testing'!isIdentityDictionary	^ true! !!StandardOrderedIdentityDictionary methodsFor: 'private'!orderedKeysIndexOf: aKey	^ self orderedKeysIdentityIndexOf: aKey! !!Object methodsFor: '*Collections-OrderPreservingDictionary'!isOrderPreservingDictionary	"Defined here because not all collections inherit from Collection,	so just defining it in Collection and StandardOrderedDictionary	and using #isCollection with #isOrderPreservingDictionary in	StandardOrderedDictionary>>#= would trigger a DNU."	^ false! !"Collections-OrderPreservingDictionary"!!DTDAttributeDefinitionParser commentStamp: '' prior: 0!This class parses an attribute definition in an ATTLIST declaration and returns a new XMLAttributeValidator for it. It assumes the type has already been checked for well-formedness by the tokenizer and that it contains a value like "ID", "ENTITY", or an enumeration list.!!DTDStandaloneExternalAttributeDefinitionParser commentStamp: '' prior: 0!This class parses standalone externally defined ATTLIST attribute definitions and returns XMLAttributeValidators for them that disallow attributes needing further value normalization or substitution with default or fixed default values.!!DTDContentModelParser commentStamp: '' prior: 0!This is a base class for DTD content model parsers that turn element declarations into XMLElementValidators.!!DTDElementContentModelParser commentStamp: '' prior: 0!This class parses element content models. It uses postfix conversion and an XMLNFABuilder to build an NFA before converting it to a lazy DFA (states are built when needed and cached) and returns it as an XMLElementValidator.It assumes all spaces have been removed from the input and that it's been checked for well-formedness, meaning no missing names or misplaced operators/parentheses.!!DTDStandaloneExternalElementContentModelParser commentStamp: '' prior: 0!This class parses standalone externally defined element content models and returns XMLElementValidators for them. Validators for content models that specify element content like "(one|two+)" won't treat whitespace as ignorable.!!DTDLiteralContentModelParser commentStamp: '' prior: 0!This class parses literal "ANY" and "EMPTY" element content models and returns XMLElementValidators accepting any content or no content (not even whitespace, comments, or PIs).!!DTDMixedContentModelParser commentStamp: '' prior: 0!This class parses mixed content declarations like "(#PCDATA|one|two)*" using a DTDEnumerationListParser and returns an XMLElementValidator accepting any sequence of PCDATA and the named elements in any order.!!DTDDoctypeDefinition commentStamp: '' prior: 0!This class represents the parsed internal and external subset of a DTD taken together.!!DTDEntity commentStamp: '' prior: 0!This is an abstract base class for internal and external parsed entities with replacements that can be inserted into an XML document.!!DTDParsedEntity commentStamp: '' prior: 0!This is an abstract base class for parsed entities with replacements that can be inserted into an XML document.!!DTDExternalParsedEntity commentStamp: '' prior: 0!This is an abstract base class for external parsed entities with external replacements that can be inserted into an XML document.The external replacements are resolved lazily the first time #replacement or #replacementStream is sent.!!DTDExternalGeneralParsedEntity commentStamp: '' prior: 0!This is a class for external general parsed entities with external replacements that can be inserted into an XML document.!!DTDStandaloneExternalExternalGeneralParsedEntity commentStamp: '' prior: 0!This is a class for standalone externally defined external general entities that cannot be referenced in documents.!!DTDExternalParameterParsedEntity commentStamp: '' prior: 0!This is a class for external parameter parsed entities with external replacements that can be inserted into an XML document.!!DTDInternalParsedEntity commentStamp: '' prior: 0!This is an abstract base class for internal parsed entities with replacements that can be inserted into an XML document.!!DTDInternalGeneralParsedEntity commentStamp: '' prior: 0!This is a class for internal general parsed entities with replacements that can be inserted into documents.!!DTDStandaloneExternalInternalGeneralParsedEntity commentStamp: '' prior: 0!This is a class for standalone externally defined external general entities that cannot be referenced in documents except in ATTLIST attribute declaration default values.!!DTDInternalParameterParsedEntity commentStamp: '' prior: 0!This is a class for internal parameter parsed entities with replacements that can be inserted into documents.!!DTDUnresolvableExternalParsedEntity commentStamp: '' prior: 0!This is an abstract base class for unresolvable external parsed entities that lazily raises an error when #replacement or #replacementStream is sent, which would normally trigger resolution.!!DTDUnresolvableExternalGeneralParsedEntity commentStamp: '' prior: 0!This is a class for unresolvable external general parsed entities that lazily raises an error when #replacement or #replacementStream is sent, which would normally trigger resolution.!!DTDUnresolvableExternalParameterParsedEntity commentStamp: '' prior: 0!This is a class for unresolvable external parameter parsed entities that lazily raises an error when #replacement or #replacementStream is sent, which would normally trigger resolution.!!DTDUnparsedEntity commentStamp: '' prior: 0!A class for unparsed entities. These should never be directly referenced in content with the &name; syntax, but can be named in values of ENTITY and ENTITIES attributes.!!DTDEntityConfiguration commentStamp: '' prior: 0!This class contains configurations for entity replacement/retrieval. It is separate from XMLConfiguration so it is only lazy initialized when needed and saves memory.!!DTDEnumerationListParser commentStamp: '' prior: 0!This is a parser of lists in the form of "(one|two|...)".  It assumes there is no whitespace around the "|" separated list values.!!DTDMixedContentEnumerationListParser commentStamp: '' prior: 0!This is a parser of mixed content lists in the form of "(#PCDATA|one|two|...)*".  It assumes there is no whitespace around the "|" separated list values.!!DTDNotationEnumerationListParser commentStamp: '' prior: 0!This class parses notation attribute value lists in the form of "NOTATION (one|two|...)". It assumes there is no whitespace around the "|" separated list values.!!DTDExternalEntityLimits commentStamp: '' prior: 0!This class places security limits on the number and size of external parsed entities. You can set these using the configuration messages in DTDExternalEntityResolver or remove them using removeLimits.!!DTDExternalEntityResolver commentStamp: '' prior: 0!This class resolves external entity references using XMLURI, XMLHTTPRequest, and XMLFileHandle.The #externalEntityURIFromPublicID:systemID: and #externalEntityURIFromPublicID:systemID:baseURI: convert public IDs and system IDs into resolvable XMLURI objects.The #resolveExternalEntityURI: and #streamResolveExternalEntityURI: messages can resolve external entity XMLURIs or URI strings as either a string or a stream on the undecoded entity content. If the entity is in a file, then #streamResolveExternalEntityURI: can be used to avoid storing it in-memory, but if it's fetched over HTTP, it will just return a stream on the entire in-memory HTTP response.!!DTDCachingExternalEntityResolver commentStamp: '' prior: 0!This class is a resolver that caches non-local entities in a global cache so they don't have to be retrieved again (like over HTTP). This is the default resolver.!!DTDStaticExternalEntityResolver commentStamp: '' prior: 0!This class is a resolver that maps entity URIs to string replacements so resolution can be done without HTTP or file access. Used during testing.!!DTDExternalEntityResolverLimitingDecorator commentStamp: '' prior: 0!This class is a decorator for DTDExternalEntityResolvers that limits the number of entities that can be resolved. This is not handled directly by resolvers to make them less stateful and more reusable.!!DTDNotation commentStamp: '' prior: 0!A class for notation declarations.!!DTDResolvedExternalParsedEntityReplacement commentStamp: '' prior: 0!This is an abstract class for resolved external entity replacements.!!DTDDecodedResolvedExternalParsedEntityReplacement commentStamp: '' prior: 0!This class stores the decoded resolved replacement of an external parsed entity.!!DTDUndecodedResolvedExternalParsedEntityReplacement commentStamp: '' prior: 0!This class stores the undecoded resolved replacement of an external parsed entity as well as its likely encoding.!!DTDUnresolvedExternalParsedEntityReplacement commentStamp: '' prior: 0!This class stores an entity resolver and the public ID, system ID, and base URI of an external entity so its replacement can be lazily resolved only if the entity is referenced.!!SAX2ContentHandler commentStamp: '' prior: 0!This is a base class for SAX2 content handler classes that can be injected into SAX2Parser instances with #contentHandler: before parsing:	(SAX2Parser on: xmlStringOrStream)		contentHandler: MyContentHandlerClass new;		parseDocument.See SAX2Parser and SAXHandler for more info.!!SAX2DeclarationHandler commentStamp: '' prior: 0!This is a base class for SAX2 declaration handler classes that can be injected into SAX2Parser instances with #declarationHandler: before parsing:	(SAX2Parser on: xmlStringOrStream)		declarationHandler: MyDeclarationHandlerClass new;		parseDocument.See SAX2Parser and SAXHandler for more info.!!SAX2ElementHandler commentStamp: '' prior: 0!This is a base class for SAX2 element handlers to be used with SAX2ElementParsers.SAX2ElementParsers use individual SAX2ElementHandlers to handle the #startElement*, #endElement*, and #characters: events of each element in the document.The parser can be accessed with #parser, and the parent element handler (if any) can be accessed with #parent.!!SAX2ElementCharacterHandler commentStamp: '' prior: 0!This class is a SAX2ElementHandler that handles #characters: events. Sending #characters returns the complete character data of the element as a string.!!SAX2ElementHandlerFactory commentStamp: '' prior: 0!This is a base class for element handler factories used by SAX2ElementParsers to create element handlers. Instances can be injected into a SAX2ElementParser with #elementHandlerFactory: before parsing.This factory just uses the default handler class SAX2ElementHandler for all elements.!!SAX2PluggableElementHandlerFactory commentStamp: '' prior: 0!This class is a pluggable element handler factory with an API like XMLPluggableElementFactory. Instances can be injected into a SAX2ElementParser with #elementHandlerFactory: before parsing.You can map combinations of element name, namespace URI, and attributes to specific element handler classes using the "handling" messages, and change the default element handler class used when there's no mapping with #elementHandlerClass:.Instances can be saved and reused for performance and safely modified after copying.!!SAX2ElementHandlerFactoryMapper commentStamp: '' prior: 0!This is a base class for mappers to map element handler objects to element handler factories.Requesting the factory for an element handler checks the handler's #elementHandlerFactory message first and then the mapper's own #elementHandlerFactory message which can be (and is) overridden in subclasses to return a default factory.When a SAX2ElementParser requests the factory for a new element handler, if none is found, it will reuse (inherit) the current factory.!!SAX2PluggableElementHandlerFactoryMapper commentStamp: '' prior: 0!This class is a pluggable mapper to map element handler objects to element handler factories.Requesting the factory for an element handler checks for a mapping set with  #mapElementHandlerClass: toFactory:, then the handler's  #elementHandlerFactory message, then the mapper's own #elementHandlerFactory message, which returns a default factory (unlike in the base class) which can be changed with #elementHandlerFactory:.When a SAX2ElementParser requests the factory for a new element handler, if none is found, it will reuse (inherit) the current factory, but this won't happen unless the default factory is cleared by setting #elementHandlerFactory: to nil.Instances can be saved and reused for performance and safely modified after copying.!!SAX2LexicalHandler commentStamp: '' prior: 0!This is a base class for SAX2 lexical handler classes that can be injected into SAX2Parser instances with #lexicalHandler: before parsing:	(SAX2Parser on: xmlStringOrStream)		lexicalHandler: MyLexicalHandlerClass new;		parseDocument.See SAX2Parser and SAXHandler for more info.!!SAXHandler commentStamp: '' prior: 0!This class is an event-handling XML parser. To use it, subclass it and override event handlers in the "handling" categories, such as #startDocument, #startElement:attributes:, #endElement:, and #endDocument.By default XML namespace support and validation are enabled but not external entity resolution.Once the subclass is ready, use the class "parsing" messages to parse XML:	result := SAXHandlerSubclass parse: xmlStringOrStream.	resultFromURL := SAXHandlerSubclass parseURL: xmlURLString.	resultFromFile := SAXHandlerSubclass parseFileNamed: xmlFileName.The class "instance creation" messages create and return new parsers on the input so they can be configured with messages in the  "configuring" category before parsing:	result :=		(SAXHandlerSubclass on: xmlStringOrStream)			isValidating: true;			resolvesExternalEntities: true;			parseDocument.#interruptParsing can be sent from within a handler to stop parsing, and there is also #parseDocumentWhile: and #parseDocumentUntil: 	result :=		(SAXHandlerSubclass on: xmlStringOrStream)			parseDocumentWhile: [self shouldKeepParsing].To parse incrementally, send #parser to an instance to get the underlying XMLParser object and send it #parseToken repeatedly:	(handler := SAXHandlerSubclass on: xmlStringOrStream)		isValidating: false; 		preservesUndeclaredEntityReferences: true.	parser := handler parser.	"Only parse the first 10 tokens:"	10 timesRepeat: [parser parseToken].There are security limits on input you can remove with #removeLimits or change with messages like #documentReadLimit:	result :=		(SAXHandlerSubclass on: xmlStringOrStream)			removeLimits;			documentReadLimit: newReadLimit;			maxEntityReplacementDepth: newMaxEntityDepth;			parseDocument.		#optimizeForLargeDocuments can be used when parsing large documents if you don't care for validating or namespaces.!!SAX2Parser commentStamp: '' prior: 0!This class is a parser with an API like SAX 2.0, with separate SAX2ContentHandler, SAX2LexicalHandler, and SAX2DeclarationHandler classes that are subclassed unlike SAX 1.0 where a single,  unified handler class is subclassed directly. Parsers can be created with #on: or other instance creation messages, and instances of the content, lexical, and declaration handlers can be injected before parsing with #contentHandler:, #lexicalHandler:, and #declarationHandler:, like this:	(SAX2Parser on: xmlStringOrStream)		contentHandler: MyContentHandlerClass new;		declarationHandler: MyDeclarationHandlerClass new;		lexicalHandler: MyLexicalHandlerClass new;		parseDocument.Each handler can access the SAX2Parser object with #parser and set the parsing result returned by #parseDocument with #parsingResult:.SAXHandler is not deprecated and can still be used if you prefer the SAX 1.0 style API.!!SAX2ElementParser commentStamp: '' prior: 0!This class is a SAX2Parser that uses individual SAX2ElementHandlers to handle the #startElement*, #endElement*, and #characters: events of each element in the document. All other content events are handled by a single SAX2ContentHandler as usual.Custom subclasses of SAX2ElementHandler can be mapped to element names, namespace URIs, and attributes using a SAX2PluggableElementHandlerFactory. Factories can be injected with #elementHandlerFactory: before parsing.See #testParsingSampleBooks for an example.You can have multiple factories by mapping specific SAX2ElementHandlers to specific factories using a SAX2PluggableElementHandlerFactoryMapper, which can be injected with #elementHandlerFactoryMapper: before parsing. This can be used to create a finite-state machine, with the element handler instances being the states and the mapped factories being their transitions.See #testParsingSamplePerson for an example.!!XMLDOMParser commentStamp: '' prior: 0!This class is an XML parser that parses XML into a tree of nodes with an XMLDocument node as the root:	document := XMLDOMParser parse: xmlStringOrStream.See the XML-Parser-DOM category for info on the node classes.By default, XML comments are ignored during parsing and "<!![CDATA[...]]>" sections are merged with adjacent character data as XMLString nodes. Use #preservesCommentNodes: or #preservesCDataNodes: before parsing to change this. You can also use #preservesIgnorableWhitespace: to preserve ignorable whitespace as XMLString nodes, but this requires a DTD with <!!ELEMENT> declarations to distinguish ignorable and unignorable whitespace.To control what node classes the parser uses to construct the tree, inject a custom node factory with #nodeFactory: prior to parsing. See XMLNodeFactory.See the superclass for more info.!!XMLAbstractFactory commentStamp: '' prior: 0!An abstract class for dynamically choosing a supported concrete implementation from a class hierarchy for this platform.Each root subclass needs to override #preferredImplementation to return the preferred subclass and #noSupportedImplementationFound to signal an error if none are supported, and then each subclass of the root needs to define #isSupportedImplementation to return true if it supports this platform.!!XMLFileHandle commentStamp: '' prior: 0!This is an abstract class for file handles to read/write/delete files. Subclasses need to implement the abstract methods, and then instances of the correct concrete class for this platform can be created by sending #asXMLFileHandle to a string.The #readStream/#writeStream messages return file streams that do decoding/encoding, while the #rawReadStream/#rawWriteStream streams don't.These classes implement the #get/#getUpToLimit:decoding: and #streamGet/#streamGetUpToLimit:decoding: interface of XMLURI.!!XMLFileDirectoryFileHandle commentStamp: '' prior: 0!This class uses FileDirectory/DirectoryEntry to implement file IO. This is used on Squeak and Gemstone, which don't support the Pharo FileSystem API.!!XMLFileSystemFileHandle commentStamp: '' prior: 0!This class uses the Pharo FileSystem API to implement file IO. The preferred implementation.!!XMLFileReadStreamFactory commentStamp: '' prior: 0!An abstract factory for file read streams used by XMLFileHandles.Subclasses should create read streams that return raw byte characters and not characters decoded from some encoding (like UTF-8), so that XMLParser can do its own decoding later looking at byte-order marks and the <?xml ...?> encoding attribute.!!XMLStandardFileStreamReadStreamFactory commentStamp: '' prior: 0!A StandardFileStream read stream factory. This stream is preferred for Squeak/Pharo because it does no decoding and returns byte characters so XMLParser can do its own decoding.!!XMLFileWriteStreamFactory commentStamp: '' prior: 0!An abstract factory for file write streams used by XMLFileHandles.Subclasses should create write streams that do no automatic encoding and accept raw byte characters, so XMLParser can do its own encoding.!!XMLStandardFileStreamWriteStreamFactory commentStamp: '' prior: 0!A StandardFileStream write stream factory. This stream is preferred for Pharo/Squeak because it does no encoding and accepts byte characters so XMLParser can do its own encoding.!!XMLHTTPMessage commentStamp: '' prior: 0!This is an abstract class for HTTP messages.!!XMLHTTPRequest commentStamp: '' prior: 0!This is an abstract base class for HTTP requests.These classes implement the #get/#getUpToLimit:decoding: and #streamGet/#streamGetUpToLimit:decoding: interface of XMLURI.!!XMLHTTPWebClientRequest commentStamp: '' prior: 0!This class uses the WebClient library to implement HTTP requests. This is used on Squeak when Zinc isn't installed.!!XMLHTTPZincRequest commentStamp: '' prior: 0!This class uses Zinc HTTP Components to implement HTTP requests and is the preferred implementation.!!XMLHTTPResponse commentStamp: '' prior: 0!This is an abstract base class for HTTP responses.!!XMLHTTPWebClientResponse commentStamp: '' prior: 0!This class uses the WebClient library to implement HTTP responses. This is used on Squeak when Zinc isn't installed.!!XMLHTTPZincResponse commentStamp: '' prior: 0!This class uses Zinc HTTP Components to implement HTTP responses and is the preferred implementation.!!XMLKeyValueCache commentStamp: '' prior: 0!A simple key-value cache that automatically empties when it reaches a maximum size. Uses a reentrant mutex to ensure thread-safety.!!XMLStandardKeyValueCache commentStamp: '' prior: 0!This class is the standard key-value cache implementation used on Pharo/Squeak.!!XMLReentrantMutex commentStamp: '' prior: 0!An abstract class for reentrant mutexes that support nested sends of #critical: by the same process without deadlocking.!!XMLStandardReentrantMutex commentStamp: '' prior: 0!This class is the standard implementation that uses Pharo and Squeak's Mutex class to implement a reentrant mutex.!!XMLAbstractReadStream commentStamp: '' prior: 0!An abstract class for read streams.!!XMLNullReadStream commentStamp: '' prior: 0!This class is a null read stream that is already #atEnd and also makes sending #atEnd after #close or sending #close more than once safe, which is needed for the XMLNestedStreamReader null stream.!!XMLSingleCharacterReadStream commentStamp: '' prior: 0!A read stream for single characters. This is faster and uses less memory than converting a char to a string and using a read stream on it.!!XMLAbstractReadStreamParser commentStamp: '' prior: 0!This class is a generic abstract parser class for read-stream based parsers. It wraps its input stream with an XMLReadStreamAdapter and can parse tokens using #nextDelimitedBy: and #nextDelimitedByAny: and a temp write stream buffer.!!XMLHTTPMIMETypeParser commentStamp: '' prior: 0!This is a class to parse MIME types with a main type and sub type separated by a "/", like "text/plain", and optional name=value parameters separated by ";" after. Adapted from ZnMimeType.!!XMLURIParser commentStamp: '' prior: 0!This class is a parser that can extract the scheme, user info, host, port, path segments, query (as an OrderedCollection of associations), and fragment of a URI. It does not handle percent decoding and raises no errors.!!XMLAttributeDefaultValidator commentStamp: '' prior: 0!This is a base class for attribute default validators that implement constraints from the default declaration part of an ATTLIST attribute definition.!!XMLAttributeImpliedDefaultValidator commentStamp: '' prior: 0!This class allows an attribute to be absent (the #IMPLIED constraint).!!XMLAttributeRequiredDefaultValidator commentStamp: '' prior: 0!This class makes sure an attribute is present (the #REQUIRED constrant).!!XMLAttributeValueDefaultValidator commentStamp: '' prior: 0!This class will put a default value for an attribute if the attribute is absent.!!XMLAttributeFixedValueDefaultValidator commentStamp: '' prior: 0!This class will put a default value for an attribute if the attribute is absent and also makes sure that any value matches the default (the #FIXED constraint).!!XMLStandaloneExternalAttributeFixedValueDefaultValidator commentStamp: '' prior: 0!This class will make sure the value of a standalone externally defined attribute is present and that it matches a fixed default value (the #FIXED constraint).!!XMLStandaloneExternalAttributeValueDefaultValidator commentStamp: '' prior: 0!This class will make sure the value of a standalone externally defined attribute is present (the default value is never used).!!XMLAttributeSpec commentStamp: '' prior: 0!This is a base class for attribute specifications. Subclasses need to implement matchesAttributes: to return true if the argument attribute dictionary matches the spec and false otherwise.!!XMLBasicAttributeSpec commentStamp: '' prior: 0!A simple attribute spec that checks for attributes being present and optionally having a specific value.!!XMLPluggableAttributeSpec commentStamp: '' prior: 0!A block-based pluggable attribute spec that evaluates blocks with the attribute dictionary to test matching.!!XMLAttributeValidator commentStamp: '' prior: 0!This is a base class for attribute validators.!!XMLCDataAttributeValidator commentStamp: '' prior: 0!This class validates CDATA attributes, which are not whitespace-normalized further.!!XMLStandaloneExternalCDataAttributeValidator commentStamp: '' prior: 0!This class validates standalone externally defined CDATA attributes. It disallows attributes that need substitution with default or fixed default values.!!XMLEntityAttributeValidator commentStamp: '' prior: 0!This class validates attributes that contain unparsed entity names (that must be declared).!!XMLEntitiesAttributeValidator commentStamp: '' prior: 0!This class validates attributes with lists of unparsed entity name values (that must be declared) separated by spaces.!!XMLStandaloneExternalEntitiesAttributeValidator commentStamp: '' prior: 0!This class validates standalone externally defined attributes with lists of unparsed entity name values (that must be declared) separated by spaces. It disallows attributes that require further value normalization or substitution with default or fixed default values.!!XMLStandaloneExternalEntityAttributeValidator commentStamp: '' prior: 0!This class validates standalone externally defined attributes that contain unparsed entity names (that must be declared). It disallows attributes that require further value normalization or substitution with default or fixed default values.!!XMLEnumerationAttributeValidator commentStamp: '' prior: 0!This class validates attributes that can have any value taken from a list like "(one|two|thee)".!!XMLNotationEnumerationAttributeValidator commentStamp: '' prior: 0!This class validates attributes that can have NOTATION names from a list as values.!!XMLStandaloneExternalNotationEnumerationAttributeValidator commentStamp: '' prior: 0!This class validates attributes that can have NOTATION names from a list as values. It disallows attributes that require further value normalization or substitution with default or fixed default values.!!XMLStandaloneExternalEnumerationAttributeValidator commentStamp: '' prior: 0!This class validates attributes that can have any value taken from a list like "(one|two|thee)". It disallows attributes that require further value normalization or substitution with default or fixed default values.!!XMLIDAttributeValidator commentStamp: '' prior: 0!This class validates ID attributes that must have unique (not repeated in the same document) values.!!XMLStandaloneExternalIDAttributeValidator commentStamp: '' prior: 0!This class validates standalone externally defined ID attributes that must have unique (not repeated in the same document) values. It disallows attributes that require further value normalization.!!XMLXMLIDAttributeValidator commentStamp: '' prior: 0!This class validates ID attributes for the xml:id spec.!!XMLStandaloneExternalXMLIDAttributeValidator commentStamp: '' prior: 0!This class validates standalone externally defined xml:id ID attributes. It disallows attributes that require further value normalization.!!XMLIDRefAttributeValidator commentStamp: '' prior: 0!This class validates attributes that refer to an ID of another element with a ID attribute.!!XMLIDRefsAttributeValidator commentStamp: '' prior: 0!This class validates attributes with lists of ID ref values separated by spaces.!!XMLStandaloneExternalIDRefsAttributeValidator commentStamp: '' prior: 0!This class validates standalone externally defined attributes with lists of ID ref values separated by spaces. It disallows attributes that require further value normalization or substitution with default or fixed default values.!!XMLStandaloneExternalIDRefAttributeValidator commentStamp: '' prior: 0!This class validates standalone externally defined attributes that refer to an ID of another element with an ID attribute. It disallows attributes that require further value normalization or substitution with default or fixed default values.!!XMLNmtokenAttributeValidator commentStamp: '' prior: 0!This class validates Nmtoken name attributes.!!XMLNmtokensAttributeValidator commentStamp: '' prior: 0!This class validates attributes with lists of Nmtoken name values separated by spaces.!!XMLStandaloneExternalNmtokensAttributeValidator commentStamp: '' prior: 0!This class validates standalone externally defined attributes with lists of Nmtoken name values separated by spaces. It disallows attributes that require further value normalization or substitution with default or fixed default values.!!XMLStandaloneExternalNmtokenAttributeValidator commentStamp: '' prior: 0!This class validates standalone externally defined Nmtoken name attributes. It disallows attributes that require further value normalization or substitution with default or fixed default values.!!XMLClassFinder commentStamp: '' prior: 0!A simple cross-platform interface for finding classes that may not be in the image.!!XMLConfiguration commentStamp: '' prior: 0!This class stores the settings and components of a parser. For performance it uses separate inst vars instead of a dictionary and lazy initializes some components.!!XMLDOMConfiguration commentStamp: '' prior: 0!This class stores additional settings and components relevant to the DOM parser and DOM nodes.!!XMLDFAState commentStamp: '' prior: 0!This class is a DFA state made by grouping one or more NFA states.!!XMLDFAStateCache commentStamp: '' prior: 0!This class uses a dictionary with NFAStateSet keys to cache DFA states. (Does not use the regular XML key/value  cache for performance)!!XMLDocumentValidator commentStamp: '' prior: 0!This is a base class for XML document validators.!!DTDDocumentValidator commentStamp: '' prior: 0!This class validates documents using a DTD.!!XMLElementClassMapper commentStamp: '' prior: 0!This is a base class for element class mappers. Subclasses need to implement the abstract methods to register and lookup classes mapped to element names, namespace URIs, and attributes.!!XMLBasicElementClassMapper commentStamp: '' prior: 0!This class can match elements to classes based on their names, namespace URIs, and attributes.The precedence of mapping goes:-Qualified name, namespace URI, and attributes-Qualified name and namespace URI-Qualified name and attributes-Qualified name-Non-qualified name, namespace URI, and attributes-Non-qualified name and namespace URI-Non-qualified name and attributes-Non-qualified name!!XMLElementIDValidator commentStamp: '' prior: 0!This class is shared by attribute validators to validate element IDs and ID references, including xml:id IDs.!!XMLElementNester commentStamp: '' prior: 0!This is a base class for element nesters that are used by parser tokenizers and drivers to keep track of which elements are open while parsing and ensure they are properly nested.!!XMLElementValidator commentStamp: '' prior: 0!This is a base class for element validators.!!XMLAnyElementValidator commentStamp: '' prior: 0!This class validates elements that can contain any content.!!XMLDFAElementValidator commentStamp: '' prior: 0!This class validates elements using a regular expression converted to a DFA. It ignores PCDATA, comments, and PIs.!!XMLDFAElementContentElementValidator commentStamp: '' prior: 0!This class validates elements that can only contain element content (no PCDATA) using a regular expression converted to a DFA. It ignores comments, PIs, and whitespace.!!XMLStandaloneExternalDFAElementContentElementValidator commentStamp: '' prior: 0!This class validates standalone externally defined elements with element content that cannot have whitespace between elements unlike the superclass.!!XMLEmptyElementValidator commentStamp: '' prior: 0!This class validates EMPTY elements, which can't contain elements, PCDATA, or even comments or PIs.!!XMLMixedContentElementValidator commentStamp: '' prior: 0!This class validates elements that can contain a mix of PCDATA and certain elements.!!XMLEncodingDetector commentStamp: '' prior: 0!This is a class for automatic encoding detection of streams that infers encodings from a leading byte order mark (BOM) sequence.!!XMLImplicitEncodingDetector commentStamp: '' prior: 0!This is a class for automatic encoding detection of streams that infers explicit encodings from a leading byte order mark (BOM) sequence and implicit encodings from a sequence of one or three null bytes before or after a leading ASCII character (implicit UTF 16/32).(It actually implements the YAML implicit encoding detection algorithm, looking for any leading ASCII char, not just '<', before or after a null byte sequence. This algorithm is more general than the XML one, supporting non-XML text, and since the XML one is in a "(Non-Normative)" section of the spec, we don't actually have to implement it.)!!XMLHTTPDecompressingReadStreamAdapterFactory commentStamp: '' prior: 0!This class is a read stream adapter factory for decoding content compressed with compression schemes like GZip and DEFLATE.!!XMLHTTPGZipDecompressingReadStreamAdapterFactory commentStamp: '' prior: 0!A read stram adapter factory for the GZip compression scheme. Uses GZipReadStream if available.!!XMLHTTPMIMEType commentStamp: '' prior: 0!This is an immutable class for HTTP MIME types. Adapted from ZnMimeType.!!XMLHTTPResponseContentReader commentStamp: '' prior: 0!This is an abstract base class for response content readers. The #readUpToLimit:decoding: message returns the entire  decoded (if enabled) response content, raising an XMLLimitException if it exceeds the specified limit.Subclasses need to implement #rawReadWithLength:upToLimit: to read and return the raw response content and signal an error if it exceeds the limit.!!XMLHTTPWebClientResponseContentReader commentStamp: '' prior: 0!A WebClient content reader.!!XMLHTTPZincResponseContentReader commentStamp: '' prior: 0!A Zinc content reader. Zinc handles decompression automatically, so this class doesn't.!!XMLIntegerReader commentStamp: '' prior: 0!This class reads positive hex or decimal integers from minimal streams supporting #next, #peek, and #atEnd. It returns nil instead of raising errors for invalid integers.!!XMLSmallIntegerReader commentStamp: '' prior: 0!This class reads positive hex or decimal integers up to the maximum a SmallInteger can hold from minimal streams supporting #next, #peek, and #atEnd, handling overflow with saturation. It returns nil instead of raising errors for invalid integers.!!XMLNFABuilder commentStamp: '' prior: 0!This class builds an NFA using a stack of NFAFragments.!!XMLNFAFragment commentStamp: '' prior: 0!This class implements NFA fragments for an XMLNFABuilder. It stores a first state and either a single terminal state or a collection of terminal states (using an OrderedCollection instead of an XMLNFAStateSet), and it can be connected to a state or another fragment.!!XMLNFAState commentStamp: '' prior: 0!This is a base class for NFA states.!!XMLNFAAcceptingState commentStamp: '' prior: 0!An NFA in this state is considered to accept the input.!!XMLNFABranchingState commentStamp: '' prior: 0!This state can branch off into two different states without matching against anything.!!XMLNFAMatchingState commentStamp: '' prior: 0!This state can pass to a next state if the input matches against an object.!!XMLNamespaceScope commentStamp: '' prior: 0!A namespace scope is a possibly empty set of mappings from namespace prefixes to URIs and an optional default namespace URI to be used for unprefixed elements. Scopes can be created from other scopes by copying. (Uses copy-on-write to reduce memory use.)!!XMLNamespaceScopeAllocator commentStamp: '' prior: 0!This class allocates namespace scopes with a stack. Sending #enterScope pushes a new scope onto the stack that inherits all mappings from the previous (enclosing) scope, and #exitScop pops it off.!!XMLNestedStreamReader commentStamp: '' prior: 0!This class represents a stream reader that implements pushBack: using nested streams. This enables subsitution/replacement to be performed without modifying the underlying collections streamed-over or having to copy them. It also performs line-ending normalization, transforming a CR or a CRLF sequence into a single LF character.(The code in this class is optimized; refactor with care.)!!XMLNode commentStamp: '' prior: 0!This is a base class for XML nodes. It has testing messages, messages to access the parent, sibling, and ancestor nodes, and messages to control printing.!!XMLAttribute commentStamp: '' prior: 0!The class represents an attribute node stored in an attribute node list. The name of an attribute node can be namespaced using prefixes, but the prefix must be mapped to a namespace URI in the containing element node. Unprefixed attributes have no namespace, not even a default if one is in scope, per the XML namespace standard.The element of an attribute can be accessed with #element, but also with #parent, because attributes are modeled so their element is their parent (to simplify the implementation of the XPath library).!!XMLComment commentStamp: '' prior: 0!This class represents a comment node. Comments are ignored during parsing by default. If you want them preserved as comment nodes, use #preservesCommentNodes: with the DOM parser before parsing.!!XMLDeclarationNode commentStamp: '' prior: 0!This is an abstract class for markup declaration nodes in the internal subset.!!XMLAttributeDeclaration commentStamp: '' prior: 0!This is a class for <!!ATTLIST> declarations with definitions for single attributes. (An ATTLIST with multiple attribute defs is the same as a series of separate ATTLISTs for each def)!!XMLElementDeclaration commentStamp: '' prior: 0!This is a class for <!!ELEMENT> declarations.!!XMLEntityDeclaration commentStamp: '' prior: 0!This is an abstract class for general and parameter <!!ENTITY> declarations.!!XMLGeneralEntityDeclaration commentStamp: '' prior: 0!This is a class for general <!!ENTITY> declarations.!!XMLParameterEntityDeclaration commentStamp: '' prior: 0!This is a class for parameter <!!ENTITY> declarations.!!XMLNotationDeclaration commentStamp: '' prior: 0!This is class for <!!NOTATION> declarations.!!XMLNodeWithChildren commentStamp: '' prior: 0!This is an abstract class for nodes that can contain child nodes.It has messages to access, add and remove child nodes. The nodes are stored in a kind of XMLObservableList returned by #nodes, which can be modified directly to add or remove nodes from the owner of #nodes (copy it first if that isn't what you want).There are three types of "enumerating" messages: the #nodes* messages enumerate child nodes of the receiver, the #allNode* forms enumerate (using depth-first traversal) the receiver and all descendant nodes, and the #descendantNode* forms  enumerate only descendant nodes.!!XMLDoctypeDeclaration commentStamp: '' prior: 0!This class represents a <!!DOCTYPE ...> declaration. It stores the root element name, public/system ID, and its nodes are the internal subset.!!XMLNodeWithElements commentStamp: '' prior: 0!This is an abstract class for nodes with elements.Instances provide "accessing" messages to retrieve child elements by their name and namespace information. The #elementAt: forms return the first matching element, while the #elementsAt: forms return all matching child elements.There are three different modes of enumeration: the #elements* enumerating messages enumerate child elements, the #allElements* forms enumerate the receiver (if it's an element) and all descendant elements, and the #descendantElement* forms enumerate descendant elements only.The #findElementNamed:* forms search the receicer (if it's an element) and descendants for a specific element.Element name matching is done the qualified and local name, so 'prefix:element-name' will only match 'prefix:element-name' while 'element-name' will match 'element-name', 'prefix:element-name' or 'different-prefix:element-name' and so on.The inner XML can be accessed as a string using #innerXML and set (reparsed) using #innerXML:.!!XMLDocument commentStamp: '' prior: 0!This class represents a document node, which is often the root of a DOM tree. Nodes can access their document ancestor with #document.!!XMLElement commentStamp: '' prior: 0!The class represents an element node, which has a qualified or unqualified name and optionally attributes, namespace declarations and child nodes.Element names can be tested using #isNamed: and #isNamedAny:, which test both the qualified and local name.If the name is qualified and namespace support is enabled (the default), then the prefix must be mapped to a namespace URI in the element or an ancestor. The class-side instance creation #name:namespaceURI:* and #name:namespaces:* messages and the instance-side #name:namespaceURI: message can set both simultaneously. If namespace support is disabled, prefixes are not checked.The #attribute* messages provide a Dictionary-like protocol for manipulating attribute nodes. Unlike the #elementAt:* messages, they match qualified names only, and attribute value accessors return empty strings if the attribute is absent. The underlying attribute node list can be accessed using #attributeNodes (copy before modifying if you don't want to change the element's attributes), and the names/values can be obtained as an (order-preserving) dictionary using #attributes.See the superclasses for more info.!!XMLPI commentStamp: '' prior: 0!This class represents a processing instruction node.!!XMLString commentStamp: '' prior: 0!This class represents a string (character data) node. Instances are mutable, but the string is treated as immutable. String nodes can be created using the class-side #string: message or by sending a String #asXMLStringNode. When printing, XML-escaping of special characters is done.!!XMLCData commentStamp: '' prior: 0!This class represents a preserved <!![CDATA[...]]> section. By default these are handled as XMLString nodes and merged with adjacent string nodes during parsing.  To preserve CDATA nodes, use #preservesCDataNodes: with the DOM parser before parsing.!!XMLNodeFactory commentStamp: '' prior: 0!This class is the default node factory. Its accessor messages return the classes used by the DOM parser to build a node tree. You can override these messages to return different classes and inject an instance with the DOM parser's #nodeFactory: message before parsing.!!XMLPluggableNodeFactory commentStamp: '' prior: 0!This is a pluggable node factory that can be used to change which classes the DOM parser uses to build the DOM tree. Here is an example:	(XMLDOMParser on: anXMLStringOrStream)		nodeFactory:			(XMLPluggableNodeFactory new				documentClass: MyDocumentClass;				elementClass: MyElementClass;				stringNodeClass: MyStringNodeClass);		parseDocument.Instances can be saved and reused for performance and safely modified after copying.!!XMLPluggableElementFactory commentStamp: '' prior: 0!This class is a pluggable node factory that can also map elements to different XMLElement subclasses based on the name, namespace information, and attributes of those elements. You have to create an instance, configure it to handle certain elements with certain classes, and then inject your instance into a DOM parser using #nodeFactory: before parsing. Here is an example:	(XMLDOMParser on: anXMLStringOrStream)		nodeFactory:			(XMLPluggableElementFactory new				elementClass: GenericElement;				handleElement: 'user' withClass: UserElement;				handleElement: 'report' withClass: ReportElement;				handleElement: 'report' namespaceURI: 'urn:specialreprot' withClass: SpecialReportElement);		parseDocument.Instances can be saved and reused for performance and safely modified after copying.!!XMLNodeVisitor commentStamp: '' prior: 0!This is a base class for DOM node tree visitors. Subclasses can implement any of the "visiting" messages, and instances can be used by sending a node #acceptNodeVisitor: with it as the argument.!!XMLMutatingNodeVisitor commentStamp: '' prior: 0!This is a mutating node visitor that can remove nodes during enumeration by returning nil from a #visit* method, or replace a node by returning a new node other than the argument.!!XMLValidatingNodeVisitor commentStamp: '' prior: 0!A validating node visitor that can validate DOM node trees using XMLDocumentValidators.!!XMLParser commentStamp: '' prior: 0!This class is a facade that parses XML using a driver and tokenizer. See SAXHandler and XMLDOMParser for ready-made front ends to it.!!XMLParserDriver commentStamp: '' prior: 0!This is a base class for parser drivers. Subclasses should override any of the "handling" or "handling - dtd" messages sent by tokenizers to parse tokens.!!DTDSubsetParserDriver commentStamp: '' prior: 0!An abstract class for handling internal and external DTD subset events.!!DTDExternalSubsetParserDriver commentStamp: '' prior: 0!This class is used by SAXParserDriver for parsing the external subset of a DTD.!!SAXParserDriver commentStamp: '' prior: 0!SAXParserDriver together with SAXHandler provides a SAX-like API for XML parsing. The driver processes XML tokens and signals SAX events to a SAXHandler. See SAXHandler for more info.!!XMLParserLimits commentStamp: '' prior: 0!This class places security limits on input. Setting a limit to nil disables it, and removeAll disables all.!!XMLParserTokenizer commentStamp: '' prior: 0!This is a base class for parser tokenizers that read tokens from a stream using an XMLNestedStreamReader and state objects. Sending #nextToken causes a token to be read and handler messages to be sent to a driver.Be careful changing the code in this class or subclasses because it's optimized.!!XMLWellFormedParserTokenizer commentStamp: '' prior: 0!This is a tokenizer for well-formed XML documents that supports DTD subsets and entity replacement.!!XMLPushedBackEntity commentStamp: '' prior: 0!An abstract base class for decorating pushed-back entities to keep track of the nesting of markup within entity replacements.!!XMLPushedBackGeneralEntity commentStamp: '' prior: 0!A class to decorate pushed-back general entities to keep track of the nesting of elements within entity replacements.Each time a start tag is parsed from the entity's replacement, the count is incremented, and each time an end tag is parsed, it's decremented. If it goes negative, then an end tag terminated an element not started by the entity. When the entity is popped, the count should be zero. (This is more efficient than having the element nester also keep track of which entity replacement an element began in.)!!XMLPushedBackParameterEntity commentStamp: '' prior: 0!A class to decorate pushed-back parameter entities to keep track of the nesting of include sections within entity replacements.!!XMLPushedBackStream commentStamp: '' prior: 0!A base class to store a nested stream for XMLNestedStreamReader, along with its callback and the current position, line number, and line start position of the current external stream.!!XMLPushedBackExternalStream commentStamp: '' prior: 0!A class to store a nested external stream for XMLNestedStreamReader.!!XMLPushedBackInternalStream commentStamp: '' prior: 0!A class to store a nested internal stream for XMLNestedStreamReader. It reports the current position, line number, and line start position of its enclosing external stream.!!XMLStreamAdapter commentStamp: '' prior: 0!An abstract class for read and write stream adapters.!!XMLReadStreamAdapter commentStamp: '' prior: 0!A base class for read stream adapters for basic streams that support #next, #peek, #atEnd, #position, #position:, and #reset. It adds support for skipping and reading upto a character or the end of the stream, and ensures #next and #peek return nil when the stream is #atEnd instead of raising an error.!!XMLDecodingReadStreamAdapter commentStamp: '' prior: 0!A read stream adapter that decodes stream contents using a stream converter. Used to handle encoded external streams.The class  #on: and #on:streamConverter: instance creation messages accept character and binary streams.!!XMLLimitedReadStreamAdapter commentStamp: '' prior: 0!This class is a limited read stream adapter that will not read beyond a limit. Position changes are limited so you can only move forward as many positions as the limit allows, and moving backwards increases the number of objects that can be read.!!XMLPercentDecodingReadStreamAdapter commentStamp: '' prior: 0!This class percent decodes octets for URIs.!!XMLStringReadStreamAdapter commentStamp: '' prior: 0!A read stream adapter for string read streams that accepts character input and converts it to binary output.!!XMLWriteStreamAdapter commentStamp: '' prior: 0!A base class for write stream adapters for basic streams that support #nextPut:, #nextPutAll:, #contents, #position, #position:, and #reset. It adds support for writing characters like tabs, spaces, and line endings.!!XMLEncodingWriteStreamAdapter commentStamp: '' prior: 0!A write stream adapter that encodes stream contents using a stream converter.!!XMLNodeContentWriteStreamAdapter commentStamp: '' prior: 0!A write stream adapter for writing node content with whitespace insertion if needed between writes.!!XMLPercentEncodingWriteStreamAdapter commentStamp: '' prior: 0!A write stream adapter for percent encoding octets for URIs.!!XMLStringWriteStreamAdapter commentStamp: '' prior: 0!A write stream adapter that accepts binary input and converts it to character output for string write streams.!!XMLStreamConverter commentStamp: '' prior: 0!An abstract class for stream converters.Subclasses need to implement #nextFromStream: to use #basicNext on the argument to read byte characters and decode them, and implement #nextPut:toStream: to use #basicNextPut:/#basicNextPutByte: on the second argument to encode the first.The class #basicEncodingNames method should return a basic list of names for the encoding handled by the class, and #byteOrderMarkBytes can return the bytes of a BOM if the encoding has one.!!XMLStatelessStreamConverter commentStamp: '' prior: 0!This is a base class for stateless, immutable stream converter classes. Each subclass has a single instance that is shared.!!XMLASCIIStreamConverter commentStamp: '' prior: 0!A stream converter for ASCII.!!XMLLatin1StreamConverter commentStamp: '' prior: 0!A stream converter for ISO Latin-1.!!XMLNullStreamConverter commentStamp: '' prior: 0!A stream converter that does no encoding or decoding.!!XMLUTFStreamConverter commentStamp: '' prior: 0!An abstract class for Unicode stream converters.!!XMLUTF16StreamConverter commentStamp: '' prior: 0!An abstract class for UTF-16 stream converters.!!XMLUTF16BigEndianStreamConverter commentStamp: '' prior: 0!A stream converter for big endian UTF-16 streams, and the default converter class used when a UTF-16 stream converter is created with newForEncoding: or asXMLStreamConverter and no endian is specified by the encoding name.!!XMLImplicitUTF16BigEndianStreamConverter commentStamp: '' prior: 0!A stream converter for implicit big endian UTF-16 streams.!!XMLUTF16LittleEndianStreamConverter commentStamp: '' prior: 0!A stream converter for little endian UTF-16 streams.!!XMLImplicitUTF16LittleEndianStreamConverter commentStamp: '' prior: 0!A stream converter for implicit little endian UTF-16 streams.!!XMLUTF32StreamConverter commentStamp: '' prior: 0!An abstract class for UTF-32 stream converters.!!XMLUTF32BigEndianStreamConverter commentStamp: '' prior: 0!A stream converter for big endian UTF-32 streams, and the default converter class used when a UTF-32 stream converter is created with newForEncoding: or asXMLStreamConverter and no endian is specified by the encoding name.!!XMLImplicitUTF32BigEndianStreamConverter commentStamp: '' prior: 0!A stream converter for implicit big endian UTF-32 streams.!!XMLUTF32LittleEndianStreamConverter commentStamp: '' prior: 0!A stream converter for little endian UTF-32 streams.!!XMLImplicitUTF32LittleEndianStreamConverter commentStamp: '' prior: 0!A stream converter for implicit little endian UTF-32 streams.!!XMLUTF8StreamConverter commentStamp: '' prior: 0!A stream converter for UTF-8 streams. (Rejects overlong encodings.)!!XMLImplicitUTF8StreamConverter commentStamp: '' prior: 0!A stream converter for implicit UTF-8 streams.!!XMLZincByteEncoderStreamConverter commentStamp: '' prior: 0!A stream converter that wraps the ZnByteEncoder legacy byte encoder class. (Requires Zinc.)!!XMLTokenizerState commentStamp: '' prior: 0!This is an abstract class for states to control tokenization. Subclasses must implement #nextTokenFrom: to send a tokenizing message to the argument tokenizer.!!XMLContentState commentStamp: '' prior: 0!A state for content tokens, everything from the first stat tag to the end of the document.!!XMLExternalSubsetState commentStamp: '' prior: 0!A state for external subset tokens.!!XMLExternalSubsetTextDeclarationState commentStamp: '' prior: 0!A state for <?xml ...?> text declaration tokens at the start of the external DTD subset.This state #canTerminateInput unlike XMLXMLDeclarationState because external subsets and parsed entities can be empty, but documents must have at least one element.!!XMLPrologState commentStamp: '' prior: 0!A state for prolog tokens.!!XMLDoctypeDeclarationState commentStamp: '' prior: 0!A state for <!!DOCTYPE ...> and internal subset tokens.!!XMLInternalSubsetState commentStamp: '' prior: 0!A state for internal subset tokens.!!XMLPostDoctypeDeclarationState commentStamp: '' prior: 0!A state for parsing prolog tokens after <!!DOCTYPE ...> declarations.!!XMLXMLDeclarationState commentStamp: '' prior: 0!A state for parsing the <?xml ...?> token.!!XMLTerminatedState commentStamp: '' prior: 0!A state for when tokenizing has stopped.!!XMLUninitializedState commentStamp: '' prior: 0!A state for before tokenizing has started.!!XMLURI commentStamp: '' prior: 0!A class for XML URIs. Instances are immutable and support combining with other XMLURIs or URI strings using / (to resolve relative URIs in the context of the receiver), accessing URI components, creating copies with replaced components, and retrieving the contents of http:// and file:// URLs using XMLHTTPRequest and XMLFileHandle.Uses XMLURIParser to parse URIs lazily (for example, when a URI compoenent is accessed with an "accessing" message) when created from a string and eagerly when created from a stream.URI components are stored internally in encoded form and decoded only when needed, because the XML standard requires delaying decoding for as long as possible.!!XMLUnparsedEntityValidator commentStamp: '' prior: 0!Used by attribute validators to validate attribute references to unparsed entities and notations.!!XMLAttributeDictionary commentStamp: '' prior: 0!This class is an OrderPreservingStringDictionary for XML attributes that returns empty strings instead of raising errors when absent keys are looked up. It has messages to lookup the namespace URI of an attribute key and to lookup an attribute value or association by local or qualified name and namespace URI.!!XMLNamespacedAttributeDictionary commentStamp: '' prior: 0!This subclass is used when namespaces are enabled. It has an extra inst var for namespace scopes.!!XMLException commentStamp: '' prior: 0!A generic exception class that supports message formatting. Used as a base class for exceptions in XMLParser and related packages like XPath.!!XMLParserException commentStamp: '' prior: 0!A base class for XMLParser exceptions that supports line number error info and can be used with on:do: to catch any XMLParser-related errors.!!XMLDOMException commentStamp: '' prior: 0!Invoked when a DOM tree is manipulated wrong.!!XMLEncodingException commentStamp: '' prior: 0!Invoked for encoding errors.!!XMLFileException commentStamp: '' prior: 0!Invoked for file IO errors.!!XMLHTTPException commentStamp: '' prior: 0!Invoked for HTTP errors.!!XMLLimitException commentStamp: '' prior: 0!Invoked when a security limit on input is exceeded. Use the messages in XMLParserLimits and DTDExternalEntityLimits to configure these limits or the removeLimits message to remove them completely.!!XMLNamespaceException commentStamp: '' prior: 0!Invoked when namespaces are used improperly and namespace checking is on.!!XMLParsingInterruptException commentStamp: '' prior: 0!Used to interrupt parsing from a SAXHandler. Will be silently caught.!!XMLValidationException commentStamp: '' prior: 0!Invoked when invalid XML is detected and validation is on.!!XMLWellFormednessException commentStamp: '' prior: 0!Invoked when XML markup is not well-formed.!!XMLLazyAttributeDictionary commentStamp: '' prior: 0!A lazy version of XMLAttributeDictionary that uses less memory until it's modified.!!XMLLazyNamespacedAttributeDictionary commentStamp: '' prior: 0!A lazy version of XMLNamespacedAttributeDictionary that uses less memory until it's modified.!!XMLNFAStateSet commentStamp: '' prior: 0!This class is a set of NFA states. It wraps an IdentitySet and keeps track of if any of its states is accepting.!!XMLOrderedList commentStamp: '' prior: 0!This class functions as an OrderedCollection that will not raise exceptions when attempts are made to access absent objects. This means messages like #at:, #after:, and #first will return nil when the requested object cannot be retrieved. Messages that modify the collection will still raise exceptions as usual.!!XMLObservableList commentStamp: '' prior: 0!This class is an ordered list that sends notifications to an observer when objects are added to it or removed from it. Subclasses should override the #beforeAdding:, #afterAdding:at:, #afterAddingLast: and #afterRemoving: messages to send custom notifications.!!XMLAttributeList commentStamp: '' prior: 0!This class represents an ordered list of attribute nodes. It is not the default attribute list class, but it can be used by injecting it into a DOM parser before parsing:	(parser := XMLDOMParser on: xmlSource)		nodeFactory:			(XMLPluggableNodeFactory new				attributeListClass: XMLAttributeList);		parseDocument.It should be used over the default class when you want to reduce memory use at the cost of slower attribute lookup.!!XMLCachingAttributeList commentStamp: '' prior: 0!This class represents an ordered list of attribute nodes that also keeps a dictionary mapping attribute names to nodes for faster lookup.This is the default attribute list class.!!XMLInternalSubsetList commentStamp: '' prior: 0!This class represents the list of nodes that comprise a document's internal DTD subset.!!XMLNodeList commentStamp: '' prior: 0!This class represents an ordered list of child nodes for an XML document or element. Non-modifying accessing messages like #first and #last return nil instead of raising exceptions.!!XMLCachingNodeList commentStamp: '' prior: 0!This is a node list that caches child elements by name, keeping both an ordered list of elements and a dictionary that allows for faster retrieval of elements by qualified or local name. To use it, inject it into a DOM parser before parsing:	(parser := XMLDOMParser on: xmlSource)		nodeFactory:			(XMLPluggableNodeFactory new				nodeListClass: XMLCachingNodeList);		parseDocument.It should only be used when you know the DOM tree will be queried much more often than parsed or modified and the extra memory use is OK.!!DTDAttributeDefinitionParser class methodsFor: 'private'!attributeDefaultValidatorClassForPragma: aDefaultPragma	"the default pragma should have been checked for well-formedness by the	tokenizer so it's either empty, 'FIXED', 'REQUIRED', or 'IMPLIED'"	aDefaultPragma size > 0		ifTrue: [			(aDefaultPragma at: 1) == $F				ifTrue: [^ XMLAttributeFixedValueDefaultValidator].			(aDefaultPragma at: 1) == $I				ifTrue: [^ XMLAttributeImpliedDefaultValidator].			^ XMLAttributeRequiredDefaultValidator].	^ XMLAttributeValueDefaultValidator.! !!DTDAttributeDefinitionParser class methodsFor: 'instance creation'!element: anElement attribute: anAttribute type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue	^ self new		setElement: anElement		attribute: anAttribute		type: aType		defaultValidator:			((self attributeDefaultValidatorClassForPragma: aDefaultPragma)				attribute: anAttribute				value: aDefaultValue)! !!DTDAttributeDefinitionParser methodsFor: 'private'!attributeValidatorClassForType	"the tokenizer should have checked the type for well-formedness	so it's only one of CDATA, ID, IDREF, IDREFS, etc"		| nextChar |	(nextChar := type at: 1) == $C		ifTrue: [^ XMLCDataAttributeValidator].	nextChar == $I		ifTrue: [			type size = 2 "'ID' size"				ifTrue: [					attribute = 'xml:id'						ifTrue: [^ XMLXMLIDAttributeValidator].					^ XMLIDAttributeValidator].			type size = 5 "'IDREF' size"				ifTrue: [^ XMLIDRefAttributeValidator].			"'IDREF' size < 'IDREFS' size"			^ XMLIDRefsAttributeValidator].	nextChar == $E		ifTrue: [			type size = 6 "'ENTITY' size"				ifTrue: [^ XMLEntityAttributeValidator].			"'ENTITY' size < 'ENTITIES' size"			^ XMLEntitiesAttributeValidator].	nextChar == $N		ifTrue: [			type size = 7 "'NMTOKEN' size"				ifTrue: [^ XMLNmtokenAttributeValidator].			type size = 8 "'NMTOKENS' size"				ifTrue: [^ XMLNmtokensAttributeValidator].			"'NMTOKENS' size < 'NOTATION (' size"			enumerationListParserClass := DTDNotationEnumerationListParser.			^ XMLNotationEnumerationAttributeValidator].	"otherwise it's a (one|two|...) enumeration attribute"	enumerationListParserClass := DTDEnumerationListParser.	^ XMLEnumerationAttributeValidator.! !!DTDAttributeDefinitionParser methodsFor: 'parsing'!parse	| validator |		validator :=		self attributeValidatorClassForType			element: element			attribute: attribute			defaultValidator: defaultValidator.	enumerationListParserClass		ifNotNil: [			validator allowedValues:				(enumerationListParserClass on: type) parse].	^ validator.! !!DTDAttributeDefinitionParser methodsFor: 'initialization'!setElement: anElement attribute: anAttribute type: aType defaultValidator: aDefaultValidator	element := anElement.	attribute := anAttribute.	type := aType.	defaultValidator := aDefaultValidator.! !!DTDStandaloneExternalAttributeDefinitionParser class methodsFor: 'private'!attributeDefaultValidatorClassForPragma: aDefaultPragma	^ (super attributeDefaultValidatorClassForPragma: aDefaultPragma)		standaloneExternalClass! !!DTDStandaloneExternalAttributeDefinitionParser methodsFor: 'private'!attributeValidatorClassForType	^ super attributeValidatorClassForType standaloneExternalClass! !!DTDContentModelParser class methodsFor: 'instance creation'!element: anElement contentModel: aContentModel	^ self new		setElement: anElement		contentModel: aContentModel! !!DTDContentModelParser class methodsFor: 'accessing'!parserClassForContentModel: aContentModel	"the tokenizer removes all spaces from the content model	and checks it for well-formedness"	(aContentModel at: 1) == $(		ifTrue: [			(aContentModel at: 2) == $# "#PCDATA mixed content"				ifTrue: [^ DTDMixedContentModelParser]				ifFalse: [^ DTDElementContentModelParser]]		ifFalse: [^ DTDLiteralContentModelParser]! !!DTDContentModelParser class methodsFor: 'defaults'!standaloneExternalClass	^ self! !!DTDContentModelParser methodsFor: 'parsing'!parse	self subclassResponsibility! !!DTDContentModelParser methodsFor: 'initialization'!setElement: anElement contentModel: aContentModel	element := anElement.	contentModel := aContentModel.! !!DTDElementContentModelParser class methodsFor: 'class initialization'!initialize	"self initialize"	self		initializeSpecialCharacterParsers;		initializeOperatorApplicators! !!DTDElementContentModelParser class methodsFor: 'class initialization'!initializeOperatorApplicators	"use an array instead of a dictionary for speed, and	assign after with #yourself to avoid possible race	conditions when reinitializing the class"	OperatorApplicators :=		(Array new: 255)			at: $, asciiValue put: #applyConcatenation;			at: $| asciiValue put: #applyBranch;			at: $? asciiValue put: #applyOptional;			at: $* asciiValue put: #applyStar;			at: $+ asciiValue put: #applyPlus;			yourself! !!DTDElementContentModelParser class methodsFor: 'class initialization'!initializeSpecialCharacterParsers	"use an array instead of a dictionary for speed, and	assign after with #yourself to avoid possible race	conditions when reinitializing the class"	SpecialCharacterParsers :=		(Array new: 255)			at: $( asciiValue put: #parseOpeningParenthesis:;			at: $) asciiValue put: #parseClosingParenthesis:;			at: $, asciiValue put: #parseBinaryOperator:;			at: $| asciiValue put: #parseBinaryOperator:;			at: $? asciiValue put: #parseUnaryOperator:;			at: $* asciiValue put: #parseUnaryOperator:;			at: $+ asciiValue put: #parseUnaryOperator:;			yourself! !!DTDElementContentModelParser class methodsFor: 'defaults'!standaloneExternalClass	^ DTDStandaloneExternalElementContentModelParser! !!DTDElementContentModelParser methodsFor: 'private'!applyBinaryOperatorOnStack	self applyOperator: binaryOperatorStack removeLast! !!DTDElementContentModelParser methodsFor: 'private'!applyOperator: aCharacter	nfaBuilder perform:		(OperatorApplicators at: aCharacter asciiValue)! !!DTDElementContentModelParser methodsFor: 'defaults'!elementValidatorClass	^ XMLDFAElementContentElementValidator! !!DTDElementContentModelParser methodsFor: 'private'!hasBinaryOperatorOnStack	^ binaryOperatorStack size > 0		and: [binaryOperatorStack last ~~ $(]! !!DTDElementContentModelParser methodsFor: 'parsing'!parse	"the tokenizer removes all spaces from the content model and checks	it for well-formedness (meaning no missing names or misplaced	operators/parentheses), which simplifies parsing"	| nameStart |	binaryOperatorStack := OrderedCollection new.	nfaBuilder := XMLNFABuilder new.	1 to: contentModel size do: [:i |		(self parserForSpecialCharacter: (contentModel at: i))			ifNil: [				nameStart					ifNil: [nameStart := i]]			ifNotNil: [:selector |				nameStart					ifNotNil: [						nfaBuilder pushFragmentMatching:							(contentModel copyFrom: nameStart to: i - 1).						nameStart := nil].				self					perform: selector					with: (contentModel at: i)]].	self popRemainingBinaryOperators.	^ self elementValidatorClass		element: element		dfa: nfaBuilder asAcceptingNFA asDFAState.! !!DTDElementContentModelParser methodsFor: 'private'!parseBinaryOperator: aCharacter	binaryOperatorStack addLast: aCharacter! !!DTDElementContentModelParser methodsFor: 'private'!parseClosingParenthesis: aCharacter	self popRemainingBinaryOperators.	(binaryOperatorStack size > 0		and: [binaryOperatorStack last == $(])		ifTrue: [binaryOperatorStack removeLast].! !!DTDElementContentModelParser methodsFor: 'private'!parseOpeningParenthesis: aCharacter	binaryOperatorStack addLast: $(! !!DTDElementContentModelParser methodsFor: 'private'!parseUnaryOperator: aCharacter	self applyOperator: aCharacter! !!DTDElementContentModelParser methodsFor: 'private'!parserForSpecialCharacter: aCharacter	| asciiValue |	"avoid at:ifAbsent: for speed"	((asciiValue := aCharacter asciiValue) > 0		and: [asciiValue <= SpecialCharacterParsers size])			ifTrue: [^ SpecialCharacterParsers at: asciiValue]			ifFalse: [^ nil]! !!DTDElementContentModelParser methodsFor: 'private'!popRemainingBinaryOperators	[self hasBinaryOperatorOnStack]		whileTrue: [self applyBinaryOperatorOnStack]! !!DTDStandaloneExternalElementContentModelParser methodsFor: 'defaults'!elementValidatorClass	^ XMLStandaloneExternalDFAElementContentElementValidator! !!DTDLiteralContentModelParser methodsFor: 'parsing'!parse	"either ANY or EMPTY"	(contentModel at: 1) == $A		ifTrue: [^ XMLAnyElementValidator element: element]		ifFalse: [^ XMLEmptyElementValidator element: element]! !!DTDMixedContentModelParser methodsFor: 'parsing'!parse	^ XMLMixedContentElementValidator		element: element		allowedContent:			(DTDMixedContentEnumerationListParser on: contentModel)				parse! !!DTDDoctypeDefinition methodsFor: 'adding'!addExternalGeneralEntity: aName resolver: aResolver publicID: aPublicID systemID: aSystemID baseURI: aBaseURIString	(self generalEntities includesKey: aName)		ifTrue: [^ nil].	^ self generalEntities		at: aName		put:			(DTDExternalGeneralParsedEntity				name: aName				resolver: aResolver				publicID: aPublicID				systemID: aSystemID				baseURI: aBaseURIString).! !!DTDDoctypeDefinition methodsFor: 'adding'!addExternalParameterEntity: aName resolver: aResolver publicID: aPublicID systemID: aSystemID baseURI: aBaseURIString	(self parameterEntities includesKey: aName)		ifTrue: [^ nil].	^ self parameterEntities		at: aName		put:			(DTDExternalParameterParsedEntity				name: aName				resolver: aResolver				publicID: aPublicID				systemID: aSystemID				baseURI: aBaseURIString).! !!DTDDoctypeDefinition methodsFor: 'adding'!addGeneralEntitiesFrom: aDoctypeDefinition	aDoctypeDefinition generalEntities keysAndValuesDo: [:name :entity |		self generalEntities			at: name			ifAbsentPut: [entity]]! !!DTDDoctypeDefinition methodsFor: 'adding'!addInternalGeneralEntity: aName replacement: aReplacement baseURI: aBaseURIString	(self generalEntities includesKey: aName)		ifTrue: [^ nil].	^ self generalEntities		at: aName		put:			(DTDInternalGeneralParsedEntity 				name: aName				replacement: aReplacement				uri: aBaseURIString).! !!DTDDoctypeDefinition methodsFor: 'adding'!addInternalParameterEntity: aName replacement: aReplacement baseURI: aBaseURIString	(self parameterEntities includesKey: aName)		ifTrue: [^ nil].	^ self parameterEntities		at: aName		put:			(DTDInternalParameterParsedEntity				name: aName				replacement: aReplacement				uri: aBaseURIString).! !!DTDDoctypeDefinition methodsFor: 'adding'!addNotation: aName publicID: aPublicID systemID: aSystemID	(self notations includesKey: aName)		ifTrue: [^ nil].	^ self notations		at: aName		put:			(DTDNotation				name: aName				publicID: aPublicID				systemID: aSystemID).! !!DTDDoctypeDefinition methodsFor: 'adding'!addStandaloneExternalExternalGeneralEntity: aName resolver: aResolver publicID: aPublicID systemID: aSystemID baseURI: aBaseURIString	(self generalEntities includesKey: aName)		ifTrue: [^ nil].	^ self generalEntities		at: aName		put:			(DTDStandaloneExternalExternalGeneralParsedEntity				name: aName				resolver: aResolver				publicID: aPublicID				systemID: aSystemID				baseURI: aBaseURIString).! !!DTDDoctypeDefinition methodsFor: 'adding'!addStandaloneExternalInternalGeneralEntity: aName replacement: aReplacement baseURI: aBaseURIString	(self generalEntities includesKey: aName)		ifTrue: [^ nil].	^ self generalEntities		at: aName		put:			(DTDStandaloneExternalInternalGeneralParsedEntity 				name: aName				replacement: aReplacement				uri: aBaseURIString).! !!DTDDoctypeDefinition methodsFor: 'adding'!addStandaloneExternalValidatorForAttributeIn: anElement named: anAttribute type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue	| attributes |	attributes :=		self attributeValidators			at: anElement			ifAbsentPut: [Dictionary new].	(attributes includesKey: anAttribute)		ifTrue: [^ nil].	^ attributes		at: anAttribute		put:			((DTDStandaloneExternalAttributeDefinitionParser				element: anElement				attribute: anAttribute				type: aType				defaultPragma: aDefaultPragma				defaultValue: aDefaultValue) parse					initializeWithValidatorsFrom: self).! !!DTDDoctypeDefinition methodsFor: 'adding'!addStandaloneExternalValidatorForElement: anElement contentModel: aContentModel	(self elementValidators includesKey: anElement)		ifTrue: [^ nil].	^ self elementValidators		at: anElement		put:			((DTDContentModelParser parserClassForContentModel: aContentModel)				standaloneExternalClass					element: anElement					contentModel: aContentModel) parse.! !!DTDDoctypeDefinition methodsFor: 'adding'!addUnparsedEntity: aName publicID: aPublicID systemID: aSystemID ndata: aNotation	(self generalEntities includesKey: aName)		ifTrue: [^ nil].	^ self generalEntities		at: aName		put:			(self unparsedEntities				at: aName				put:					(DTDUnparsedEntity						name: aName						publicID: aPublicID						systemID: aSystemID						ndata: aNotation)).! !!DTDDoctypeDefinition methodsFor: 'adding'!addUnresolvableExternalGeneralEntity: aName	(self generalEntities includesKey: aName)		ifTrue: [^ nil].	^ self generalEntities		at: aName		put: (DTDUnresolvableExternalGeneralParsedEntity named: aName).! !!DTDDoctypeDefinition methodsFor: 'adding'!addUnresolvableExternalParameterEntity: aName	(self parameterEntities includesKey: aName)		ifTrue: [^ nil].	^ self parameterEntities		at: aName		put: (DTDUnresolvableExternalParameterParsedEntity named: aName).! !!DTDDoctypeDefinition methodsFor: 'adding'!addValidatorForAttributeIn: anElement named: anAttribute type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue	| attributes |	attributes :=		self attributeValidators			at: anElement			ifAbsentPut: [Dictionary new].	(attributes includesKey: anAttribute)		ifTrue: [^ nil].	^ attributes		at: anAttribute		put:			((DTDAttributeDefinitionParser				element: anElement				attribute: anAttribute				type: aType				defaultPragma: aDefaultPragma				defaultValue: aDefaultValue) parse					initializeWithValidatorsFrom: self).! !!DTDDoctypeDefinition methodsFor: 'adding'!addValidatorForElement: anElement contentModel: aContentModel	(self elementValidators includesKey: anElement)		ifTrue: [^ nil].	^ self elementValidators		at: anElement		put:			((DTDContentModelParser parserClassForContentModel: aContentModel)				element: anElement				contentModel: aContentModel) parse.! !!DTDDoctypeDefinition methodsFor: 'accessing'!attributeValidators	^ attributeValidators ifNil: [attributeValidators := Dictionary new]! !!DTDDoctypeDefinition methodsFor: 'accessing'!attributeValidatorsAt: aName	^ self		attributeValidatorsAt: aName		ifAbsent: [nil]! !!DTDDoctypeDefinition methodsFor: 'accessing'!attributeValidatorsAt: aName ifAbsent: aBlock	^ self attributeValidators		at: aName		ifAbsent: aBlock! !!DTDDoctypeDefinition methodsFor: 'accessing'!elementIDValidator	^ elementIDValidator ifNil: [elementIDValidator := XMLElementIDValidator new]! !!DTDDoctypeDefinition methodsFor: 'accessing'!elementValidators	^ elementValidators ifNil: [elementValidators := Dictionary new]! !!DTDDoctypeDefinition methodsFor: 'accessing'!elementValidatorsAt: aName	^ self		elementValidatorsAt: aName		ifAbsent: [nil]! !!DTDDoctypeDefinition methodsFor: 'accessing'!elementValidatorsAt: aName ifAbsent: aBlock	^ self elementValidators		at: aName		ifAbsent: aBlock! !!DTDDoctypeDefinition methodsFor: 'accessing'!generalEntities	^ generalEntities ifNil: [generalEntities := Dictionary new]! !!DTDDoctypeDefinition methodsFor: 'accessing'!generalEntityAt: aName	^ self		generalEntityAt: aName		ifAbsent: [nil]! !!DTDDoctypeDefinition methodsFor: 'accessing'!generalEntityAt: aName ifAbsent: aBlock	^ self generalEntities		at: aName		ifAbsent: aBlock! !!DTDDoctypeDefinition methodsFor: 'testing'!hasAttributeValidators	"optimized to avoid lazy initialization"	attributeValidators == nil		ifTrue: [^ false].	^ attributeValidators size > 0.! !!DTDDoctypeDefinition methodsFor: 'testing'!hasElementIDReferences	"direct access to avoid lazy initialization"	^ elementIDValidator notNil		and: [elementIDValidator hasIDReferences]! !!DTDDoctypeDefinition methodsFor: 'testing'!hasElementIDs	"direct access to avoid lazy initialization"	^ elementIDValidator notNil		and: [elementIDValidator hasIDs]! !!DTDDoctypeDefinition methodsFor: 'testing'!hasElementValidators	"optimized to avoid lazy initialization"	elementValidators == nil		ifTrue: [^ false].	^ elementValidators size > 0.! !!DTDDoctypeDefinition methodsFor: 'testing'!hasEntities	^ self hasGeneralEntities		or: [self hasParameterEntities			or: [self hasUnparsedEntities]]! !!DTDDoctypeDefinition methodsFor: 'testing'!hasGeneralEntities	"direct access to avoid lazy initialization"	^ generalEntities notNil		and: [generalEntities notEmpty]! !!DTDDoctypeDefinition methodsFor: 'testing'!hasNotationAttributeValidators	^ self hasAttributeValidators		and: [self unparsedEntityValidator hasNotationAttributeValidators]! !!DTDDoctypeDefinition methodsFor: 'testing'!hasNotations	"direct access to avoid lazy initialization"	^ notations notNil		and: [notations notEmpty]! !!DTDDoctypeDefinition methodsFor: 'testing'!hasParameterEntities	"direct access to avoid lazy initialization"	^ parameterEntities notNil		and: [parameterEntities notEmpty]! !!DTDDoctypeDefinition methodsFor: 'testing'!hasRoot	^ root notNil and: [root notEmpty]! !!DTDDoctypeDefinition methodsFor: 'testing'!hasUnparsedEntities	"direct access to avoid lazy initialization"	^ unparsedEntities notNil		and: [unparsedEntities notEmpty]! !!DTDDoctypeDefinition methodsFor: 'instance creation'!newValidator	^ DTDDocumentValidator doctypeDefinition: self! !!DTDDoctypeDefinition methodsFor: 'accessing'!notations	^ notations ifNil: [notations := Dictionary new]! !!DTDDoctypeDefinition methodsFor: 'accessing'!parameterEntities	^ parameterEntities ifNil: [parameterEntities := Dictionary new]! !!DTDDoctypeDefinition methodsFor: 'accessing'!parameterEntityAt: aName	^ self		parameterEntityAt: aName		ifAbsent: [nil]! !!DTDDoctypeDefinition methodsFor: 'accessing'!parameterEntityAt: aName ifAbsent: aBlock	^ self parameterEntities		at: aName		ifAbsent: aBlock! !!DTDDoctypeDefinition methodsFor: 'processing'!processStartTag: anElement attributes: aDictionary	self hasAttributeValidators		ifFalse: [^ self].	(self		attributeValidatorsAt: anElement		ifAbsent: [^ self])		valuesDo: [:each | each processAttributes: aDictionary]! !!DTDDoctypeDefinition methodsFor: 'removing'!removeElementIDReferences	self hasElementIDReferences		ifTrue: [self elementIDValidator removeIDReferences]! !!DTDDoctypeDefinition methodsFor: 'removing'!removeElementIDs	self hasElementIDs		ifTrue: [self elementIDValidator removeIDs]! !!DTDDoctypeDefinition methodsFor: 'accessing'!root	^ root ifNil: [root := '']! !!DTDDoctypeDefinition methodsFor: 'accessing'!root: aRootElement	root := aRootElement! !!DTDDoctypeDefinition methodsFor: 'accessing'!unparsedEntities	^ unparsedEntities ifNil: [unparsedEntities := Dictionary new]! !!DTDDoctypeDefinition methodsFor: 'accessing'!unparsedEntityValidator	^ unparsedEntityValidator		ifNil: [			unparsedEntityValidator :=				XMLUnparsedEntityValidator					unparsedEntities: self unparsedEntities					notations: self notations]! !!DTDDoctypeDefinition methodsFor: 'validation'!validateCompletedDefinition	self hasUnparsedEntities		ifTrue: [self unparsedEntityValidator validateUnparsedEntityDeclarations].	self hasNotationAttributeValidators		ifTrue: [self unparsedEntityValidator validateNotationAttributeDeclarationDefaults].! !!DTDEntity class methodsFor: 'instance creation'!name: aName	^ self named: aName! !!DTDEntity class methodsFor: 'instance creation'!named: aName	^ self new name: aName! !!DTDEntity methodsFor: 'converting'!asReference	^ String streamContents: [:stream | self printReferenceOn: stream]! !!DTDEntity methodsFor: 'testing'!isExternal	^ false! !!DTDEntity methodsFor: 'testing'!isParameter	^ false! !!DTDEntity methodsFor: 'testing'!isStandaloneExternal	^ false! !!DTDEntity methodsFor: 'testing'!isUnparsed	^ false! !!DTDEntity methodsFor: 'accessing'!name	^ name ifNil: [name := '']! !!DTDEntity methodsFor: 'accessing'!name: aName	name := aName! !!DTDEntity methodsFor: 'printing'!printNameOn: aStream	aStream nextPutAll: self name! !!DTDEntity methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self printNameOn: aStream.	aStream nextPut: $).! !!DTDEntity methodsFor: 'printing'!printReferenceOn: aStream	aStream		nextPut: self referencePrefix;		nextPutAll: self name;		nextPut: $;! !!DTDEntity methodsFor: 'private '!referencePrefix	^ self isParameter		ifTrue: [$%]		ifFalse: [$&]! !!DTDEntity methodsFor: 'accessing'!uri	^ uri ifNil: [uri := '']! !!DTDEntity methodsFor: 'accessing'!uri: aURIString	uri := aURIString! !!DTDStandaloneExternalExternalGeneralParsedEntity methodsFor: 'testing'!isStandaloneExternal	^ true! !!DTDExternalParameterParsedEntity methodsFor: 'testing'!isParameter	^ true! !!DTDExternalParsedEntity class methodsFor: 'instance creation'!name: aName resolver: aResolver publicID: aPublicID systemID: aSystemID baseURI: aBaseURIString	^ self new		setName: aName		unresolvedReplacement:			(DTDUnresolvedExternalParsedEntityReplacement				resolver: aResolver				publicID: aPublicID				systemID: aSystemID				baseURI: aBaseURIString)! !!DTDExternalParsedEntity methodsFor: 'testing'!hasReplacement	^ self resolvedReplacement notEmpty! !!DTDExternalParsedEntity methodsFor: 'testing'!hasUnresolvedReplacement	^ self unresolvedReplacement notNil! !!DTDExternalParsedEntity methodsFor: 'testing'!isExternal	^ true! !!DTDExternalParsedEntity methodsFor: 'printing'!printNameOn: aStream	aStream		nextPut: ${;		nextPutAll: self uri;		nextPut: $}.	super printNameOn: aStream.! !!DTDExternalParsedEntity methodsFor: 'accessing'!replacement	^ self resolvedReplacement contents! !!DTDExternalParsedEntity methodsFor: 'accessing'!replacementStream	^ self resolvedReplacement readStream! !!DTDExternalParsedEntity methodsFor: 'resolving'!resolveUnresolvedReplacement	self hasUnresolvedReplacement		ifTrue: [self unresolvedReplacement resolveForExternalEntity: self]! !!DTDExternalParsedEntity methodsFor: 'accessing'!resolvedReplacement	self resolveUnresolvedReplacement.	^ resolvedReplacement.! !!DTDExternalParsedEntity methodsFor: 'accessing'!resolvedReplacement: aResolvedReplacement	resolvedReplacement := aResolvedReplacement! !!DTDExternalParsedEntity methodsFor: 'initialization'!setName: aName unresolvedReplacement: anUnresolvedReplacement	name := aName.	unresolvedReplacement := anUnresolvedReplacement.! !!DTDExternalParsedEntity methodsFor: 'accessing'!unresolvedReplacement	^ unresolvedReplacement! !!DTDExternalParsedEntity methodsFor: 'accessing'!unresolvedReplacement: anUnresolvedReplacement	unresolvedReplacement := anUnresolvedReplacement! !!DTDStandaloneExternalInternalGeneralParsedEntity methodsFor: 'testing'!isStandaloneExternal	^ true! !!DTDInternalParameterParsedEntity methodsFor: 'testing'!isParameter	^ true! !!DTDInternalParsedEntity class methodsFor: 'instance creation'!name: aName replacement: aReplacementString	^ self		name: aName		replacement: aReplacementString		uri: ''! !!DTDInternalParsedEntity class methodsFor: 'instance creation'!name: aName replacement: aReplacementString uri: aURIString	^ self new		setName: aName		replacement: aReplacementString		uri: aURIString! !!DTDInternalParsedEntity methodsFor: 'testing'!hasReplacement	^ self replacement notEmpty! !!DTDInternalParsedEntity methodsFor: 'accessing'!replacement	^ replacement ifNil: [replacement := '']! !!DTDInternalParsedEntity methodsFor: 'accessing'!replacement: aReplacementString	replacement := aReplacementString! !!DTDInternalParsedEntity methodsFor: 'accessing'!replacementStream	^ self replacement readStream! !!DTDInternalParsedEntity methodsFor: 'initialization'!setName: aName replacement: aReplacementString uri: aURIString	name := aName.	replacement := aReplacementString.	uri := aURIString.! !!DTDParsedEntity methodsFor: 'converting'!asPushedBackEntity	^ self isParameter		ifTrue: [XMLPushedBackParameterEntity entity: self]		ifFalse: [XMLPushedBackGeneralEntity entity: self]! !!DTDParsedEntity methodsFor: 'testing'!hasReplacement	self subclassResponsibility! !!DTDParsedEntity methodsFor: 'accessing'!replacement	self subclassResponsibility! !!DTDParsedEntity methodsFor: 'accessing'!replacementStream	self subclassResponsibility! !!DTDUnresolvableExternalParameterParsedEntity methodsFor: 'testing'!isParameter	^ true! !!DTDUnresolvableExternalParsedEntity methodsFor: 'private'!errorUnresolvableExternalEntity	XMLParserException		formatSignal:			'External entity {1} can''t be resolved unless resolution is ',			'enabled; use #resolvesExternalEntityReferences: before parsing ',			'to enable'		with: self asReference! !!DTDUnresolvableExternalParsedEntity methodsFor: 'testing'!hasReplacement	^ true! !!DTDUnresolvableExternalParsedEntity methodsFor: 'testing'!isExternal	^ true! !!DTDUnresolvableExternalParsedEntity methodsFor: 'accessing'!replacement	self errorUnresolvableExternalEntity! !!DTDUnresolvableExternalParsedEntity methodsFor: 'accessing'!replacementStream	self errorUnresolvableExternalEntity! !!DTDUnparsedEntity class methodsFor: 'instance creation'!name: aName publicID: aPublicID systemID: aSystemID ndata: aNotationName	^ self new		setName: aName		publicID: aPublicID		systemID: aSystemID		ndata: aNotationName! !!DTDUnparsedEntity methodsFor: 'testing'!isUnparsed	^ true! !!DTDUnparsedEntity methodsFor: 'accessing'!ndata	^ ndata ifNil: [ndata := '']! !!DTDUnparsedEntity methodsFor: 'accessing'!ndata: aNotationName	ndata := aNotationName! !!DTDUnparsedEntity methodsFor: 'accessing'!publicID	^ publicID ifNil: [publicID := '']! !!DTDUnparsedEntity methodsFor: 'accessing'!publicID: aPublicID	publicID := aPublicID! !!DTDUnparsedEntity methodsFor: 'initialization'!setName: aName publicID: aPublicID systemID: aSystemID ndata: aNotationName	name := aName.	publicID := aPublicID.	systemID := aSystemID.	ndata := aNotationName.! !!DTDUnparsedEntity methodsFor: 'accessing'!systemID	^ systemID ifNil: [systemID := '']! !!DTDUnparsedEntity methodsFor: 'accessing'!systemID: aSystemID	systemID := aSystemID! !!DTDEntityConfiguration methodsFor: 'accessing'!externalEntityResolver	"uses the caching resolver by default"	^ externalEntityResolver		ifNil: [externalEntityResolver := DTDExternalEntityResolver default]! !!DTDEntityConfiguration methodsFor: 'accessing'!externalEntityResolver: anExternalEntityResolver	externalEntityResolver := anExternalEntityResolver! !!DTDEntityConfiguration methodsFor: 'copying'!postCopy	super postCopy.	externalEntityResolver		ifNotNil: [externalEntityResolver := externalEntityResolver copy].! !!DTDEntityConfiguration methodsFor: 'accessing'!preservesUndeclaredEntityReferences	^ preservesUndeclaredEntityReferences		ifNil: [preservesUndeclaredEntityReferences := false]! !!DTDEntityConfiguration methodsFor: 'accessing'!preservesUndeclaredEntityReferences: aBoolean	preservesUndeclaredEntityReferences := aBoolean! !!DTDEntityConfiguration methodsFor: 'accessing'!replacesContentEntityReferences	^ replacesContentEntityReferences ifNil: [replacesContentEntityReferences := true]! !!DTDEntityConfiguration methodsFor: 'accessing'!replacesContentEntityReferences: aBoolean	replacesContentEntityReferences := aBoolean! !!DTDEntityConfiguration methodsFor: 'accessing'!resolvesExternalEntities	^ resolvesExternalEntities ifNil: [resolvesExternalEntities := false]! !!DTDEntityConfiguration methodsFor: 'accessing'!resolvesExternalEntities: aBoolean	resolvesExternalEntities := aBoolean! !!DTDEnumerationListParser class methodsFor: 'instance creation'!on: aString	^ self new on: aString! !!DTDEnumerationListParser methodsFor: 'private'!errorDuplicateListValue: aValue	XMLValidationException		formatSignal: 'Duplicate value "{1}" in list'		with: aValue! !!DTDEnumerationListParser methodsFor: 'private'!listEndOffset	^ 1 "')' size"! !!DTDEnumerationListParser methodsFor: 'private'!listStartOffset	^ 1 "'(' size"! !!DTDEnumerationListParser methodsFor: 'initialization'!on: aString	listString := aString! !!DTDEnumerationListParser methodsFor: 'parsing'!parse	"the tokenizer removes all spaces from lists"	| listStartIndex listEndIndex totalListValues listValues nextListValuesIndex nextValueStartIndex |	listStartIndex := 1 + self listStartOffset.	listEndIndex := listString size - self listEndOffset.	"count the values to preallocate an Array"	totalListValues := 1.	listStartIndex to: listEndIndex do: [:i |		(listString at: i) == $|			ifTrue: [totalListValues := totalListValues + 1]].	listValues := Array new: totalListValues.	nextListValuesIndex := 1.	nextValueStartIndex := listStartIndex.	listStartIndex to: listEndIndex do: [:i | 		(listString at: i) == $|			ifTrue: [				listValues					at: nextListValuesIndex					put:						(listString							copyFrom: nextValueStartIndex							to: i - 1).				nextListValuesIndex := nextListValuesIndex + 1.				nextValueStartIndex := i + 1]].	listValues		at: nextListValuesIndex		put:			(listString				copyFrom: nextValueStartIndex				to: listEndIndex).	^ listValues.! !!DTDMixedContentEnumerationListParser methodsFor: 'private'!listEndOffset	^ listString last == $*		ifTrue: [2] "')*' size"		ifFalse: [1] "')' size"! !!DTDNotationEnumerationListParser methodsFor: 'private'!listStartOffset	^ 10 "'NOTATION (' size"! !!DTDExternalEntityLimits class methodsFor: 'accessing'!defaultExternalSubsetReadLimit	^ XMLParserLimits defaultReadLimit		ifNotNil: [:limit | (limit / 4) asInteger]! !!DTDExternalEntityLimits class methodsFor: 'accessing'!defaultMaxExternalEntities	^ 20! !!DTDExternalEntityLimits class methodsFor: 'accessing'!defaultMaxExternalEntitySize	^ 2500000! !!DTDExternalEntityLimits methodsFor: 'accessing'!externalSubsetReadLimit	^ externalSubsetReadLimit! !!DTDExternalEntityLimits methodsFor: 'accessing'!externalSubsetReadLimit: anInteger	externalSubsetReadLimit := anInteger! !!DTDExternalEntityLimits methodsFor: 'initialization'!initialize	super initialize.	externalSubsetReadLimit := self class defaultExternalSubsetReadLimit.	maxExternalEntities := self class defaultMaxExternalEntities.	maxExternalEntitySize := self class defaultMaxExternalEntitySize.	resolvesLocalFromNonLocal := false.! !!DTDExternalEntityLimits methodsFor: 'accessing'!maxExternalEntities	^ maxExternalEntities! !!DTDExternalEntityLimits methodsFor: 'accessing'!maxExternalEntities: anInteger	maxExternalEntities := anInteger! !!DTDExternalEntityLimits methodsFor: 'accessing'!maxExternalEntitySize	^ maxExternalEntitySize! !!DTDExternalEntityLimits methodsFor: 'accessing'!maxExternalEntitySize: anInteger	maxExternalEntitySize := anInteger! !!DTDExternalEntityLimits methodsFor: 'removing'!removeAll	externalSubsetReadLimit := nil.	maxExternalEntities := nil.	maxExternalEntitySize := nil.	resolvesLocalFromNonLocal := true.! !!DTDExternalEntityLimits methodsFor: 'accessing'!resolvesLocalFromNonLocal	^ resolvesLocalFromNonLocal! !!DTDExternalEntityLimits methodsFor: 'accessing'!resolvesLocalFromNonLocal: aBoolean	resolvesLocalFromNonLocal := aBoolean! !!DTDCachingExternalEntityResolver class methodsFor: 'clearing'!clearEntityCache	"self clearEntityCache"	self entityCache clear! !!DTDCachingExternalEntityResolver class methodsFor: 'accessing'!entityCache	"a class variable so it's shared by all subclasses, but lazy initialized	so it isn't initialized unless needed"	^ EntityCache		ifNil: [EntityCache := XMLKeyValueCache maxSize: 64]! !!DTDCachingExternalEntityResolver class methodsFor: 'accessing'!entityCacheAtURI: anXMLURIOrURIString	^ self entityCache		at: anXMLURIOrURIString asXMLURI		ifAbsent: [nil]! !!DTDCachingExternalEntityResolver class methodsFor: 'accessing'!entityCacheAtURI: anXMLURIOrURIString ifAbsent: aBlock	^ self entityCache		at: anXMLURIOrURIString asXMLURI		ifAbsent: aBlock! !!DTDCachingExternalEntityResolver class methodsFor: 'accessing'!entityCacheAtURI: anXMLURIOrURIString ifAbsentPut: aBlock	^ self entityCache		at: anXMLURIOrURIString asXMLURI		ifAbsentPut: aBlock! !!DTDCachingExternalEntityResolver class methodsFor: 'accessing'!entityCacheAtURI: anXMLURIOrURIString put: aStringOrByteArray	^ self entityCache		at: anXMLURIOrURIString asXMLURI		put: aStringOrByteArray! !!DTDCachingExternalEntityResolver class methodsFor: 'class initialization'!initialize	"self initialize"	"reset to nil instead of just clearing to force reinitialization"	EntityCache := nil! !!DTDCachingExternalEntityResolver class methodsFor: 'accessing'!maxCachedEntities	^ self entityCache maxSize! !!DTDCachingExternalEntityResolver class methodsFor: 'accessing'!maxCachedEntities: anInteger	self entityCache maxSize: anInteger! !!DTDCachingExternalEntityResolver methodsFor: 'clearing'!clearEntityCache	self class clearEntityCache! !!DTDCachingExternalEntityResolver methodsFor: 'accessing'!maxCachedEntities	^ self class maxCachedEntities! !!DTDCachingExternalEntityResolver methodsFor: 'accessing'!maxCachedEntities: anInteger	self class maxCachedEntities: anInteger! !!DTDCachingExternalEntityResolver methodsFor: 'private'!resolveNonLocalExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize	| uri |	uri := anXMLURIOrURIString asXMLURI.	"avoid #entityCacheAtURI:ifAbsent: and #entityCacheAtURI:ifAbsentPut:	so the cache isn't locked during resolution which could stall other	processes"	^ (self class entityCacheAtURI: uri)		ifNil: [			self class				entityCacheAtURI: uri				put:					(super						resolveNonLocalExternalEntityURI: uri						upToLimit: aMaxSize)].! !!DTDExternalEntityResolver class methodsFor: 'instance creation'!default	^ self defaultClass new! !!DTDExternalEntityResolver class methodsFor: 'accessing'!defaultClass	^ DTDCachingExternalEntityResolver! !!DTDExternalEntityResolver methodsFor: 'converting'!asLimitingExternalEntityResolver	^ DTDExternalEntityResolverLimitingDecorator externalEntityResolver: self! !!DTDExternalEntityResolver methodsFor: 'private'!errorLocalFromNonLocal	XMLLimitException signal:		'Local URI referenced from non-local URI; ',		'use #resolvesLocalFromNonLocal: to change'! !!DTDExternalEntityResolver methodsFor: 'configuring'!externalEntityLimits	^ externalEntityLimits		ifNil: [externalEntityLimits := DTDExternalEntityLimits new]! !!DTDExternalEntityResolver methodsFor: 'configuring'!externalEntityLimits: anExternalEntityLimits	externalEntityLimits := anExternalEntityLimits! !!DTDExternalEntityResolver methodsFor: 'resolving'!externalEntityURIFromPublicID: aPublicID systemID: aSystemID	^ aSystemID asXMLURI! !!DTDExternalEntityResolver methodsFor: 'resolving'!externalEntityURIFromPublicID: aPublicID systemID: aSystemID baseURI: aBaseXMLURIOrURIString	| baseURI externalEntityURI |	baseURI := aBaseXMLURIOrURIString asXMLURI.	externalEntityURI :=		baseURI combinedWith:			(self				externalEntityURIFromPublicID: aPublicID				systemID: aSystemID).	(externalEntityURI isLocal		and: [baseURI isLocal not			and: [self resolvesLocalFromNonLocal not]])		ifTrue: [self errorLocalFromNonLocal].	^ externalEntityURI.! !!DTDExternalEntityResolver methodsFor: 'configuring'!externalSubsetReadLimit	^ self externalEntityLimits externalSubsetReadLimit! !!DTDExternalEntityResolver methodsFor: 'configuring'!externalSubsetReadLimit: anInteger	"change the external subset read limit or nil to disable"	self externalEntityLimits externalSubsetReadLimit: anInteger! !!DTDExternalEntityResolver methodsFor: 'configuring'!maxExternalEntities	^ self externalEntityLimits maxExternalEntities! !!DTDExternalEntityResolver methodsFor: 'configuring'!maxExternalEntities: anInteger	self externalEntityLimits maxExternalEntities: anInteger! !!DTDExternalEntityResolver methodsFor: 'configuring'!maxExternalEntitySize	^ self externalEntityLimits maxExternalEntitySize! !!DTDExternalEntityResolver methodsFor: 'configuring'!maxExternalEntitySize: anInteger	self externalEntityLimits maxExternalEntitySize: anInteger! !!DTDExternalEntityResolver methodsFor: 'copying'!postCopy	super postCopy.	externalEntityLimits		ifNotNil: [externalEntityLimits := externalEntityLimits copy].! !!DTDExternalEntityResolver methodsFor: 'configuring'!removeLimits	self externalEntityLimits removeAll! !!DTDExternalEntityResolver methodsFor: 'resolving'!resolveExternalEntityURI: anXMLURIOrURIString	^ self		resolveExternalEntityURI: anXMLURIOrURIString		upToLimit: self maxExternalEntitySize! !!DTDExternalEntityResolver methodsFor: 'resolving'!resolveExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize	| uri |	^ (uri := anXMLURIOrURIString asXMLURI) isLocal		ifTrue: [			self				resolveLocalExternalEntityURI: uri				upToLimit: aMaxSize]		ifFalse: [			self				resolveNonLocalExternalEntityURI: uri				upToLimit: aMaxSize]! !!DTDExternalEntityResolver methodsFor: 'private'!resolveLocalExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize	^ DTDUndecodedResolvedExternalParsedEntityReplacement rawContents:		(anXMLURIOrURIString asXMLFileHandle			getUpToLimit: aMaxSize			decoding: false)! !!DTDExternalEntityResolver methodsFor: 'private'!resolveNonLocalExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize	| response |	response :=		anXMLURIOrURIString asXMLHTTPRequest			resolveUpToLimit: aMaxSize			decoding: false.	"saves the undecoded replacement with its Content-Type	charset encoding tag for later decoding (if needed)"	^ DTDUndecodedResolvedExternalParsedEntityReplacement		rawContents: response content		encoding: response contentCharset.! !!DTDExternalEntityResolver methodsFor: 'configuring'!resolvesLocalFromNonLocal	^ self externalEntityLimits resolvesLocalFromNonLocal! !!DTDExternalEntityResolver methodsFor: 'configuring'!resolvesLocalFromNonLocal: aBoolean	"allow non-local (http) entities to reference local (file) entities?	(default disabled)"	self externalEntityLimits resolvesLocalFromNonLocal: aBoolean! !!DTDExternalEntityResolver methodsFor: 'resolving'!streamResolveExternalEntityURI: anXMLURIOrURIString	^ self		streamResolveExternalEntityURI: anXMLURIOrURIString		upToLimit: self maxExternalEntitySize! !!DTDExternalEntityResolver methodsFor: 'resolving'!streamResolveExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize	| uri |	^ (uri := anXMLURIOrURIString asXMLURI) isLocal		ifTrue: [			self				streamResolveLocalExternalEntityURI: uri				upToLimit: aMaxSize]		ifFalse: [			self				streamResolveNonLocalExternalEntityURI: uri				upToLimit: aMaxSize]! !!DTDExternalEntityResolver methodsFor: 'private'!streamResolveLocalExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize	"return our own decoding adapter on the raw, undecoded stream	to avoid looking for any byte-order mark until later"	^ XMLDecodingReadStreamAdapter nonDecodingOn:		(anXMLURIOrURIString asXMLFileHandle			streamGetUpToLimit: aMaxSize			decoding: false)! !!DTDExternalEntityResolver methodsFor: 'private'!streamResolveNonLocalExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize	^ (self		resolveNonLocalExternalEntityURI: anXMLURIOrURIString		upToLimit: aMaxSize) readStream! !!DTDStaticExternalEntityResolver class methodsFor: 'instance creation'!externalEntities: anAssociationCollection	^ self new externalEntities: anAssociationCollection! !!DTDStaticExternalEntityResolver methodsFor: 'private'!errorMaxExternalEntitySize: aMaxSize exceededByURI: anXMLURIOrURIString	XMLLimitException		formatSignal: 'Entity exceeds max size of {1} bytes: {2}'		with: aMaxSize		with: anXMLURIOrURIString asString! !!DTDStaticExternalEntityResolver methodsFor: 'private'!errorUnresolvableExternalEntityURI: anXMLURIOrURIString	XMLParserException		formatSignal: 'Unresolvable external entity URI: {1}'		with: anXMLURIOrURIString asString! !!DTDStaticExternalEntityResolver methodsFor: 'accessing'!externalEntities	^ externalEntities ifNil: [externalEntities := Dictionary new]! !!DTDStaticExternalEntityResolver methodsFor: 'accessing'!externalEntities: anAssociationCollection	self hasExternalEntities		ifTrue: [self removeExternalEntities].	anAssociationCollection associationsDo: [:each |		self			externalEntityAtURI: each key			put: each value].! !!DTDStaticExternalEntityResolver methodsFor: 'accessing'!externalEntityAtURI: anXMLURIOrURIString	^ self		externalEntityAtURI: anXMLURIOrURIString asXMLURI		ifAbsent: ['']! !!DTDStaticExternalEntityResolver methodsFor: 'accessing'!externalEntityAtURI: anXMLURIOrURIString ifAbsent: aBlock	^ self externalEntities		at: anXMLURIOrURIString asXMLURI		ifAbsent: aBlock! !!DTDStaticExternalEntityResolver methodsFor: 'accessing'!externalEntityAtURI: anXMLURIOrURIString ifAbsentPut: aBlock	^ self externalEntities		at: anXMLURIOrURIString asXMLURI		ifAbsentPut: aBlock! !!DTDStaticExternalEntityResolver methodsFor: 'accessing'!externalEntityAtURI: anXMLURIOrURIString put: aReplacement	^ self externalEntities		at: anXMLURIOrURIString asXMLURI		put: aReplacement! !!DTDStaticExternalEntityResolver methodsFor: 'testing'!hasExternalEntities	^ self externalEntities notEmpty! !!DTDStaticExternalEntityResolver methodsFor: 'testing'!includesExternalEntityURI: anXMLURIOrURIString	^ self externalEntities includesKey: anXMLURIOrURIString asXMLURI! !!DTDStaticExternalEntityResolver methodsFor: 'copying'!postCopy	super postCopy.	externalEntities		ifNotNil: [externalEntities := externalEntities copy].! !!DTDStaticExternalEntityResolver methodsFor: 'removing'!removeExternalEntities	self externalEntities removeAll! !!DTDStaticExternalEntityResolver methodsFor: 'removing'!removeExternalEntityURI: anXMLURIOrURIString	^ self externalEntities removeKey: anXMLURIOrURIString asXMLURI! !!DTDStaticExternalEntityResolver methodsFor: 'removing'!removeExternalEntityURI: anXMLURIOrURIString ifAbsent: aBlock	^ self externalEntities		removeKey: anXMLURIOrURIString asXMLURI		ifAbsent: aBlock! !!DTDStaticExternalEntityResolver methodsFor: 'resolving'!resolveExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize	| replacement |	replacement :=		self			externalEntityAtURI: anXMLURIOrURIString			ifAbsent: [				self errorUnresolvableExternalEntityURI: anXMLURIOrURIString].	(aMaxSize notNil		and: [replacement size > aMaxSize])		ifTrue: [			self				errorMaxExternalEntitySize: aMaxSize				exceededByURI: anXMLURIOrURIString].		^ DTDUndecodedResolvedExternalParsedEntityReplacement rawContents: replacement.! !!DTDStaticExternalEntityResolver methodsFor: 'resolving'!streamResolveExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize	^ (self		resolveExternalEntityURI: anXMLURIOrURIString		upToLimit: aMaxSize) readStream! !!DTDExternalEntityResolverLimitingDecorator class methodsFor: 'instance creation'!externalEntityResolver: anExternalEntityResolver	^ self new externalEntityResolver: anExternalEntityResolver! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'converting'!asLimitingExternalEntityResolver	^ self! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'private'!checkExternalEntityLimit	| maxExternalEntities |	((maxExternalEntities := self externalEntityResolver maxExternalEntities) notNil		and: [self totalResolvedExternalEntities >= maxExternalEntities])		ifTrue: [self erorrExternalEntityLimitExceeded]! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'private'!erorrExternalEntityLimitExceeded	XMLLimitException signal:		'External entity limit exceeded; ',		'use #maxExternalEntities: to change or disable'! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!externalEntityLimits	^ self externalEntityResolver externalEntityLimits! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!externalEntityLimits: anExternalEntityLimits	self externalEntityResolver externalEntityLimits: anExternalEntityLimits! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'accessing'!externalEntityResolver	^ externalEntityResolver! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'accessing'!externalEntityResolver: anExternalEntityResolver	externalEntityResolver := anExternalEntityResolver! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'resolving'!externalEntityURIFromPublicID: aPublicID systemID: aSystemID	^ self externalEntityResolver		externalEntityURIFromPublicID: aPublicID		systemID: aSystemID! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'resolving'!externalEntityURIFromPublicID: aPublicID systemID: aSystemID baseURI: aBaseXMLURIOrURIString	^ self externalEntityResolver		externalEntityURIFromPublicID: aPublicID		systemID: aSystemID		baseURI: aBaseXMLURIOrURIString! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!externalSubsetReadLimit	^ self externalEntityResolver externalSubsetReadLimit! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!externalSubsetReadLimit: anInteger	self externalEntityResolver externalSubsetReadLimit: anInteger! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'private'!incrementTotalResolvedExternalEntities	totalResolvedExternalEntities :=		totalResolvedExternalEntities			ifNil: [1]			ifNotNil: [totalResolvedExternalEntities + 1]! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!maxExternalEntities	^ self externalEntityResolver maxExternalEntities! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!maxExternalEntities: anInteger	self externalEntityResolver maxExternalEntities: anInteger! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!maxExternalEntitySize	^ self externalEntityResolver maxExternalEntitySize! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!maxExternalEntitySize: anInteger	self externalEntityResolver maxExternalEntitySize: anInteger! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		print: self externalEntityResolver;		nextPut: $).! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!removeLimits	self externalEntityResolver removeLimits! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'resolving'!resolveExternalEntityURI: anXMLURIOrURIString	^ self resolveExternalEntityWith: [		self externalEntityResolver resolveExternalEntityURI:			anXMLURIOrURIString]! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'resolving'!resolveExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize	^ self resolveExternalEntityWith: [		self externalEntityResolver			resolveExternalEntityURI: anXMLURIOrURIString			upToLimit: aMaxSize]! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'private'!resolveExternalEntityWith: aBlock	| result |	self checkExternalEntityLimit.	result := aBlock value.	self incrementTotalResolvedExternalEntities.	^ result.! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!resolvesLocalFromNonLocal	^ self externalEntityResolver resolvesLocalFromNonLocal! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!resolvesLocalFromNonLocal: aBoolean	self externalEntityResolver resolvesLocalFromNonLocal: aBoolean! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'resolving'!streamResolveExternalEntityURI: anXMLURIOrURIString	^ self resolveExternalEntityWith: [		self externalEntityResolver streamResolveExternalEntityURI:			anXMLURIOrURIString]! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'resolving'!streamResolveExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize	^ self resolveExternalEntityWith: [		self externalEntityResolver			streamResolveExternalEntityURI: anXMLURIOrURIString			upToLimit: aMaxSize]! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'accessing'!totalResolvedExternalEntities	^ totalResolvedExternalEntities ifNil: [totalResolvedExternalEntities := 0]! !!DTDNotation class methodsFor: 'instance creation'!name: aName publicID: aPublicID	^ self		name: aName		publicID: aPublicID		systemID: ''! !!DTDNotation class methodsFor: 'instance creation'!name: aName publicID: aPublicID systemID: aSystemID	^ self new		setName: aName		publicID: aPublicID		systemID: aSystemID! !!DTDNotation methodsFor: 'accessing'!name	^ name ifNil: [name := '']! !!DTDNotation methodsFor: 'accessing'!name: aName	name := aName! !!DTDNotation methodsFor: 'accessing'!publicID	^ publicID ifNil: [publicID := '']! !!DTDNotation methodsFor: 'accessing'!publicID: aPublicID	publicID := aPublicID! !!DTDNotation methodsFor: 'initialization'!setName: aName publicID: aPublicID systemID: aSystemID	name := aName.	publicID := aPublicID.	systemID := aSystemID.! !!DTDNotation methodsFor: 'accessing'!systemID	^ systemID ifNil: [systemID := '']! !!DTDNotation methodsFor: 'accessing'!systemID: aSystemID	systemID := aSystemID! !!DTDDecodedResolvedExternalParsedEntityReplacement class methodsFor: 'instance creation'!contents: aString	^ self new setContents: aString! !!DTDDecodedResolvedExternalParsedEntityReplacement methodsFor: 'accessing'!contents	^ contents! !!DTDDecodedResolvedExternalParsedEntityReplacement methodsFor: 'testing'!isEmpty	^ self contents isEmpty! !!DTDDecodedResolvedExternalParsedEntityReplacement methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: self contents;		nextPut: $).! !!DTDDecodedResolvedExternalParsedEntityReplacement methodsFor: 'accessing'!readStream	^ self contents readStream! !!DTDDecodedResolvedExternalParsedEntityReplacement methodsFor: 'initialization'!setContents: aString	contents := aString! !!DTDResolvedExternalParsedEntityReplacement methodsFor: 'converting'!asString	^ self contents! !!DTDResolvedExternalParsedEntityReplacement methodsFor: 'accessing'!contents	self subclassResponsibility! !!DTDResolvedExternalParsedEntityReplacement methodsFor: 'testing'!isEmpty	self subclassResponsibility! !!DTDResolvedExternalParsedEntityReplacement methodsFor: 'testing'!notEmpty	^ self isEmpty not! !!DTDResolvedExternalParsedEntityReplacement methodsFor: 'accessing'!readStream	self subclassResponsibility! !!DTDUndecodedResolvedExternalParsedEntityReplacement class methodsFor: 'instance creation'!rawContents: aString	^ self		rawContents: aString		encoding: ''! !!DTDUndecodedResolvedExternalParsedEntityReplacement class methodsFor: 'instance creation'!rawContents: aString encoding: anEncodingName	^ self new		setRawContents: aString		encoding: anEncodingName! !!DTDUndecodedResolvedExternalParsedEntityReplacement methodsFor: 'accessing'!contents	^ self readStream upToEnd! !!DTDUndecodedResolvedExternalParsedEntityReplacement methodsFor: 'accessing'!encoding	^ encoding! !!DTDUndecodedResolvedExternalParsedEntityReplacement methodsFor: 'testing'!isEmpty	^ self rawContents isEmpty! !!DTDUndecodedResolvedExternalParsedEntityReplacement methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: self encoding;		nextPut: $).! !!DTDUndecodedResolvedExternalParsedEntityReplacement methodsFor: 'accessing'!rawContents	^ rawContents! !!DTDUndecodedResolvedExternalParsedEntityReplacement methodsFor: 'accessing'!readStream	^ XMLDecodingReadStreamAdapter		on: self rawContents readStream		streamConverter: self encoding asXMLStreamConverter! !!DTDUndecodedResolvedExternalParsedEntityReplacement methodsFor: 'initialization'!setRawContents: aString encoding: anEncodingName	rawContents := aString.	encoding := anEncodingName.! !!DTDUnresolvedExternalParsedEntityReplacement class methodsFor: 'instance creation'!resolver: aResolver publicID: aPublicID systemID: aSystemID baseURI: aBaseURIString	^ self new		setResolver: aResolver		publicID: aPublicID		systemID: aSystemID		baseURI: aBaseURIString! !!DTDUnresolvedExternalParsedEntityReplacement methodsFor: 'accessing'!baseURI	^ baseURI ifNil: [baseURI := '']! !!DTDUnresolvedExternalParsedEntityReplacement methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self publicID isEmpty		ifTrue: [aStream nextPutAll: 'SYSTEM']		ifFalse: [			aStream				nextPutAll: 'PUBLIC "';				nextPutAll: self publicID;				nextPut: $"].	aStream		nextPutAll: ' "';		nextPutAll: self systemID;		nextPutAll: '")'.! !!DTDUnresolvedExternalParsedEntityReplacement methodsFor: 'accessing'!publicID	^ publicID ifNil: [publicID := '']! !!DTDUnresolvedExternalParsedEntityReplacement methodsFor: 'resolving'!resolveForExternalEntity: anExternalEntity	| externalEntityURI |	externalEntityURI :=		self resolver			externalEntityURIFromPublicID: self publicID			systemID: self systemID			baseURI: self baseURI.	anExternalEntity		resolvedReplacement:			(self resolver resolveExternalEntityURI: externalEntityURI);		uri: externalEntityURI asString;		unresolvedReplacement: nil.! !!DTDUnresolvedExternalParsedEntityReplacement methodsFor: 'accessing'!resolver	^ resolver ifNil: [resolver := DTDExternalEntityResolver default]! !!DTDUnresolvedExternalParsedEntityReplacement methodsFor: 'initialization'!setResolver: aResolver publicID: aPublicID systemID: aSystemID baseURI: aBaseURIString	resolver := aResolver.	publicID := aPublicID.	systemID := aSystemID.	baseURI := aBaseURIString.! !!DTDUnresolvedExternalParsedEntityReplacement methodsFor: 'accessing'!systemID	^ systemID ifNil: [systemID := '']! !!Object methodsFor: '*XML-Parser'!isXMLBinaryOrExternalStream	"Not every stream or stream-like object is a subclass of Stream, so this	must be defined here.	At a minimum, these streams must accept binary objects (like SmallIntegers	and ByteArrays) when writing. When reading, they can return byte values	as SmallIntegers or Characters and collections of byte values as ByteArrays	or ByteStrings."	^ self isStream		and: [(self respondsTo: #isBinary)			and: [self isBinary]]! !!Object methodsFor: '*XML-Parser'!isXMLConvertingStreamAdapter	^ false! !!SAX2ContentHandler class methodsFor: 'instance creation'!parser: aParser	^ self new parser: aParser! !!SAX2ContentHandler methodsFor: 'handling - content'!characters: aString	"Handles character data in an element, such as the 'test' in	'<characters>test</characters>' or in the CDATA section '<!![CDATA[test]]>'.		It may be sent multiple times for different sections of character data	in a single element if they're separated by other nodes or entity	references like in '<characters>one<!!--comment-->two</characters>'.		See ignorableWhitespace:"! !!SAX2ContentHandler methodsFor: 'handling - content'!endDocument	"Handles the end of an XML document. No more handlers are invoked after this."! !!SAX2ContentHandler methodsFor: 'handling - content'!endElement: aQualifiedName	"Handles the end of an element if a subclass doesn't implement	#endElement:prefix:uri:localName: or #endElement:prefix:uri:."! !!SAX2ContentHandler methodsFor: 'handling - content'!endElement: aQualifiedName prefix: aPrefix uri: aURI	"Handles the end of an element if a subclass doesn't implement	#endElement:prefix:uri:localName:. By default it forwards to a simpler	handler, #endElement:.		aQualifiedName - the full name, including any prefix, such as 'prefix:name'	aPrefix - the prefix of the qualified name or an empty string	aURI - the namespace URI of the element or an empty string"	self endElement: aQualifiedName! !!SAX2ContentHandler methodsFor: 'handling - content'!endElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName	"Handles the end of an element, either an end tag like '</end>' or a	self-closed tag like '<empty/>'. By default it forwards to a simpler handler,	#endElement:prefix:uri:.		aQualifiedName - the full name, including any prefix, such as 'prefix:name'	aPrefix - the prefix of the qualified name or an empty string	aURI - the namespace URI of the element or an empty string	aLocalName - the local part of the qualified name"	self		endElement: aQualifiedName		prefix: aPrefix		uri:  aURI! !!SAX2ContentHandler methodsFor: 'handling - content'!endPrefixMapping: aPrefix	"Handles the end of a namespace prefix/URI mapping when namespaces are	enabled. After, aPrefix (empty for the default namespace) will be either	unmapped or mapped to a different URI. The 'xml' prefix is predefined	and never unmapped."! !!SAX2ContentHandler methodsFor: 'handling - content'!ignorableWhitespace: aString	"When validation is enabled and a DTD with element declarations is	present, this can be used to handle ignorable whitespace in elements	with 'element content' (meaning they can only contain other elements	and no PCDATA), such as between '<element-content>' and '<mixed-content>'	or between '</mixed-content>' and '</element-content>' in this sample:		'<!!DOCTYPE element-content [			<!!--this has element content, so its whitespace is ignorable-->			<!!ELEMENT element-content (mixed-content)>			<!!--this has mixed content, so its whitespace is not ignorable-->			<!!ELEMENT mixed-content (#PCDATA|any-content)*>			<!!--this has any content, so its whitespace is not ignorable-->			<!!ELEMENT any-content ANY>		]>		<element-content>			<mixed-content>				<any-content> any </any-content>			</mixed-content>		</element-content>'	Not sent if validation is disabled or if there's no DTD with element	declarations."! !!SAX2ContentHandler methodsFor: 'accessing'!parser	"Returns the SAX2Parser this handler was injected into"	^ parser! !!SAX2ContentHandler methodsFor: 'accessing'!parser: aParser	parser := aParser! !!SAX2ContentHandler methodsFor: 'handling - content'!processingInstruction: aTargetString data: aDataString	"Handles processing instructions like '<?name value?>', where 'name' is	the target and 'value' is the data.		XML declarations may look like PIs but are different and are handled	with xmlVersion:encoding:standalone: instead."! !!SAX2ContentHandler methodsFor: 'handling - content'!skippedEntity: anEntityName	"Sent when a general parsed entity reference like '&name;' is	unreplaced in content. Only sent when validation is turned off	or entity replacement is disabled."! !!SAX2ContentHandler methodsFor: 'handling - content'!startDocument	"Handles the start of an XML document, the first handler invoked."! !!SAX2ContentHandler methodsFor: 'handling - content'!startElement: aQualifiedName attributes: anAttributeDictionary	"Handles the start of an element if a subclass doesn't implement	#startElement:prefix:uri:localName:attributes: or	#startElement:prefix:uri:attributes:.	aQualifiedName - the full name, including any prefix, such as 'prefix:name'	anAttributeDictionary - an XMLAttributeDictionary of attributes"! !!SAX2ContentHandler methodsFor: 'handling - content'!startElement: aQualifiedName prefix: aPrefix uri: aURI attributes: anAttributeDictionary	"Handles the start of an element if a subclass doesn't implement	#startElement:prefix:uri:localName:attributes:. By default it forwards	to a simpler handler, #startElement:attributes:.		aQualifiedName - the full name, including any prefix, such as 'prefix:name'	aPrefix - the prefix of the qualified name or an empty string	aURI - the namespace URI of the element or an empty string	anAttributeDictionary - an XMLAttributeDictionary of attributes"	self		startElement: aQualifiedName		attributes: anAttributeDictionary! !!SAX2ContentHandler methodsFor: 'handling - content'!startElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName attributes: anAttributeDictionary	"Handles the start of an element, either a start tag like '<start>' or a	self-closed tag like '<empty/>'. By default it forwards to a simpler handler,	#startElement:prefix:uri:attributes:.		aQualifiedName - the full name, including any prefix, such as 'prefix:name'	aPrefix - the prefix of the qualified name or an empty string	aURI - the namespace URI of the element or an empty string	aLocalName - the local part of the qualified name	anAttributeDictionary - an XMLAttributeDictionary of attributes"	self		startElement: aQualifiedName		prefix: aPrefix		uri: aURI		attributes: anAttributeDictionary! !!SAX2ContentHandler methodsFor: 'handling - content'!startPrefixMapping: aPrefix uri: aURI	"Handles the start of a namespace prefix/URI mapping when namespaces are	enabled. The 'xml' prefix is predefined and never remapped.	aPrefix - the prefix of the namespace (empty for the default namesapce)	aURI - the namespace URI"! !!SAX2DeclarationHandler class methodsFor: 'instance creation'!parser: aParser	^ self new parser: aParser! !!SAX2DeclarationHandler methodsFor: 'handling - declaration'!attributeDeclaration: anElementName name: anAttributeName type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue! !!SAX2DeclarationHandler methodsFor: 'handling - declaration'!elementDeclaration: anElementName contentModel: aContentModel! !!SAX2DeclarationHandler methodsFor: 'handling - declaration'!generalEntityDeclaration: aName publicID: aPublicID systemID: aSystemID ndata: aNotationName! !!SAX2DeclarationHandler methodsFor: 'handling - declaration'!generalEntityDeclaration: aName replacement: aReplacement! !!SAX2DeclarationHandler methodsFor: 'handling - declaration'!notationDeclaration: aName publicID: aPublicID systemID: aSystemID! !!SAX2DeclarationHandler methodsFor: 'handling - declaration'!parameterEntityDeclaration: aName publicID: aPublicID systemID: aSystemID! !!SAX2DeclarationHandler methodsFor: 'handling - declaration'!parameterEntityDeclaration: aName replacement: aReplacement! !!SAX2DeclarationHandler methodsFor: 'accessing'!parser	"Returns the SAX2Parser this handler was injected into"	^ parser! !!SAX2DeclarationHandler methodsFor: 'accessing'!parser: aParser	parser := aParser! !!SAX2ElementCharacterHandler methodsFor: 'accessing'!characters	"This returns the combined #characters: events handled by the receiver	as a string."	^ characters ifNil: [characters := '']! !!SAX2ElementCharacterHandler methodsFor: 'handling - content'!characters: aString	"building the string this way is simpler and performs as well in tests	as using a write stream"	characters :=		characters			ifNil: [aString]			ifNotNil: [characters, aString]! !!SAX2ElementHandler class methodsFor: 'parsing'!parser: aParser	^ self		parser: aParser		parent: aParser elementHandler		parentFactory: aParser elementHandlerFactory! !!SAX2ElementHandler class methodsFor: 'parsing'!parser: aParser parent: anElementHandler parentFactory: anElementHandlerFactory	^ self new		setParser: aParser		parent: anElementHandler		parentFactory: anElementHandlerFactory! !!SAX2ElementHandler methodsFor: 'accessing'!ancestors		"Returns a list of all ancestor element handlers of the receiver."	| ancestors |	ancestors := XMLOrderedList new.	self ancestorsDo: [:each | ancestors addLast: each].	^ ancestors.! !!SAX2ElementHandler methodsFor: 'enumerating'!ancestorsDo: aBlock	| ancestor |	ancestor := self parent.	[ancestor notNil]		whileTrue: [			aBlock value: ancestor.			ancestor := ancestor parent].! !!SAX2ElementHandler methodsFor: 'accessing'!characters	"This handler ignores #characters: events, so this always returns	an empty string."	^ ''! !!SAX2ElementHandler methodsFor: 'handling - content'!characters: aString	"Handles character data in an element, such as the 'test' in	'<characters>test</characters>' or in the CDATA section '<!![CDATA[test]]>'.		It may be sent multiple times for different sections of character data	in a single element if they're separated by other nodes or entity	references like in '<characters>one<!!--comment-->two</characters>'."! !!SAX2ElementHandler methodsFor: 'accessing'!elementHandlerFactory	"Can be overridden to return a default factory to use by a factory	mapper when no other factory is mapped to the receiver."	^ nil! !!SAX2ElementHandler methodsFor: 'handling - content'!endElement: aQualifiedName	"Handles the end of an element if a subclass doesn't implement	#endElement:prefix:uri:localName: or #endElement:prefix:uri:."! !!SAX2ElementHandler methodsFor: 'handling - content'!endElement: aQualifiedName prefix: aPrefix uri: aURI	"Handles the end of an element if a subclass doesn't implement	#endElement:prefix:uri:localName:. By default it forwards to a simpler	handler, #endElement:.		aQualifiedName - the full name, including any prefix, such as 'prefix:name'	aPrefix - the prefix of the qualified name or an empty string	aURI - the namespace URI of the element or an empty string"	self endElement: aQualifiedName! !!SAX2ElementHandler methodsFor: 'handling - content'!endElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName	"Handles the end of an element, either an end tag like '</end>' or a	self-closed tag like '<empty/>'. By default it forwards to a simpler handler,	#endElement:prefix:uri:.		aQualifiedName - the full name, including any prefix, such as 'prefix:name'	aPrefix - the prefix of the qualified name or an empty string	aURI - the namespace URI of the element or an empty string	aLocalName - the local part of the qualified name"	self		endElement: aQualifiedName		prefix: aPrefix		uri:  aURI! !!SAX2ElementHandler methodsFor: 'testing'!hasParent	"Returns true if the receiver has a parent element handler (meaning it's	not the root element handler)"	^ parent notNil! !!SAX2ElementHandler methodsFor: 'accessing'!parent	"Returns the parent element handler or nil if there isn't one (if	the receiver is handling the root element)."	^ parent! !!SAX2ElementHandler methodsFor: 'accessing'!parentFactory	"Returns the factory that created the receiver."	^ parentFactory! !!SAX2ElementHandler methodsFor: 'accessing'!parser	"Returns the SAX2ElementParser"	^ parser! !!SAX2ElementHandler methodsFor: 'initialization'!setParser: aParser parent: anElementHandler parentFactory: anElementHandlerFactory	parser := aParser.	parent := anElementHandler.	parentFactory := anElementHandlerFactory.! !!SAX2ElementHandler methodsFor: 'handling - content'!startElement: aQualifiedName attributes: anAttributeDictionary	"Handles the start of an element if a subclass doesn't implement	#startElement:prefix:uri:localName:attributes: or	#startElement:prefix:uri:attributes:.	aQualifiedName - the full name, including any prefix, such as 'prefix:name'	anAttributeDictionary - an XMLAttributeDictionary of attributes"! !!SAX2ElementHandler methodsFor: 'handling - content'!startElement: aQualifiedName prefix: aPrefix uri: aURI attributes: anAttributeDictionary	"Handles the start of an element if a subclass doesn't implement	#startElement:prefix:uri:localName:attributes:. By default it forwards	to a simpler handler, #startElement:attributes:.		aQualifiedName - the full name, including any prefix, such as 'prefix:name'	aPrefix - the prefix of the qualified name or an empty string	aURI - the namespace URI of the element or an empty string	anAttributeDictionary - an XMLAttributeDictionary of attributes"	self		startElement: aQualifiedName		attributes: anAttributeDictionary! !!SAX2ElementHandler methodsFor: 'handling - content'!startElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName attributes: anAttributeDictionary	"Handles the start of an element, either a start tag like '<start>' or a	self-closed tag like '<empty/>'. By default it forwards to a simpler handler,	#startElement:prefix:uri:attributes:.		aQualifiedName - the full name, including any prefix, such as 'prefix:name'	aPrefix - the prefix of the qualified name or an empty string	aURI - the namespace URI of the element or an empty string	aLocalName - the local part of the qualified name	anAttributeDictionary - an XMLAttributeDictionary of attributes"	self		startElement: aQualifiedName		prefix: aPrefix		uri: aURI		attributes: anAttributeDictionary! !!SAX2ElementHandlerFactory methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI localName: aLocalName attributes: anAssociationCollection	^ self elementHandlerClass! !!SAX2ElementHandlerFactory methodsFor: 'accessing'!elementHandlerClass	^ SAX2ElementHandler! !!SAX2PluggableElementHandlerFactory methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI localName: aLocalName attributes: anAssociationCollection	^ elementClassMapper		classForElement: aQualifiedName		namespaceURI: aURI		attributes: anAssociationCollection		ifNone: [self elementHandlerClass]! !!SAX2PluggableElementHandlerFactory methodsFor: 'private'!elementClassMapper	^ elementClassMapper! !!SAX2PluggableElementHandlerFactory methodsFor: 'private'!elementClassMapper: anElementClassMapper	elementClassMapper := anElementClassMapper! !!SAX2PluggableElementHandlerFactory methodsFor: 'defaults'!elementClassMapperClass	^ XMLBasicElementClassMapper! !!SAX2PluggableElementHandlerFactory methodsFor: 'accessing'!elementHandlerClass	^ elementHandlerClass! !!SAX2PluggableElementHandlerFactory methodsFor: 'accessing'!elementHandlerClass: aClass	"set the default element handler class"	elementHandlerClass := aClass! !!SAX2PluggableElementHandlerFactory methodsFor: 'handling'!handleElement: anElementName attributes: aCollectionOrAttributeSpec withClass: aClass	"aCollectionOrAttributeSpec can be some kind of XMLAttributeSpec or a	collection of associations of required attribute names and values, and the	required values can be strings, blocks, or nil meaning the attribute is	required but can take any value"	elementClassMapper		mapElement: anElementName		attributeSpec: aCollectionOrAttributeSpec asXMLAttributeSpec		toClass: aClass! !!SAX2PluggableElementHandlerFactory methodsFor: 'handling'!handleElement: anElementName namespaceURI: aURI attributes: aCollectionOrAttributeSpec withClass: aClass	"aCollectionOrAttributeSpec can be some kind of XMLAttributeSpec or a	collection of associations of required attribute names and values, and the	required values can be strings, blocks, or nil meaning the attribute is	required but can take any value"	elementClassMapper		mapElement: anElementName		namespaceURI: aURI		attributeSpec: aCollectionOrAttributeSpec asXMLAttributeSpec		toClass: aClass! !!SAX2PluggableElementHandlerFactory methodsFor: 'handling'!handleElement: anElementName namespaceURI: aURI withClass: aClass	elementClassMapper		mapElement: anElementName		namespaceURI: aURI		toClass: aClass! !!SAX2PluggableElementHandlerFactory methodsFor: 'handling'!handleElement: anElementName withClass: aClass	elementClassMapper		mapElement: anElementName		toClass: aClass! !!SAX2PluggableElementHandlerFactory methodsFor: 'handling'!handleElements: anElementNameCollection namespaceURI: aNamespaceURI withClass: aClass	elementClassMapper		mapElements: anElementNameCollection		namespaceURI: aNamespaceURI		toClass: aClass! !!SAX2PluggableElementHandlerFactory methodsFor: 'handling'!handleElements: anElementNameCollection withClass: aClass	elementClassMapper		mapElements: anElementNameCollection		toClass: aClass! !!SAX2PluggableElementHandlerFactory methodsFor: 'handling'!handleElementsMatchingClass: aClass	"This will handle all elements matching the name of a class with that	class, but igoring the class's prefix and any 'Element' or 'ElementHandler'	suffix.	For example, it will match MyUserDefinedElement to:		<UserDefined>		<userDefined>		<user-defined>		<user_defined>"	elementClassMapper		mapAllMatchingElementsToClass: aClass		ignoringSuffixes: self ignorableClassNameSuffixes! !!SAX2PluggableElementHandlerFactory methodsFor: 'handling'!handleElementsMatchingClasses: aClassCollection	"See the comment in #handleElementsMatchingClass:"	elementClassMapper		mapAllMatchingElementsToClasses: aClassCollection		ignoringSuffixes: self ignorableClassNameSuffixes! !!SAX2PluggableElementHandlerFactory methodsFor: 'defaults'!ignorableClassNameSuffixes	^ #('Element' 'ElementHandler')! !!SAX2PluggableElementHandlerFactory methodsFor: 'initialization'!initialize	super initialize.	elementClassMapper := self elementClassMapperClass new.	elementHandlerClass := SAX2ElementHandler.! !!SAX2PluggableElementHandlerFactory methodsFor: 'copying'!postCopy	super postCopy.	elementClassMapper := elementClassMapper copy.! !!SAX2ElementHandlerFactoryMapper methodsFor: 'accessing'!elementHandlerFactory	"Can be overridden to return a default element handler factory to use	if no other mapping is defined for it."	^ nil! !!SAX2ElementHandlerFactoryMapper methodsFor: 'accessing'!factoryForElementHandler: anElementHandler	^ self		factoryForElementHandler: anElementHandler		ifNone: [nil]! !!SAX2ElementHandlerFactoryMapper methodsFor: 'accessing'!factoryForElementHandler: anElementHandler ifNone: aBlock	^ anElementHandler elementHandlerFactory		ifNil: [			self elementHandlerFactory				ifNil: [aBlock value]]! !!SAX2PluggableElementHandlerFactoryMapper methodsFor: 'defaults'!defaultElementHandlerFactoryClass	^ SAX2ElementHandlerFactory! !!SAX2PluggableElementHandlerFactoryMapper methodsFor: 'accessing'!elementHandlerFactory	^ elementHandlerFactory! !!SAX2PluggableElementHandlerFactoryMapper methodsFor: 'accessing'!elementHandlerFactory: anElementHandlerFactory	"set the default element handler factory"	elementHandlerFactory := anElementHandlerFactory! !!SAX2PluggableElementHandlerFactoryMapper methodsFor: 'private'!elementHandlerFactoryMap	^ elementHandlerFactoryMap! !!SAX2PluggableElementHandlerFactoryMapper methodsFor: 'accessing'!factoryForElementHandler: anElementHandler ifNone: aBlock	"optimization to skip any unneeded hash lookups"	elementHandlerFactoryMap size > 0		ifTrue: [			^ elementHandlerFactoryMap				at: anElementHandler class				ifAbsent: [					super						factoryForElementHandler: anElementHandler						ifNone: aBlock]]		ifFalse: [			^ super				factoryForElementHandler: anElementHandler				ifNone: aBlock]! !!SAX2PluggableElementHandlerFactoryMapper methodsFor: 'initialization'!initialize	super initialize.	elementHandlerFactoryMap := IdentityDictionary new.	elementHandlerFactory := self defaultElementHandlerFactoryClass new.! !!SAX2PluggableElementHandlerFactoryMapper methodsFor: 'mapping'!mapElementHandlerClass: aClass toFactory: aFactory	elementHandlerFactoryMap		at: aClass		put: aFactory! !!SAX2PluggableElementHandlerFactoryMapper methodsFor: 'copying'!postCopy	super postCopy.	elementHandlerFactoryMap := elementHandlerFactoryMap copy.! !!SAX2LexicalHandler class methodsFor: 'instance creation'!parser: aParser	^ self new parser: aParser! !!SAX2LexicalHandler methodsFor: 'handling - lexical'!comment: aString	"Handles '<!!--comment-->' sections in documents."! !!SAX2LexicalHandler methodsFor: 'handling - lexical'!endCData	"Sent after the character data of a '<!![CDATA[...]]>' section."! !!SAX2LexicalHandler methodsFor: 'handling - lexical'!endDTD! !!SAX2LexicalHandler methodsFor: 'handling - lexical'!endEntity: anEntityName	"Handles the end of some general entity's replacement in content.	Not sent if the entity is undeclared or if content entity replacement	is disabled."! !!SAX2LexicalHandler methodsFor: 'accessing'!parser	"Returns the SAX2Parser this handler was injected into"	^ parser! !!SAX2LexicalHandler methodsFor: 'accessing'!parser: aParser	parser := aParser! !!SAX2LexicalHandler methodsFor: 'handling - lexical'!startCData	"Sent before the character data of a '<!![CDATA[...]]>' section."! !!SAX2LexicalHandler methodsFor: 'handling - lexical'!startDTD: aRootElementName publicID: aPublicID systemID: aSystemID	"Handles the start of a '<!!DOCTYPE ...>' declaration. Any events	after this and until endDTD is sent are part of the internal subset	of the DTD.		aRootElementName - the expected name of the document's root element	aPublicID - the public ID of the external DTD subset or an empty string	aSystemID - the URI where the external subset can be found or an empty string"! !!SAX2LexicalHandler methodsFor: 'handling - lexical'!startEntity: anEntityName	"Handles the start of some general entity's replacement in content.	Not sent if the entity is undeclared or if content entity replacement	is disabled."! !!SAX2LexicalHandler methodsFor: 'handling - lexical'!xmlVersion: aVersionFloat encoding: anEncoding standalone: aBoolean	"Handles the '<?xml ...?>' declaration of a document.		aVersionFloat - the version of XML the document uses, usually 1.0	anEncoding - the name of the encoding or an empty string	aBoolean - true if standalone='yes'"! !!SAX2ElementParser methodsFor: 'handling - content'!characters: aString	self elementHandler characters: aString! !!SAX2ElementParser methodsFor: 'defaults'!defaultElementHandlerFactoryClass	^ SAX2ElementHandlerFactory! !!SAX2ElementParser methodsFor: 'defaults'!defaultElementHandlerFactoryMapperClass	^ SAX2ElementHandlerFactoryMapper! !!SAX2ElementParser methodsFor: 'accessing'!elementHandler	^ elementHandler! !!SAX2ElementParser methodsFor: 'accessing'!elementHandler: anElementHandler	elementHandler := anElementHandler! !!SAX2ElementParser methodsFor: 'accessing'!elementHandlerFactory	^ elementHandlerFactory! !!SAX2ElementParser methodsFor: 'accessing'!elementHandlerFactory: anElementHandlerFactory	elementHandlerFactory := anElementHandlerFactory! !!SAX2ElementParser methodsFor: 'accessing'!elementHandlerFactoryMapper	^ elementHandlerFactoryMapper! !!SAX2ElementParser methodsFor: 'accessing'!elementHandlerFactoryMapper: anElementHandlerFactoryMapper	elementHandlerFactoryMapper := anElementHandlerFactoryMapper! !!SAX2ElementParser methodsFor: 'handling - content'!endElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName	| oldElementHandler |	(oldElementHandler := self elementHandler)		endElement: aQualifiedName		prefix: aPrefix		uri: aURI		localName: aLocalName.	self		elementHandler: oldElementHandler parent;		elementHandlerFactory: oldElementHandler parentFactory.! !!SAX2ElementParser methodsFor: 'initialization'!on: aStringOrStream	super on: aStringOrStream.	elementHandlerFactory := self defaultElementHandlerFactoryClass new.	elementHandlerFactoryMapper := self defaultElementHandlerFactoryMapperClass new.! !!SAX2ElementParser methodsFor: 'handling - content'!startElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName attributes: anAttributeDictionary	| newElementHandler |	newElementHandler :=		(self elementHandlerFactory			classForElement: aQualifiedName			namespaceURI: aURI			localName: aLocalName			attributes: anAttributeDictionary)				parser: self				parent: self elementHandler				parentFactory: self elementHandlerFactory.	self		elementHandler: newElementHandler;		elementHandlerFactory:			(self elementHandlerFactoryMapper				factoryForElementHandler: newElementHandler				ifNone: [self elementHandlerFactory]).	newElementHandler		startElement: aQualifiedName		prefix: aPrefix		uri: aURI		localName: aLocalName		attributes: anAttributeDictionary.! !!SAX2Parser class methodsFor: 'private '!generateHandlerForwardingMethods	"	self generateHandlerForwardingMethods	"	(Array		with: 'contentHandler' -> #'handling - content'		with: 'lexicalHandler' -> #'handling - lexical'		with: 'declarationHandler' -> #'handling - declaration')		do: [:handlerAccessorAndCategory | | handlerAccessor handlerCategory |			handlerAccessor := handlerAccessorAndCategory key.			handlerCategory := handlerAccessorAndCategory value.			(SAXHandler selectorsInCategory: handlerCategory) do: [:each | | parsedMethod sourceStream |				parsedMethod := RBParser parseMethod: (SAXHandler sourceCodeAt: each).				(sourceStream := String new writeStream)					nextPutAll: parsedMethod selectorAndArgumentNames;					cr;					nextPutAll: '	self ';					nextPutAll: handlerAccessor.				1 to: parsedMethod keywords size do: [:i |					parsedMethod keywords size > 1						ifTrue: [							sourceStream								cr;								tab;								tab]						ifFalse: [sourceStream space].					sourceStream nextPutAll: (parsedMethod keywords at: i).					parsedMethod argumentNames						ifNotEmpty: [							sourceStream								space;								nextPutAll: (parsedMethod argumentNames at: i)]].				self					compile: sourceStream contents					classified: handlerCategory]]! !!SAX2Parser class methodsFor: 'private '!generateMethodsInHandlerClasses	"	self generateMethodsInHandlerClasses	"	(Array		with: SAX2ContentHandler -> #'handling - content'		with: SAX2LexicalHandler -> #'handling - lexical'		with: SAX2DeclarationHandler -> #'handling - declaration')		do: [:handlerClassAndCategory | | handlerClass handlerCategory |			handlerClass := handlerClassAndCategory key.			handlerCategory := handlerClassAndCategory value.			(SAXHandler selectorsInCategory: handlerCategory) do: [:each |				handlerClass					compile: (SAXHandler sourceCodeAt: each)					classified: handlerCategory]]! !!SAX2Parser methodsFor: 'handling - declaration'!attributeDeclaration: anElementName name: anAttributeName type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue	self declarationHandler		attributeDeclaration: anElementName		name: anAttributeName		type: aType		defaultPragma: aDefaultPragma		defaultValue: aDefaultValue! !!SAX2Parser methodsFor: 'handling - content'!characters: aString	self contentHandler characters: aString! !!SAX2Parser methodsFor: 'handling - lexical'!comment: aString	self lexicalHandler comment: aString! !!SAX2Parser methodsFor: 'accessing'!contentHandler	^ contentHandler! !!SAX2Parser methodsFor: 'accessing'!contentHandler: aContentHandler	(contentHandler :=		aContentHandler ifNil: [self defaultContentHandlerClass new])			parser: self! !!SAX2Parser methodsFor: 'accessing'!declarationHandler	^ declarationHandler! !!SAX2Parser methodsFor: 'accessing'!declarationHandler: aDeclarationHandler	(declarationHandler :=		aDeclarationHandler ifNil: [self defaultDeclarationHandlerClass new])			parser: self! !!SAX2Parser methodsFor: 'defaults'!defaultContentHandlerClass	^ SAX2ContentHandler! !!SAX2Parser methodsFor: 'defaults'!defaultDeclarationHandlerClass	^ SAX2DeclarationHandler! !!SAX2Parser methodsFor: 'defaults'!defaultLexicalHandlerClass	^ SAX2LexicalHandler! !!SAX2Parser methodsFor: 'defaults'!defaultParsingResult	"the default parsing result of SAXHandler"	^ self! !!SAX2Parser methodsFor: 'handling - declaration'!elementDeclaration: anElementName contentModel: aContentModel	self declarationHandler		elementDeclaration: anElementName		contentModel: aContentModel! !!SAX2Parser methodsFor: 'handling - lexical'!endCData	self lexicalHandler endCData! !!SAX2Parser methodsFor: 'handling - lexical'!endDTD	self lexicalHandler endDTD! !!SAX2Parser methodsFor: 'handling - content'!endDocument	self contentHandler endDocument! !!SAX2Parser methodsFor: 'handling - content'!endElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName	self contentHandler		endElement: aQualifiedName		prefix: aPrefix		uri: aURI		localName: aLocalName! !!SAX2Parser methodsFor: 'handling - lexical'!endEntity: anEntityName	self lexicalHandler endEntity: anEntityName! !!SAX2Parser methodsFor: 'handling - content'!endPrefixMapping: aPrefix	self contentHandler endPrefixMapping: aPrefix! !!SAX2Parser methodsFor: 'handling - declaration'!generalEntityDeclaration: aName publicID: aPublicID systemID: aSystemID ndata: aNotationName	self declarationHandler		generalEntityDeclaration: aName		publicID: aPublicID		systemID: aSystemID		ndata: aNotationName! !!SAX2Parser methodsFor: 'handling - declaration'!generalEntityDeclaration: aName replacement: aReplacement	self declarationHandler		generalEntityDeclaration: aName		replacement: aReplacement! !!SAX2Parser methodsFor: 'handling - content'!ignorableWhitespace: aString	self contentHandler ignorableWhitespace: aString! !!SAX2Parser methodsFor: 'accessing'!lexicalHandler	^ lexicalHandler! !!SAX2Parser methodsFor: 'accessing'!lexicalHandler: aLexicalHandler	(lexicalHandler :=		aLexicalHandler ifNil: [self defaultLexicalHandlerClass new])			parser: self! !!SAX2Parser methodsFor: 'handling - declaration'!notationDeclaration: aName publicID: aPublicID systemID: aSystemID	self declarationHandler		notationDeclaration: aName		publicID: aPublicID		systemID: aSystemID! !!SAX2Parser methodsFor: 'initialization'!on: aStringOrStream	super on: aStringOrStream.	contentHandler := self defaultContentHandlerClass parser: self.	lexicalHandler := self defaultLexicalHandlerClass parser: self.	declarationHandler := self defaultDeclarationHandlerClass parser: self.	parsingResult := self defaultParsingResult.! !!SAX2Parser methodsFor: 'handling - declaration'!parameterEntityDeclaration: aName publicID: aPublicID systemID: aSystemID	self declarationHandler		parameterEntityDeclaration: aName		publicID: aPublicID		systemID: aSystemID! !!SAX2Parser methodsFor: 'handling - declaration'!parameterEntityDeclaration: aName replacement: aReplacement	self declarationHandler		parameterEntityDeclaration: aName		replacement: aReplacement! !!SAX2Parser methodsFor: 'parsing'!parsingResult	^ parsingResult! !!SAX2Parser methodsFor: 'parsing'!parsingResult: anObject	parsingResult := anObject! !!SAX2Parser methodsFor: 'handling - content'!processingInstruction: aTargetString data: aDataString	self contentHandler		processingInstruction: aTargetString		data: aDataString! !!SAX2Parser methodsFor: 'handling - content'!skippedEntity: anEntityName	self contentHandler skippedEntity: anEntityName! !!SAX2Parser methodsFor: 'handling - lexical'!startCData	self lexicalHandler startCData! !!SAX2Parser methodsFor: 'handling - lexical'!startDTD: aRootElementName publicID: aPublicID systemID: aSystemID	self lexicalHandler		startDTD: aRootElementName		publicID: aPublicID		systemID: aSystemID! !!SAX2Parser methodsFor: 'handling - content'!startDocument	self contentHandler startDocument! !!SAX2Parser methodsFor: 'handling - content'!startElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName attributes: aDictionary	self contentHandler		startElement: aQualifiedName		prefix: aPrefix		uri: aURI		localName: aLocalName		attributes: aDictionary! !!SAX2Parser methodsFor: 'handling - lexical'!startEntity: anEntityName	self lexicalHandler startEntity: anEntityName! !!SAX2Parser methodsFor: 'handling - content'!startPrefixMapping: aPrefix uri: aURI	self contentHandler		startPrefixMapping: aPrefix		uri: aURI! !!SAX2Parser methodsFor: 'handling - lexical'!xmlVersion: aVersionFloat encoding: anEncoding standalone: aBoolean	self lexicalHandler		xmlVersion: aVersionFloat		encoding: anEncoding		standalone: aBoolean! !!SAXHandler class methodsFor: 'instance creation'!new	Error signal:		'Parsers should be created with #on: or ',		'some other "instance creation" message'! !!SAXHandler class methodsFor: 'instance creation'!on: aStringOrStream	"Returns a new parser on the string or stream argument but doesn't parse it.	Can be used to configure a parser with 'configuring' messages before	parsing with #parseDocument."	^ self basicNew initialize on: aStringOrStream! !!SAXHandler class methodsFor: 'instance creation'!on: aStringOrStream documentURI: aURIString	"Returns a new parser on the string or stream argument treating the	specified URI as the base URI of the document but doesn't parse it.	Can be used to configure a parser with 'configuring' messages before	parsing with #parseDocument."	^ (self on: aStringOrStream) documentURI: aURIString! !!SAXHandler class methodsFor: 'instance creation'!onFileNamed: aFileName	"Returns a new parser on the specified file but doesn't parse it.	If aFileName is a relative path, it will be resolved in the context of	the current working directory.	Can be used to configure file parsers with 'configuring' messages before	parsing with #parseDocument."	^ self		on:			"return an XMLDecodingReadStreamAdapter on the undecoded file			stream so we can do our own decoding looking at byte order			marks and <?xml ...?> encoding attributes"			(XMLDecodingReadStreamAdapter nonDecodingOn:				aFileName asXMLFileHandle rawReadStream)		documentURI: aFileName! !!SAXHandler class methodsFor: 'instance creation'!onURL: aURLString	"Fetches the URL and returns new parser on the response content but doesn't	parse it. If the URL has no scheme, it will be treated as a file path.	Can be used to configure URL parsers with 'configuring' messages before	parsing with #parseDocument."	^ self		onURL: aURLString		upToLimit: XMLParserLimits defaultDocumentReadLimit! !!SAXHandler class methodsFor: 'instance creation'!onURL: aURLString upToLimit: aMaxSize	"Fetches a URL and returns new parser on the response content up to the	input limit (use nil to disable) but doesn't parse it. If the URL has	no scheme, it will be treated as a file path.	Can be used to configure limited URL parsers with 'configuring' messages	before parsing with #parseDocument."	^ (self		on:			(DTDExternalEntityResolver new				streamResolveExternalEntityURI: aURLString				upToLimit: aMaxSize)		documentURI: aURLString)			documentReadLimit: aMaxSize! !!SAXHandler class methodsFor: 'parsing'!parse: aStringOrStream	"Parses the document in the string or stream argument"	^ (self on: aStringOrStream) parseDocument! !!SAXHandler class methodsFor: 'parsing'!parse: aStringOrStream documentURI: aURIString	"Parses the document in the string or stream argument treating the specified	URI as the base URI of the document."	^ (self		on: aStringOrStream		documentURI: aURIString) parseDocument! !!SAXHandler class methodsFor: 'parsing'!parse: aStringOrStream usingNamespaces: aBoolean	"Parses the document in the string or stream argument possibly with namespace	checking enabled (default)"	^ (self on: aStringOrStream)		usesNamespaces: aBoolean;		parseDocument! !!SAXHandler class methodsFor: 'parsing'!parse: aStringOrStream usingNamespaces: aNamespaceBoolean validation: aValidationBoolean	"Parses the document in the string or stream argument possibly with namespace	checking (default) and validation (default) enabled."	^ (self on: aStringOrStream)		usesNamespaces: aNamespaceBoolean;		isValidating: aValidationBoolean;		parseDocument! !!SAXHandler class methodsFor: 'parsing'!parse: aStringOrStream usingNamespaces: aNamespaceBoolean validation: aValidationBoolean externalEntities: anEntityResolutionBoolean	"Parses the document in the string or stream argument possibly with namespace	checking (default), validation (default), or external entity resolution (not	default) enabled."	^ (self on: aStringOrStream)		usesNamespaces: aNamespaceBoolean;		isValidating: aValidationBoolean;		resolvesExternalEntities: anEntityResolutionBoolean;		parseDocument! !!SAXHandler class methodsFor: 'deprecated'!parseDocumentFrom: aStringOrStream	self deprecated: 'Use #parse: instead'.	^ self parse: aStringOrStream.! !!SAXHandler class methodsFor: 'deprecated'!parseDocumentFromFileNamed: aFileName	self deprecated: 'Use #parseFileNamed: instead'.	^ self parseFileNamed: aFileName.! !!SAXHandler class methodsFor: 'parsing'!parseFileNamed: aFileNameString	"Parses the specified file. If aFileName is a relative path, it will be	resolved in the context of the current working directory."	^ (self onFileNamed: aFileNameString) parseDocument! !!SAXHandler class methodsFor: 'parsing'!parseURL: aURLString	"Fetches the URL and parses the response content. If the URL has no scheme,	it will be treated as a file path."	^ (self onURL: aURLString) parseDocument! !!SAXHandler class methodsFor: 'parsing'!parseURL: aURLString upToLimit: aMaxSize	"Fetches the URL upto the input limit (nil to disable) and parses the	response content. If the URL has no scheme, it will be treated as a file	path."	^ (self		onURL: aURLString		upToLimit: aMaxSize) parseDocument! !!SAXHandler methodsFor: 'handling - declaration'!attributeDeclaration: anElementName name: anAttributeName type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue! !!SAXHandler methodsFor: 'handling - content'!characters: aString	"Handles character data in an element, such as the 'test' in	'<characters>test</characters>' or in the CDATA section '<!![CDATA[test]]>'.		It may be sent multiple times for different sections of character data	in a single element if they're separated by other nodes or entity	references like in '<characters>one<!!--comment-->two</characters>'.		See #isInCDataSection and #ignorableWhitespace:"! !!SAXHandler methodsFor: 'handling - lexical'!comment: aString	"Handles '<!!--comment-->' sections in documents."! !!SAXHandler methodsFor: 'accessing'!configuration	^ configuration! !!SAXHandler methodsFor: 'accessing'!configuration: aConfiguration	(configuration := aConfiguration) parserHandlerClass: self class! !!SAXHandler methodsFor: 'defaults'!configurationClass	^ XMLConfiguration! !!SAXHandler methodsFor: 'configuring'!decodesCharacters	^ self configuration decodesCharacters! !!SAXHandler methodsFor: 'configuring'!decodesCharacters: aBoolean	"When enabled, encoding detection and character decoding will be attemped if:		1) the input stream or string is binary/external		2) it starts with a byte-order mark (BOM) byte sequence		3) the input is wrapped with an XMLDecodingReadStreamAdapter that has			a null or implicit stream converter	(Default.)"	self configuration decodesCharacters: aBoolean! !!SAXHandler methodsFor: 'defaults'!defaultDocumentURI	^ ''! !!SAXHandler methodsFor: 'private'!doctypeDefinition: aDoctypeDefinition! !!SAXHandler methodsFor: 'configuring'!documentReadLimit	^ self configuration documentReadLimit! !!SAXHandler methodsFor: 'configuring'!documentReadLimit: anInteger	"change the document read limit (maximum number of chars that can be read)	or nil to disable"	self configuration documentReadLimit: anInteger! !!SAXHandler methodsFor: 'accessing'!documentURI	"Returns current document base URI string"	^ documentURI ifNil: [documentURI := self defaultDocumentURI]! !!SAXHandler methodsFor: 'accessing'!documentURI: aURIString	documentURI := aURIString! !!SAXHandler methodsFor: 'defaults'!driverClass	^ SAXParserDriver! !!SAXHandler methodsFor: 'handling - declaration'!elementDeclaration: anElementName contentModel: aContentModel! !!SAXHandler methodsFor: 'handling - lexical'!endCData	"Sent after the character data of a '<!![CDATA[...]]>' section."! !!SAXHandler methodsFor: 'handling - lexical'!endDTD! !!SAXHandler methodsFor: 'handling - content'!endDocument	"Handles the end of an XML document. No more handlers are invoked after this."! !!SAXHandler methodsFor: 'handling - content'!endElement: aQualifiedName	"Handles the end of an element if a subclass doesn't implement	#endElement:prefix:uri:localName: or #endElement:prefix:uri:."! !!SAXHandler methodsFor: 'handling - content'!endElement: aQualifiedName prefix: aPrefix uri: aURI	"Handles the end of an element if a subclass doesn't implement	#endElement:prefix:uri:localName:. By default it forwards to a simpler	handler, #endElement:.		aQualifiedName - the full name, including any prefix, such as 'prefix:name'	aPrefix - the prefix of the qualified name or an empty string	aURI - the namespace URI of the element or an empty string"	self endElement: aQualifiedName! !!SAXHandler methodsFor: 'handling - content'!endElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName	"Handles the end of an element, either an end tag like '</end>' or a	self-closed tag like '<empty/>'. By default it forwards to a simpler handler,	#endElement:prefix:uri:.		aQualifiedName - the full name, including any prefix, such as 'prefix:name'	aPrefix - the prefix of the qualified name or an empty string	aURI - the namespace URI of the element or an empty string	aLocalName - the local part of the qualified name"	self		endElement: aQualifiedName		prefix: aPrefix		uri:  aURI! !!SAXHandler methodsFor: 'handling - lexical'!endEntity: anEntityName	"Handles the end of some general entity's replacement in content.	Not sent if the entity is undeclared or if content entity replacement	is disabled."! !!SAXHandler methodsFor: 'handling - content'!endPrefixMapping: aPrefix	"Handles the end of a namespace prefix/URI mapping when namespaces are	enabled. After, aPrefix (empty for the default namespace) will be either	unmapped or mapped to a different URI. The 'xml' prefix is predefined	and never unmapped."! !!SAXHandler methodsFor: 'private'!errorInstancesCannotHaveMultipleParsers	XMLParserException		formatSignal: 'Instances of {1} cannot have multiple parsers'		with: self class name! !!SAXHandler methodsFor: 'configuring'!externalEntityResolver	^ self configuration externalEntityResolver! !!SAXHandler methodsFor: 'configuring'!externalEntityResolver: anExternalEntityResolver	"This can be used to set a different DTDExternalEntityResolver"	self configuration externalEntityResolver: anExternalEntityResolver! !!SAXHandler methodsFor: 'handling - declaration'!generalEntityDeclaration: aName publicID: aPublicID systemID: aSystemID ndata: aNotationName! !!SAXHandler methodsFor: 'handling - declaration'!generalEntityDeclaration: aName replacement: aReplacement! !!SAXHandler methodsFor: 'testing'!hasParser	^ hasParser! !!SAXHandler methodsFor: 'handling - content'!ignorableWhitespace: aString	"When validation is enabled and a DTD with ELEMENT declarations is	present, this can be used to handle ignorable whitespace in elements	with 'element content' (meaning they can only contain other elements	and no PCDATA), such as between '<element-content>' and '<mixed-content>'	or between '</mixed-content>' and '</element-content>' in this sample:		'<!!DOCTYPE element-content [			<!!--this has element content, so its whitespace is ignorable-->			<!!ELEMENT element-content (mixed-content)>			<!!--this has mixed content, so its whitespace is not ignorable-->			<!!ELEMENT mixed-content (#PCDATA|any-content)*>			<!!--this has any content, so its whitespace is not ignorable-->			<!!ELEMENT any-content ANY>		]>		<element-content>			<mixed-content>				<any-content> any </any-content>			</mixed-content>		</element-content>'	Not sent if validation is disabled or if there's no DTD with element	declarations."! !!SAXHandler methodsFor: 'initialization'!initializeParser: aParser! !!SAXHandler methodsFor: 'accessing'!input	"the input being parsed or to be parsed"	^ input! !!SAXHandler methodsFor: 'private'!input: aStringOrStream	"here for backwards compatibility; use #on: instead"	input := aStringOrStream! !!SAXHandler methodsFor: 'parsing'!interruptParsing	"Can be sent within a handler to stop parsing;	will be silently caught within #parseDocument or other parsing methods"	XMLParsingInterruptException signal! !!SAXHandler methodsFor: 'testing'!isInCDataSection	"Can be used by characters: handlers to distinguish ordinary character	data from characters within '<!![CDATA[...]]>' sections"	^ isInCDataSection! !!SAXHandler methodsFor: 'private'!isInCDataSection: aBoolean	isInCDataSection := aBoolean! !!SAXHandler methodsFor: 'testing'!isInContent	"True if parsing has reached the first element of the document."	^ isInContent! !!SAXHandler methodsFor: 'configuring'!isValidating	^ self configuration isValidating! !!SAXHandler methodsFor: 'configuring'!isValidating: aBoolean	"If true and the document has a schema (like a DTD with ELEMENT and ATTLIST	declarations) the document will be validated against it. Otherwise only	entity references and xml:id attributes will be validated.		(This is unlike the standard which requires validating parsers to reject	all documents without DTDs or other schemas. To get that behavior,	use requiresDocumentConstraints:)	Enabling disables preservesUndeclaredEntityReferences.	Disabling disables requiresDocumentConstraints."	self configuration isValidating: aBoolean! !!SAXHandler methodsFor: 'configuring'!maxEntityReplacementDepth	^ self configuration maxEntityReplacementDepth! !!SAXHandler methodsFor: 'configuring'!maxEntityReplacementDepth: anInteger	"change the max replacement depth or nil to disable"	self configuration maxEntityReplacementDepth: anInteger! !!SAXHandler methodsFor: 'handling - declaration'!notationDeclaration: aName publicID: aPublicID systemID: aSystemID! !!SAXHandler methodsFor: 'initialization'!on: aStringOrStream	input := aStringOrStream.	"a single instance can parse multiple documents with #on:,	so each variable must be reset"	documentURI := nil.	configuration		ifNil: [self configuration: self configurationClass new]		ifNotNil: [self configuration: configuration copy].	hasParser := false.	isInContent := false.	isInCDataSection := false.! !!SAXHandler methodsFor: 'configuring'!optimizeForLargeDocuments	"use this for faster parsing/less memory use with large documents"	self		isValidating: false;		usesNamespaces: false;		documentReadLimit: nil! !!SAXHandler methodsFor: 'handling - declaration'!parameterEntityDeclaration: aName publicID: aPublicID systemID: aSystemID! !!SAXHandler methodsFor: 'handling - declaration'!parameterEntityDeclaration: aName replacement: aReplacement! !!SAXHandler methodsFor: 'parsing'!parseDocument	"Parse the entire input string or stream and return the result"	self parser parseDocument.	^ self parsingResult.! !!SAXHandler methodsFor: 'parsing'!parseDocumentUntil: aBlock	"Parse the input string or stream only until aBlock evalautes as true	and return the result"	self parser parseDocumentUntil: aBlock.	^ self parsingResult.! !!SAXHandler methodsFor: 'parsing'!parseDocumentWhile: aBlock	"Parse the input string or stream only as long as aBlock evalautes as true	and return the result"	self parser parseDocumentWhile: aBlock.	^ self parsingResult.! !!SAXHandler methodsFor: 'parsing'!parser	"returns a new XMLParser object for this handler"	| parser |	hasParser		ifTrue: [self errorInstancesCannotHaveMultipleParsers].	hasParser := true.	parser :=		self parserClass			driver: (self driverClass saxHandler: self)			on: self input.	self initializeParser: parser.	^ parser.! !!SAXHandler methodsFor: 'defaults'!parserClass	^ XMLParser! !!SAXHandler methodsFor: 'parsing'!parsingResult	"value returned by parseDocument and other parsing methods"	^ self! !!SAXHandler methodsFor: 'configuring'!preservesUndeclaredEntityReferences	^ self configuration preservesUndeclaredEntityReferences! !!SAXHandler methodsFor: 'configuring'!preservesUndeclaredEntityReferences: aBoolean	"If true, references to undeclared entities in content are	preserved (not default).	Disables validation.		(See also replacesContentEntityReferences:, which is usually more appropriate.)"	self configuration preservesUndeclaredEntityReferences: aBoolean! !!SAXHandler methodsFor: 'handling - content'!processingInstruction: aTargetString data: aDataString	"Handles processing instructions like '<?name value?>', where 'name' is	the target and 'value' is the data.		XML declarations may look like PIs but are different and are handled	with #xmlVersion:encoding:standalone: instead."! !!SAXHandler methodsFor: 'configuring'!removeLimits	"remove all input security limits (unsafe)"	self configuration removeLimits! !!SAXHandler methodsFor: 'configuring'!replacesContentEntityReferences	^ self configuration replacesContentEntityReferences! !!SAXHandler methodsFor: 'configuring'!replacesContentEntityReferences: aBoolean	"Replace general parsed entity and character references	in content (default)"	self configuration replacesContentEntityReferences: aBoolean! !!SAXHandler methodsFor: 'deprecated'!requiresDocumentConstraints	"will be deprecated; use #requiresSchema instead"	^ self requiresSchema! !!SAXHandler methodsFor: 'deprecated'!requiresDocumentConstraints: aBoolean	"will be deprecated; use #requiresSchema: instead"	self requiresSchema: aBoolean! !!SAXHandler methodsFor: 'configuring'!requiresSchema	^ self configuration requiresSchema! !!SAXHandler methodsFor: 'configuring'!requiresSchema: aBoolean	"If true, a schema containing constraints on elements and attributes	(like a DTD with ELEMENT and ATTLIST declarations) will be required.	Enables validation.	(Not default)."	self configuration requiresSchema: aBoolean! !!SAXHandler methodsFor: 'configuring'!resolvesExternalEntities	^ self configuration resolvesExternalEntities! !!SAXHandler methodsFor: 'configuring'!resolvesExternalEntities: aBoolean	"When true, external DTDs and parsed entities will be	fetched (not default)."	self configuration resolvesExternalEntities: aBoolean! !!SAXHandler methodsFor: 'private'!schema	^ nil! !!SAXHandler methodsFor: 'handling - content'!skippedEntity: anEntityName	"Sent when a general parsed entity reference like '&name;' is	unreplaced in content. Only sent when validation is turned off	or entity replacement is disabled."! !!SAXHandler methodsFor: 'handling - lexical'!startCData	"Sent before the character data of a '<!![CDATA[...]]>' section."! !!SAXHandler methodsFor: 'private'!startContent	isInContent := true! !!SAXHandler methodsFor: 'handling - lexical'!startDTD: aRootElementName publicID: aPublicID systemID: aSystemID	"Handles the start of a '<!!DOCTYPE ...>' declaration. Any events	after this and until #endDTD is sent are part of the internal subset	of the DTD.		aRootElementName - the expected name of the document's root element	aPublicID - the public ID of the external DTD subset or an empty string	aSystemID - the URI where the external subset can be found or an empty string"! !!SAXHandler methodsFor: 'handling - content'!startDocument	"Handles the start of an XML document, the first handler invoked."! !!SAXHandler methodsFor: 'handling - content'!startElement: aQualifiedName attributes: anAttributeDictionary	"Handles the start of an element if a subclass doesn't implement	#startElement:prefix:uri:localName:attributes: or	#startElement:prefix:uri:attributes:.	aQualifiedName - the full name, including any prefix, such as 'prefix:name'	anAttributeDictionary - an XMLAttributeDictionary of attributes"! !!SAXHandler methodsFor: 'handling - content'!startElement: aQualifiedName prefix: aPrefix uri: aURI attributes: anAttributeDictionary	"Handles the start of an element if a subclass doesn't implement	#startElement:prefix:uri:localName:attributes:. By default it forwards	to a simpler handler, #startElement:attributes:.		aQualifiedName - the full name, including any prefix, such as 'prefix:name'	aPrefix - the prefix of the qualified name or an empty string	aURI - the namespace URI of the element or an empty string	anAttributeDictionary - an XMLAttributeDictionary of attributes"	self		startElement: aQualifiedName		attributes: anAttributeDictionary! !!SAXHandler methodsFor: 'handling - content'!startElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName attributes: anAttributeDictionary	"Handles the start of an element, either a start tag like '<start>' or a	self-closed tag like '<empty/>'. By default it forwards to a simpler handler,	#startElement:prefix:uri:attributes:.		aQualifiedName - the full name, including any prefix, such as 'prefix:name'	aPrefix - the prefix of the qualified name or an empty string	aURI - the namespace URI of the element or an empty string	aLocalName - the local part of the qualified name	anAttributeDictionary - an XMLAttributeDictionary of attributes"	self		startElement: aQualifiedName		prefix: aPrefix		uri: aURI		attributes: anAttributeDictionary! !!SAXHandler methodsFor: 'handling - lexical'!startEntity: anEntityName	"Handles the start of some general entity's replacement in content.	Not sent if the entity is undeclared or if content entity replacement	is disabled."! !!SAXHandler methodsFor: 'handling - content'!startPrefixMapping: aPrefix uri: aURI	"Handles the start of a namespace prefix/URI mapping when namespaces are	enabled. The 'xml' prefix is predefined and never remapped.	aPrefix - the prefix of the namespace (empty for the default namesapce)	aURI - the namespace URI"! !!SAXHandler methodsFor: 'private'!startScope: aNamespaceScope! !!SAXHandler methodsFor: 'configuring'!usesNamespaces	^ self configuration usesNamespaces! !!SAXHandler methodsFor: 'configuring'!usesNamespaces: aBoolean	"Namespace checking when true (default)"	self configuration usesNamespaces: aBoolean! !!SAXHandler methodsFor: 'handling - lexical'!xmlVersion: aVersionFloat encoding: anEncoding standalone: aBoolean	"Handles the '<?xml ...?>' declaration of a document.		aVersionFloat - the version of XML the document uses, usually 1.0	anEncoding - the name of the encoding or an empty string	aBoolean - true if standalone='yes'"! !!XMLDOMParser methodsFor: 'handling - declaration'!attributeDeclaration: anElementName name: anAttributeName type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue	self topNodeAdd:		(self nodeFactory attributeDeclarationClass			element: anElementName			attribute: anAttributeName			type: aType			defaultPragma: aDefaultPragma			defaultValue: aDefaultValue)! !!XMLDOMParser methodsFor: 'handling - content'!characters: aString	(self isInCDataSection		and: [self preservesCDataNodes])		ifTrue: [self topNodeAdd: (self nodeFactory newCData: aString)]		ifFalse: [self topNodeAddString: aString]! !!XMLDOMParser methodsFor: 'handling - lexical'!comment: aString	self preservesCommentNodes		ifTrue: [self topNodeAdd: (self nodeFactory newComment: aString)]! !!XMLDOMParser methodsFor: 'defaults'!configurationClass	^ XMLDOMConfiguration! !!XMLDOMParser methodsFor: 'private'!doctypeDefinition: aDoctypeDefinition	self document doctypeDefinition: aDoctypeDefinition! !!XMLDOMParser methodsFor: 'accessing'!document	^ document! !!XMLDOMParser methodsFor: 'accessing'!document: aDocument	document := aDocument! !!XMLDOMParser methodsFor: 'handling - declaration'!elementDeclaration: anElementName contentModel: aContentModel	self topNodeAdd:		(self nodeFactory elementDeclarationClass			element: anElementName			contentModel: aContentModel)! !!XMLDOMParser methodsFor: 'handling - lexical'!endDTD	self popNode! !!XMLDOMParser methodsFor: 'handling - content'!endDocument	"nodeStack is not popped here for efficiency because #document keeps	a reference to the root too, and there may not be a root to pop	anyway if it's an inner XML parser"! !!XMLDOMParser methodsFor: 'handling - content'!endElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName	self popNode! !!XMLDOMParser methodsFor: 'handling - declaration'!generalEntityDeclaration: aName publicID: aPublicID systemID: aSystemID ndata: aNotationName	self topNodeAdd:		(self nodeFactory generalEntityDeclarationClass			name: aName			publicID: aPublicID			systemID: aSystemID			ndata: aNotationName)! !!XMLDOMParser methodsFor: 'handling - declaration'!generalEntityDeclaration: aName replacement: aReplacement	self topNodeAdd:		(self nodeFactory generalEntityDeclarationClass			name: aName			replacement: aReplacement)! !!XMLDOMParser methodsFor: 'handling - content'!ignorableWhitespace: aString	self preservesIgnorableWhitespace		ifTrue: [self characters: aString]! !!XMLDOMParser methodsFor: 'initialization'!initializeInnerXMLParser: aParser	self document		ifNotNil: [			aParser driver isStandalone: self document isStandalone.			self document hasDoctypeDefinition				ifTrue: [					aParser driver doctypeDefinition addGeneralEntitiesFrom:						self document doctypeDefinition]].	self nodeStack do: [:each |		each isElement			ifTrue: [				self					startInnerXMLElement: each					forParser: aParser]].	aParser state: self topNode newInnerXMLState.	aParser state isContentState		ifTrue: [self startContent].! !!XMLDOMParser methodsFor: 'initialization'!initializeParser: aParser	super initializeParser: aParser.	self nodeStack size > 0		ifTrue: [self initializeInnerXMLParser: aParser].! !!XMLDOMParser methodsFor: 'private'!innerXMLRootNode: aRootNode	self		configuration: aRootNode configuration;		document: aRootNode document;		pushNode: aRootNode! !!XMLDOMParser methodsFor: 'configuring'!nodeFactory	^ self configuration nodeFactory! !!XMLDOMParser methodsFor: 'configuring'!nodeFactory: aNodeFactory	self configuration nodeFactory: aNodeFactory! !!XMLDOMParser methodsFor: 'deprecated'!nodeListClass	"will be deprecated"	^ self configuration nodeListClass! !!XMLDOMParser methodsFor: 'deprecated'!nodeListClass: aClass	"will be deprecated"	self configuration nodeListClass: aClass! !!XMLDOMParser methodsFor: 'private'!nodeStack	^ nodeStack! !!XMLDOMParser methodsFor: 'handling - declaration'!notationDeclaration: aName publicID: aPublicID systemID: aSystemID	self topNodeAdd:		(self nodeFactory notationDeclarationClass			name: aName			publicID: aPublicID			systemID: aSystemID)! !!XMLDOMParser methodsFor: 'initialization'!on: aStringOrStream	super on: aStringOrStream.	document := nil.	nodeStack := OrderedCollection new: 10.	currentScope := nil.! !!XMLDOMParser methodsFor: 'configuring'!optimizeForLargeDocuments	super optimizeForLargeDocuments.	"use the non-caching attribute list class to save memory"	self configuration attributeListClass: XMLAttributeList.! !!XMLDOMParser methodsFor: 'handling - declaration'!parameterEntityDeclaration: aName publicID: aPublicID systemID: aSystemID	self topNodeAdd:		(self nodeFactory parameterEntityDeclarationClass			name: aName			publicID: aPublicID			systemID: aSystemID)! !!XMLDOMParser methodsFor: 'handling - declaration'!parameterEntityDeclaration: aName replacement: aReplacement	self topNodeAdd:		(self nodeFactory parameterEntityDeclarationClass			name: aName			replacement: aReplacement)! !!XMLDOMParser methodsFor: 'parsing'!parsingResult	^ self document! !!XMLDOMParser methodsFor: 'private'!popNode	^ self nodeStack removeLast! !!XMLDOMParser methodsFor: 'configuring'!preservesCDataNodes	^ self configuration preservesCDataNodes! !!XMLDOMParser methodsFor: 'configuring'!preservesCDataNodes: aBoolean	"if enabled, <!![CDATA[...]]> sections will be preserved as CDATA nodes	and not ordinary string nodes and won't be merged with adjacent string	nodes (not default)"	self configuration preservesCDataNodes: aBoolean! !!XMLDOMParser methodsFor: 'configuring'!preservesCommentNodes	^ self configuration preservesCommentNodes! !!XMLDOMParser methodsFor: 'configuring'!preservesCommentNodes: aBoolean	"if enabled, comments will be preserved as comment nodes (not default)"	self configuration preservesCommentNodes: aBoolean! !!XMLDOMParser methodsFor: 'configuring'!preservesIgnorableWhitespace	^ self configuration preservesIgnorableWhitespace! !!XMLDOMParser methodsFor: 'configuring'!preservesIgnorableWhitespace: aBoolean	"If enabled, ignorable whitespace (identified by DTD element declarations	with element content) will be preserved as string nodes. Enables validation.	(Not default)"	self configuration preservesIgnorableWhitespace: aBoolean! !!XMLDOMParser methodsFor: 'handling - content'!processingInstruction: aTargetString data: aDataString	self topNodeAdd:		(self nodeFactory newPI			target: aTargetString;			data: aDataString)! !!XMLDOMParser methodsFor: 'private'!pushElement: anElement	self topNodeAdd: anElement.	^ self pushNode: anElement.! !!XMLDOMParser methodsFor: 'private'!pushNode: aNode	^ self nodeStack addLast: aNode! !!XMLDOMParser methodsFor: 'handling - lexical'!startDTD: aRootElementName publicID: aPublicID systemID: aSystemID	| doctypeDeclaration |	doctypeDeclaration := 		self nodeFactory doctypeDeclarationClass			root: aRootElementName			publicID: aPublicID			systemID: aSystemID.	self pushNode: doctypeDeclaration.	self document doctypeDeclaration: doctypeDeclaration.! !!XMLDOMParser methodsFor: 'handling - content'!startDocument	"inner XML parsers should ignore this event"	self nodeStack size > 0		ifFalse: [			self				document: self nodeFactory newDocument;				pushNode: self document.			self document configuration: self configuration]! !!XMLDOMParser methodsFor: 'handling - content'!startElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName attributes: anAttributeDictionary	self pushElement:		((self nodeFactory			classForElement: aQualifiedName			namespaceURI: aURI			localName: aLocalName			attributes: anAttributeDictionary) new				setConfiguration: self configuration				name: aQualifiedName				localName: aLocalName				attributes: anAttributeDictionary				namespaceScope: currentScope)! !!XMLDOMParser methodsFor: 'private'!startInnerXMLElement: anElement forParser: aParser	aParser driver currentElement: anElement name.	anElement hasNamespaces		ifTrue: [aParser driver currentScope: anElement namespaceScope].! !!XMLDOMParser methodsFor: 'private'!startScope: aNamespaceScope	currentScope := aNamespaceScope! !!XMLDOMParser methodsFor: 'accessing'!topNode	^ self nodeStack xmlLastOrNil! !!XMLDOMParser methodsFor: 'private'!topNodeAdd: aNode	^ self nodeStack last addNode: aNode! !!XMLDOMParser methodsFor: 'private'!topNodeAddString: aString	^ self nodeStack last addString: aString! !!XMLDOMParser methodsFor: 'handling - lexical'!xmlVersion: aVersionFloat encoding: anEncoding standalone: aBoolean	self document ifNotNil: [		self document			version: aVersionFloat;			encoding: anEncoding;			isStandalone: aBoolean]! !!XMLAbstractFactory class methodsFor: 'testing'!canBeImplemented	^ false! !!XMLAbstractFactory class methodsFor: 'clearing'!clearAllImplementations	"self clearAllImplementations"	self		implementation: nil;		allSubclassesDo: [:each | each implementation: nil]! !!XMLAbstractFactory class methodsFor: 'finding'!findSupportedImplementation	self canBeImplemented		ifTrue: [			self isSupportedImplementation				ifTrue: [^ self].			(self preferredImplementation notNil				and: [self preferredImplementation isSupportedImplementation])				ifTrue: [^ self preferredImplementation].			self allSubclassesDo: [:each |				each isSupportedImplementation					ifTrue: [^ each]]].	^ nil.! !!XMLAbstractFactory class methodsFor: 'testing'!hasSupportedImplementation	^ self findSupportedImplementation notNil! !!XMLAbstractFactory class methodsFor: 'accessing'!implementation	^ implementation		ifNil: [			"avoid assigning to the class inst var unless an implementation			was found to minimize write conflicts on GS"			self findSupportedImplementation				ifNil: [self noSupportedImplementationFound]				ifNotNil: [:supportedImplementation |					implementation := supportedImplementation].			implementation]! !!XMLAbstractFactory class methodsFor: 'accessing'!implementation: aClassOrNil	implementation := aClassOrNil! !!XMLAbstractFactory class methodsFor: 'instance creation'!implementationNew	^ self implementation basicNew initialize! !!XMLAbstractFactory class methodsFor: 'class initialization'!initialize	"self initialize"	self clearAllImplementations! !!XMLAbstractFactory class methodsFor: 'testing'!isSupportedImplementation	^ false! !!XMLAbstractFactory class methodsFor: 'instance creation'!new	^ self implementationNew! !!XMLAbstractFactory class methodsFor: 'finding'!noSupportedImplementationFound	Error signal: 'No implementation available'! !!XMLAbstractFactory class methodsFor: 'defaults'!preferredImplementation	^ nil! !!XMLFileDirectoryFileHandle class methodsFor: 'basic'!basicCurrentWorkingDirectory	^ (XMLClassFinder classNamed: #FileDirectory) default pathName! !!XMLFileDirectoryFileHandle class methodsFor: 'testing'!isSupportedImplementation	^ XMLClassFinder hasClassNamed: #FileDirectory! !!XMLFileDirectoryFileHandle methodsFor: 'basic'!basicDelete	"FileDirectory's deleteFileNamed: is used because DirectoryEntry	doesn't understand #delete on GS"	self fileDirectory deleteFileNamed: self path! !!XMLFileDirectoryFileHandle methodsFor: 'basic'!basicFileSize	^ self directoryEntry fileSize! !!XMLFileDirectoryFileHandle methodsFor: 'accessing'!directoryEntry	"a bug on Squeak (but not GS) with the handling of dot relative paths	like './file.xml' requires fully qualifying the path before creating	the DirectoryEntry"	^ self fileDirectory directoryEntryFor:		(self fileDirectory fullPathFor: self path)! !!XMLFileDirectoryFileHandle methodsFor: 'testing'!exists	^ self directoryEntry notNil! !!XMLFileDirectoryFileHandle methodsFor: 'accessing'!fileDirectory	^ fileDirectory		ifNil: [fileDirectory := (XMLClassFinder classNamed: #FileDirectory) default]! !!XMLFileDirectoryFileHandle methodsFor: 'testing'!isFile	^ self exists		and: [self directoryEntry isDirectory not]! !!XMLFileHandle class methodsFor: 'basic'!basicCurrentWorkingDirectory	self subclassResponsibility! !!XMLFileHandle class methodsFor: 'testing'!canBeImplemented	^ true! !!XMLFileHandle class methodsFor: 'accessing'!currentWorkingDirectory	"returns a path string for the current working directory"	^ self implementation basicCurrentWorkingDirectory! !!XMLFileHandle class methodsFor: 'finding'!noSupportedImplementationFound	XMLFileException signal: 'File IO unsupported'! !!XMLFileHandle class methodsFor: 'instance creation'!path: aPathString	^ self new setPath: aPathString! !!XMLFileHandle class methodsFor: 'defaults'!preferredImplementation	^ XMLFileSystemFileHandle! !!XMLFileHandle class methodsFor: 'accessing'!xmlDocumentFileExtensions	"a class variable so it's shared by all subclasses, but lazy initialized	so it isn't initialized unless needed"	^ XMLDocumentFileExtensions		ifNil: [			XMLDocumentFileExtensions :=				#('atom' "Atom Syndication Format"					'dbk' "DocBook XML"					'docm' "Office Open XML Document"					'docx' "Office Open XML Document"					'pptm' "Office Open XML Presentation"					'pptx' "Office Open XML Presentation"					'rdf' "Resource Description Framework"					'rss' "Rich Site Summary"					'svg' "Scalable Vector Graphics"					'xbel' "XML Bookmark Exchange Language"					'xfd' "Extensible Forms Description Language"					'xfdl' "Extensible Forms Description Language"					'xhtml'					'xlsm' "Office Open XML Workbook"					'xlsx' "Office Open XML Workbook"					'xml'					'xsd' "XML Schema Definition"					'xspf' "XML Shareable Playlist Format"					'xul' "XML User Interface Language"				) asSet]! !!XMLFileHandle class methodsFor: 'accessing'!xmlDocumentFileExtensions: aCollectionOrNil	XMLDocumentFileExtensions :=		aCollectionOrNil			ifNotNil: [aCollectionOrNil asSet]! !!XMLFileHandle methodsFor: 'converting'!asXMLFileHandle	^ self! !!XMLFileHandle methodsFor: 'basic'!basicDelete	self subclassResponsibility! !!XMLFileHandle methodsFor: 'basic'!basicFileSize	"This is named #basicFileSize instead of #basicSize to avoid conflicting	with the Object>>#basicSize primitive"	self subclassResponsibility! !!XMLFileHandle methodsFor: 'accessing'!contents	^ self readStreamDo: [:readStream | readStream upToEnd]! !!XMLFileHandle methodsFor: 'deleting'!delete	self exists		ifFalse: [self errorFileDoesNotExist].	[self basicDelete]		on: Error		do: [:error | XMLFileException signalMessageFrom: error].! !!XMLFileHandle methodsFor: 'private'!errorFileDoesNotExist	XMLFileException		formatSignal: 'File does does not exist: {1}'		with: self path! !!XMLFileHandle methodsFor: 'private'!errorFileExceedsMaxSize: aMaxSize	XMLLimitException		formatSignal: 'File exceeds max size of {1} bytes: {2}'		with: aMaxSize		with: self path! !!XMLFileHandle methodsFor: 'private'!errorNotAFile	XMLFileException		formatSignal: 'Not a file: {1}'		with: self path! !!XMLFileHandle methodsFor: 'testing'!exists	"returns true if the file exists"	self subclassResponsibility! !!XMLFileHandle methodsFor: 'accessing'!extension	"Returns the file extension, everything after the first '.' of the	last path segment:		'one.two/three.txt' asXMLFileHandle extension = 'txt'.		'one.two/three.tar.gz' asXMLFileHandle extension = 'tar.gz'.		'one.two/three.four/' asXMLFileHandle extension = ''.	"	| i |	^ ((i := self path lastIndexOf: $/) > 0		ifTrue: [self path copyFrom: i + 1 to: self path size]		ifFalse: [self path]) copyAfter: $.! !!XMLFileHandle methodsFor: 'resolving'!get	^ self		getUpToLimit: nil		decoding: true! !!XMLFileHandle methodsFor: 'resolving'!getUpToLimit: aMaxSize decoding: aBoolean	| stream contents |	"can be safely implemented using streamGetUpToLimit:decoding: rather	than the other way around like XMLHTTPRequest requires, because files	are local and can be safely read incrementally, unlike an HTTP response	which must be read immediately and stored entirely in memory"	stream :=		self			streamGetUpToLimit: aMaxSize			decoding: aBoolean.	contents := stream upToEnd.	stream close.	^ contents.! !!XMLFileHandle methodsFor: 'testing'!isFile	"returns true if the file exists and is a file (not a directory)"	self subclassResponsibility! !!XMLFileHandle methodsFor: 'testing'!isXMLDocumentFile	"Returns true if the file has a known extension of an XML document format	such as .xml, .xhtml, .xul, but not .dtd, .ent, or other XML-related	formats that aren't proper XML documents."	^ self class xmlDocumentFileExtensions includes: self extension asLowercase! !!XMLFileHandle methodsFor: 'instance creation'!newFileReadStreamOnPath	^ XMLFileReadStreamFactory onPath: self path! !!XMLFileHandle methodsFor: 'instance creation'!newFileWriteStreamOnPath	^ XMLFileWriteStreamFactory onPath: self path! !!XMLFileHandle methodsFor: 'accessing'!path	^ path ifNil: [path := '']! !!XMLFileHandle methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: self path;		nextPut: $).! !!XMLFileHandle methodsFor: 'reading'!rawReadStream	"returns a raw file read stream with no decoding"	self exists		ifFalse: [self errorFileDoesNotExist].	self isFile		ifFalse: [self errorNotAFile].		^ [self newFileReadStreamOnPath]		on: Error		do: [:error | XMLFileException signalMessageFrom: error].! !!XMLFileHandle methodsFor: 'writing'!rawWriteStream	"returns a raw file write stream with no encoding; truncates existing files"	^ [self newFileWriteStreamOnPath]		on: Error		do: [:error | XMLFileException signalMessageFrom: error]! !!XMLFileHandle methodsFor: 'reading'!readStream	"returns a file read stream with decoding"	^ (XMLDecodingReadStreamAdapter nonDecodingOn: self rawReadStream)		detectEncoding! !!XMLFileHandle methodsFor: 'reading'!readStreamDo: aBlock	"evaluates aBlock with a file read stream with decoding and automatically	closes it after"	| readStream |	readStream := self readStream.	^ [aBlock value: readStream]		ensure: [readStream close].! !!XMLFileHandle methodsFor: 'initialization'!setPath: aPathString	path := aPathString! !!XMLFileHandle methodsFor: 'accessing'!size	self exists		ifFalse: [self errorFileDoesNotExist].	^ self basicFileSize.! !!XMLFileHandle methodsFor: 'resolving'!streamGet	^ self		streamGetUpToLimit: nil		decoding: true! !!XMLFileHandle methodsFor: 'resolving'!streamGetUpToLimit: aMaxSize decoding: aBoolean	(aMaxSize notNil		and: [self size > aMaxSize])		ifTrue: [self errorFileExceedsMaxSize: aMaxSize].	^ aBoolean		ifTrue: [self readStream]		ifFalse: [self rawReadStream].! !!XMLFileHandle methodsFor: 'writing'!writeStream	"returns a file write stream with encoding; truncates existing files"	^ XMLEncodingWriteStreamAdapter on: self rawWriteStream! !!XMLFileHandle methodsFor: 'writing'!writeStreamDo: aBlock	"evaluates aBlock with a file write stream with encoding and	automatically closes it after; truncates existing files"	| writeStream |	writeStream := self writeStream.	^ [aBlock value: writeStream]		ensure: [writeStream close].! !!XMLFileSystemFileHandle class methodsFor: 'basic'!basicCurrentWorkingDirectory	"avoid the class #workingDirectory message for Pharo1x compatibility"	^ (XMLClassFinder classNamed: #FileSystem) disk workingDirectory pathString! !!XMLFileSystemFileHandle class methodsFor: 'instance creation'!fileReference: aFileReference	^ self new setFileReference: aFileReference! !!XMLFileSystemFileHandle class methodsFor: 'testing'!isSupportedImplementation	^ XMLClassFinder hasClassNamed: #FileSystem! !!XMLFileSystemFileHandle methodsFor: 'basic'!basicDelete	self fileReference delete! !!XMLFileSystemFileHandle methodsFor: 'basic'!basicFileSize	^ self fileReference size! !!XMLFileSystemFileHandle methodsFor: 'testing'!exists	^ self fileReference exists! !!XMLFileSystemFileHandle methodsFor: 'accessing'!fileReference	^ fileReference ifNil: [fileReference := self path asFileReference]! !!XMLFileSystemFileHandle methodsFor: 'testing'!isFile	^ self fileReference isFile! !!XMLFileSystemFileHandle methodsFor: 'instance creation'!newFileReadStreamOnPath	"memory file references need special handling"	self usesMemoryStore		ifTrue: [^ self fileReference readStream].	^ super newFileReadStreamOnPath.! !!XMLFileSystemFileHandle methodsFor: 'instance creation'!newFileWriteStreamOnPath	"memory file references need special handling"	self usesMemoryStore		ifTrue: [^ self fileReference writeStream].	^ super newFileWriteStreamOnPath.! !!XMLFileSystemFileHandle methodsFor: 'initialization'!setFileReference: aFileReference	fileReference := aFileReference.	self setPath: aFileReference fullName.! !!XMLFileSystemFileHandle methodsFor: 'testing'!usesMemoryStore	"Pharo 3.0 has memory stores but lacks #isMemoryFileSystem, so	this test is used instead for backwards compatibility"	^ self fileReference fileSystem store class ==		(XMLClassFinder classNamed: #MemoryStore)! !!XMLFileReadStreamFactory class methodsFor: 'basic'!basicOnPath: aPathString	self subclassResponsibility! !!XMLFileReadStreamFactory class methodsFor: 'testing'!canBeImplemented	^ true! !!XMLFileReadStreamFactory class methodsFor: 'finding'!noSupportedImplementationFound	XMLFileException signal: 'File reading unsupported'! !!XMLFileReadStreamFactory class methodsFor: 'instance creation'!onPath: aPathString	^ self implementation basicOnPath: aPathString! !!XMLFileReadStreamFactory class methodsFor: 'defaults'!preferredImplementation	^ XMLStandardFileStreamReadStreamFactory! !!XMLStandardFileStreamReadStreamFactory class methodsFor: 'basic'!basicOnPath: aPathString	^ ((XMLClassFinder classNamed: #StandardFileStream)		readOnlyFileNamed: aPathString)			binary;			yourself! !!XMLStandardFileStreamReadStreamFactory class methodsFor: 'testing'!isSupportedImplementation	^ XMLClassFinder hasClassNamed: #StandardFileStream! !!XMLFileWriteStreamFactory class methodsFor: 'basic'!basicOnPath: aPathString	self subclassResponsibility! !!XMLFileWriteStreamFactory class methodsFor: 'testing'!canBeImplemented	^ true! !!XMLFileWriteStreamFactory class methodsFor: 'finding'!noSupportedImplementationFound	XMLFileException signal: 'File writing unsupported'! !!XMLFileWriteStreamFactory class methodsFor: 'instance creation'!onPath: aPathString	^ self implementation basicOnPath: aPathString! !!XMLFileWriteStreamFactory class methodsFor: 'defaults'!preferredImplementation	^ XMLStandardFileStreamWriteStreamFactory! !!XMLStandardFileStreamWriteStreamFactory class methodsFor: 'basic'!basicOnPath: aPathString	"use forceNewFileNamed: to ensure truncation of existing files before writing"	^ ((XMLClassFinder classNamed: #StandardFileStream)		forceNewFileNamed: aPathString)			binary;			yourself! !!XMLStandardFileStreamWriteStreamFactory class methodsFor: 'testing'!isSupportedImplementation	^ XMLClassFinder hasClassNamed: #StandardFileStream! !!XMLHTTPMessage methodsFor: 'adding'!addHeader: anAssociation	self		headerValuesAt: anAssociation key		add: anAssociation value.	^ anAssociation.! !!XMLHTTPMessage methodsFor: 'accessing'!content	"Returns the response content as a String or ByteArray"	"Requests with content aren't supported yet"	^ content ifNil: [content := '']! !!XMLHTTPMessage methodsFor: 'accessing'!content: aStringOrByteArray	content := aStringOrByteArray! !!XMLHTTPMessage methodsFor: 'accessing'!contentCharset	| contentType charset |	^ ((contentType := self contentType) isNil		or: [(charset := contentType charset) isEmpty])		ifTrue: [self defaultContentCharset]		ifFalse: [charset]! !!XMLHTTPMessage methodsFor: 'accessing'!contentEncoding	"Returns the non-identity content encoding compression schemes	in the order they were applied"	^ self encodingNamesFromHeaderValuesAt: 'Content-Encoding'! !!XMLHTTPMessage methodsFor: 'accessing'!contentEncoding: aStringOrCollection	self		encodingNamesFromHeaderValuesAt: 'Content-Encoding'		put: aStringOrCollection! !!XMLHTTPMessage methodsFor: 'accessing'!contentLength	^ XMLIntegerReader		readFrom:			(self				headerAt: 'Content-Length'				ifAbsent: [^ nil]) readStream		withBase: 10! !!XMLHTTPMessage methodsFor: 'accessing'!contentLength: anInteger	anInteger		ifNil: [			self				removeHeaderAt: 'Content-Length'				ifAbsent: []]		ifNotNil: [			self				headerAt: 'Content-Length'				put: anInteger asString]! !!XMLHTTPMessage methodsFor: 'accessing'!contentType	"Returns an XMLMIMEType object for the Content-Type header value"	^ XMLHTTPMIMEType fromString:		(self			headerAt: 'Content-Type'			ifAbsent: [^ nil])! !!XMLHTTPMessage methodsFor: 'accessing'!contentType: aMIMETypeOrString	aMIMETypeOrString		ifNil: [			self				removeHeaderAt: 'Content-Type'				ifAbsent: []]		ifNotNil: [			self				headerAt: 'Content-Type'				put: aMIMETypeOrString asString]! !!XMLHTTPMessage methodsFor: 'defaults'!defaultContentCharset	^ XMLHTTPMIMEType defaultCharset! !!XMLHTTPMessage methodsFor: 'private'!encodingNamesFromHeaderValuesAt: aKey	"Returns the non-identity encoding compression schemes	in the order they were applied from the value(s) of the	specified header"	| encodingNames |	encodingNames := OrderedCollection new.	self		headerValuesAt: aKey		do: [:headerValue |			$,				xmlSplit: headerValue				do: [:headerValueField | | encodingName |					encodingName :=						headerValueField xmlCopyWithoutWhitespace asLowercase.					(encodingName isEmpty						or: [encodingName = 'identity'])						ifFalse: [encodingNames addLast: encodingName]]].	^ encodingNames.! !!XMLHTTPMessage methodsFor: 'private'!encodingNamesFromHeaderValuesAt: aKey put: aStringOrCollection	aStringOrCollection isEmpty		ifTrue: [			self				removeHeaderAt: aKey				ifAbsent: []]		ifFalse: [			self				headerAt: aKey				put:					(aStringOrCollection isString						ifTrue: [aStringOrCollection]						ifFalse: [							String streamContents: [:stream |								aStringOrCollection									do: [:each | stream nextPutAll: each]									separatedBy: [stream nextPutAll: ', ']]])]! !!XMLHTTPMessage methodsFor: 'private'!errorRemovingAbsentHeader: aKey	XMLHTTPException		formatSignal: 'Cannot remove absent HTTP header "{1}" from message'		with: aKey! !!XMLHTTPMessage methodsFor: 'testing'!hasContent	^ self content notEmpty! !!XMLHTTPMessage methodsFor: 'testing'!hasHeaders	self headerKeysDo: [:key | ^ true].	^ false.! !!XMLHTTPMessage methodsFor: 'accessing'!headerAt: aKey	^ self		headerAt: aKey		ifAbsent: ['']! !!XMLHTTPMessage methodsFor: 'accessing'!headerAt: aKey ifAbsent: aBlock	self subclassResponsibility! !!XMLHTTPMessage methodsFor: 'accessing'!headerAt: aKey ifAbsentPut: aBlock	^ self		headerAt: aKey		ifAbsent: [			self				headerAt: aKey				put: aBlock value]! !!XMLHTTPMessage methodsFor: 'accessing'!headerAt: aKey put: aValue	self subclassResponsibility! !!XMLHTTPMessage methodsFor: 'accessing'!headerKeys	| keys |	keys := OrderedCollection new.	self headerKeysDo: [:key |		keys addLast: key].	^ keys.! !!XMLHTTPMessage methodsFor: 'enumerating'!headerKeysAndValuesDo: aTwoArgumentBlock	self subclassResponsibility! !!XMLHTTPMessage methodsFor: 'enumerating'!headerKeysDo: aBlock	self headerKeysAndValuesDo: [:key :value |		aBlock value: key]! !!XMLHTTPMessage methodsFor: 'accessing'!headerValuesAt: aKey	| values |	values := OrderedCollection new.	self		headerValuesAt: aKey		do: [:each | values addLast: each].	^ values.! !!XMLHTTPMessage methodsFor: 'adding'!headerValuesAt: aKey add: aValue	self subclassResponsibility! !!XMLHTTPMessage methodsFor: 'enumerating'!headerValuesAt: aKey do: aBlock	self subclassResponsibility! !!XMLHTTPMessage methodsFor: 'accessing'!headers	| headers |	headers := OrderedCollection new.	self headerKeysAndValuesDo: [:key :value |		headers addLast: key -> value].	^ headers.! !!XMLHTTPMessage methodsFor: 'testing'!includesHeaderAt: aKey	self		headerAt: aKey		ifAbsent: [^ false].	^ true.! !!XMLHTTPMessage methodsFor: 'removing'!removeHeaderAt: aKey	^ self		removeHeaderAt: aKey		ifAbsent: [self errorRemovingAbsentHeader: aKey]! !!XMLHTTPMessage methodsFor: 'removing'!removeHeaderAt: aKey ifAbsent: aBlock	self subclassResponsibility! !!XMLHTTPMessage methodsFor: 'removing'!removeHeaders	self headerKeys do: [:each |		self			removeHeaderAt: each			ifAbsent: []]! !!XMLHTTPRequest class methodsFor: 'testing'!canBeImplemented	^ true! !!XMLHTTPRequest class methodsFor: 'instance creation'!new	^ self url: ''! !!XMLHTTPRequest class methodsFor: 'finding'!noSupportedImplementationFound	XMLHTTPException signal: 'HTTP unsupported; install Zinc or WebClient'! !!XMLHTTPRequest class methodsFor: 'defaults'!preferredImplementation	^ XMLHTTPZincRequest! !!XMLHTTPRequest class methodsFor: 'instance creation'!url: aURLString	^ self implementationNew setURL: aURLString! !!XMLHTTPRequest methodsFor: 'accessing'!acceptEncoding	^ self encodingNamesFromHeaderValuesAt: 'Accept-Encoding'! !!XMLHTTPRequest methodsFor: 'accessing'!acceptEncoding: aStringOrCollection	"NOTE: only gzip is currently supported"	self		encodingNamesFromHeaderValuesAt: 'Accept-Encoding'		put: aStringOrCollection! !!XMLHTTPRequest methodsFor: 'converting'!asXMLHTTPRequest	^ self! !!XMLHTTPRequest methodsFor: 'basic'!basicCleanup	"can be overridden to handle cleanup after sending the	request and reading the response"! !!XMLHTTPRequest methodsFor: 'basic'!basicSend	self subclassResponsibility! !!XMLHTTPRequest methodsFor: 'defaults'!defaultAcceptEncoding	^ #()! !!XMLHTTPRequest methodsFor: 'defaults'!defaultMethod	^ 'GET'! !!XMLHTTPRequest methodsFor: 'defaults'!defaultTimeout	^ 30! !!XMLHTTPRequest methodsFor: 'accessing'!enableCompression	"NOTE: only gzip is currently supported"	self acceptEncoding: 'gzip'! !!XMLHTTPRequest methodsFor: 'private'!errorBadResponse: aResponse	XMLHTTPException		formatSignal: '{1} ({2})'		with: aResponse statusDescription		with: aResponse statusCode! !!XMLHTTPRequest methodsFor: 'resolving'!get	^ self		getUpToLimit: nil		decoding: true! !!XMLHTTPRequest methodsFor: 'resolving'!getUpToLimit: aMaxSize decoding: aBoolean	self method: 'GET'.	^ (self		resolveUpToLimit: aMaxSize		decoding: aBoolean) content! !!XMLHTTPRequest methodsFor: 'accessing'!method	self subclassResponsibility! !!XMLHTTPRequest methodsFor: 'accessing'!method: aString	self subclassResponsibility! !!XMLHTTPRequest methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: self method;		space;		nextPutAll: self url;		nextPut: $).! !!XMLHTTPRequest methodsFor: 'resolving - response'!resolve	"Sends and retrieves the response as an XMLHTTPResponse object."	^ self		resolveUpToLimit: nil		decoding: true! !!XMLHTTPRequest methodsFor: 'resolving - response'!resolveUpToLimit: aMaxSize decoding: aBoolean	| response |	[		[			(response := self basicSend) isSuccess				ifFalse: [self errorBadResponse: response].			response				readContentUpToLimit: aMaxSize				decoding: aBoolean]			on: Error			do: [:error |				error isXMLParserException					ifTrue: [error pass]					ifFalse: [XMLHTTPException signalMessageFrom: error]]		] ensure: [self basicCleanup].	^ response.! !!XMLHTTPRequest methodsFor: 'defaults'!responseClass	self subclassResponsibility! !!XMLHTTPRequest methodsFor: 'initialization'!setURL: aURLString	url := aURLString.	self		timeout: self defaultTimeout;		method: self defaultMethod;		"even if #defaultAcceptEncoding returns an empty collection,		#acceptEncoding: must still be sent here to override any default		setting of the underlying HTTP library that we don't support"		acceptEncoding: self defaultAcceptEncoding.! !!XMLHTTPRequest methodsFor: 'resolving'!streamGet	^ self		streamGetUpToLimit: nil		decoding: true! !!XMLHTTPRequest methodsFor: 'resolving'!streamGetUpToLimit: aMaxSize decoding: aBoolean	"must be implemented using getUpToLimit:decoding: rather than the other	way around like XMLFileHandle does, because HTTP responses must be read	immediately and stored entirely in memory, unlike a file stream which	can safely be left open and read from incrementally"	^ (self		getUpToLimit: aMaxSize		decoding: aBoolean) readStream! !!XMLHTTPRequest methodsFor: 'accessing'!timeout	self subclassResponsibility! !!XMLHTTPRequest methodsFor: 'accessing'!timeout: anInteger	self subclassResponsibility! !!XMLHTTPRequest methodsFor: 'accessing'!url	^ url ifNil: [url := '']! !!XMLHTTPWebClientRequest class methodsFor: 'testing'!isSupportedImplementation	^ XMLClassFinder hasClassNamed: #WebClient! !!XMLHTTPWebClientRequest methodsFor: 'basic'!basicCleanup	self webClientClient close! !!XMLHTTPWebClientRequest methodsFor: 'basic'!basicSend	^ self responseClass		request: self		webClientResponse:			(self webClientClient				"#sendRequest: unfortunately requires #initializeFromUrl:				to be sent first"				initializeFromUrl: self url;				sendRequest: self webClientRequest)! !!XMLHTTPWebClientRequest methodsFor: 'accessing'!headerAt: aKey ifAbsent: aBlock	^ self webClientRequest		headerAt: aKey		ifAbsent: aBlock! !!XMLHTTPWebClientRequest methodsFor: 'accessing'!headerAt: aKey put: aValue	self webClientRequest		removeHeader: aKey;		addHeader: aKey value: aValue.	^ aValue.! !!XMLHTTPWebClientRequest methodsFor: 'enumerating'!headerKeysAndValuesDo: aTwoArgumentBlock	self webClientRequest headersDo: aTwoArgumentBlock! !!XMLHTTPWebClientRequest methodsFor: 'adding'!headerValuesAt: aKey add: aValue	self webClientRequest		addHeader: aKey		value: aValue.	^ aValue.! !!XMLHTTPWebClientRequest methodsFor: 'enumerating'!headerValuesAt: aKey do: aBlock	self webClientRequest		headersAt: aKey		do: aBlock! !!XMLHTTPWebClientRequest methodsFor: 'accessing'!method	^ self webClientRequest method! !!XMLHTTPWebClientRequest methodsFor: 'accessing'!method: aString	self webClientRequest method: aString! !!XMLHTTPWebClientRequest methodsFor: 'removing'!removeHeaderAt: aKey ifAbsent: aBlock	| removedValues |	removedValues :=		self webClientRequest			headersAt: aKey			ifAbsent: [^ aBlock value].	self webClientRequest removeHeader: aKey.	^ removedValues asOrderedCollection.! !!XMLHTTPWebClientRequest methodsFor: 'defaults'!responseClass	^ XMLHTTPWebClientResponse! !!XMLHTTPWebClientRequest methodsFor: 'accessing'!timeout	^ self webClientClient timeout! !!XMLHTTPWebClientRequest methodsFor: 'accessing'!timeout: anInteger	self webClientClient timeout: anInteger! !!XMLHTTPWebClientRequest methodsFor: 'private'!webClientClient	^ webClientClient		ifNil: [			webClientClient := (XMLClassFinder classNamed: #WebClient) new]! !!XMLHTTPWebClientRequest methodsFor: 'private'!webClientRequest	^ webClientRequest		ifNil: [			webClientRequest :=				(XMLClassFinder classNamed: #WebRequest) new					initializeFromUrl: self url;					yourself]! !!XMLHTTPZincRequest class methodsFor: 'testing'!isSupportedImplementation	^ XMLClassFinder hasClassNamed: #ZnClient! !!XMLHTTPZincRequest methodsFor: 'basic'!basicCleanup	self zincClient close! !!XMLHTTPZincRequest methodsFor: 'basic'!basicSend	^ self responseClass		request: self		zincResponse:			(self zincClient				request: self zincRequest;				execute;				response)! !!XMLHTTPZincRequest methodsFor: 'accessing'!headerAt: aKey ifAbsent: aBlock	self zincRequest headers		at: aKey		ifPresent: [:value |			^ value isArray				ifTrue: [value first]				ifFalse: [value]].	^ aBlock value.! !!XMLHTTPZincRequest methodsFor: 'accessing'!headerAt: aKey put: aValue	self zincRequest headers		at: aKey		put: aValue.	^ aValue.! !!XMLHTTPZincRequest methodsFor: 'enumerating'!headerKeysAndValuesDo: aTwoArgumentBlock	self zincRequest headersDo: aTwoArgumentBlock! !!XMLHTTPZincRequest methodsFor: 'adding'!headerValuesAt: aKey add: aValue	self zincRequest headers		at: aKey		add: aValue.	^ aValue.! !!XMLHTTPZincRequest methodsFor: 'enumerating'!headerValuesAt: aKey do: aBlock	self zincRequest headers		at: aKey		ifPresent: [:value |			value isArray				ifTrue: [value do: aBlock]				ifFalse: [aBlock value: value]]! !!XMLHTTPZincRequest methodsFor: 'accessing'!method	^ self zincRequest method asString! !!XMLHTTPZincRequest methodsFor: 'accessing'!method: aString	self zincRequest method: aString asSymbol! !!XMLHTTPZincRequest methodsFor: 'removing'!removeHeaderAt: aKey ifAbsent: aBlock	| removedValues |	removedValues :=		self zincRequest headers			removeKey: aKey			ifAbsent: [^ aBlock value].	^ removedValues isString		ifTrue: [OrderedCollection with: removedValues]		ifFalse: [removedValues asOrderedCollection].! !!XMLHTTPZincRequest methodsFor: 'defaults'!responseClass	^ XMLHTTPZincResponse! !!XMLHTTPZincRequest methodsFor: 'accessing'!timeout	^ self zincClient timeout! !!XMLHTTPZincRequest methodsFor: 'accessing'!timeout: anInteger	self zincClient timeout: anInteger! !!XMLHTTPZincRequest methodsFor: 'private '!zincClient	^ zincClient		ifNil: [			zincClient :=				(XMLClassFinder classNamed: #ZnClient) new					streaming: true;					yourself]! !!XMLHTTPZincRequest methodsFor: 'private '!zincRequest	^ zincRequest		ifNil: [			zincRequest :=				(XMLClassFinder classNamed: #ZnRequest)					get: self url]! !!XMLHTTPResponse class methodsFor: 'testing'!canBeImplemented	^ true! !!XMLHTTPResponse class methodsFor: 'finding'!noSupportedImplementationFound	XMLHTTPRequest noSupportedImplementationFound! !!XMLHTTPResponse class methodsFor: 'defaults'!preferredImplementation	^ XMLHTTPZincResponse! !!XMLHTTPResponse class methodsFor: 'instance creation'!request: aRequest	^ self new setRequest: aRequest! !!XMLHTTPResponse methodsFor: 'defaults'!contentReaderClass	self subclassResponsibility! !!XMLHTTPResponse methodsFor: 'defaults'!defaultProtocol	^ 'HTTP/1.1'! !!XMLHTTPResponse methodsFor: 'defaults'!defaultStatusCode	^ 200! !!XMLHTTPResponse methodsFor: 'testing'!isChunked	^ (self		headerAt: 'Transfer-Encoding'		ifAbsent: [^ false]) beginsWith: 'chunked'! !!XMLHTTPResponse methodsFor: 'testing'!isSuccess	self subclassResponsibility! !!XMLHTTPResponse methodsFor: 'instance creation'!newContentReader	^ self contentReaderClass response: self! !!XMLHTTPResponse methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: self statusLine;		nextPut: $).! !!XMLHTTPResponse methodsFor: 'accessing'!protocol	self subclassResponsibility! !!XMLHTTPResponse methodsFor: 'accessing'!protocol: aString	self		setProtocol: aString		statusCode: self statusCode! !!XMLHTTPResponse methodsFor: 'reading'!readContentUpToLimit: aMaxSize decoding: aBoolean	self content:		(self newContentReader			readUpToLimit: aMaxSize			decoding: aBoolean)! !!XMLHTTPResponse methodsFor: 'converting'!readStream	^ self content readStream! !!XMLHTTPResponse methodsFor: 'accessing'!request	"Returns the XMLHTTPRequest object that created this response"	^ request! !!XMLHTTPResponse methodsFor: 'initialization'!setProtocol: aString statusCode: anInteger	self subclassResponsibility! !!XMLHTTPResponse methodsFor: 'initialization'!setRequest: aRequest	request := aRequest! !!XMLHTTPResponse methodsFor: 'accessing'!statusCode	"Returns the status code as an integer"	self subclassResponsibility! !!XMLHTTPResponse methodsFor: 'accessing'!statusCode: anInteger	self		setProtocol: self protocol		statusCode: anInteger! !!XMLHTTPResponse methodsFor: 'accessing'!statusDescription	| delimiter |	delimiter := Character space.	^ (self statusLine copyAfter: delimiter)		copyAfter: delimiter! !!XMLHTTPResponse methodsFor: 'accessing'!statusLine	"Returns the status line as a string"	self subclassResponsibility! !!XMLHTTPWebClientResponse class methodsFor: 'testing'!isSupportedImplementation	^ XMLClassFinder hasClassNamed: #WebResponse! !!XMLHTTPWebClientResponse class methodsFor: 'instance creation'!request: aRequest webClientResponse: aWebClientResponse	^ (self request: aRequest)		setWebClientResponse: aWebClientResponse! !!XMLHTTPWebClientResponse methodsFor: 'defaults'!contentReaderClass	^ XMLHTTPWebClientResponseContentReader! !!XMLHTTPWebClientResponse methodsFor: 'accessing'!headerAt: aKey ifAbsent: aBlock	^ self webClientResponse		headerAt: aKey		ifAbsent: aBlock! !!XMLHTTPWebClientResponse methodsFor: 'accessing'!headerAt: aKey put: aValue	self webClientResponse		removeHeader: aKey;		addHeader: aKey value: aValue.	^ aValue.! !!XMLHTTPWebClientResponse methodsFor: 'enumerating'!headerKeysAndValuesDo: aTwoArgumentBlock	self webClientResponse headersDo: aTwoArgumentBlock! !!XMLHTTPWebClientResponse methodsFor: 'adding'!headerValuesAt: aKey add: aValue	self webClientResponse		addHeader: aKey		value: aValue.	^ aValue.! !!XMLHTTPWebClientResponse methodsFor: 'enumerating'!headerValuesAt: aKey do: aBlock	self webClientResponse		headersAt: aKey		do: aBlock! !!XMLHTTPWebClientResponse methodsFor: 'testing'!isSuccess	^ self webClientResponse isSuccess! !!XMLHTTPWebClientResponse methodsFor: 'accessing'!protocol	^ self webClientResponse protocol! !!XMLHTTPWebClientResponse methodsFor: 'removing'!removeHeaderAt: aKey ifAbsent: aBlock	| removedValues |	removedValues :=		self webClientResponse			headersAt: aKey			ifAbsent: [^ aBlock value].	self webClientResponse removeHeader: aKey.	^ removedValues asOrderedCollection.! !!XMLHTTPWebClientResponse methodsFor: 'initialization'!setProtocol: aString statusCode: anInteger	self webClientResponse		protocol: aString		code: anInteger! !!XMLHTTPWebClientResponse methodsFor: 'initialization'!setWebClientResponse: aWebClientResponse	webClientResponse := aWebClientResponse! !!XMLHTTPWebClientResponse methodsFor: 'accessing'!statusCode	^ self webClientResponse code! !!XMLHTTPWebClientResponse methodsFor: 'accessing'!statusLine	^ self webClientResponse status! !!XMLHTTPWebClientResponse methodsFor: 'private'!webClientResponse	^ webClientResponse		ifNil: [			webClientResponse :=				(XMLClassFinder classNamed: #WebResponse)					protocol: self defaultProtocol					code: self defaultStatusCode]! !!XMLHTTPZincResponse class methodsFor: 'testing'!isSupportedImplementation	^ XMLClassFinder hasClassNamed: #ZnResponse! !!XMLHTTPZincResponse class methodsFor: 'instance creation'!request: aRequest zincResponse: aZincResponse	^ (self request: aRequest)		setZincResponse: aZincResponse! !!XMLHTTPZincResponse methodsFor: 'defaults'!contentReaderClass	^ XMLHTTPZincResponseContentReader! !!XMLHTTPZincResponse methodsFor: 'accessing'!headerAt: aKey ifAbsent: aBlock	self zincResponse headers		at: aKey		ifPresent: [:value |			^ value isArray				ifTrue: [value first]				ifFalse: [value]].	^ aBlock value.! !!XMLHTTPZincResponse methodsFor: 'accessing'!headerAt: aKey put: aValue	self zincResponse headers		at: aKey		put: aValue.	^ aValue.! !!XMLHTTPZincResponse methodsFor: 'enumerating'!headerKeysAndValuesDo: aTwoArgumentBlock	self zincResponse headersDo: aTwoArgumentBlock! !!XMLHTTPZincResponse methodsFor: 'adding'!headerValuesAt: aKey add: aValue	self zincResponse headers		at: aKey		add: aValue.	^ aValue.! !!XMLHTTPZincResponse methodsFor: 'enumerating'!headerValuesAt: aKey do: aBlock	self zincResponse headers		at: aKey		ifPresent: [:value |			value isArray				ifTrue: [value do: aBlock]				ifFalse: [aBlock value: value]]! !!XMLHTTPZincResponse methodsFor: 'testing'!isSuccess	^ self zincResponse isSuccess! !!XMLHTTPZincResponse methodsFor: 'accessing'!protocol	^ self zincResponse statusLine version! !!XMLHTTPZincResponse methodsFor: 'removing'!removeHeaderAt: aKey ifAbsent: aBlock	| removedValues |	removedValues :=		self zincResponse headers			removeKey: aKey			ifAbsent: [^ aBlock value].	^ removedValues isString		ifTrue: [OrderedCollection with: removedValues]		ifFalse: [removedValues asOrderedCollection].! !!XMLHTTPZincResponse methodsFor: 'initialization'!setProtocol: aString statusCode: anInteger	self zincResponse statusLine:		((ZnStatusLine code: anInteger)			version: aString;			yourself)! !!XMLHTTPZincResponse methodsFor: 'initialization'!setZincResponse: aZincResponse	zincResponse := aZincResponse! !!XMLHTTPZincResponse methodsFor: 'accessing'!statusCode	^ self zincResponse status! !!XMLHTTPZincResponse methodsFor: 'accessing'!statusLine	| statusLine |		statusLine := self zincResponse statusLine.	^ String streamContents: [:stream |		stream			nextPutAll: statusLine version;			space.		statusLine printCodeAndReasonOn: stream].! !!XMLHTTPZincResponse methodsFor: 'private'!zincResponse	^ zincResponse		ifNil: [			zincResponse :=				(XMLClassFinder classNamed: #ZnResponse) new					statusLine:						((ZnStatusLine code: self defaultStatusCode)							version: self defaultProtocol;							yourself);					yourself]! !!XMLKeyValueCache class methodsFor: 'testing'!canBeImplemented	^ true! !!XMLKeyValueCache class methodsFor: 'defaults'!defaultMaxSize	^ 32! !!XMLKeyValueCache class methodsFor: 'instance creation'!maxSize: anInteger	^ self implementationNew setMaxSize: anInteger! !!XMLKeyValueCache class methodsFor: 'instance creation'!new	^ self maxSize: self defaultMaxSize! !!XMLKeyValueCache class methodsFor: 'finding'!noSupportedImplementationFound	Error signal: 'No supported key-value cache class available'! !!XMLKeyValueCache class methodsFor: 'defaults'!preferredImplementation	^ XMLStandardKeyValueCache! !!XMLKeyValueCache methodsFor: 'accessing'!at: aKey	^ self		at: aKey		ifAbsent: [nil]! !!XMLKeyValueCache methodsFor: 'accessing'!at: aKey ifAbsent: aBlock	^ self critical: [		self collection			at: aKey			ifAbsent: aBlock]! !!XMLKeyValueCache methodsFor: 'accessing'!at: aKey ifAbsentPut: aBlock	^ self		at: aKey		ifAbsent: [			self				at: aKey				put: aBlock value]! !!XMLKeyValueCache methodsFor: 'accessing'!at: aKey ifPresent: aBlock	^ self critical: [		"Gemstone's at:ifAbsentPut: does not use cull:"		aBlock cull:			(self collection				at: aKey				ifAbsent: [^ nil])]! !!XMLKeyValueCache methodsFor: 'accessing'!at: aKey ifPresent: aPresentBlock put: aValueBlock	"Looks up the value of aKey and if present, evaluates aPresentBlock	optionally with it, and if aPresentBlock returns true, replaces the old	value with the result of evaluating aValueBlock."	^ self		at: aKey		ifPresent: [:value |			(aPresentBlock cull: value)				ifTrue: [						self						at: aKey						put: aValueBlock value]				ifFalse: [value]]! !!XMLKeyValueCache methodsFor: 'accessing'!at: aKey put: aValue	^ self critical: [		(self collection includesKey: aKey)			ifFalse: [				self collection size >= self maxSize					ifTrue: [self collection removeAll]].		self collection			at: aKey			put: aValue]! !!XMLKeyValueCache methodsFor: 'accessing'!capacity	^ self maxSize! !!XMLKeyValueCache methodsFor: 'clearing'!clear	self removeAll! !!XMLKeyValueCache methodsFor: 'accessing'!collection	self subclassResponsibility! !!XMLKeyValueCache methodsFor: 'defaults'!collectionClass	^ Dictionary! !!XMLKeyValueCache methodsFor: 'copying'!copy	^ self critical: [self shallowCopy postCopy]! !!XMLKeyValueCache methodsFor: 'mutual exclusion'!critical: aBlock	"Can be used to lock the cache during one or more operations in aBlock"	^ self mutex critical: aBlock! !!XMLKeyValueCache methodsFor: 'testing'!includesKey: aKey	^ self critical: [self collection includesKey: aKey]! !!XMLKeyValueCache methodsFor: 'testing'!isEmpty	^ self size = 0! !!XMLKeyValueCache methodsFor: 'accessing'!keys	^ self critical: [self collection keys]! !!XMLKeyValueCache methodsFor: 'enumerating'!keysAndValuesDo: aTwoArgumentBlock	self critical: [self collection keysAndValuesDo: aTwoArgumentBlock]! !!XMLKeyValueCache methodsFor: 'enumerating'!keysDo: aBlock	self critical: [self collection keysDo: aBlock]! !!XMLKeyValueCache methodsFor: 'accessing'!loadFactor	^ (self size / self maxSize) asFraction! !!XMLKeyValueCache methodsFor: 'accessing'!maxSize	^ maxSize! !!XMLKeyValueCache methodsFor: 'accessing'!maxSize: anInteger	self critical: [| oldMaxSize |		oldMaxSize := maxSize.		(maxSize := anInteger) < oldMaxSize			ifTrue: [self collection removeAll]]! !!XMLKeyValueCache methodsFor: 'private'!mutex	^ mutex! !!XMLKeyValueCache methodsFor: 'testing'!notEmpty	^ self size > 0! !!XMLKeyValueCache methodsFor: 'copying'!postCopy	super postCopy.	mutex := XMLReentrantMutex new.	self setCollection: self collection copy.! !!XMLKeyValueCache methodsFor: 'printing'!printOn: aStream	| loadFactor |	super printOn: aStream.	loadFactor := self loadFactor.	aStream		nextPut: $(;		print: loadFactor numerator;		nextPut: $/;		print: loadFactor denominator;		nextPut: $).! !!XMLKeyValueCache methodsFor: 'removing'!removeAll	self critical: [self collection removeAll]! !!XMLKeyValueCache methodsFor: 'removing'!removeKey: aKey	"this attempts to remove a key, but to support concurrent removal, it	does not raise errors if it was already removed"	^ self critical: [		self collection			removeKey: aKey			ifAbsent: [nil]]! !!XMLKeyValueCache methodsFor: 'removing'!removeKey: aKey ifAbsent: aBlock	^ self critical: [		self collection			removeKey: aKey			ifAbsent: aBlock]! !!XMLKeyValueCache methodsFor: 'removing'!removeKey: aKey ifPresent: aBlock	"Looks up the value of aKey and if present, evaluates aPresentBlock	optionally with it, and if aPresentBlock returns true, removes the	key from the cache and returns its old value."	^ self		at: aKey		ifPresent: [:value |			(aBlock cull: value)				ifTrue: [self removeKey: aKey]				ifFalse: [value]]! !!XMLKeyValueCache methodsFor: 'initialization'!setCollection: aKeyValueCollection	self subclassResponsibility! !!XMLKeyValueCache methodsFor: 'initialization'!setMaxSize: anInteger	maxSize := anInteger.	mutex := XMLReentrantMutex new.	self setCollection: self collectionClass new.! !!XMLKeyValueCache methodsFor: 'accessing'!size	^ self collection size! !!XMLKeyValueCache methodsFor: 'accessing'!values	^ self critical: [self collection values]! !!XMLKeyValueCache methodsFor: 'enumerating'!valuesDo: aBlock	self critical: [self collection valuesDo: aBlock]! !!XMLStandardKeyValueCache class methodsFor: 'testing'!isSupportedImplementation	"need some type of reentrant mutex"	XMLReentrantMutex hasSupportedImplementation		ifFalse: [^ false].	"MUST use the transient class on GS to avoid persisting and causing	write conflicts"	XMLClassFinder		classNamed: #XMLTransientKeyValueCache		ifPresent: [:transientKeyValueCacheClass |			transientKeyValueCacheClass isSupportedImplementation				ifTrue: [^ false]].	^ true.! !!XMLStandardKeyValueCache methodsFor: 'accessing'!collection	^ collection! !!XMLStandardKeyValueCache methodsFor: 'initialization'!setCollection: aKeyValueCollection	collection := aKeyValueCollection! !!XMLReentrantMutex class methodsFor: 'testing'!canBeImplemented	^ true! !!XMLReentrantMutex class methodsFor: 'finding'!noSupportedImplementationFound	Error signal: 'No supported reentrant mutex class available'! !!XMLReentrantMutex class methodsFor: 'defaults'!preferredImplementation	"Prefer the Pharo/Squeak Mutex-based implementation"	^ XMLStandardReentrantMutex! !!XMLReentrantMutex methodsFor: 'mutual exclusion'!critical: aBlock	self subclassResponsibility! !!XMLStandardReentrantMutex class methodsFor: 'testing'!isSupportedImplementation	(XMLClassFinder hasClassNamed: #Mutex)		ifFalse: [^ false].	"MUST use the transient class on GS to avoid persisting and causing	write conflicts"	XMLClassFinder		classNamed: #XMLTransientReentrantMutex		ifPresent: [:transientReentrantMutexClass |			transientReentrantMutexClass isSupportedImplementation				ifTrue: [^ false]].	^ true.! !!XMLStandardReentrantMutex methodsFor: 'mutual exclusion'!critical: aBlock	^ mutex critical: aBlock! !!XMLStandardReentrantMutex methodsFor: 'initialization'!initialize	super initialize.	mutex := (XMLClassFinder classNamed: #Mutex) new.! !!XMLAbstractReadStream class methodsFor: 'basic'!basicOn: anObject	^ self basicNew initialize on: anObject! !!XMLAbstractReadStream class methodsFor: 'instance creation'!new	self shouldNotImplement! !!XMLAbstractReadStream class methodsFor: 'instance creation'!on: anObject	^ self basicOn: anObject! !!XMLAbstractReadStream methodsFor: 'testing'!atEnd	self subclassResponsibility! !!XMLAbstractReadStream methodsFor: 'closing'!close! !!XMLAbstractReadStream methodsFor: 'accessing'!contents	self subclassResponsibility! !!XMLAbstractReadStream methodsFor: 'testing'!isBinary	^ false! !!XMLAbstractReadStream methodsFor: 'testing'!isStream	^ true! !!XMLAbstractReadStream methodsFor: 'testing'!isXMLBinaryOrExternalStream	^ self isBinary! !!XMLAbstractReadStream methodsFor: 'instance creation'!newWriteStream	^ (self writeStreamCollectionClass new: 128) writeStream! !!XMLAbstractReadStream methodsFor: 'accessing'!next	self subclassResponsibility! !!XMLAbstractReadStream methodsFor: 'accessing'!next: anInteger	| writeStream i |	writeStream := self newWriteStream.	i := 0.	[self atEnd		or: [i >= anInteger]]		whileFalse: [			writeStream nextPut: self next.			i := i + 1].	^ writeStream contents.! !!XMLAbstractReadStream methodsFor: 'initialization'!on: anObject	self subclassResponsibility! !!XMLAbstractReadStream methodsFor: 'accessing'!peek	self subclassResponsibility! !!XMLAbstractReadStream methodsFor: 'accessing'!peekFor: anObject	(self atEnd not		and: [self peek = anObject])		ifTrue: [			self next.			^ true]		ifFalse: [^ false]! !!XMLAbstractReadStream methodsFor: 'positioning'!position	self subclassResponsibility! !!XMLAbstractReadStream methodsFor: 'positioning'!position: anInteger	self subclassResponsibility! !!XMLAbstractReadStream methodsFor: 'positioning'!reset	self subclassResponsibility! !!XMLAbstractReadStream methodsFor: 'positioning'!skip: anInteger	"only supports skipping forwards"	1 to: anInteger do: [:i |		self atEnd			ifTrue: [^ self].		self next]! !!XMLAbstractReadStream methodsFor: 'positioning'!skipSeparators	"we use #isXMLWhitespace instead of the narrower, XML-specific	#isXMLSeparator, because this class can be used for non-XML	streams too"	[self atEnd not		and: [self peek isXMLWhitespace]]		whileTrue: [self next]! !!XMLAbstractReadStream methodsFor: 'positioning'!skipTo: anObject	[self atEnd]		whileFalse: [			self next = anObject				ifTrue: [^ true]].	^ false.! !!XMLAbstractReadStream methodsFor: 'accessing'!upTo: anObject	| writeStream next |	writeStream := self newWriteStream.	[self atEnd		or: [(next := self next) = anObject]]		whileFalse: [writeStream nextPut: next].	^ writeStream contents.! !!XMLAbstractReadStream methodsFor: 'accessing'!upToEnd	| writeStream |	writeStream := self newWriteStream.	[self atEnd]		whileFalse: [writeStream nextPut: self next].	^ writeStream contents.! !!XMLAbstractReadStream methodsFor: 'writing'!writeStreamCollectionClass	self isBinary		ifTrue: [^ ByteArray]		ifFalse: [^ String]! !!XMLNullReadStream class methodsFor: 'class initialization'!initialize	"self initialize"	instance := self basicOn: nil! !!XMLNullReadStream class methodsFor: 'instance creation'!new	^ instance! !!XMLNullReadStream class methodsFor: 'instance creation'!on: anObject	^ instance! !!XMLNullReadStream methodsFor: 'testing'!atEnd	^ true! !!XMLNullReadStream methodsFor: 'accessing'!contents	^ String new! !!XMLNullReadStream methodsFor: 'accessing'!next	^ nil! !!XMLNullReadStream methodsFor: 'initialization'!on: anObject! !!XMLNullReadStream methodsFor: 'accessing'!peek	^ nil! !!XMLNullReadStream methodsFor: 'positioning'!position	^ 0! !!XMLNullReadStream methodsFor: 'positioning'!position: anInteger! !!XMLNullReadStream methodsFor: 'positioning'!reset! !!XMLSingleCharacterReadStream methodsFor: 'testing'!atEnd	^ atEnd! !!XMLSingleCharacterReadStream methodsFor: 'closing'!close	atEnd := true! !!XMLSingleCharacterReadStream methodsFor: 'accessing'!contents	^ String with: character! !!XMLSingleCharacterReadStream methodsFor: 'accessing'!next	atEnd		ifTrue: [^ nil]		ifFalse: [			atEnd := true.			^ character]! !!XMLSingleCharacterReadStream methodsFor: 'initialization'!on: aCharacter	character := aCharacter.	atEnd := false.! !!XMLSingleCharacterReadStream methodsFor: 'accessing'!peek	atEnd		ifTrue: [^ nil]		ifFalse: [^ character]! !!XMLSingleCharacterReadStream methodsFor: 'positioning'!position	^ atEnd		ifTrue: [1]		ifFalse: [0]! !!XMLSingleCharacterReadStream methodsFor: 'positioning'!position: anInteger	atEnd := anInteger > 0! !!XMLSingleCharacterReadStream methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		print: character;		nextPut: $).! !!XMLSingleCharacterReadStream methodsFor: 'positioning'!reset	atEnd := false! !!XMLAbstractReadStreamParser class methodsFor: 'instance creation'!new	self shouldNotImplement! !!XMLAbstractReadStreamParser class methodsFor: 'instance creation'!on: aStringOrStream	^ self basicNew initialize on: aStringOrStream! !!XMLAbstractReadStreamParser methodsFor: 'tokenizing'!nextDelimitedBy: aCharacter	writeStream reset.	[readStream atEnd		or: [readStream peek = aCharacter]]		whileFalse: [writeStream nextPut: readStream next].	^ writeStream contents.! !!XMLAbstractReadStreamParser methodsFor: 'tokenizing'!nextDelimitedByAny: aCharacterCollection	writeStream reset.	[readStream atEnd		or: [aCharacterCollection includes: readStream peek]]		whileFalse: [writeStream nextPut: readStream next].	^ writeStream contents.! !!XMLAbstractReadStreamParser methodsFor: 'initialization'!on: aStringOrStream	readStream :=		XMLReadStreamAdapter on:			(aStringOrStream isStream				ifTrue: [aStringOrStream]				ifFalse: [aStringOrStream readStream]).	writeStream := (String new: 64) writeStream.! !!XMLHTTPMIMETypeParser class methodsFor: 'class initialization'!initialize	"self initialize"	self initializeTokenDelimiters! !!XMLHTTPMIMETypeParser class methodsFor: 'class initialization'!initializeTokenDelimiters	"String streamContents: [:writeStream | | readStream current previous |		readStream := self tspecialsTemplate readStream.		[readStream atEnd]			whileFalse: [				previous := current.				current := readStream next.				(#('""' '<>') anySatisfy: [:each |					previous = each first						and: [readStream peek = each last]])					ifTrue: [writeStream nextPut: current]]]"	TokenDelimiters :=		BitmapCharacterSet newFrom: '()<>@,;:\"/[]?.=', Character xmlWhitespace! !!XMLHTTPMIMETypeParser class methodsFor: 'private'!tspecialsTemplate	^ '	tspecials :=  "(" / ")" / "<" / ">" / "@"  ; Must be in                       /  "," / ";" / ":" / "\" / <">  ; quoted-string,                       /  "/" / "[" / "]" / "?" / "."  ; to use within                       /  "="                        ; parameter values'! !!XMLHTTPMIMETypeParser methodsFor: 'private'!nextOptionalQuotedString	| isEscaping nextChar |	(readStream		skipSeparators;		peekFor: $")		ifFalse: [^ nil].	writeStream		reset;		nextPut: $".	isEscaping := false.	[(nextChar := readStream next) isNil		or: [isEscaping not			and: [nextChar == $"]]]		whileFalse: [			isEscaping :=				isEscaping not					and: [nextChar == $\].			writeStream nextPut: nextChar].	^ writeStream		nextPut: $";		contents.! !!XMLHTTPMIMETypeParser methodsFor: 'private'!nextToken	readStream skipSeparators.	^ self nextDelimitedByAny: TokenDelimiters.! !!XMLHTTPMIMETypeParser methodsFor: 'private'!nextTokenOrQuotedString	^ self nextOptionalQuotedString		ifNil: [self nextToken]! !!XMLHTTPMIMETypeParser methodsFor: 'parsing'!parseMainType	"main types are case insensitive and are converted to	lowercase for consistentcy"	^ self nextToken asLowercase! !!XMLHTTPMIMETypeParser methodsFor: 'parsing'!parseParameters	| parameters attributes totalAttributes |	parameters := OrderedCollection new.	totalAttributes := 0.	[(readStream		skipSeparators;		peekFor: $;)			and: [				(readStream					skipSeparators;					atEnd) not]]		whileTrue: [| attribute value hasValue |			"attributes are case insensitive and are converted			to lowercase for convenience"			attribute := self nextToken asLowercase.			(hasValue :=				readStream					skipSeparators;					peekFor: $=)				ifTrue: [value := self nextTokenOrQuotedString]				ifFalse: [value := ''].			(attribute notEmpty				or: [hasValue])				ifTrue: [					"only initialize if needed"					((attributes ifNil: [attributes := Set new])						add: attribute;						size) > totalAttributes						ifTrue: [							parameters addLast: attribute -> value.							totalAttributes := totalAttributes + 1]]].	^ parameters.! !!XMLHTTPMIMETypeParser methodsFor: 'parsing'!parseSubType	"sub types are case insensitive and are converted to	lowercase for consistentcy"	readStream		skipSeparators;		peekFor: $/.	^ self nextToken asLowercase.! !!XMLURIParser class methodsFor: 'class initialization'!initialize	"self initialize"	self		initializeSchemeDelimiters;		initializeUserInfoDelimiters;		initializeHostDelimiters;		initializePathDelimiters;		initializeQueryKeyDelimiters;		initializeQueryValueDelimiters! !!XMLURIParser class methodsFor: 'class initialization'!initializeHostDelimiters	HostDelimiters := BitmapCharacterSet newFrom: ':/?#'! !!XMLURIParser class methodsFor: 'class initialization'!initializePathDelimiters	PathDelimiters := BitmapCharacterSet newFrom: '/?#'! !!XMLURIParser class methodsFor: 'class initialization'!initializeQueryKeyDelimiters	QueryKeyDelimiters := BitmapCharacterSet newFrom: '=&#'! !!XMLURIParser class methodsFor: 'class initialization'!initializeQueryValueDelimiters	QueryValueDelimiters := BitmapCharacterSet newFrom: '&#'! !!XMLURIParser class methodsFor: 'class initialization'!initializeSchemeDelimiters	"including % disallows percent encoding in schemes"	SchemeDelimiters := BitmapCharacterSet newFrom: ':@/?#%'! !!XMLURIParser class methodsFor: 'class initialization'!initializeUserInfoDelimiters	UserInfoDelimiters := BitmapCharacterSet newFrom: '@/?#'! !!XMLURIParser methodsFor: 'parsing'!parseAuthorityPrefix	| oldPosition |	oldPosition := readStream position.	((readStream peekFor: $/)		and: [readStream peekFor: $/])		ifTrue: [^ true]		ifFalse: [			readStream position: oldPosition.			^ false].! !!XMLURIParser methodsFor: 'parsing'!parseFragment	(readStream peekFor: $#)		ifTrue: [^ readStream upToEnd]		ifFalse: [^ '']! !!XMLURIParser methodsFor: 'parsing'!parseHost	| host |	readStream peek == $[		ifTrue: [			host := (self nextDelimitedBy: $]) copyWith: $].			readStream peekFor: $]]		ifFalse: [host := self nextDelimitedByAny: HostDelimiters].	^ host.! !!XMLURIParser methodsFor: 'parsing'!parsePathSegments	| pathSegments segment |	pathSegments := OrderedCollection new.	segment := self nextDelimitedByAny: PathDelimiters.	[readStream peekFor: $/]		whileTrue: [			pathSegments addLast: segment.			segment := self nextDelimitedByAny: PathDelimiters].	(pathSegments isEmpty		and: [segment isEmpty])		ifFalse: [pathSegments addLast: segment].	^ pathSegments.! !!XMLURIParser methodsFor: 'parsing'!parsePort	| port |	(readStream peekFor: $:)		ifTrue: [			"do not limit the number of chars read, because port			number literals can have an arbitrary number of			leading zeros"			port :=				XMLSmallIntegerReader					readFrom: readStream					withBase: 10.			[readStream atEnd				or: [PathDelimiters includes: readStream peek]]				whileFalse: [readStream next]].	^ port.! !!XMLURIParser methodsFor: 'parsing'!parseQuery	"parse the query as an OrderedCollection of name=value associations	to handle multiple values for the same key and different encoded keys	that later percent/plus decode to the same key"	| query key value |	(readStream peekFor: $?)		ifFalse: [^ OrderedCollection new: 0].	query := OrderedCollection new.	[readStream atEnd		or: [(key := self nextDelimitedByAny: QueryKeyDelimiters) isEmpty			and: [readStream peek == $#]]]		whileFalse: [| hasValue |			(hasValue := readStream peekFor: $=)				ifTrue: [value := self nextDelimitedByAny: QueryValueDelimiters]				ifFalse: [value := ''].			(key notEmpty				or: [hasValue])				ifTrue: [query addLast: key -> value].			readStream peekFor: $&].	^ query.! !!XMLURIParser methodsFor: 'parsing'!parseScheme	| oldPosition scheme |	oldPosition := readStream position.	scheme := self nextDelimitedByAny: SchemeDelimiters.	(readStream peekFor: $:)		ifTrue: [^ scheme asLowercase]		ifFalse: [			readStream position: oldPosition.			^ ''].! !!XMLURIParser methodsFor: 'parsing'!parseUserInfo	| userInfo oldPosition |	oldPosition := readStream position.	userInfo := self nextDelimitedByAny: UserInfoDelimiters.	(readStream peekFor: $@)		ifTrue: [^ userInfo]		ifFalse: [			readStream position: oldPosition.			^ ''].! !!XMLAttributeDefaultValidator class methodsFor: 'instance creation'!attribute: anAttribute	^ self		attribute: anAttribute		value: ''! !!XMLAttributeDefaultValidator class methodsFor: 'instance creation'!attribute: anAttribute value: aDefaultValue	^ self new		setAttribute: anAttribute		value: aDefaultValue! !!XMLAttributeDefaultValidator class methodsFor: 'defaults'!standaloneExternalClass	^ self! !!XMLAttributeDefaultValidator methodsFor: 'accessing'!attribute	^ attribute! !!XMLAttributeDefaultValidator methodsFor: 'testing'!isFixedValue	^ false! !!XMLAttributeDefaultValidator methodsFor: 'testing'!isImplied	^ false! !!XMLAttributeDefaultValidator methodsFor: 'testing'!isRequired	^ false! !!XMLAttributeDefaultValidator methodsFor: 'testing'!isValue	^ false! !!XMLAttributeDefaultValidator methodsFor: 'printing'!printNameAndValueOn: aStream	aStream		nextPutAll: self attribute;		nextPutAll: '="';		nextPutAll: self value;		nextPut: $"! !!XMLAttributeDefaultValidator methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self printNameAndValueOn: aStream.	aStream nextPut: $).! !!XMLAttributeDefaultValidator methodsFor: 'processing'!processedDefaultForAbsentAttributeValue	^ nil! !!XMLAttributeDefaultValidator methodsFor: 'processing'!processedDefaultForPresentAttributeValue: anAttributeValue	^ anAttributeValue! !!XMLAttributeDefaultValidator methodsFor: 'initialization'!setAttribute: anAttribute value: aDefaultValue	attribute := anAttribute! !!XMLAttributeDefaultValidator methodsFor: 'validating'!validatedDefaultForAbsentAttributeValue	^ nil! !!XMLAttributeDefaultValidator methodsFor: 'validating'!validatedDefaultForPresentAttributeValue: anAttributeValue	^ anAttributeValue! !!XMLAttributeDefaultValidator methodsFor: 'accessing'!value	^ ''! !!XMLAttributeImpliedDefaultValidator methodsFor: 'testing'!isImplied	^ true! !!XMLAttributeRequiredDefaultValidator methodsFor: 'private'!errorRequiredAttributeMissing	XMLValidationException		formatSignal: 'Required attribute "{1}" is missing'		with: self attribute! !!XMLAttributeRequiredDefaultValidator methodsFor: 'testing'!isRequired	^ true! !!XMLAttributeRequiredDefaultValidator methodsFor: 'validating'!validatedDefaultForAbsentAttributeValue	self errorRequiredAttributeMissing! !!XMLAttributeFixedValueDefaultValidator class methodsFor: 'defaults'!standaloneExternalClass	^ XMLStandaloneExternalAttributeFixedValueDefaultValidator! !!XMLAttributeFixedValueDefaultValidator methodsFor: 'private'!errorFixedAttributeValueCannotChange	XMLValidationException		formatSignal: 'Fixed attribute "{1}" can only have "{2}" as its value'		with: self attribute		with: self value! !!XMLAttributeFixedValueDefaultValidator methodsFor: 'testing'!isFixedValue	^ true! !!XMLAttributeFixedValueDefaultValidator methodsFor: 'processing'!processedDefaultForPresentAttributeValue: anAttributeValue	^ self value! !!XMLAttributeFixedValueDefaultValidator methodsFor: 'validating'!validatedDefaultForPresentAttributeValue: anAttributeValue	anAttributeValue = self value		ifFalse: [self errorFixedAttributeValueCannotChange].	^ anAttributeValue.! !!XMLStandaloneExternalAttributeFixedValueDefaultValidator methodsFor: 'private'!errorStandaloneExternalAttributeDefaultFixedValueUsed	XMLValidationException		formatSignal:			'Externally defined attribute "{1}" fixed default value ',			'cannot be used by elements when standalone="yes"'		with: self attribute! !!XMLStandaloneExternalAttributeFixedValueDefaultValidator methodsFor: 'validating'!validatedDefaultForAbsentAttributeValue	self errorStandaloneExternalAttributeDefaultFixedValueUsed! !!XMLAttributeValueDefaultValidator class methodsFor: 'defaults'!standaloneExternalClass	^ XMLStandaloneExternalAttributeValueDefaultValidator! !!XMLAttributeValueDefaultValidator methodsFor: 'testing'!isValue	^ true! !!XMLAttributeValueDefaultValidator methodsFor: 'processing'!processedDefaultForAbsentAttributeValue	^ self value! !!XMLAttributeValueDefaultValidator methodsFor: 'initialization'!setAttribute: anAttribute value: aDefaultValue	attribute := anAttribute.	value := aDefaultValue.! !!XMLAttributeValueDefaultValidator methodsFor: 'validating'!validatedDefaultForAbsentAttributeValue	^ self value! !!XMLAttributeValueDefaultValidator methodsFor: 'accessing'!value	^ value! !!XMLAttributeValueDefaultValidator methodsFor: 'accessing'!value: aDefaultValue	value := aDefaultValue! !!XMLStandaloneExternalAttributeValueDefaultValidator methodsFor: 'private'!errorStandaloneExternalAttributeDefaultValueUsed	XMLValidationException		formatSignal:			'Externally defined attribute "{1}" default value ',			'cannot be used by elements when standalone="yes"'		with: self attribute! !!XMLStandaloneExternalAttributeValueDefaultValidator methodsFor: 'validating'!validatedDefaultForAbsentAttributeValue	self errorStandaloneExternalAttributeDefaultValueUsed! !!XMLAttributeSpec methodsFor: 'converting'!asXMLAttributeSpec	^ self! !!XMLAttributeSpec methodsFor: 'matching'!matchesAttributes: anAttributeDictionary	self subclassResponsibility! !!XMLBasicAttributeSpec class methodsFor: 'instance creation'!attributes: aDictionaryOrCollectionOfAssociationsAndStrings	^ self new setAttributes: aDictionaryOrCollectionOfAssociationsAndStrings! !!XMLBasicAttributeSpec methodsFor: 'adding'!addAttribute: anAttribute	^ attributeSpec		at: anAttribute		ifAbsentPut: [nil]! !!XMLBasicAttributeSpec methodsFor: 'adding'!addAttributeAssociation: anAssociation	^ self		addAttributeName: anAssociation key		value: anAssociation value! !!XMLBasicAttributeSpec methodsFor: 'adding'!addAttributeName: aName value: aValue	^ attributeSpec		at: aName		put: aValue! !!XMLBasicAttributeSpec methodsFor: 'initialization'!initialize	super initialize.	attributeSpec := Dictionary new.! !!XMLBasicAttributeSpec methodsFor: 'matching'!matchesAttributes: anAttributeDictionary	attributeSpec keysAndValuesDo: [:specName :specValue |		specValue			ifNil: [				"nil values mean the attribute has to be present and can have				any value"				(anAttributeDictionary includesKey: specName)					ifFalse: [^ false]]			ifNotNil: [				(specValue isBlock					ifTrue: [						specValue value:							(anAttributeDictionary								at: specName								ifAbsent: [^ false])]					ifFalse: [						specValue =							(anAttributeDictionary								at: specName								ifAbsent: [^ false])])							ifFalse: [^ false]]].	^ true.! !!XMLBasicAttributeSpec methodsFor: 'initialization'!setAttributes: aDictionaryOrCollectionOfAssociationsAndStrings	attributeSpec removeAll.	"associationsDo: works for dictionaries and non-dictionaries, including	arrays, to support specs like {'one'. 'two'->'three'}"	aDictionaryOrCollectionOfAssociationsAndStrings associationsDo: [:each |		each isString			ifTrue: [self addAttribute: each]			ifFalse: [self addAttributeAssociation: each]].! !!XMLPluggableAttributeSpec class methodsFor: 'generated'!block: aOneArgumentBlock	^ self new block: aOneArgumentBlock! !!XMLPluggableAttributeSpec methodsFor: 'accessing'!block	^ block! !!XMLPluggableAttributeSpec methodsFor: 'accessing'!block: aOneArgumentBlock	block := aOneArgumentBlock! !!XMLPluggableAttributeSpec methodsFor: 'matching'!matchesAttributes: anAttributeDictionary	"if there's no block, then it automatically matches, similar to an	XMLBasicAttributeSpec with no attributes"	block		ifNil: [^ true]		ifNotNil: [^ block value: anAttributeDictionary]! !!XMLAttributeValidator class methodsFor: 'instance creation'!element: anElement attribute: anAttribute defaultValidator: aDefaultValidator	^ self new		setElement: anElement		attribute: anAttribute		defaultValidator: aDefaultValidator! !!XMLAttributeValidator class methodsFor: 'class initialization'!initialize	"self initialize"	"stored in a class var for faster access"	NormalizedSpace := Character space! !!XMLAttributeValidator class methodsFor: 'defaults'!standaloneExternalClass	^ self! !!XMLAttributeValidator methodsFor: 'accessing'!attribute	^ attribute! !!XMLAttributeValidator methodsFor: 'accessing'!defaultValidator	^ defaultValidator! !!XMLAttributeValidator methodsFor: 'accessing'!element	^ element! !!XMLAttributeValidator methodsFor: 'private'!errorInvalidDefaultAttributeValue: aDefaultValue	XMLValidationException		formatSignal:			'Invalid default value "{1}" in declaration for ',			'attribute "{2}" of element <3>'		with: aDefaultValue		with: self attribute		with: self element! !!XMLAttributeValidator methodsFor: 'private'!errorInvalidXMLIDAttributeDeclaration	XMLValidationException signal:		'All "xml:id" attributes must be declared to be of ID type'! !!XMLAttributeValidator methodsFor: 'private'!errorInvalidXMLSpaceAttributeDeclaration	XMLValidationException		formatSignal:			'Attribute "xml:space" of element <{1}> must be declared as ',			'an enumeration type with "default" and/or "preserve" values'		with: self element! !!XMLAttributeValidator methodsFor: 'private'!errorNormalizedStandaloneExternalAttribute	XMLValidationException		formatSignal:			'Externally defined attribute "{1}" of element <{2}> required ',			'further value normalizaiton in standalone="yes" document'		with: self attribute		with: self element! !!XMLAttributeValidator methodsFor: 'private'!furtherNormalizeAttributeValue: aSemiNormalizedAttributeValue	"The tokenizer normalizes all non-char escaped whitespace in attribute	values to spaces (0x20). This further normalizes them by removing leading	and trailing spaces and turing multiple spaces to single spaces."	| writeStream isInWhitespace |	aSemiNormalizedAttributeValue size > 0 "optimization"		ifFalse: [^ aSemiNormalizedAttributeValue].	"must use #writeStream instead of 'WriteStream on:' to get a 0-based stream	on Gemstone"	writeStream := (String new: aSemiNormalizedAttributeValue size) writeStream.	isInWhitespace := false.	"use #to:do: for speed"	1 to: aSemiNormalizedAttributeValue size do: [:i | | nextChar |		(nextChar := aSemiNormalizedAttributeValue at: i) == NormalizedSpace			ifTrue: [				isInWhitespace					ifFalse: [isInWhitespace := true]]			ifFalse: [				isInWhitespace					ifTrue: [						writeStream position > 0							ifTrue: [writeStream nextPut: NormalizedSpace].						isInWhitespace := false].				writeStream nextPut: nextChar]].	^ writeStream contents.! !!XMLAttributeValidator methodsFor: 'initialization'!initializeWithValidatorsFrom: aValidatorContainer	(self mustFurtherNormalizeAttributeValue		and: [self defaultValidator isValue])		ifTrue: [			self defaultValidator value:				(self furtherNormalizeAttributeValue:					self defaultValidator value)]! !!XMLAttributeValidator methodsFor: 'testing'!isCData	^ false! !!XMLAttributeValidator methodsFor: 'testing'!isEntities	^ false! !!XMLAttributeValidator methodsFor: 'testing'!isEntity	^ false! !!XMLAttributeValidator methodsFor: 'testing'!isEnumeration	^ false! !!XMLAttributeValidator methodsFor: 'testing'!isID	^ false! !!XMLAttributeValidator methodsFor: 'testing'!isIDRef	^ false! !!XMLAttributeValidator methodsFor: 'testing'!isIDRefs	^ false! !!XMLAttributeValidator methodsFor: 'testing'!isNmtoken	^ false! !!XMLAttributeValidator methodsFor: 'testing'!isNmtokens	^ false! !!XMLAttributeValidator methodsFor: 'testing'!isNotationEnumeration	^ false! !!XMLAttributeValidator methodsFor: 'testing'!isStandaloneExternal	"this is overridden in each standalone external subclass to return	true instead of just returning a boolean inst var to save memory"	^ false! !!XMLAttributeValidator methodsFor: 'testing'!isXMLID	^ false! !!XMLAttributeValidator methodsFor: 'testing'!mustFurtherNormalizeAttributeValue	^ true! !!XMLAttributeValidator methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: '(<';		nextPutAll: self element;		space.	self defaultValidator printNameAndValueOn: aStream.	aStream nextPutAll: '>)'.! !!XMLAttributeValidator methodsFor: 'processing'!processAttributes: aDictionary	| attributeAssociation normalizedValue |	attributeAssociation :=		aDictionary			associationAt: self attribute			ifAbsent: [				self defaultValidator processedDefaultForAbsentAttributeValue					ifNotNil: [:defaultValue |						aDictionary							at: self attribute							put: defaultValue].				^ self].	self mustFurtherNormalizeAttributeValue		ifTrue: [			normalizedValue :=				self furtherNormalizeAttributeValue:					attributeAssociation value]		ifFalse: [normalizedValue := attributeAssociation value].	attributeAssociation value:		(self defaultValidator processedDefaultForPresentAttributeValue:			normalizedValue).! !!XMLAttributeValidator methodsFor: 'initialization'!setElement: anElement attribute: anAttribute defaultValidator: aDefaultValidator	element := anElement.	attribute := anAttribute.	defaultValidator := aDefaultValidator.! !!XMLAttributeValidator methodsFor: 'private'!spaceSeparatedListValuesIn: aSpaceSeparatedList do: aBlock	NormalizedSpace		xmlSplit: aSpaceSeparatedList		do: aBlock! !!XMLAttributeValidator methodsFor: 'validating'!validateAttributeDeclaration	(self attribute at: 1) == $x "optimization"		ifTrue: [			(self attribute = 'xml:id')				ifTrue: [^ self validateXMLIDAttributeDeclaration].			(self attribute = 'xml:space')				ifTrue: [^ self validateXMLSpaceAttributeDeclaration]].	self defaultValidator isValue		ifTrue: [				self validateAttributeDefaultValue:				self defaultValidator value].! !!XMLAttributeValidator methodsFor: 'validating'!validateAttributeDefaultValue: aDefaultValue	"This is overridden in subclasses to check default values when validating	the declaration, but CDATA types should not be validated, and ID types	cannot have default values at all"! !!XMLAttributeValidator methodsFor: 'validating'!validateAttributeValue: aValue	"This is overridden in subclasses to check attribute values"! !!XMLAttributeValidator methodsFor: 'validating'!validateAttributes: aDictionary	| attributeAssociation wasAbsent |	wasAbsent := false.	attributeAssociation :=		aDictionary			associationAt: self attribute			ifAbsent: [				wasAbsent := true.				self defaultValidator validatedDefaultForAbsentAttributeValue					ifNil: [^ self]					ifNotNil: [:defaultValue |						aDictionary add: self attribute -> defaultValue]].	wasAbsent		ifFalse: [| normalizedValue |			self mustFurtherNormalizeAttributeValue				ifTrue: [					normalizedValue :=						self furtherNormalizeAttributeValue:							attributeAssociation value.					self isStandaloneExternal						ifTrue: [							"since further normalization just condences multiple spaces							to single spaces and removes trailing and leading spaces,							comparing the sizes after is enough to detect if it was							done"							normalizedValue size = attributeAssociation value size								ifFalse: [									self errorNormalizedStandaloneExternalAttribute]]]				ifFalse: [normalizedValue := attributeAssociation value].			attributeAssociation value:				(self defaultValidator validatedDefaultForPresentAttributeValue:					normalizedValue)].	self validateAttributeValue: attributeAssociation value.! !!XMLAttributeValidator methodsFor: 'validating'!validateXMLIDAttributeDeclaration	self errorInvalidXMLIDAttributeDeclaration! !!XMLAttributeValidator methodsFor: 'validating'!validateXMLSpaceAttributeDeclaration	self errorInvalidXMLSpaceAttributeDeclaration! !!XMLCDataAttributeValidator class methodsFor: 'defaults'!standaloneExternalClass	^ XMLStandaloneExternalCDataAttributeValidator! !!XMLCDataAttributeValidator methodsFor: 'testing'!isCData	^ true! !!XMLCDataAttributeValidator methodsFor: 'testing'!mustFurtherNormalizeAttributeValue	^ false! !!XMLStandaloneExternalCDataAttributeValidator methodsFor: 'testing'!isStandaloneExternal	^ true! !!XMLEntitiesAttributeValidator class methodsFor: 'defaults'!standaloneExternalClass	^ XMLStandaloneExternalEntitiesAttributeValidator! !!XMLEntitiesAttributeValidator methodsFor: 'testing'!isEntities	^ true! !!XMLEntitiesAttributeValidator methodsFor: 'validating'!validateAttributeDefaultValue: aDefaultValue	self		spaceSeparatedListValuesIn: aDefaultValue		do: [:each |			each isXMLName				ifFalse: [self errorInvalidDefaultAttributeValue: aDefaultValue]]! !!XMLEntitiesAttributeValidator methodsFor: 'validating'!validateAttributeValue: aValue	self		spaceSeparatedListValuesIn: aValue		do: [:each |			self unparsedEntityValidator				validateEntityReference: each				inAttribute: self attribute]! !!XMLStandaloneExternalEntitiesAttributeValidator methodsFor: 'testing'!isStandaloneExternal	^ true! !!XMLEntityAttributeValidator class methodsFor: 'defaults'!standaloneExternalClass	^ XMLStandaloneExternalEntityAttributeValidator! !!XMLEntityAttributeValidator methodsFor: 'initialization'!initializeWithValidatorsFrom: aValidatorContainer	super initializeWithValidatorsFrom: aValidatorContainer.	unparsedEntityValidator := aValidatorContainer unparsedEntityValidator! !!XMLEntityAttributeValidator methodsFor: 'testing'!isEntity	^ true! !!XMLEntityAttributeValidator methodsFor: 'accessing'!unparsedEntityValidator	^ unparsedEntityValidator! !!XMLEntityAttributeValidator methodsFor: 'validating'!validateAttributeDefaultValue: aDefaultValue	aDefaultValue isXMLName		ifFalse: [self errorInvalidDefaultAttributeValue: aDefaultValue]! !!XMLEntityAttributeValidator methodsFor: 'validating'!validateAttributeValue: aValue	self unparsedEntityValidator		validateEntityReference: aValue		inAttribute: self attribute! !!XMLStandaloneExternalEntityAttributeValidator methodsFor: 'testing'!isStandaloneExternal	^ true! !!XMLEnumerationAttributeValidator class methodsFor: 'defaults'!standaloneExternalClass	^ XMLStandaloneExternalEnumerationAttributeValidator! !!XMLEnumerationAttributeValidator methodsFor: 'accessing'!allowedValues	^ allowedValues ifNil: [allowedValues := Set new]! !!XMLEnumerationAttributeValidator methodsFor: 'accessing'!allowedValues: anAllowedValuesCollection	allowedValues := anAllowedValuesCollection! !!XMLEnumerationAttributeValidator methodsFor: 'private '!errorEnumerationContainsDuplicateValues	XMLValidationException		formatSignal:			'Declaration for enumeration attribute "{1}" of element ',			'<{2}> contains duplicate values'		with: self attribute		with: self element! !!XMLEnumerationAttributeValidator methodsFor: 'private '!errorInvalidValue: aValue	XMLValidationException		formatSignal: 'Invalid value "{1}" for attribute "{2}" of element <{3}>'		with: aValue		with: self attribute		with: self element! !!XMLEnumerationAttributeValidator methodsFor: 'testing'!isEnumeration	^ true! !!XMLEnumerationAttributeValidator methodsFor: 'validating'!validateAttributeDeclaration	| oldAllowedValues |	oldAllowedValues := self allowedValues.	self allowedValues: oldAllowedValues asSet.	(self allowedValues size < oldAllowedValues size)		ifTrue: [self errorEnumerationContainsDuplicateValues].	super validateAttributeDeclaration.! !!XMLEnumerationAttributeValidator methodsFor: 'validating'!validateAttributeDefaultValue: aDefaultValue	(self allowedValues includes: aDefaultValue)		ifFalse: [self errorInvalidDefaultAttributeValue: aDefaultValue]! !!XMLEnumerationAttributeValidator methodsFor: 'validating'!validateAttributeValue: aValue	(self allowedValues includes: aValue)		ifFalse: [self errorInvalidValue: aValue]! !!XMLEnumerationAttributeValidator methodsFor: 'validating'!validateXMLSpaceAttributeDeclaration	self allowedValues size > 2		ifTrue: [self errorInvalidXMLSpaceAttributeDeclaration].	self allowedValues do: [:each |		(each = 'preserve'			or: [each = 'default'])			ifFalse: [self errorInvalidXMLSpaceAttributeDeclaration]].! !!XMLNotationEnumerationAttributeValidator class methodsFor: 'defaults'!standaloneExternalClass	^ XMLStandaloneExternalNotationEnumerationAttributeValidator! !!XMLNotationEnumerationAttributeValidator methodsFor: 'initialization'!initializeWithValidatorsFrom: aValidatorContainer	super initializeWithValidatorsFrom: aValidatorContainer.	unparedEntityValidator := aValidatorContainer unparsedEntityValidator.! !!XMLNotationEnumerationAttributeValidator methodsFor: 'testing'!isNotationEnumeration	^ true! !!XMLNotationEnumerationAttributeValidator methodsFor: 'accessing'!unparsedEntityValidator	^ unparedEntityValidator! !!XMLNotationEnumerationAttributeValidator methodsFor: 'validating'!validateAttributeDeclaration	self unparsedEntityValidator validateNotationAttributeDeclaration: self.	super validateAttributeDeclaration.! !!XMLNotationEnumerationAttributeValidator methodsFor: 'validating'!validateXMLSpaceAttributeDeclaration	self errorInvalidXMLSpaceAttributeDeclaration! !!XMLStandaloneExternalNotationEnumerationAttributeValidator methodsFor: 'testing'!isStandaloneExternal	^ true! !!XMLStandaloneExternalEnumerationAttributeValidator methodsFor: 'testing'!isStandaloneExternal	^ true! !!XMLIDAttributeValidator class methodsFor: 'defaults'!standaloneExternalClass	^ XMLStandaloneExternalIDAttributeValidator! !!XMLIDAttributeValidator methodsFor: 'accessing'!elementIDValidator	^ elementIDValidator! !!XMLIDAttributeValidator methodsFor: 'accessing'!elementIDValidator: anElementIDValidator	elementIDValidator := anElementIDValidator! !!XMLIDAttributeValidator methodsFor: 'private'!errorIDAttributeMustBeRequiredOrImplied	XMLValidationException		formatSignal:			'Attribute "{1}" of element <{2}> is of ID type and must ',			'be declared #REQUIRED or #IMPLIED'		with: self attribute		with: self element! !!XMLIDAttributeValidator methodsFor: 'initialization'!initializeWithValidatorsFrom: aValidatorContainer	super initializeWithValidatorsFrom: aValidatorContainer.	elementIDValidator := aValidatorContainer elementIDValidator.! !!XMLIDAttributeValidator methodsFor: 'testing'!isID	^ true! !!XMLIDAttributeValidator methodsFor: 'validating'!validateAttributeDeclaration	self elementIDValidator		validateIDAttribute: self attribute		forElement: self element.	super validateAttributeDeclaration.! !!XMLIDAttributeValidator methodsFor: 'validating'!validateAttributeDefaultValue: aDefaultValue	self errorIDAttributeMustBeRequiredOrImplied! !!XMLIDAttributeValidator methodsFor: 'validating'!validateAttributeValue: aValue	self elementIDValidator		validateID: aValue		inAttribute: self attribute! !!XMLStandaloneExternalIDAttributeValidator methodsFor: 'testing'!isStandaloneExternal	^ true! !!XMLStandaloneExternalXMLIDAttributeValidator methodsFor: 'testing'!isStandaloneExternal	^ true! !!XMLXMLIDAttributeValidator class methodsFor: 'defaults'!standaloneExternalClass	^ XMLStandaloneExternalXMLIDAttributeValidator! !!XMLXMLIDAttributeValidator methodsFor: 'testing'!isXMLID	^ true! !!XMLXMLIDAttributeValidator methodsFor: 'validating'!validateAttributeValue: aValue	self elementIDValidator validateXMLID: aValue! !!XMLXMLIDAttributeValidator methodsFor: 'validating'!validateXMLIDAttributeDeclaration! !!XMLIDRefAttributeValidator class methodsFor: 'defaults'!standaloneExternalClass	^ XMLStandaloneExternalIDRefAttributeValidator! !!XMLIDRefAttributeValidator methodsFor: 'accessing'!elementIDValidator	^ elementIDValidator! !!XMLIDRefAttributeValidator methodsFor: 'initialization'!initializeWithValidatorsFrom: aValidatorContainer	super initializeWithValidatorsFrom: aValidatorContainer.	elementIDValidator := aValidatorContainer elementIDValidator.! !!XMLIDRefAttributeValidator methodsFor: 'testing'!isIDRef	^ true! !!XMLIDRefAttributeValidator methodsFor: 'validating'!validateAttributeDefaultValue: aDefaultValue	aDefaultValue isXMLName		ifFalse: [self errorInvalidDefaultAttributeValue: aDefaultValue]! !!XMLIDRefAttributeValidator methodsFor: 'validating'!validateAttributeValue: aValue	self elementIDValidator		validateIDReference: aValue		inAttribute: self attribute! !!XMLIDRefsAttributeValidator class methodsFor: 'defaults'!standaloneExternalClass	^ XMLStandaloneExternalIDRefsAttributeValidator! !!XMLIDRefsAttributeValidator methodsFor: 'testing'!isIDRefs	^ true! !!XMLIDRefsAttributeValidator methodsFor: 'validating'!validateAttributeDefaultValue: aDefaultValue	self		spaceSeparatedListValuesIn: aDefaultValue		do: [:each |			each isXMLName				ifFalse: [self errorInvalidDefaultAttributeValue: aDefaultValue]]! !!XMLIDRefsAttributeValidator methodsFor: 'validating'!validateAttributeValue: aValue	self		spaceSeparatedListValuesIn: aValue		do: [:each |			self elementIDValidator				validateIDReference: each				inAttribute: self attribute]! !!XMLStandaloneExternalIDRefsAttributeValidator methodsFor: 'testing'!isStandaloneExternal	^ true! !!XMLStandaloneExternalIDRefAttributeValidator methodsFor: 'testing'!isStandaloneExternal	^ true! !!XMLNmtokenAttributeValidator class methodsFor: 'defaults'!standaloneExternalClass	^ XMLStandaloneExternalNmtokenAttributeValidator! !!XMLNmtokenAttributeValidator methodsFor: 'private'!errorInvalidNmtoken: aName	XMLValidationException		formatSignal: 'Invalid Nmtoken name "{1}" in attribute "{2}" of element <{3}>'		with: aName		with: self attribute		with: self element! !!XMLNmtokenAttributeValidator methodsFor: 'testing'!isNmtoken	^ true! !!XMLNmtokenAttributeValidator methodsFor: 'validating'!validateAttributeDefaultValue: aDefaultValue	aDefaultValue isXMLNmtoken		ifFalse: [self errorInvalidDefaultAttributeValue: aDefaultValue]! !!XMLNmtokenAttributeValidator methodsFor: 'validating'!validateAttributeValue: aValue	self validateNmtoken: aValue! !!XMLNmtokenAttributeValidator methodsFor: 'validating'!validateNmtoken: aName	aName isXMLNmtoken		ifFalse: [self errorInvalidNmtoken: aName]! !!XMLNmtokensAttributeValidator class methodsFor: 'defaults'!standaloneExternalClass	^ XMLStandaloneExternalNmtokensAttributeValidator! !!XMLNmtokensAttributeValidator methodsFor: 'testing'!isNmtokens	^ true! !!XMLNmtokensAttributeValidator methodsFor: 'validating'!validateAttributeDefaultValue: aDefaultValue	self		spaceSeparatedListValuesIn: aDefaultValue		do: [:each |			each isXMLNmtoken				ifFalse: [self errorInvalidDefaultAttributeValue: aDefaultValue]]! !!XMLNmtokensAttributeValidator methodsFor: 'validating'!validateAttributeValue: aValue	self		spaceSeparatedListValuesIn: aValue		do: [:each | self validateNmtoken: each]! !!XMLStandaloneExternalNmtokensAttributeValidator methodsFor: 'testing'!isStandaloneExternal	^ true! !!XMLStandaloneExternalNmtokenAttributeValidator methodsFor: 'testing'!isStandaloneExternal	^ true! !!XMLClassFinder class methodsFor: 'accessing'!classNamed: aClassName	^ self		classNamed: aClassName		ifAbsent: [nil]! !!XMLClassFinder class methodsFor: 'accessing'!classNamed: aClassName ifAbsent: aBlock	"'self environment at:' is the proper way to get a class that may not	exist, not 'Smalltalk at:', 'Smalltalk globals at:' or '#ClassName asClass'	(assuming both this class and aClassName class are in the same environment)"	^ self environment		at: aClassName asSymbol		ifAbsent: aBlock! !!XMLClassFinder class methodsFor: 'accessing'!classNamed: aClassName ifPresent: aBlock	^ aBlock cull:		(self			classNamed: aClassName			ifAbsent: [^ nil])! !!XMLClassFinder class methodsFor: 'accessing'!classNamed: aClassName ifPresent: aPresentBlock ifAbsent: anAbsentBlock	^ aPresentBlock cull:		(self			classNamed: aClassName			ifAbsent: [^ anAbsentBlock value])! !!XMLClassFinder class methodsFor: 'testing'!hasClassNamed: aClassName	self		classNamed: aClassName		ifAbsent: [^ false].	^ true.! !!XMLConfiguration methodsFor: 'accessing'!decodesCharacters	^ decodesCharacters! !!XMLConfiguration methodsFor: 'accessing'!decodesCharacters: aBoolean	decodesCharacters := aBoolean! !!XMLConfiguration methodsFor: 'defaults'!defaultParserHandlerClass	^ SAXHandler! !!XMLConfiguration methodsFor: 'accessing'!documentReadLimit	^ self parserLimits documentReadLimit! !!XMLConfiguration methodsFor: 'accessing'!documentReadLimit: anInteger	self parserLimits documentReadLimit: anInteger! !!XMLConfiguration methodsFor: 'accessing'!entityConfiguration	^ entityConfiguration ifNil: [entityConfiguration := DTDEntityConfiguration new]! !!XMLConfiguration methodsFor: 'accessing'!entityConfiguration: anEntityConfiguration	entityConfiguration := anEntityConfiguration! !!XMLConfiguration methodsFor: 'accessing'!externalEntityResolver	^ self entityConfiguration externalEntityResolver! !!XMLConfiguration methodsFor: 'accessing'!externalEntityResolver: anExternalEntityResolver	self entityConfiguration externalEntityResolver: anExternalEntityResolver! !!XMLConfiguration methodsFor: 'initialization'!initialize	super initialize.	"always used, so explicitly initialized"	isValidating := true.	usesNamespaces := true.	decodesCharacters := true.	requiresSchema := false.	parserLimits := XMLParserLimits new.! !!XMLConfiguration methodsFor: 'accessing'!isValidating	^ isValidating! !!XMLConfiguration methodsFor: 'accessing'!isValidating: aBoolean	(isValidating := aBoolean)		ifTrue: [self preservesUndeclaredEntityReferences: false]		ifFalse: [self requiresSchema: false]! !!XMLConfiguration methodsFor: 'accessing'!maxEntityReplacementDepth	^ self parserLimits maxEntityReplacementDepth! !!XMLConfiguration methodsFor: 'accessing'!maxEntityReplacementDepth: anInteger	self parserLimits maxEntityReplacementDepth: anInteger! !!XMLConfiguration methodsFor: 'accessing'!parserHandlerClass	^ parserHandlerClass ifNil: [parserHandlerClass := self defaultParserHandlerClass]! !!XMLConfiguration methodsFor: 'accessing'!parserHandlerClass: aClass	parserHandlerClass := aClass! !!XMLConfiguration methodsFor: 'accessing'!parserLimits	^ parserLimits! !!XMLConfiguration methodsFor: 'accessing'!parserLimits: aParserLimits	parserLimits := aParserLimits! !!XMLConfiguration methodsFor: 'copying'!postCopy	super postCopy.	parserLimits := parserLimits copy.	entityConfiguration		ifNotNil: [entityConfiguration := entityConfiguration copy].! !!XMLConfiguration methodsFor: 'accessing'!preservesUndeclaredEntityReferences	^ self entityConfiguration preservesUndeclaredEntityReferences! !!XMLConfiguration methodsFor: 'accessing'!preservesUndeclaredEntityReferences: aBoolean	self entityConfiguration preservesUndeclaredEntityReferences: aBoolean.	aBoolean		ifTrue: [self isValidating: false].! !!XMLConfiguration methodsFor: 'removing'!removeLimits	self parserLimits removeAll.	self externalEntityResolver removeLimits.! !!XMLConfiguration methodsFor: 'accessing'!replacesContentEntityReferences	^ self entityConfiguration replacesContentEntityReferences! !!XMLConfiguration methodsFor: 'accessing'!replacesContentEntityReferences: aBoolean	self entityConfiguration replacesContentEntityReferences: aBoolean! !!XMLConfiguration methodsFor: 'deprecated'!requiresDocumentConstraints	^ self requiresSchema! !!XMLConfiguration methodsFor: 'deprecated'!requiresDocumentConstraints: aBoolean	"will be deprecated; use #requiresSchema: instead"	self requiresSchema: aBoolean! !!XMLConfiguration methodsFor: 'accessing'!requiresSchema	^ requiresSchema! !!XMLConfiguration methodsFor: 'accessing'!requiresSchema: aBoolean	(requiresSchema := aBoolean)		ifTrue: [self isValidating: true]! !!XMLConfiguration methodsFor: 'accessing'!resolvesExternalEntities	^ self entityConfiguration resolvesExternalEntities! !!XMLConfiguration methodsFor: 'accessing'!resolvesExternalEntities: aBoolean	self entityConfiguration resolvesExternalEntities: aBoolean! !!XMLConfiguration methodsFor: 'accessing'!usesNamespaces	^ usesNamespaces! !!XMLConfiguration methodsFor: 'accessing'!usesNamespaces: aBoolean	usesNamespaces := aBoolean! !!XMLDOMConfiguration methodsFor: 'accessing'!attributeListClass	^ self nodeFactory attributeListClass! !!XMLDOMConfiguration methodsFor: 'accessing'!attributeListClass: aClass	self nodeFactory:		(self nodeFactory asPluggableNodeFactory attributeListClass: aClass)! !!XMLDOMConfiguration methodsFor: 'defaults'!defaultNodeFactoryClass	^ XMLNodeFactory! !!XMLDOMConfiguration methodsFor: 'defaults'!defaultParserHandlerClass	^ XMLDOMParser! !!XMLDOMConfiguration methodsFor: 'initialization'!initialize	super initialize.	"always used, so explicitly initialized"	preservesCDataNodes := false.	preservesCommentNodes := false.	preservesIgnorableWhitespace := false.	nodeFactory := self defaultNodeFactoryClass new.! !!XMLDOMConfiguration methodsFor: 'accessing'!isValidating: aBoolean	aBoolean		ifFalse: [self preservesIgnorableWhitespace: false].	super isValidating: aBoolean.! !!XMLDOMConfiguration methodsFor: 'accessing'!nodeFactory	^ nodeFactory! !!XMLDOMConfiguration methodsFor: 'accessing'!nodeFactory: aFactory	nodeFactory := aFactory! !!XMLDOMConfiguration methodsFor: 'accessing'!nodeListClass	^ self nodeFactory nodeListClass! !!XMLDOMConfiguration methodsFor: 'accessing'!nodeListClass: aClass	self nodeFactory:		(self nodeFactory asPluggableNodeFactory nodeListClass: aClass)! !!XMLDOMConfiguration methodsFor: 'copying'!postCopy	super postCopy.	nodeFactory := nodeFactory copy.! !!XMLDOMConfiguration methodsFor: 'accessing'!preservesCDataNodes	^ preservesCDataNodes! !!XMLDOMConfiguration methodsFor: 'accessing'!preservesCDataNodes: aBoolean	preservesCDataNodes := aBoolean! !!XMLDOMConfiguration methodsFor: 'accessing'!preservesCommentNodes	^ preservesCommentNodes! !!XMLDOMConfiguration methodsFor: 'accessing'!preservesCommentNodes: aBoolean	preservesCommentNodes := aBoolean! !!XMLDOMConfiguration methodsFor: 'accessing'!preservesIgnorableWhitespace	^ preservesIgnorableWhitespace! !!XMLDOMConfiguration methodsFor: 'accessing'!preservesIgnorableWhitespace: aBoolean	(preservesIgnorableWhitespace := aBoolean)		ifTrue: [self isValidating: true]! !!XMLDFAState class methodsFor: 'instance creation'!nfaStates: anNFAStateSet	^ self		nfaStates: anNFAStateSet		dfaStateCache: nil! !!XMLDFAState class methodsFor: 'instance creation'!nfaStates: anNFAStateSet dfaStateCache: aDFAStateCache	^ self new		setNFAStates: anNFAStateSet		dfaStateCache: aDFAStateCache! !!XMLDFAState methodsFor: 'private'!addDFAStateTransitionMatching: aMatcher	| matchingNFAStates totalMatched matchingDFAState |	self dfaStateTransitions size >= self maxDFAStateTransitions		ifTrue: [self removeDFAStateTransitions].	matchingNFAStates := XMLNFAStateSet new.	totalMatched := 0.	self nfaStatesDo: [:state |		(state matches: aMatcher)			ifTrue: [				state nextState addTo: matchingNFAStates.				totalMatched := totalMatched + 1]].	matchingNFAStates size > 0		ifTrue: [			matchingDFAState :=				dfaStateCache dfaStateForNFAStates: matchingNFAStates.			totalMatched > 1				ifTrue: [matchingDFAState hasNonDeterminism: true]].	^ self dfaStateTransitions		at: aMatcher		put: matchingDFAState. "nil if no match"! !!XMLDFAState methodsFor: 'private'!dfaStateCache	^ dfaStateCache! !!XMLDFAState methodsFor: 'private'!dfaStateTransitions	^ dfaStateTransitions ifNil: [dfaStateTransitions := Dictionary new]! !!XMLDFAState methodsFor: 'testing'!hasNonDeterminism	^ hasNonDeterminism! !!XMLDFAState methodsFor: 'accessing'!hasNonDeterminism: aBoolean	hasNonDeterminism := aBoolean! !!XMLDFAState methodsFor: 'testing'!isAccepting	^ nfaStates isAccepting! !!XMLDFAState methodsFor: 'private'!maxDFAStateTransitions	^ 64! !!XMLDFAState methodsFor: 'matching'!nextDFAStateMatching: aMatcher	^ self		nextDFAStateMatching: aMatcher		ifNone: [nil]! !!XMLDFAState methodsFor: 'matching'!nextDFAStateMatching: aMatcher ifNone: aBlock	^ (self dfaStateTransitions		at: aMatcher		ifAbsent: [self addDFAStateTransitionMatching: aMatcher])			ifNil: [aBlock value]! !!XMLDFAState methodsFor: 'accessing'!nfaStates	^ nfaStates! !!XMLDFAState methodsFor: 'enumerating'!nfaStatesDo: aBlock	nfaStates do: aBlock! !!XMLDFAState methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		print: self nfaStates;		nextPut: $).! !!XMLDFAState methodsFor: 'private'!removeDFAStateTransitions	dfaStateTransitions := nil! !!XMLDFAState methodsFor: 'initialization'!setNFAStates: anNFAStateSet dfaStateCache: aDFAStateCache	nfaStates := anNFAStateSet.	dfaStateCache :=		aDFAStateCache				ifNil: [XMLDFAStateCache firstDFAState: self].	hasNonDeterminism := false.! !!XMLDFAStateCache class methodsFor: 'instance creation'!firstDFAState: aDFAState	^ self new setFirstDFAState: aDFAState! !!XMLDFAStateCache methodsFor: 'private'!addDFAStateForNFAStates: anNFAStateSet	cachedDFAStates size >= self maxCachedDFAStates		ifTrue: [self removeDFAStates].	^ cachedDFAStates		at: anNFAStateSet		put: (anNFAStateSet asDFAStateWithStateCache: self).! !!XMLDFAStateCache methodsFor: 'private'!cachedDFAStates	^ cachedDFAStates! !!XMLDFAStateCache methodsFor: 'accessing'!dfaStateForNFAStates: anNFAStateSet	^ cachedDFAStates		at: anNFAStateSet		ifAbsent: [self addDFAStateForNFAStates: anNFAStateSet]! !!XMLDFAStateCache methodsFor: 'accessing'!firstDFAState	^ firstDFAState! !!XMLDFAStateCache methodsFor: 'private'!maxCachedDFAStates	^ 64! !!XMLDFAStateCache methodsFor: 'private'!removeDFAStates	cachedDFAStates		valuesDo: [:each | each removeDFAStateTransitions];		removeAll.	cachedDFAStates		at: firstDFAState nfaStates		put: firstDFAState.! !!XMLDFAStateCache methodsFor: 'initialization'!setFirstDFAState: aDFAState	firstDFAState := aDFAState.	(cachedDFAStates := Dictionary new: 5)		at: firstDFAState nfaStates		put: firstDFAState.! !!DTDDocumentValidator class methodsFor: 'instance creation'!doctypeDefinition: aDoctypeDefinition	^ self new doctypeDefinition: aDoctypeDefinition! !!DTDDocumentValidator methodsFor: 'accessing'!attributeValidatorsFor: anElement ifNone: aBlock	^ self doctypeDefinition		attributeValidatorsAt: anElement		ifAbsent: aBlock! !!DTDDocumentValidator methodsFor: 'accessing'!doctypeDefinition	^ doctypeDefinition! !!DTDDocumentValidator methodsFor: 'accessing'!doctypeDefinition: aDoctypeDefinition	doctypeDefinition := aDoctypeDefinition! !!DTDDocumentValidator methodsFor: 'accessing'!elementValidatorFor: anElement ifNone: aBlock	^ self doctypeDefinition		elementValidatorsAt: anElement		ifAbsent: aBlock! !!DTDDocumentValidator methodsFor: 'private'!errorInvalidRootElement: anElement	XMLValidationException		formatSignal:			'Root element must be <{1}> according to DOCTYPE declaration, not <{2}>'		with: self doctypeDefinition root		with: anElement! !!DTDDocumentValidator methodsFor: 'testing'!hasAttributeValidators	^ self doctypeDefinition hasAttributeValidators! !!DTDDocumentValidator methodsFor: 'testing'!hasElementValidators	^ self doctypeDefinition hasElementValidators! !!DTDDocumentValidator methodsFor: 'validating'!unvalidatedAttributes: anAttributeCollection inElement: anElement	XMLValidationException		formatSignal: 'Undeclared attribute "{1}" in element <{2}>'		with: anAttributeCollection anyOne		with: anElement! !!DTDDocumentValidator methodsFor: 'validating'!unvalidatedElement: anElement	XMLValidationException		formatSignal: 'Undeclared element <{1}>'		with: anElement! !!DTDDocumentValidator methodsFor: 'validating'!validateIDReferences	self doctypeDefinition hasElementIDReferences		ifTrue: [self doctypeDefinition elementIDValidator validateIDReferences]! !!DTDDocumentValidator methodsFor: 'validating'!validateRootElement: anElement	(self doctypeDefinition hasRoot		and: [self doctypeDefinition root ~= anElement])		ifTrue: [self errorInvalidRootElement: anElement]! !!XMLDocumentValidator methodsFor: 'accessing'!attributeValidatorsFor: anElement	^ self		attributeValidatorsFor: anElement		ifNone: [nil]! !!XMLDocumentValidator methodsFor: 'accessing'!attributeValidatorsFor: anElement ifNone: aBlock	self subclassResponsibility! !!XMLDocumentValidator methodsFor: 'accessing'!currentElementValidator	^ self elementValidatorStack xmlLastOrNil! !!XMLDocumentValidator methodsFor: 'accessing'!defaultElementValidatorFor: aName	^ XMLAnyElementValidator element: aName! !!XMLDocumentValidator methodsFor: 'private'!defaultXMLIDValidator	"used to validate xml:id attributes if there's no DTD or other validators"	^ defaultXMLIDValidator		ifNil: [			defaultXMLIDValidator :=				XMLXMLIDAttributeValidator					element: ''					attribute: 'xml:id'					defaultValidator:						(XMLAttributeImpliedDefaultValidator attribute: 'xml:id').			defaultXMLIDValidator				elementIDValidator: XMLElementIDValidator new;				yourself]! !!XMLDocumentValidator methodsFor: 'accessing'!elementValidatorFor: anElement	^ self		elementValidatorFor: anElement		ifNone: [nil]! !!XMLDocumentValidator methodsFor: 'accessing'!elementValidatorFor: anElement ifNone: aBlock	self subclassResponsibility! !!XMLDocumentValidator methodsFor: 'accessing'!elementValidatorStack	^ elementValidatorStack ifNil: [elementValidatorStack := OrderedCollection new]! !!XMLDocumentValidator methodsFor: 'private'!errorUnexpectEndOfElement: anElement	XMLValidationException		formatSignal: 'Element <{1}> terminated prematurely'		with: anElement! !!XMLDocumentValidator methodsFor: 'testing'!hasAttributeValidators	self subclassResponsibility! !!XMLDocumentValidator methodsFor: 'testing'!hasCurrentElementValidator	"optimized to avoid lazy initialization"	elementValidatorStack == nil		ifTrue: [^ false].	^ elementValidatorStack size > 0.! !!XMLDocumentValidator methodsFor: 'testing'!hasElementValidators	self subclassResponsibility! !!XMLDocumentValidator methodsFor: 'testing'!isCurrentElementWhitespaceIgnorable	^ self hasCurrentElementValidator		and: [self currentElementValidator ignoresWhitespace]! !!XMLDocumentValidator methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	self hasCurrentElementValidator		ifTrue: [			aStream				nextPut: $(;				print: self currentElementValidator;				nextPut: $)].! !!XMLDocumentValidator methodsFor: 'validating'!unvalidatedAttributes: anAttributeCollection inElement: anElement	"sent when at least one attribute of an element wasn't validated by an	attribute validator and there are element or attribute validators defined"! !!XMLDocumentValidator methodsFor: 'validating'!unvalidatedElement: anElement	"sent when an element was not validated by an element validator	and there are element or attribute validators defined"! !!XMLDocumentValidator methodsFor: 'validating'!validateAttributes: aDictionary withAttributeValidatorsFor: anElement	| totalUnvalidatedAttributes validatedAttributes |	totalUnvalidatedAttributes := aDictionary size.	(self attributeValidatorsFor: anElement)		ifNotNil: [:attributeValidators |			attributeValidators keysAndValuesDo: [:attribute :validator |				(aDictionary includesKey: attribute)					ifTrue: [						"only initialize if needed, and as an OrderedCollection that						is only converted to a Set later if needed, for permformance"						(validatedAttributes							ifNil: [								validatedAttributes :=									OrderedCollection new: totalUnvalidatedAttributes])							addLast: attribute.						totalUnvalidatedAttributes := totalUnvalidatedAttributes - 1].				validator validateAttributes: aDictionary]].	totalUnvalidatedAttributes > 0		ifTrue: [			self				unvalidatedAttributes:					(validatedAttributes						ifNil: [aDictionary keys]						ifNotNil: [| validatedAttributesSet |							validatedAttributesSet := validatedAttributes asSet.							aDictionary keys reject: [:each |								validatedAttributesSet includes: each]])				inElement: anElement].! !!XMLDocumentValidator methodsFor: 'validating'!validateComment: aString	self hasCurrentElementValidator		ifTrue: [self currentElementValidator validateComment: aString]! !!XMLDocumentValidator methodsFor: 'validating'!validateEndDocument	self validateIDReferences! !!XMLDocumentValidator methodsFor: 'validating'!validateEndTag: anElement	self hasCurrentElementValidator		ifTrue: [			self currentElementValidator atEnd				ifFalse: [self errorUnexpectEndOfElement: anElement].			self elementValidatorStack removeLast]! !!XMLDocumentValidator methodsFor: 'validating'!validateIDReferences	self subclassResponsibility! !!XMLDocumentValidator methodsFor: 'validating'!validatePCData: aString	self hasCurrentElementValidator		ifTrue: [self currentElementValidator validatePCData: aString]! !!XMLDocumentValidator methodsFor: 'validating'!validatePI: aTargetString data: aDataString	self hasCurrentElementValidator		ifTrue: [			self currentElementValidator				validatePI: aTargetString				data: aDataString]! !!XMLDocumentValidator methodsFor: 'validating'!validateRootElement: anElement! !!XMLDocumentValidator methodsFor: 'validating'!validateStartTag: anElement	self currentElementValidator		ifNotNil: [:elementValidator |			elementValidator validateStartTag: anElement].	self elementValidatorStack addLast:		(self			elementValidatorFor: anElement			ifNone: [				self					unvalidatedElement: anElement;					defaultElementValidatorFor: anElement]) asReadyElementValidator.! !!XMLDocumentValidator methodsFor: 'validating'!validateStartTag: anElement attributes: aDictionary	(self hasElementValidators		or: [self hasAttributeValidators])		ifTrue: [			self validateStartTag: anElement.			self				validateAttributes: aDictionary				withAttributeValidatorsFor: anElement]! !!XMLDocumentValidator methodsFor: 'validating'!validateXMLIDAttributeIn: aDictionary	self hasAttributeValidators		ifFalse: [self defaultXMLIDValidator validateAttributes: aDictionary]! !!XMLBasicElementClassMapper methodsFor: 'accessing'!classForElement: aQualifiedName attributes: anAssociationCollection ifNone: aBlock	^ self		classForElement: aQualifiedName		namespaceURI: ''		attributes: anAssociationCollection		ifNone: aBlock! !!XMLBasicElementClassMapper methodsFor: 'accessing'!classForElement: aQualifiedName ifNone: aBlock	^ self		classForElement: aQualifiedName		namespaceURI: ''		attributes: XMLLazyAttributeDictionary  new		ifNone: aBlock! !!XMLBasicElementClassMapper methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI attributes: anAssociationCollection ifNone: aBlock	| localName attributeDictionary |	attributeDictionary := anAssociationCollection asXMLAttributeDictionary.	aURI size > 0 "optimization"		ifTrue: [			(self				elementClassMapAt: aQualifiedName -> aURI				attributes: attributeDictionary)				ifNotNil: [:class | ^ class].			(self				elementClassMapAt: aQualifiedName				attributes: attributeDictionary)				ifNotNil: [:class | ^ class].			(localName := aQualifiedName xmlLocalNameAfterPrefix) size <				aQualifiedName size				ifTrue: [					(self						elementClassMapAt: localName -> aURI						attributes: attributeDictionary)						ifNotNil: [:class | ^ class].					(self						elementClassMapAt: localName						attributes: attributeDictionary)						ifNotNil: [:class | ^ class]]]		ifFalse: [			(self				elementClassMapAt: aQualifiedName				attributes: attributeDictionary)				ifNotNil: [:class | ^ class].			(localName := aQualifiedName xmlLocalNameAfterPrefix) size <				aQualifiedName size				ifTrue: [					(self						elementClassMapAt: localName						attributes: attributeDictionary)						ifNotNil: [:class | ^ class]]].	^ aBlock value.! !!XMLBasicElementClassMapper methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI ifNone: aBlock	^ self		classForElement: aQualifiedName		namespaceURI: aURI		attributes: XMLLazyAttributeDictionary new		ifNone: aBlock! !!XMLBasicElementClassMapper methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI localName: aLocalName attributes: anAssociationCollection ifNone: aBlock	| attributeDictionary |	attributeDictionary := anAssociationCollection.	aURI size > 0 "optimization"		ifTrue: [			(self				elementClassMapAt: aQualifiedName -> aURI				attributes: attributeDictionary)				ifNotNil: [:class | ^ class].			(self				elementClassMapAt: aQualifiedName				attributes: attributeDictionary)				ifNotNil: [:class | ^ class].			aLocalName size < aQualifiedName size				ifTrue: [					(self						elementClassMapAt: aLocalName -> aURI						attributes: attributeDictionary)						ifNotNil: [:class | ^ class].					(self						elementClassMapAt: aLocalName						attributes: attributeDictionary)						ifNotNil: [:class | ^ class]]]		ifFalse: [			(self				elementClassMapAt: aQualifiedName				attributes: attributeDictionary)				ifNotNil: [:class | ^ class].			aLocalName size < aQualifiedName size				ifTrue: [					(self						elementClassMapAt: aLocalName						attributes: attributeDictionary)						ifNotNil: [:class | ^ class]]].	^ aBlock value.! !!XMLBasicElementClassMapper methodsFor: 'private'!elementClassMap	^ elementClassMap! !!XMLBasicElementClassMapper methodsFor: 'private'!elementClassMapAt: aKey attributes: anAttributeDictionary	| classOrCollection |	classOrCollection :=		elementClassMap			at: aKey			ifAbsent: [^ nil].	classOrCollection isCollection		ifTrue: [			"to:do: for speed"			1 to: classOrCollection size - 1 do: [:i |				((classOrCollection at: i) key					matchesAttributes: anAttributeDictionary)					ifTrue: [^ (classOrCollection at: i) value]].			^ classOrCollection last]		ifFalse: [^ classOrCollection].! !!XMLBasicElementClassMapper methodsFor: 'initialization'!initialize	super initialize.	elementClassMap := Dictionary new.! !!XMLBasicElementClassMapper methodsFor: 'mapping'!mapElement: anElement attributeSpec: anAttributeSpec toClass: aClass	| classOrCollection |	classOrCollection :=		elementClassMap			at: anElement			ifAbsent: [nil].	classOrCollection isCollection		ifTrue: [			"new mappings have precedence over old"			classOrCollection addFirst: anAttributeSpec -> aClass]		ifFalse: [			elementClassMap				at: anElement				put:					(OrderedCollection						with: anAttributeSpec -> aClass						with: classOrCollection)].! !!XMLBasicElementClassMapper methodsFor: 'mapping'!mapElement: anElement namespaceURI: aURI attributeSpec: anAttributeSpec toClass: aClass	self		mapElement:			(aURI size > 0				ifTrue: [anElement -> aURI]				ifFalse: [anElement])		attributeSpec: anAttributeSpec		toClass: aClass! !!XMLBasicElementClassMapper methodsFor: 'mapping'!mapElement: anElement namespaceURI: aURI toClass: aClass	self		mapElement:			(aURI size > 0				ifTrue: [anElement -> aURI]				ifFalse: [anElement])		toClass: aClass! !!XMLBasicElementClassMapper methodsFor: 'mapping'!mapElement: anElement toClass: aClass	| classOrCollection |	classOrCollection :=		elementClassMap			at: anElement			ifAbsent: [nil].	classOrCollection isCollection		ifTrue: [			classOrCollection				at: classOrCollection size				put: aClass]		ifFalse: [			elementClassMap				at: anElement				put: aClass].! !!XMLBasicElementClassMapper methodsFor: 'copying'!postCopy	super postCopy.	elementClassMap := elementClassMap copy.	"each val is either a class or an OrderedCollection, which needs	to be copied so new mappings in either the copy or original don't	effect the other"	elementClassMap associationsDo: [:each |		each value isCollection			ifTrue: [each value: each value copy]].! !!XMLElementClassMapper methodsFor: 'private'!camelCasedNameFromClassNameSegments: aNameSegmentCollection	^ String streamContents: [:stream |		aNameSegmentCollection withIndexDo: [:each :i |			stream nextPutAll:				(i > 1					ifTrue: [each]					ifFalse: [each asLowercase])]]! !!XMLElementClassMapper methodsFor: 'accessing'!classForElement: aQualifiedName	^ self		classForElement: aQualifiedName		ifNone: [nil]! !!XMLElementClassMapper methodsFor: 'accessing'!classForElement: aQualifiedName attributes: anAssociationCollection	^ self		classForElement: aQualifiedName		attributes: anAssociationCollection		ifNone: [nil]! !!XMLElementClassMapper methodsFor: 'accessing'!classForElement: aQualifiedName attributes: anAssociationCollection ifNone: aBlock	self subclassResponsibility! !!XMLElementClassMapper methodsFor: 'accessing'!classForElement: aQualifiedName ifNone: aBlock	self subclassResponsibility! !!XMLElementClassMapper methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI	^ self		classForElement: aQualifiedName		namespaceURI: aURI		ifNone: [nil]! !!XMLElementClassMapper methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI attributes: anAssociationCollection	^ self		classForElement: aQualifiedName		namespaceURI: aURI		attributes: anAssociationCollection		ifNone: [nil]! !!XMLElementClassMapper methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI attributes: anAssociationCollection ifNone: aBlock	self subclassResponsibility! !!XMLElementClassMapper methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI ifNone: aBlock	self subclassResponsibility! !!XMLElementClassMapper methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI localName: aLocalName attributes: anAssociationCollection	^ self		classForElement: aQualifiedName		namespaceURI: aURI		localName: aLocalName		attributes: anAssociationCollection		ifNone: [nil]! !!XMLElementClassMapper methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI localName: aLocalName attributes: anAssociationCollection ifNone: aBlock	self subclassResponsibility! !!XMLElementClassMapper methodsFor: 'private'!classNameFrom: aClass withoutIgnorableSuffixes: aSuffixCollection	| className |	className := aClass name asString.	aSuffixCollection do: [:each |		(className endsWith: each)			ifTrue: [^ className allButLast: each size]].	^ className.! !!XMLElementClassMapper methodsFor: 'private'!classNameSegmentsFrom: aString	| nameSegments startIndex |	nameSegments := OrderedCollection new.	startIndex := 1.	1 to: aString size do: [:i |		(((aString at: i) isLowercase			and: [aString size >= (i + 1)				and: [(aString at: i + 1) isLowercase not]])			or: [				((aString at: i) isUppercase					and: [aString size >= (i + 2)						and: [(aString at: i + 1) isUppercase							and: [(aString at: i + 2) isUppercase not]]])])			ifTrue: [				nameSegments addLast:					(aString						copyFrom: startIndex						to: i).				startIndex := i + 1]].	startIndex <= aString size		ifTrue: [			nameSegments addLast:				(aString					copyFrom: startIndex					to: aString size)].	^ nameSegments.! !!XMLElementClassMapper methodsFor: 'private'!hyphenatedNameFromClassNameSegments: aNameSegmentCollection	^ String streamContents: [:stream |		aNameSegmentCollection			do: [:each | stream nextPutAll: each asLowercase]			separatedBy: [stream nextPut: $-]]! !!XMLElementClassMapper methodsFor: 'mapping'!mapAllMatchingElementsToClass: aClass ignoringSuffixes: aSuffixCollection	| classNameWithoutSuffixes classNameSegments totalClassNameSegments |	classNameWithoutSuffixes :=		self			classNameFrom: aClass			withoutIgnorableSuffixes: aSuffixCollection.	classNameSegments := self classNameSegmentsFrom: classNameWithoutSuffixes.	(totalClassNameSegments := classNameSegments size) > 0		ifFalse: [^ self].	"remove the class prefix if any"	totalClassNameSegments > 1		ifTrue: [classNameSegments removeFirst].	self		mapElement:			(self nameFromClassNameSegments: classNameSegments)		toClass: aClass.	self		mapElement:			(self camelCasedNameFromClassNameSegments: classNameSegments)		toClass: aClass.	self		mapElement:			(self hyphenatedNameFromClassNameSegments: classNameSegments)		toClass: aClass.	self		mapElement:			(self underscoredNameFromClassNameSegments: classNameSegments)		toClass: aClass.! !!XMLElementClassMapper methodsFor: 'mapping'!mapAllMatchingElementsToClasses: aClassCollection ignoringSuffixes: aSuffixCollection	aClassCollection do: [:each |		self			mapAllMatchingElementsToClass: each			ignoringSuffixes: aSuffixCollection]! !!XMLElementClassMapper methodsFor: 'mapping'!mapElement: anElement attributeSpec: anAttributeSpec toClass: aClass	self subclassResponsibility! !!XMLElementClassMapper methodsFor: 'mapping'!mapElement: anElement namespaceURI: aURI attributeSpec: anAttributeSpec toClass: aClass	self subclassResponsibility! !!XMLElementClassMapper methodsFor: 'mapping'!mapElement: anElement namespaceURI: aURI toClass: aClass	self subclassResponsibility! !!XMLElementClassMapper methodsFor: 'mapping'!mapElement: anElement toClass: aClass	self subclassResponsibility! !!XMLElementClassMapper methodsFor: 'mapping'!mapElements: anElementCollection namespaceURI: aNamespaceURI toClass: aClass	anElementCollection do: [:each |		self			mapElement: each			namespaceURI: aNamespaceURI			toClass: aClass]! !!XMLElementClassMapper methodsFor: 'mapping'!mapElements: anElementCollection toClass: aClass	anElementCollection do: [:each |		self			mapElement: each			toClass: aClass]! !!XMLElementClassMapper methodsFor: 'private'!nameFromClassNameSegments: aNameSegmentCollection	"avoid join: for Squeak/GS portability"	^ String streamContents: [:stream |		aNameSegmentCollection do: [:each | stream nextPutAll: each]]! !!XMLElementClassMapper methodsFor: 'private'!underscoredNameFromClassNameSegments: aNameSegmentCollection	^ String streamContents: [:stream |		aNameSegmentCollection			do: [:each | stream nextPutAll: each asLowercase]			separatedBy: [stream nextPut: $_]]! !!XMLElementIDValidator methodsFor: 'accessing'!elementsAndIDAttributes	^ elementsAndIdAttributes ifNil: [elementsAndIdAttributes := Dictionary new]! !!XMLElementIDValidator methodsFor: 'private'!errorDuplicateID: anID inAttribute: anAttribute	XMLValidationException		formatSignal: 'Duplicate element ID "{1}" used in attribute "{2}"'		with: anID		with: anAttribute! !!XMLElementIDValidator methodsFor: 'private'!errorInvalidID: anID inAttribute: anAttribute	XMLValidationException		formatSignal: 'Invalid element ID value "{1}" in attribute "{2}"'		with: anID		with: anAttribute! !!XMLElementIDValidator methodsFor: 'private'!errorMultipleIDAttributesForElement: anElement	XMLValidationException		formatSignal: 'Element <{1}> has multiple ID attributes'		with: anElement! !!XMLElementIDValidator methodsFor: 'private'!errorUnknownIDReference: anID	XMLValidationException		formatSignal: 'Reference to unknown element ID "{1}"'		with: anID! !!XMLElementIDValidator methodsFor: 'testing'!hasIDReferences	^ idReferences notNil		and: [idReferences notEmpty]! !!XMLElementIDValidator methodsFor: 'testing'!hasIDs	^ ids notNil		and: [ids notEmpty]! !!XMLElementIDValidator methodsFor: 'accessing'!idReferences	^ idReferences ifNil: [idReferences := Set new]! !!XMLElementIDValidator methodsFor: 'accessing'!ids	^ ids ifNil: [ids := Set new]! !!XMLElementIDValidator methodsFor: 'removing'!removeIDReferences	"Gemstone's Set does not understand removeAll, so nil reassignment	is used instead (will be lazy initialized by accessors)"	idReferences := nil! !!XMLElementIDValidator methodsFor: 'removing'!removeIDs	"Gemstone's Set does not understand removeAll, so nil reassignment	is used instead (will be lazy initialized by accessors)"	ids := nil! !!XMLElementIDValidator methodsFor: 'validating'!validateID: anID inAttribute: anAttribute	anID isXMLName		ifFalse: [			self				errorInvalidID: anID				inAttribute: anAttribute].	self		validateUniquenessOfID: anID		inAttribute: anAttribute.! !!XMLElementIDValidator methodsFor: 'validating'!validateIDAttribute: anAttribute forElement: anElement	| oldSize |	"checking size after is faster than includes test"	oldSize := self elementsAndIDAttributes size.	(self elementsAndIDAttributes		at: anElement		put: anAttribute;		size) > oldSize		ifFalse: [self errorMultipleIDAttributesForElement: anElement].! !!XMLElementIDValidator methodsFor: 'validating'!validateIDReference: anID inAttribute: anAttribute	anID isXMLName		ifFalse: [			self				errorInvalidID: anID				inAttribute: anAttribute].	self idReferences add: anID.! !!XMLElementIDValidator methodsFor: 'validating'!validateIDReferences	self idReferences do: [:each |		(self ids includes: each)			ifFalse: [self errorUnknownIDReference: each]]! !!XMLElementIDValidator methodsFor: 'private'!validateUniquenessOfID: anID inAttribute: anAttribute	| oldSize |	"checking size after is faster than includes test"	oldSize := self ids size.	(self ids		add: anID;		size) > oldSize		ifFalse: [			self				errorDuplicateID: anID				inAttribute: anAttribute].! !!XMLElementIDValidator methodsFor: 'validating'!validateXMLID: anID	anID isXMLNCName		ifFalse: [			self				errorInvalidID: anID				inAttribute: 'xml:id'].	self		validateUniquenessOfID: anID		inAttribute: 'xml:id'.! !!XMLElementNester methodsFor: 'private'!copiedScopedAttributes	| copiedAttributes |	copiedAttributes :=		self hasScopedAttributes			ifTrue: [self scopedAttributes removeLast copy]			ifFalse: [Dictionary new].	self scopedAttributes addLast: copiedAttributes.	^ copiedAttributes.! !!XMLElementNester methodsFor: 'accessing'!currentElement	^ self openElements xmlLastOrNil! !!XMLElementNester methodsFor: 'accessing'!currentElement: anElement	self hasOpenElements		ifTrue: [			self openElements				at: self totalOpenElements				put: anElement]		ifFalse: [self setExternalRootElement: anElement]! !!XMLElementNester methodsFor: 'accessing'!currentScopedAttributes	^ self scopedAttributes xmlLastOrNil! !!XMLElementNester methodsFor: 'private'!elementPrintLimit	^ 5! !!XMLElementNester methodsFor: 'nesting'!endCurrentElement	(self openElements		removeLast;		size) > 0		ifFalse: [			isInElement := hasExternalRootElement.			wasRootElementEnded := hasExternalRootElement not].	self hasScopedAttributes		ifTrue: [self endScopedAttributes].! !!XMLElementNester methodsFor: 'private'!endScopedAttributes	scopedAttributes removeLast! !!XMLElementNester methodsFor: 'testing'!hasExternalRootElement	^ hasExternalRootElement! !!XMLElementNester methodsFor: 'testing'!hasOpenElement: anElement	^ self openElements includes: anElement! !!XMLElementNester methodsFor: 'testing'!hasOpenElements	^ self openElements size > 0! !!XMLElementNester methodsFor: 'testing'!hasScopedAttributes	"optimized to avoid lazy initialization"	scopedAttributes == nil		ifTrue: [^ false].	^ scopedAttributes size > 0.! !!XMLElementNester methodsFor: 'initialization'!initialize	super initialize.	openElements := OrderedCollection new: 10.	hasExternalRootElement := false.	wasRootElementEnded := false.	isInElement := false.! !!XMLElementNester methodsFor: 'testing'!isInElement	^ isInElement! !!XMLElementNester methodsFor: 'accessing'!openElements	^ openElements! !!XMLElementNester methodsFor: 'enumerating'!openElementsDo: aBlock	self openElements do: aBlock! !!XMLElementNester methodsFor: 'enumerating'!openElementsReverseDo: aBlock	"implemented for XMLParserHTML so it's always safe to remove at	the end while scanning backwards"	self openElements size to: 1 by: -1 do: [:i |			aBlock value: (self openElements at: i)]! !!XMLElementNester methodsFor: 'printing'!printElementsOn: aStream	self		printElementsStartingAt: 1		on: aStream! !!XMLElementNester methodsFor: 'printing'!printElementsStartingAt: aStart on: aStream	self		printElementsStartingAt: aStart		stoppingAt: aStart + self elementPrintLimit - 1		on: aStream! !!XMLElementNester methodsFor: 'printing'!printElementsStartingAt: aStart stoppingAt: aStop on: aStream	aStart		to: (aStop min: self openElements size)		do: [:i |			i > aStart				ifTrue: [aStream nextPutAll: ', '].			aStream				nextPut: $<;				nextPutAll: (self openElements at: i);				nextPut: $>].	(aStop < self openElements size)		ifTrue: [aStream nextPutAll: '...'].! !!XMLElementNester methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	self hasOpenElements		ifTrue: [			aStream nextPut: $(.			self				printElementsStartingAt: 1				on: aStream.			aStream nextPut: $)].! !!XMLElementNester methodsFor: 'printing'!printedElements	^ String streamContents: [:stream | self printElementsOn: stream]! !!XMLElementNester methodsFor: 'printing'!printedElementsEnclosedBy: anElement	^ String streamContents: [:stream |		self			printElementsStartingAt: (self openElements lastIndexOf: anElement) + 1			on: stream]! !!XMLElementNester methodsFor: 'accessing'!rootElement	^ rootElement! !!XMLElementNester methodsFor: 'accessing'!scopedAttributeAt: anAttribute	^ self		scopedAttributeAt: anAttribute		ifAbsent: ['']! !!XMLElementNester methodsFor: 'accessing'!scopedAttributeAt: anAttribute ifAbsent: aBlock	^ self currentScopedAttributes		ifNil: [aBlock value]		ifNotNil: [:attributes |			attributes				at: anAttribute				ifAbsent: aBlock]! !!XMLElementNester methodsFor: 'private'!scopedAttributes	^ scopedAttributes ifNil: [scopedAttributes := OrderedCollection new]! !!XMLElementNester methodsFor: 'accessing'!setExternalRootElement: anElement	rootElement := anElement.	hasExternalRootElement := true.	isInElement := true.! !!XMLElementNester methodsFor: 'accessing'!setScopedAttributesNamed: anAttributeCollection from: aDictionary	| attributes |	anAttributeCollection do: [:each |		aDictionary			at: each			ifPresent: [:value |				"used to copy only once if needed"				(attributes ifNil: [attributes := self copiedScopedAttributes])					at: each					put: value]]! !!XMLElementNester methodsFor: 'nesting'!startElement: anElement	self openElements addLast: anElement.	isInElement		ifFalse: [			isInElement := true.			rootElement				ifNil: [rootElement := anElement]].	self hasScopedAttributes		ifTrue: [self startScopedAttributes].! !!XMLElementNester methodsFor: 'private'!startScopedAttributes	scopedAttributes addLast: self currentScopedAttributes! !!XMLElementNester methodsFor: 'accessing'!totalOpenElements	^ self openElements size! !!XMLElementNester methodsFor: 'testing'!wasRootElementEnded	^ wasRootElementEnded! !!XMLAnyElementValidator methodsFor: 'testing'!atEnd	^ true! !!XMLAnyElementValidator methodsFor: 'testing'!isAny	^ true! !!XMLAnyElementValidator methodsFor: 'defaults'!typeName	^ 'ANY'! !!XMLDFAElementContentElementValidator methodsFor: 'testing'!ignoresWhitespace	^ true! !!XMLDFAElementContentElementValidator methodsFor: 'testing'!isElementContent	^ true! !!XMLDFAElementContentElementValidator methodsFor: 'defaults'!typeName	^ 'element content'! !!XMLDFAElementContentElementValidator methodsFor: 'validating'!validatePCData: aString	self errorUnexpectedPCData! !!XMLStandaloneExternalDFAElementContentElementValidator methodsFor: 'testing'!ignoresWhitespace	^ false! !!XMLDFAElementValidator class methodsFor: 'instance creation'!element: anElement dfa: aDFA	^ self new		setElement: anElement		dfa: aDFA! !!XMLDFAElementValidator methodsFor: 'converting'!asReadyElementValidator	^ self copy! !!XMLDFAElementValidator methodsFor: 'testing'!atEnd	^ currentState isAccepting! !!XMLDFAElementValidator methodsFor: 'accessing'!currentState	^ currentState! !!XMLDFAElementValidator methodsFor: 'accessing'!dfa	^ dfa! !!XMLDFAElementValidator methodsFor: 'private'!errorNonDeterminismInContentModelAfter: anElement	XMLValidationException		formatSignal:			'Content model for <{1}> becomes non-deterministic after <{2}>. ',			'Rewrite it deterministically; for example "{3}" instead ',			'of "{4}"'		with: self element		with: anElement		with: '(a,(b|c))'		with: '((a,b)|(a,c))'! !!XMLDFAElementValidator methodsFor: 'copying'!postCopy	currentState := dfa! !!XMLDFAElementValidator methodsFor: 'initialization'!setElement: anElement dfa: aDFA	element := anElement.	dfa := aDFA.	currentState := aDFA.! !!XMLDFAElementValidator methodsFor: 'validating'!validateStartTag: anElement	currentState :=		currentState			nextDFAStateMatching: anElement			ifNone: [self errorUnexpectedElement: anElement].	currentState hasNonDeterminism		ifTrue: [self errorNonDeterminismInContentModelAfter: anElement].! !!XMLElementValidator class methodsFor: 'instance creation'!element: anElement	^ self new element: anElement! !!XMLElementValidator methodsFor: 'converting'!asReadyElementValidator	^ self! !!XMLElementValidator methodsFor: 'testing'!atEnd	self subclassResponsibility! !!XMLElementValidator methodsFor: 'accessing'!element	^ element! !!XMLElementValidator methodsFor: 'accessing'!element: anElement	element := anElement! !!XMLElementValidator methodsFor: 'private'!errorUnexpected: aDescription	XMLValidationException		formatSignal: 'Unexpected {1} in {2} type element <{3}>'		with: aDescription		with: self typeName		with: self element! !!XMLElementValidator methodsFor: 'private'!errorUnexpectedComment	^ self errorUnexpected: 'comment'! !!XMLElementValidator methodsFor: 'private'!errorUnexpectedElement: anElement	XMLValidationException		formatSignal: 'Unexpected <{1}> element in {2} type element <{3}>'		with: anElement		with: self typeName		with: self element! !!XMLElementValidator methodsFor: 'private'!errorUnexpectedPCData	^ self errorUnexpected: 'PCDATA'! !!XMLElementValidator methodsFor: 'private'!errorUnexpectedPI	^ self errorUnexpected: 'processing instruction'! !!XMLElementValidator methodsFor: 'testing'!ignoresWhitespace	^ false! !!XMLElementValidator methodsFor: 'testing'!isAny	^ false! !!XMLElementValidator methodsFor: 'testing'!isElementContent	^ false! !!XMLElementValidator methodsFor: 'testing'!isEmpty	^ false! !!XMLElementValidator methodsFor: 'testing'!isMixedContent	^ false! !!XMLElementValidator methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: '(<';		nextPutAll: self element;		nextPutAll: '>)'.! !!XMLElementValidator methodsFor: 'defaults'!typeName	self subclassResponsibility! !!XMLElementValidator methodsFor: 'validating'!validateComment: aString! !!XMLElementValidator methodsFor: 'validating'!validateElementDeclaration! !!XMLElementValidator methodsFor: 'validating'!validatePCData: aString! !!XMLElementValidator methodsFor: 'validating'!validatePI: aTargetString data: aDataString! !!XMLElementValidator methodsFor: 'validating'!validateStartTag: anElement! !!XMLEmptyElementValidator methodsFor: 'testing'!atEnd	^ true! !!XMLEmptyElementValidator methodsFor: 'testing'!isEmpty	^ true! !!XMLEmptyElementValidator methodsFor: 'defaults'!typeName	^ 'EMPTY'! !!XMLEmptyElementValidator methodsFor: 'validating'!validateComment: aString	self errorUnexpectedComment! !!XMLEmptyElementValidator methodsFor: 'validating'!validatePCData: aString	self errorUnexpectedPCData! !!XMLEmptyElementValidator methodsFor: 'validating'!validatePI: aTargetString data: aDataString	self errorUnexpectedPI! !!XMLEmptyElementValidator methodsFor: 'validating'!validateStartTag: anElement	self errorUnexpectedElement: anElement! !!XMLMixedContentElementValidator class methodsFor: 'instance creation'!element: anElement allowedContent: anAllowedContentCollection	^ self new		setElement: anElement		allowedContent: anAllowedContentCollection! !!XMLMixedContentElementValidator methodsFor: 'accessing'!allowedContent	^ allowedContent! !!XMLMixedContentElementValidator methodsFor: 'accessing'!allowedContent: anAllowedContentCollection	allowedContent := anAllowedContentCollection! !!XMLMixedContentElementValidator methodsFor: 'testing'!atEnd	^ true! !!XMLMixedContentElementValidator methodsFor: 'private'!errorContentContainsDuplicates	XMLValidationException		formatSignal:			'Declaration for mixed content element <{1}> contains duplicate names'		with: self element! !!XMLMixedContentElementValidator methodsFor: 'testing'!isMixedContent	^ true! !!XMLMixedContentElementValidator methodsFor: 'initialization'!setElement: anElement allowedContent: anAllowedContentCollection	element := anElement.	allowedContent := anAllowedContentCollection.! !!XMLMixedContentElementValidator methodsFor: 'defaults'!typeName	^ 'mixed content'! !!XMLMixedContentElementValidator methodsFor: 'validating'!validateElementDeclaration	| oldAllowedContentCollection |	oldAllowedContentCollection := self allowedContent.	self allowedContent: oldAllowedContentCollection asSet.	(self allowedContent size < oldAllowedContentCollection size)		ifTrue: [self errorContentContainsDuplicates].! !!XMLMixedContentElementValidator methodsFor: 'validating'!validateStartTag: anElement	(self allowedContent includes: anElement)		ifFalse: [self errorUnexpectedElement: anElement]	! !!XMLEncodingDetector class methodsFor: 'class initialization'!initialize	"self initialize"	"stored in class vars for faster access"	UTF8BOMBytes :=		XMLUTF8StreamConverter byteOrderMarkBytes.	UTF16BigEndianBOMBytes :=		XMLUTF16BigEndianStreamConverter byteOrderMarkBytes.	UTF32BigEndianBOMBytes :=		XMLUTF32BigEndianStreamConverter byteOrderMarkBytes.	UTF32LittleEndianBOMBytes :=		XMLUTF32LittleEndianStreamConverter byteOrderMarkBytes.! !!XMLEncodingDetector class methodsFor: 'instance creation'!on: aStream	^ self new on: aStream! !!XMLEncodingDetector methodsFor: 'private'!atEnd	^ stream atEnd! !!XMLEncodingDetector methodsFor: 'private'!detectBigEndianUTF16BOM	2 to: UTF16BigEndianBOMBytes size do: [:i |		self next == (UTF16BigEndianBOMBytes at: i)			ifFalse: [				self resetStreamToStartPosition.				"no legal UTF-8 byte sequence begins with 16rFE, and:					UTF16BigEndianBOMBytes first = 16rFE				so it can't be implicit UTF-8"				^ nil]].	^ XMLUTF16BigEndianStreamConverter new.! !!XMLEncodingDetector methodsFor: 'private'!detectBigEndianUTF32BOMOrImplicitEncoding	2 to: UTF32BigEndianBOMBytes size do: [:i |		self peek == (UTF32BigEndianBOMBytes at: i)			ifTrue: [self next]			ifFalse: [| implicitConverterClass |				self detectsImplicitEncodings					ifTrue: [						i = 2							ifTrue: [								"(UTF32BigEndianBOMBytes at: 1) isZero"								self peekForASCII									ifTrue: [										"null char followed by an ASCII char;										implicit UTF-16 BE"										implicitConverterClass :=											XMLImplicitUTF16BigEndianStreamConverter]]							ifFalse: [								i = 3									ifTrue: [										"(UTF32BigEndianBOMBytes at: 2) isZero"										(self peekForNull											and: [self peekForASCII]) 											ifTrue: [												"three null chars followed by an ASCII char;												implicit UTF-32 BE"												implicitConverterClass :=													XMLImplicitUTF32BigEndianStreamConverter]]].						(implicitConverterClass isNil							and: [self peekForUTF8LeadingByte])							ifTrue: [								"any number of null chars followed by a leading UTF-8								byte char; implicit UTF-8"								implicitConverterClass :=									XMLImplicitUTF8StreamConverter]].				self resetStreamToStartPosition.				^ implicitConverterClass					ifNotNil: [implicitConverterClass new]]].	^ XMLUTF32BigEndianStreamConverter new.! !!XMLEncodingDetector methodsFor: 'private'!detectLittleEndianImplicitEncoding	| implicitConverterClass |	self detectsImplicitEncodings		ifTrue: [			implicitConverterClass :=				self peekForNull					ifTrue: [								(self peekForNull							and: [self peekForNull])							ifTrue: [								"a leading ASCII char followed by three nulls;								implicit little endian UTF-32"								XMLImplicitUTF32LittleEndianStreamConverter]							ifFalse: [								"a leading ASCII char followed by just one null;								implicit little endian UTF-16"								XMLImplicitUTF16LittleEndianStreamConverter]]					ifFalse: [						"an ASCII char; assume it's UTF-8"						XMLImplicitUTF8StreamConverter]].	self resetStreamToStartPosition.	^ implicitConverterClass		ifNotNil: [implicitConverterClass new].! !!XMLEncodingDetector methodsFor: 'private'!detectLittleEndianUTF32Or16BOM	2 to: UTF32LittleEndianBOMBytes size do: [:i |		self peek == (UTF32LittleEndianBOMBytes at: i)			ifTrue: [self next]			ifFalse: [				i > 2					ifTrue: [						"the 2 byte UTF-16 BOM begins the 4 byte UTF-32 BOM:							UTF32LittleEndianBOMBytes beginsWith:								XMLUTF16LittleEndianStreamConverter byteOrderMarkBytes"						stream position: startPosition + 2.						^ XMLUTF16LittleEndianStreamConverter new]					ifFalse: [						self resetStreamToStartPosition.						"no legal UTF-8 byte sequence begins with 16rFF, and:							UTF32LittleEndianBOMBytes first = 16rFF						so it can't be implicit UTF-8"						^ nil]]].	^ XMLUTF32LittleEndianStreamConverter new.! !!XMLEncodingDetector methodsFor: 'private'!detectUTF8BOM	2 to: UTF8BOMBytes size do: [:i |		self peek == (UTF8BOMBytes at: i)			ifTrue: [self next]			ifFalse: [| implicitConverter |				(self detectsImplicitEncodings					and: [self peekForUTF8NonLeadingByte])					ifTrue: [implicitConverter := XMLImplicitUTF8StreamConverter new].				self resetStreamToStartPosition.				^ implicitConverter]].	^ XMLUTF8StreamConverter new.! !!XMLEncodingDetector methodsFor: 'testing'!detectsImplicitEncodings	^ false! !!XMLEncodingDetector methodsFor: 'private'!isUTF8LeadingByte: aByte	^ aByte < 16r80		or: [aByte < 16rF8			and: [(aByte bitAnd: 16rE0) == 16rC0				or: [(aByte bitAnd: 16rF0) == 16rE0					or: [(aByte bitAnd: 16rF8) == 16rF0]]]]! !!XMLEncodingDetector methodsFor: 'private'!next	stream atEnd		ifTrue: [^ nil]		ifFalse: [^ stream next asInteger]! !!XMLEncodingDetector methodsFor: 'initialization'!on: aStream	stream := aStream.	startPosition := aStream position.! !!XMLEncodingDetector methodsFor: 'private'!peek	stream atEnd		ifTrue: [^ nil]		ifFalse: [^ stream peek asInteger]! !!XMLEncodingDetector methodsFor: 'private'!peekForASCII	| byte |	((byte := self peek) notNil		and: [byte < 16r80])		ifTrue: [			self next.			^ true]		ifFalse: [^ false]! !!XMLEncodingDetector methodsFor: 'private'!peekForNull	self peek == 0		ifTrue: [			self next.			^ true]		ifFalse: [^ false]! !!XMLEncodingDetector methodsFor: 'private'!peekForUTF8LeadingByte	| byte |	((byte := self peek) notNil		and: [self isUTF8LeadingByte: byte])		ifTrue: [			self next.			^ true]		ifFalse: [^ false]! !!XMLEncodingDetector methodsFor: 'private'!peekForUTF8NonLeadingByte	| byte |	((byte := self peek) notNil		and: [byte < 16rC0			and: [byte > 16r80]])		ifTrue: [			self next.			^ true]		ifFalse: [^ false]! !!XMLEncodingDetector methodsFor: 'private'!resetStreamToStartPosition	stream position: startPosition! !!XMLEncodingDetector methodsFor: 'detecting'!streamConverterForEncoding	| byte |	(byte := self next)		ifNil: [^ nil].	byte == 0		ifTrue: [^ self detectBigEndianUTF32BOMOrImplicitEncoding].	byte < 16r80		ifTrue: [^ self detectLittleEndianImplicitEncoding].	"(UTF8BOMBytes at: 1) >= 16r80"	byte == (UTF8BOMBytes at: 1)		ifTrue: [^ self detectUTF8BOM].	"(UTF16BigEndianBOMBytes at: 1) >= 16r80"	byte == (UTF16BigEndianBOMBytes at: 1)		ifTrue: [^ self detectBigEndianUTF16BOM].	"(UTF32LittleEndianBOMBytes at: 1) >= 16r80"	byte == (UTF32LittleEndianBOMBytes at: 1)		ifTrue: [^ self detectLittleEndianUTF32Or16BOM].	self resetStreamToStartPosition.	^ (self detectsImplicitEncodings		and: [self isUTF8LeadingByte: byte])		ifTrue: [XMLImplicitUTF8StreamConverter new]		ifFalse: [nil].! !!XMLImplicitEncodingDetector methodsFor: 'testing'!detectsImplicitEncodings	^ true! !!XMLHTTPDecompressingReadStreamAdapterFactory class methodsFor: 'basic'!basicCanDecompressCompression: aCompressionScheme	^ self compressionScheme = aCompressionScheme		and: [self isSupportedImplementation]! !!XMLHTTPDecompressingReadStreamAdapterFactory class methodsFor: 'testing'!canDecompressCompression: aCompressionScheme	^ self basicCanDecompressCompression: aCompressionScheme asLowercase! !!XMLHTTPDecompressingReadStreamAdapterFactory class methodsFor: 'accessing'!classForCompression: aCompressionScheme	| lowercaseCompressionScheme |	lowercaseCompressionScheme := aCompressionScheme asLowercase.	self allSubclassesDo: [:each |		(each basicCanDecompressCompression: lowercaseCompressionScheme)			ifTrue: [^ each]].	^ nil.! !!XMLHTTPDecompressingReadStreamAdapterFactory class methodsFor: 'accessing'!compressionScheme	self subclassResponsibility! !!XMLHTTPDecompressingReadStreamAdapterFactory class methodsFor: 'accessing'!decompressingReadStreamAdapterClass	self subclassResponsibility! !!XMLHTTPDecompressingReadStreamAdapterFactory class methodsFor: 'private '!errorUnsupportedCompression: aCompressionScheme	XMLHTTPException		formatSignal: 'Unsupported compression scheme "{1}" for HTTP content'		with: aCompressionScheme! !!XMLHTTPDecompressingReadStreamAdapterFactory class methodsFor: 'testing'!isSupportedImplementation	^ self decompressingReadStreamAdapterClass notNil! !!XMLHTTPDecompressingReadStreamAdapterFactory class methodsFor: 'instance creation'!on: aReadStream	^ self decompressingReadStreamAdapterClass on: aReadStream! !!XMLHTTPDecompressingReadStreamAdapterFactory class methodsFor: 'instance creation'!on: aReadStream compression: aCompressionScheme	^ (self classForCompression: aCompressionScheme)		ifNil: [self errorUnsupportedCompression: aCompressionScheme]		ifNotNil: [:classForCompression |			classForCompression on: aReadStream]! !!XMLHTTPDecompressingReadStreamAdapterFactory class methodsFor: 'accessing'!supportedCompressionSchemes	| supportedCompressionSchemes |	supportedCompressionSchemes := OrderedCollection new.	self allSubclassesDo: [:each |		each isSupportedImplementation			ifTrue: [supportedCompressionSchemes addLast: each compressionScheme]].	^ supportedCompressionSchemes.! !!XMLHTTPGZipDecompressingReadStreamAdapterFactory class methodsFor: 'accessing'!compressionScheme	^ 'gzip'! !!XMLHTTPGZipDecompressingReadStreamAdapterFactory class methodsFor: 'accessing'!decompressingReadStreamAdapterClass	^ XMLClassFinder classNamed: #GZipReadStream! !!XMLHTTPMIMEType class methodsFor: 'defaults'!defaultCharset	^ 'ISO-8859-1'! !!XMLHTTPMIMEType class methodsFor: 'instance creation'!fromString: aString	| parser |	parser := XMLHTTPMIMETypeParser on: aString.	^ self new		setMainType: parser parseMainType		subType: parser parseSubType		parameters: parser parseParameters.! !!XMLHTTPMIMEType class methodsFor: 'instance creation'!mainType: aMainType subType: aSubType	^ self		mainType: aMainType		subType: aSubType		parameters: #()! !!XMLHTTPMIMEType class methodsFor: 'instance creation'!mainType: aMainType subType: aSubType parameters: anAssociationCollection	| parameters attributes totalAttributes |	"convert the parameters to an OrderedCollection of attribute=value	associations, ignoring duplicate attributes"	parameters := OrderedCollection new: anAssociationCollection size.	totalAttributes := 0.	anAssociationCollection associationsDo: [:each | | attribute |		attribute := each key asLowercase.		"only initialize if needed"		((attributes ifNil: [attributes := Set new])			add: attribute;			size) > totalAttributes			ifTrue: [				parameters addLast: attribute -> each value.				totalAttributes := totalAttributes + 1]].	^ self new		setMainType: aMainType asLowercase		subType: aSubType asLowercase		parameters: parameters.! !!XMLHTTPMIMEType methodsFor: 'comparing'!= anObject	self == anObject		ifTrue: [^ true].	self species == anObject species		ifFalse: [^ false].	^ self mainType = anObject mainType		and: [self subType = anObject subType			and: [self parameters size = anObject parameters size				and: [					"order is irrelevant according to the spec"					self parameters asSet = anObject parameters asSet]]].! !!XMLHTTPMIMEType methodsFor: 'converting'!asString	"don't assume Object>>#asString is defined, for portability"	^ self printString! !!XMLHTTPMIMEType methodsFor: 'accessing'!charset	^ self		parameterAt: 'charset'		ifAbsent: [self defaultCharset]! !!XMLHTTPMIMEType methodsFor: 'defaults'!defaultCharset	^ self class defaultCharset! !!XMLHTTPMIMEType methodsFor: 'comparing'!hash	^ self species hash bitXor:		(self mainType hash bitXor:			(self subType hash bitXor:				"OrderedCollection>>#hash depends on order (and even if it				didn't, assuming it wouldn't in the future is too risky),				so instead the size is hashed"				self parameters size hash))! !!XMLHTTPMIMEType methodsFor: 'accessing'!mainType	^ mainType! !!XMLHTTPMIMEType methodsFor: 'accessing'!parameterAt: aKey	^ self		parameterAt: aKey		ifAbsent: ['']! !!XMLHTTPMIMEType methodsFor: 'accessing'!parameterAt: aKey ifAbsent: aBlock	self parameterKeysAndValuesDo: [:key :value |		key = aKey			ifTrue: [^ value]].	^ aBlock value.! !!XMLHTTPMIMEType methodsFor: 'enumerating'!parameterKeysAndValuesDo: aTwoArgumentBlock	self parameters do: [:each |		aTwoArgumentBlock			value: each key			value: each value]! !!XMLHTTPMIMEType methodsFor: 'enumerating'!parameterKeysDo: aBlock	self parameters do: [:each |		aBlock value: each key]! !!XMLHTTPMIMEType methodsFor: 'private'!parameters	^ parameters! !!XMLHTTPMIMEType methodsFor: 'printing'!printOn: aStream	aStream		nextPutAll: self mainType;		nextPut: $/;		nextPutAll: self subType.	self parameterKeysAndValuesDo: [:key :value |		aStream			nextPutAll: '; ';			nextPutAll: key;			nextPut: $=;			nextPutAll: value].! !!XMLHTTPMIMEType methodsFor: 'initialization'!setMainType: aMainType subType: aSubType parameters: aParameterCollection	mainType := aMainType.	subType := aSubType.	parameters := aParameterCollection.! !!XMLHTTPMIMEType methodsFor: 'accessing'!subType	^ subType! !!XMLHTTPResponseContentReader class methodsFor: 'accessing'!response: aResponse	^ self new setResponse: aResponse! !!XMLHTTPResponseContentReader methodsFor: 'private'!contentReadStreamUpToEnd	| contentWriteStream |	contentWriteStream := self newContentWriteStream.	[contentReadStream atEnd]		whileFalse: [contentWriteStream nextPut: contentReadStream next].	^ contentWriteStream contents.! !!XMLHTTPResponseContentReader methodsFor: 'private'!decodedContentReadStreamUpToEndWithCharset: aCharset	| streamConverter |	(streamConverter := aCharset asXMLStreamConverter) isNull		ifTrue: [self errorUnrecognizedContentTypeCharset: aCharset].	contentReadStream :=		XMLDecodingReadStreamAdapter			on: contentReadStream			streamConverter: streamConverter.	[^ self contentReadStreamUpToEnd]		on: XMLEncodingException		do: [:error |			"might actually be a limit exception"			self ensureContentReadStreamWasNotLimited.			error pass].! !!XMLHTTPResponseContentReader methodsFor: 'private'!ensureContentReadStreamWasNotLimited	(limitedContentReadStream notNil		and: [limitedContentReadStream atLimitedEnd])		ifTrue: [self errorContentLimitExceeded]! !!XMLHTTPResponseContentReader methodsFor: 'private'!errorContentLimitExceeded	XMLLimitException signal: 'HTTP reponse content limit exceeded'! !!XMLHTTPResponseContentReader methodsFor: 'private'!errorUnrecognizedContentTypeCharset: aCharset	XMLEncodingException		formatSignal:			'Unrecognized Content-Type charset "{1}" encoding for HTTP content'		with: aCharset! !!XMLHTTPResponseContentReader methodsFor: 'testing'!handlesDecompression	^ false! !!XMLHTTPResponseContentReader methodsFor: 'initialization'!initializeDecompressionWithSchemes: aCompressionSchemeSequence upToLimit: aMaxSize	isDecompressing := true.	aCompressionSchemeSequence reverseDo: [:each |		contentReadStream :=			XMLHTTPDecompressingReadStreamAdapterFactory				on: contentReadStream				compression: each].	aMaxSize		ifNotNil: [self limitContentReadStreamUpToLimit: aMaxSize].! !!XMLHTTPResponseContentReader methodsFor: 'accessing'!limitContentReadStreamUpToLimit: aMaxSize	limitedContentReadStream :=		XMLLimitedReadStreamAdapter			on: contentReadStream			limit: aMaxSize.	contentReadStream := limitedContentReadStream.! !!XMLHTTPResponseContentReader methodsFor: 'instance creation'!newContentWriteStream	^ (String new: rawContent size) writeStream! !!XMLHTTPResponseContentReader methodsFor: 'reading'!rawReadWithLength: aContentLength upToLimit: aMaxSize	self subclassResponsibility! !!XMLHTTPResponseContentReader methodsFor: 'reading'!readUpToLimit: aMaxSize decoding: aBoolean	| contentLength contentType compressionSchemes charset content |	contentLength := response contentLength.	(response isChunked		or: [contentLength isNil])		ifTrue: [contentLength := nil]		ifFalse: [			contentLength > 0				ifFalse: [^ ''].			(aMaxSize notNil				and: [contentLength > aMaxSize])				ifTrue: [self errorContentLimitExceeded]].	rawContent :=		self			rawReadWithLength: contentLength			upToLimit: aMaxSize.	contentReadStream := rawContent readStream.	(self handlesDecompression		and: [(compressionSchemes := response contentEncoding) notEmpty])		ifTrue: [			self				initializeDecompressionWithSchemes: compressionSchemes				upToLimit: aMaxSize].	(aBoolean		and: [(contentType := response contentType) notNil			and: [(charset := contentType charset) ~= contentType defaultCharset]])		ifTrue: [			content := self decodedContentReadStreamUpToEndWithCharset: charset]		ifFalse: [			content := self undecodedContentReadStreamUpToEnd].	self ensureContentReadStreamWasNotLimited.	^ content.! !!XMLHTTPResponseContentReader methodsFor: 'initialization'!setResponse: aResponse	response := aResponse.	isDecompressing := false.! !!XMLHTTPResponseContentReader methodsFor: 'streaming'!undecodedContentReadStreamUpToEnd	^ (isDecompressing		or: [limitedContentReadStream notNil])		ifTrue: [self contentReadStreamUpToEnd]		ifFalse: [rawContent]! !!XMLHTTPWebClientResponseContentReader methodsFor: 'testing'!handlesDecompression	"this class needs to handle decompression, since it uses the lower-level	WebClient #streamFrom:to:size:progress: interface"	^ true! !!XMLHTTPWebClientResponseContentReader methodsFor: 'reading'!rawReadWithLength: aContentLength upToLimit: aMaxSize	| socketStream rawContentWriteStream |	(socketStream := response webClientResponse stream) binary.	rawContentWriteStream :=		(ByteArray new:			(aContentLength				ifNil: [aMaxSize					ifNil: [4096]])) writeStream.	response webClientResponse		streamFrom: socketStream		to: rawContentWriteStream		size: aContentLength		progress:			((aContentLength isNil				and: [aMaxSize notNil])				ifTrue: [					[:ignored :total |						total > aMaxSize							ifTrue: [self errorContentLimitExceeded]]]				ifFalse: [nil]).	^ rawContentWriteStream contents.! !!XMLHTTPZincResponseContentReader methodsFor: 'reading'!rawReadWithLength: aContentLength upToLimit: aMaxSize	^ [| entityStream |		(entityStream := response zincResponse entity stream) binary.		ZnUtils			readUpToEnd: entityStream			limit: aMaxSize]		on: ZnEntityTooLarge		do: [:error | self errorContentLimitExceeded]! !!XMLIntegerReader class methodsFor: 'class initialization'!initialize	"self initialize"	self initializeCharacterDigitValues! !!XMLIntegerReader class methodsFor: 'class initialization'!initializeCharacterDigitValues	| temp |	"use an array instead of a dictionary for speed, and use a temp	to fully initialize it before assignment to avoid possible race	conditions during class reinitialization"	temp := Array new: 255.	#(#($0 $9 0) #($a $f 10) #($A $Z 10)) do: [:each |		| firstDigitValue lastDigitValue baseValue |		firstDigitValue := each first asciiValue.		lastDigitValue := each second asciiValue.		baseValue := each third.		firstDigitValue			to: lastDigitValue			do: [:i |				temp					at: i					put: i - firstDigitValue + baseValue]].	CharacterDigitValues := temp.! !!XMLIntegerReader class methodsFor: 'defaults'!maxBase	^ 16! !!XMLIntegerReader class methodsFor: 'defaults'!maxIntegerValue	^ nil! !!XMLIntegerReader class methodsFor: 'instance creation'!on: aStringOrStream	^ self new on: aStringOrStream! !!XMLIntegerReader class methodsFor: 'instance creation'!readFrom: aStream	^ (self on: aStream) nextInteger! !!XMLIntegerReader class methodsFor: 'reading'!readFrom: aStream withBase: aBase	^ (self on: aStream) nextIntegerWithBase: aBase! !!XMLIntegerReader class methodsFor: 'reading'!readFrom: aStream withBase: aFirstBase andPrefixes: aCharacterCollection orBase: aSecondBase	^ (self on: aStream)		nextIntegerWithBase: aFirstBase		andPrefixes: aCharacterCollection		orBase: aSecondBase! !!XMLIntegerReader class methodsFor: 'reading'!readFrom: aStream withBase: aFirstBase andPrefixes: aCharacterCollection orBase: aSecondBase upToLimit: aReadLimit	^ (self on: aStream)		nextIntegerWithBase: aFirstBase		andPrefixes: aCharacterCollection		orBase: aSecondBase		upToLimit: aReadLimit! !!XMLIntegerReader class methodsFor: 'reading'!readFrom: aStream withBase: aBase upToLimit: aReadLimit	^ (self on: aStream)		nextIntegerWithBase: aBase		upToLimit: aReadLimit! !!XMLIntegerReader methodsFor: 'testing'!atEnd	^ readStream atEnd! !!XMLIntegerReader methodsFor: 'private'!errorUnsupportedBase: aBase	Error signal: 'Unsupported base ', aBase printString! !!XMLIntegerReader methodsFor: 'private'!next	| nextChar |	self atEnd		ifFalse: [			nextChar := readStream next.			printStream				ifNotNil: [printStream nextPut: nextChar]].	^ nextChar.! !!XMLIntegerReader methodsFor: 'private'!nextDigitWithBase: aBase	| asciiValue digit |	((asciiValue := self peek asciiValue) > 0		and: [asciiValue <= CharacterDigitValues size			and: [(digit := CharacterDigitValues at: asciiValue) notNil				and: [digit < aBase]]])				ifTrue: [					self next.					^ digit]				ifFalse: [^ nil]! !!XMLIntegerReader methodsFor: 'reading'!nextInteger	^ self nextIntegerWithBase: 10! !!XMLIntegerReader methodsFor: 'reading'!nextIntegerWithBase: aBase	^ self		nextIntegerWithBase: aBase		upToLimit: nil! !!XMLIntegerReader methodsFor: 'reading'!nextIntegerWithBase: aFirstBase andPrefixes: aCharacterCollection orBase: aSecondBase	^ self		nextIntegerWithBase: aFirstBase		andPrefixes: aCharacterCollection		orBase: aSecondBase		upToLimit: nil! !!XMLIntegerReader methodsFor: 'reading'!nextIntegerWithBase: aFirstBase andPrefixes: aCharacterCollection orBase: aSecondBase upToLimit: aReadLimit	^ self		nextIntegerWithBase:			((self atEnd not				and: [aCharacterCollection includes: self peek])				ifTrue: [					self next.					aFirstBase]				ifFalse: [aSecondBase])		upToLimit: aReadLimit! !!XMLIntegerReader methodsFor: 'reading'!nextIntegerWithBase: aBase upToLimit: aReadLimit	| integer maxValue maxBaseValue digitValue readLimit |	(aBase > 1		and: [aBase <= self class maxBase])		ifFalse: [self errorUnsupportedBase: aBase].	self class maxIntegerValue		ifNotNil: [:maxIntegerValue |			maxValue := maxIntegerValue.			maxBaseValue := (maxValue / aBase) floor].	readLimit := aReadLimit.	[self atEnd		or: [(readLimit notNil and: [readLimit <= 0])			or: [(digitValue := self nextDigitWithBase: aBase) isNil]]]		whileFalse: [			integer				ifNil: [integer := 0].				maxBaseValue				ifNotNil: [					integer > maxBaseValue						ifTrue: [							self overflowed.							"handle overflow with saturation"							^ maxValue]].			integer := integer * aBase.			maxValue				ifNotNil: [					integer > (maxValue - digitValue)						ifTrue: [							self overflowed.							"handle overflow with saturation"							^ maxValue]].			integer := integer + digitValue.			readLimit				ifNotNil: [readLimit := readLimit - 1]].	^ integer.! !!XMLIntegerReader methodsFor: 'initialization'!on: aStringOrStream	readStream :=		aStringOrStream isStream			ifTrue: [aStringOrStream]			ifFalse: [aStringOrStream readStream]! !!XMLIntegerReader methodsFor: 'private'!overflowed	"can override to raise a warning or error"! !!XMLIntegerReader methodsFor: 'private'!peek	self atEnd		ifTrue: [^ nil]		ifFalse: [^ readStream peek]! !!XMLIntegerReader methodsFor: 'accessing'!printStream: aStream	printStream := aStream! !!XMLSmallIntegerReader class methodsFor: 'class initialization'!initialize	"self initialize"	SmallIntegerMaxValue := SmallInteger maxVal! !!XMLSmallIntegerReader class methodsFor: 'defaults'!maxIntegerValue	^ SmallIntegerMaxValue! !!XMLNFABuilder methodsFor: 'applying'!applyAccepting	| totalFragments |	(totalFragments := self totalFragments) > 0		ifTrue: [			1 to: totalFragments - 1 do: [:i |				self applyConcatenation].			self topFragment connectToState:				XMLNFAAcceptingState new]		ifFalse: [			self pushFragment:				(XMLNFAFragment firstState: XMLNFAAcceptingState new)]! !!XMLNFABuilder methodsFor: 'applying'!applyBranch	| leftFragment rightFragment branchState |	leftFragment := self popFragment.	rightFragment := self popFragment.	branchState :=		XMLNFABranchingState			leftBranch: leftFragment firstState			rightBranch: rightFragment firstState.	self pushFragment:		(XMLNFAFragment			firstState: branchState			terminalStates:				(leftFragment terminalStatesWithAllFrom: rightFragment)).! !!XMLNFABuilder methodsFor: 'applying'!applyConcatenation	| firstFragment secondFragment |	secondFragment := self popFragment.	firstFragment := self popFragment.	firstFragment connectToFragment: secondFragment.	self pushFragment: firstFragment.! !!XMLNFABuilder methodsFor: 'applying'!applyOptional	| optionalFragment branchingState |	optionalFragment := self popFragment.	branchingState :=		XMLNFABranchingState branch: optionalFragment firstState.	self pushFragment:		(XMLNFAFragment			firstState: branchingState			terminalStates:				(optionalFragment terminalStatesWith: branchingState))! !!XMLNFABuilder methodsFor: 'applying'!applyPlus	| plusFragment |	plusFragment := self topFragment.	plusFragment connectToState:		(XMLNFABranchingState branch: plusFragment firstState).! !!XMLNFABuilder methodsFor: 'applying'!applyStar	| branchState starFragment |	starFragment := self popFragment.	branchState := XMLNFABranchingState branch: starFragment firstState.	starFragment connectToState: branchState.	self pushFragment:		(XMLNFAFragment			firstState: branchState			terminalState: branchState).! !!XMLNFABuilder methodsFor: 'converting'!asAcceptingNFA	^ (self		applyAccepting;		popFragment) firstState! !!XMLNFABuilder methodsFor: 'private'!fragmentStack	^ fragmentStack! !!XMLNFABuilder methodsFor: 'testing'!hasFragments	^ self totalFragments > 0! !!XMLNFABuilder methodsFor: 'initialization'!initialize	super initialize.	fragmentStack := OrderedCollection new.! !!XMLNFABuilder methodsFor: 'accessing'!popFragment	^ self fragmentStack removeLast! !!XMLNFABuilder methodsFor: 'accessing'!pushFragment: aFragment	^ self fragmentStack addLast: aFragment! !!XMLNFABuilder methodsFor: 'accessing'!pushFragmentMatching: aMatcher	^ self pushFragment:		(XMLNFAFragment firstState:			(XMLNFAMatchingState matcher: aMatcher))! !!XMLNFABuilder methodsFor: 'accessing'!topFragment	^ self fragmentStack last! !!XMLNFABuilder methodsFor: 'accessing'!totalFragments	^ self fragmentStack size! !!XMLNFAFragment class methodsFor: 'instance creation'!firstState: aFirstState	^ self new		setFirstState: aFirstState		terminalStateOrStates: aFirstState! !!XMLNFAFragment class methodsFor: 'instance creation'!firstState: aFirstState terminalState: aTerminalState	^ self new		setFirstState: aFirstState		terminalStateOrStates: aTerminalState! !!XMLNFAFragment class methodsFor: 'instance creation'!firstState: aFirstState terminalStates: aTerminalStateCollection	^ self new		setFirstState: aFirstState		terminalStateOrStates: aTerminalStateCollection! !!XMLNFAFragment methodsFor: 'private'!connectTerminalStatesToState: aState	terminalStateOrStates isCollection		ifTrue: [			"use #to:do: for speed"			1 to: terminalStateOrStates size do: [:i |				(terminalStateOrStates at: i) connectToState: aState]]		ifFalse: [terminalStateOrStates connectToState: aState]! !!XMLNFAFragment methodsFor: 'connecting'!connectToFragment: aFragment	self connectTerminalStatesToState: aFragment firstState.	terminalStateOrStates := aFragment terminalStateOrStates.! !!XMLNFAFragment methodsFor: 'connecting'!connectToState: aState	self connectTerminalStatesToState: aState.	terminalStateOrStates := aState.! !!XMLNFAFragment methodsFor: 'accessing'!firstState	^ firstState! !!XMLNFAFragment methodsFor: 'accessing'!firstState: aFirstState	firstState := aFirstState! !!XMLNFAFragment methodsFor: 'private'!newTerminalStatesWith: aFirstTerminalState and: aSecondTerminalState	"avoid #with:with: to control the capacity"	^ (OrderedCollection new: 4)		addLast: aFirstTerminalState;		addLast: aSecondTerminalState;		yourself! !!XMLNFAFragment methodsFor: 'initialization'!setFirstState: aFirstState terminalStateOrStates: aTerminalStateOrStateCollection	firstState := aFirstState.	terminalStateOrStates := aTerminalStateOrStateCollection.! !!XMLNFAFragment methodsFor: 'accessing'!terminalState: aTerminalState	terminalStateOrStates := aTerminalState! !!XMLNFAFragment methodsFor: 'private'!terminalStateOrStates	^ terminalStateOrStates! !!XMLNFAFragment methodsFor: 'accessing'!terminalStates	^ terminalStateOrStates isCollection		ifTrue: [terminalStateOrStates]		ifFalse: [OrderedCollection with: terminalStateOrStates]! !!XMLNFAFragment methodsFor: 'accessing'!terminalStates: aTerminalStateCollection	terminalStateOrStates := aTerminalStateCollection! !!XMLNFAFragment methodsFor: 'private'!terminalStatesAddedTo: aTerminalStateCollection	terminalStateOrStates isCollection		ifTrue: [			"#to:do: for speed"			1 to: terminalStateOrStates size do: [:i |				aTerminalStateCollection addLast: (terminalStateOrStates at: i)]]		ifFalse: [aTerminalStateCollection addLast: terminalStateOrStates].	^ aTerminalStateCollection.! !!XMLNFAFragment methodsFor: 'converting'!terminalStatesWith: aTerminalState	terminalStateOrStates isCollection		ifTrue: [			terminalStateOrStates addLast: aTerminalState.			^ terminalStateOrStates]		ifFalse: [			^ self				newTerminalStatesWith: terminalStateOrStates				and: aTerminalState]! !!XMLNFAFragment methodsFor: 'converting'!terminalStatesWithAllFrom: aFragment	terminalStateOrStates isCollection		ifTrue: [^ aFragment terminalStatesAddedTo: terminalStateOrStates].	aFragment terminalStateOrStates isCollection		ifTrue: [^ self terminalStatesAddedTo: aFragment terminalStateOrStates].	^ self		newTerminalStatesWith: terminalStateOrStates		and: aFragment terminalStateOrStates.! !!XMLNFAAcceptingState methodsFor: 'testing'!isAccepting	^ true! !!XMLNFAAcceptingState methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self printLabelOn: aStream.	aStream nextPut: $).! !!XMLNFABranchingState class methodsFor: 'instance creation'!branch: aLeftBranch	^ self new		setLeftBranch: aLeftBranch		rightBranch: nil! !!XMLNFABranchingState class methodsFor: 'instance creation'!leftBranch: aLeftBranch rightBranch: aRightBranch	^ self new		setLeftBranch: aLeftBranch		rightBranch: aRightBranch! !!XMLNFABranchingState methodsFor: 'adding'!addTo: aStateSet	lastAddedTo == aStateSet		ifFalse: [			"to detect and handle cycles"			lastAddedTo := aStateSet.			"this is effectively a non-matching, non-accepting state			with epsilon transitions, so it can be skipped and its			branches can be followed (in other words, the epsilon			closure of this state, minus this state)"			leftBranch				ifNotNil: [leftBranch addTo: aStateSet].			rightBranch				ifNotNil: [rightBranch addTo: aStateSet]]! !!XMLNFABranchingState methodsFor: 'connecting'!connectToState: aState	leftBranch		ifNil: [leftBranch := aState].	rightBranch		ifNil: [rightBranch := aState].! !!XMLNFABranchingState methodsFor: 'accessing'!leftBranch	^ leftBranch! !!XMLNFABranchingState methodsFor: 'enumerating'!nextStatesDo: aBlock	leftBranch		ifNotNil: [aBlock value: leftBranch].	rightBranch		ifNotNil: [aBlock value: rightBranch].! !!XMLNFABranchingState methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self printLabelOn: aStream.	aStream nextPut: $(.	leftBranch		ifNotNil: [			leftBranch printLabelOn: aStream].	aStream nextPut: $|.	rightBranch		ifNotNil: [			rightBranch printLabelOn: aStream].	aStream nextPutAll: '))'.! !!XMLNFABranchingState methodsFor: 'accessing'!rightBranch	^ rightBranch! !!XMLNFABranchingState methodsFor: 'initialization'!setLeftBranch: aLeftBranch rightBranch: aRightBranch	leftBranch := aLeftBranch.	rightBranch := aRightBranch.! !!XMLNFAMatchingState class methodsFor: 'instance creation'!matcher: aMatcher	^ self new matcher: aMatcher! !!XMLNFAMatchingState methodsFor: 'connecting'!connectToState: aState	nextState		ifNil: [nextState := aState]! !!XMLNFAMatchingState methodsFor: 'accessing'!matcher	^ matcher! !!XMLNFAMatchingState methodsFor: 'accessing'!matcher: aMatcher	matcher := aMatcher! !!XMLNFAMatchingState methodsFor: 'testing'!matches: anObject	^ matcher = anObject! !!XMLNFAMatchingState methodsFor: 'accessing'!nextState	^ nextState! !!XMLNFAMatchingState methodsFor: 'enumerating'!nextStatesDo: aBlock	nextState		ifNotNil: [aBlock value: nextState]! !!XMLNFAMatchingState methodsFor: 'printing'!printLabelOn: aStream	aStream		print: self identityHash;		nextPut: $(;		print: matcher;		nextPut: $)! !!XMLNFAMatchingState methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self printLabelOn: aStream.	aStream nextPutAll: '->'.	nextState		ifNotNil: [			nextState printLabelOn: aStream].	aStream nextPut: $).! !!XMLNFAState methodsFor: 'adding'!addTo: aStateSet	lastAddedTo == aStateSet		ifFalse: [			"to detect and handle cycles"			lastAddedTo := aStateSet.			aStateSet add: self]! !!XMLNFAState methodsFor: 'converting'!asDFAState	| nfaStates |	nfaStates := XMLNFAStateSet new.	self addTo: nfaStates.	^ nfaStates asDFAState.! !!XMLNFAState methodsFor: 'connecting'!connectToState: aState! !!XMLNFAState methodsFor: 'testing'!isAccepting	^ false! !!XMLNFAState methodsFor: 'testing'!matches: anObject	^ false! !!XMLNFAState methodsFor: 'enumerating'!nextStatesDo: aBlock! !!XMLNFAState methodsFor: 'printing'!printLabelOn: aStream	aStream print: self identityHash! !!XMLNamespaceScope class methodsFor: 'defaults'!xmlNamespaceURI	^ 'http://www.w3.org/XML/1998/namespace'! !!XMLNamespaceScope class methodsFor: 'defaults'!xmlnsNamespaceURI	^ 'http://www.w3.org/2000/xmlns/'! !!XMLNamespaceScope methodsFor: 'comparing'!= anObject	self == anObject		ifTrue: [^ true].	self species == anObject species		ifFalse: [^ false].	self hasNamespaces		ifFalse: [^ anObject hasNamespaces not].	"use #hasNamespaces first to avoid initializing anObject's prefixMappings"	anObject hasNamespaces		ifFalse: [^ false].	^ prefixMappings = anObject prefixMappings.! !!XMLNamespaceScope methodsFor: 'private'!copiedPrefixMappings	"replaces current mappings with copy for copy-on-write"	prefixMappings		ifNil: [^ self prefixMappings]		ifNotNil: [^ prefixMappings := prefixMappings copy]! !!XMLNamespaceScope methodsFor: 'copying'!copy	"copy-on-write allows copies to share state so no postCopy is needed"	^ self shallowCopy! !!XMLNamespaceScope methodsFor: 'accessing'!defaultNamespace	^ prefixMappings		ifNil: ['']		ifNotNil: [			prefixMappings				at: ''				ifAbsent: ['']]! !!XMLNamespaceScope methodsFor: 'accessing'!defaultNamespace: aURI	self		validatePrefix: ''		beforeMappingTo: aURI.	"copy-on-write"	self copiedPrefixMappings		at: ''		put: aURI.! !!XMLNamespaceScope methodsFor: 'private'!errorAttribute: anAttribute aliasesURI: aURI	XMLNamespaceException		formatSignal: 'Attribute "{1}" has alias for namespace URI "{2}"'		with: anAttribute		with: aURI! !!XMLNamespaceScope methodsFor: 'private'!errorCannotAliasPrefix: aFirstPrefix with: aSecondPrefix	aSecondPrefix isEmpty		ifTrue: [			XMLNamespaceException				formatSignal:					'Cannot use the "{1}" namespace URI as a ',					'default namespace URI'				with: aFirstPrefix]		ifFalse: [			XMLNamespaceException				formatSignal:					'Cannot alias the "{1}" namespace URI ',					'with the "{2}" prefix'				with: aFirstPrefix				with: aSecondPrefix]! !!XMLNamespaceScope methodsFor: 'private'!errorCannotAliasXMLNSPrefixWith: aPrefix	self		errorCannotAliasPrefix: 'xmlns'		with: aPrefix! !!XMLNamespaceScope methodsFor: 'private'!errorCannotAliasXMLPrefixWith: aPrefix	self		errorCannotAliasPrefix: 'xml'		with: aPrefix! !!XMLNamespaceScope methodsFor: 'private'!errorCannotMapPrefixToEmptyURI	XMLNamespaceException signal: 'Cannot map namespace prefixes to empty URIs'! !!XMLNamespaceScope methodsFor: 'private'!errorCannotMapXMLNSPrefix	XMLNamespaceException signal:		'Cannot map "xmlns" prefix to any namespace, even the current "xmlns" namespace'! !!XMLNamespaceScope methodsFor: 'private'!errorCannotRemapXMLPrefix	XMLNamespaceException signal: 'Cannot map the "xml" prefix to a new namespace URI'! !!XMLNamespaceScope methodsFor: 'private'!errorCannotUnmapPrefix: aPrefix	XMLNamespaceException		formatSignal: 'Prefix "{1}" was not mapped and cannot be unmapped'		with: aPrefix! !!XMLNamespaceScope methodsFor: 'private'!errorInvalidPrefix: aPrefix		XMLNamespaceException		formatSignal: 'Prefix "{1}" contains ":" character'		with: aPrefix! !!XMLNamespaceScope methodsFor: 'private'!errorInvalidUnprefixedAttribute: anAttribute	XMLNamespaceException		formatSignal: 'Unprefixed attribute "{1}" contains ":" character'		with: anAttribute! !!XMLNamespaceScope methodsFor: 'private'!errorInvalidUnprefixedElement: anElement	XMLNamespaceException		formatSignal: 'Unprefixed element <{1}> contains ":" character'		with: anElement! !!XMLNamespaceScope methodsFor: 'private'!errorUnmappedPrefix: aPrefix inAttribute: anAttribute	XMLNamespaceException		formatSignal: 'Unmapped namespace prefix "{1}" in "{2}" attribute'		with: aPrefix		with: anAttribute! !!XMLNamespaceScope methodsFor: 'private'!errorUnmappedPrefix: aPrefix inElement: anElement	XMLNamespaceException		formatSignal: 'Unmapped namespace prefix "{1}" in <{2}> element'		with: aPrefix		with: anElement! !!XMLNamespaceScope methodsFor: 'private'!errorXMLNSPrefixInAttribute: anAttribute	XMLNamespaceException		formatSignal: 'Attribute "{1}" uses reserved "xmlns" namespace prefix'		with: anAttribute! !!XMLNamespaceScope methodsFor: 'private'!errorXMLNSPrefixInElement: anElement	XMLNamespaceException		formatSignal: 'Element <{1}> uses reserved "xmlns" namespace prefix'		with: anElement! !!XMLNamespaceScope methodsFor: 'testing'!hasDefaultNamespace	^ self includesPrefix: ''! !!XMLNamespaceScope methodsFor: 'testing'!hasNamespaces	"optimized to avoid lazy initialization"	prefixMappings == nil		ifTrue: [^ false].	^ prefixMappings size > 0.! !!XMLNamespaceScope methodsFor: 'comparing'!hash	self hasNamespaces		ifTrue: [^ self species hash bitXor: self prefixMappings hash]		ifFalse: [^ self species hash]! !!XMLNamespaceScope methodsFor: 'testing'!includesPrefix: aPrefix	self		prefixMappingAt: aPrefix		ifAbsent: [^ false].	^ true.! !!XMLNamespaceScope methodsFor: 'testing'!includesPrefix: aPrefix mappedTo: aURI	^ (self		prefixMappingAt: aPrefix		ifAbsent: [^ false]) = aURI! !!XMLNamespaceScope methodsFor: 'accessing'!inheritMappingsFrom: anEnclosingScope	anEnclosingScope hasNamespaces		ifFalse: [^ self].	self hasNamespaces		ifTrue: [| copiedPrefixMappings |			anEnclosingScope prefixesAndURIsDo: [:prefix :uri |				(self includesPrefix: prefix)					ifFalse: [						"nil test ensures we only copy the first time when needed"						(copiedPrefixMappings							ifNil: [copiedPrefixMappings := self copiedPrefixMappings])							at: prefix							put: uri]]]		ifFalse: [			"can safely share anEnclosingScope's prefixMappings because of			copy-on-write behavior"			prefixMappings := anEnclosingScope prefixMappings].! !!XMLNamespaceScope methodsFor: 'accessing'!mapPrefix: aPrefix to: aURI	self		validatePrefix: aPrefix		beforeMappingTo: aURI.	"copy-on-write"	self copiedPrefixMappings		at: aPrefix		put: aURI.! !!XMLNamespaceScope methodsFor: 'accessing'!mapPrefixesAndURIs: anAssociationCollection	| copiedPrefixMappings |	anAssociationCollection associationsDo: [:each |		self			validatePrefix: each key			beforeMappingTo: each value.		"nil test ensures we only copy the first time when needed"		(copiedPrefixMappings			ifNil: [copiedPrefixMappings := self copiedPrefixMappings])			at: each key			put: each value]! !!XMLNamespaceScope methodsFor: 'accessing'!mappedPrefixes	^ prefixMappings		ifNil: [#()]		ifNotNil: [prefixMappings keys]! !!XMLNamespaceScope methodsFor: 'accessing'!prefixMappingAt: aPrefix	^ self		prefixMappingAt: aPrefix		ifAbsent: ['']! !!XMLNamespaceScope methodsFor: 'accessing'!prefixMappingAt: aPrefix ifAbsent: aBlock	^ prefixMappings		ifNil: [aBlock value]		ifNotNil: [			prefixMappings				at: aPrefix				ifAbsent: aBlock]! !!XMLNamespaceScope methodsFor: 'private'!prefixMappings	^ prefixMappings		ifNil: [prefixMappings := OrderPreservingStringDictionary new: 5]! !!XMLNamespaceScope methodsFor: 'enumerating'!prefixesAndURIsDo: aTwoArgumentBlock	prefixMappings		ifNotNil: [prefixMappings keysAndValuesDo: aTwoArgumentBlock]! !!XMLNamespaceScope methodsFor: 'printing'!printDeclarationsOn: aStream	| isFirst |	isFirst := true.	self prefixesAndURIsDo: [:prefix :uri |		isFirst 			ifTrue: [isFirst := false]			ifFalse: [aStream space].		aStream nextPutAll: 'xmlns'.		prefix			ifNotEmpty: [				aStream					nextPut: $:;					nextPutAll: prefix].		aStream			nextPut: $=;			nextPut: $";			nextPutAll: uri;			nextPut: $"].! !!XMLNamespaceScope methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self printDeclarationsOn: aStream.	aStream nextPut: $).! !!XMLNamespaceScope methodsFor: 'resolving'!resolvePrefix: aPrefix	"Resolves the namespace URI of aPrefix (the defualt namespace URI if aPrefix	is empty), including the predefined 'xml' and 'xmlns' prefixes. Returns an	empty string if aPrefix is unresolvable."	^ self		resolvePrefix: aPrefix		ifUnresolvable: ''! !!XMLNamespaceScope methodsFor: 'resolving'!resolvePrefix: aPrefix ifUnresolvable: aBlock	"Resolves the namespace URI of aPrefix (the defualt namespace URI if aPrefix	is empty), including the predefined 'xml' and 'xmlns' prefixes. Returns the	value of aBlock if aPrefix is unresolvable."	aPrefix size > 0 "optimization"		ifTrue: [			(aPrefix at: 1) == $x "optimization"				ifTrue: [					aPrefix = 'xml'						ifTrue: [^ self xmlNamespaceURI].					aPrefix = 'xmlns'						ifTrue: [^ self xmlnsNamespaceURI]]].	^ self		prefixMappingAt: aPrefix		ifAbsent: aBlock.! !!XMLNamespaceScope methodsFor: 'resolving'!resolvePrefixesOfNamespaceURI: aURI	| prefixes |	"the 'xml' and 'xmlns' namespaces URIs can't be aliased"	aURI = self xmlNamespaceURI		ifTrue: [^ Set with: 'xml'].	aURI = self xmlnsNamespaceURI		ifTrue: [^ Set with: 'xmlns'].	prefixes := Set new.	self prefixesAndURIsDo: [:prefix :uri |		uri = aURI			ifTrue: [prefixes add: prefix]].	^ prefixes.! !!XMLNamespaceScope methodsFor: 'accessing'!size	^ prefixMappings		ifNil: [0]		ifNotNil: [prefixMappings size]! !!XMLNamespaceScope methodsFor: 'unmapping'!unmapPrefix: aPrefix	^ self		unmapPrefix: aPrefix		ifAbsent: [self errorCannotUnmapPrefix: aPrefix]! !!XMLNamespaceScope methodsFor: 'unmapping'!unmapPrefix: aPrefix ifAbsent: aBlock	prefixMappings		ifNil: [^ aBlock value]		ifNotNil: [			"copy-on-write"			^ self copiedPrefixMappings 				removeKey: aPrefix				ifAbsent: aBlock]! !!XMLNamespaceScope methodsFor: 'unmapping'!unmapPrefixes	self hasNamespaces		ifTrue: [			"copy-on-write"			self copiedPrefixMappings removeAll]! !!XMLNamespaceScope methodsFor: 'validating'!validateAndResolvePrefix: aPrefix ofAttribute: anAttribute	"performance critical method"	aPrefix size > 0 "optimization"		ifTrue: [			^ self				prefixMappingAt: aPrefix				ifAbsent: [					aPrefix = 'xml'						ifTrue: [self xmlNamespaceURI]						ifFalse: [												aPrefix = 'xmlns'								ifTrue: [									"this can't happen during parsing, because									'xmlns' attributes are treated as namespace									declarations, but it can happen through DOM tree									manipulation, for example:										attributeNode prefix: 'xmlns'									"									self errorXMLNSPrefixInAttribute: anAttribute]								ifFalse: [									self										errorUnmappedPrefix: aPrefix										inAttribute: anAttribute]]]]		ifFalse: [			"catch names like ':name' with an empty prefix"			(anAttribute size > 0				and: [(anAttribute at: 1) == $:])				ifTrue: [self errorInvalidUnprefixedAttribute: anAttribute].			^ '']! !!XMLNamespaceScope methodsFor: 'validating'!validateAndResolvePrefix: aPrefix ofElement: anElement	aPrefix size > 0 "optimization"		ifTrue: [			^ self				prefixMappingAt: aPrefix				ifAbsent: [					aPrefix = 'xml'						ifTrue: [self xmlNamespaceURI]						ifFalse: [												aPrefix = 'xmlns'								ifTrue: [self errorXMLNSPrefixInElement: anElement]								ifFalse: [									self										errorUnmappedPrefix: aPrefix										inElement: anElement]]]]		ifFalse: [			"catch names like ':name' with an empty prefix"			(anElement size > 0				and: [(anElement at: 1) == $:])				ifTrue: [self errorInvalidUnprefixedElement: anElement].			^ self defaultNamespace]! !!XMLNamespaceScope methodsFor: 'private'!validatePrefix: aPrefix beforeMappingTo: aURI	aPrefix size > 0 "optimization"		ifTrue: ["non-default namespace"			aPrefix = 'xml' "cannot be remapped"				ifTrue: [					aURI = self xmlNamespaceURI						ifFalse: [self errorCannotRemapXMLPrefix].					^ self].			aPrefix = 'xmlns' "cannot be mapped, even to the same URI"				ifTrue: [self errorCannotMapXMLNSPrefix].			(aPrefix indexOf: $:) > 0 				ifTrue: [self errorInvalidPrefix: aPrefix].			"non-default namespaces cannot be mapped to empty uris, even			to shadow an inherited namesapce"			aURI size > 0				ifFalse: [self errorCannotMapPrefixToEmptyURI]].	"these URIs cannot be aliased, even by the default namespace"	aURI = self xmlNamespaceURI		ifTrue: [self errorCannotAliasXMLPrefixWith: aPrefix].	aURI = self xmlnsNamespaceURI		ifTrue: [self errorCannotAliasXMLNSPrefixWith: aPrefix].! !!XMLNamespaceScope methodsFor: 'validating'!validatePrefixesOfAttributes: anAttributeCollection	^ self		validatePrefixesOfAttributes: anAttributeCollection asArray		from: 1		to: anAttributeCollection size! !!XMLNamespaceScope methodsFor: 'validating'!validatePrefixesOfAttributes: anAttributeCollection from: aStart to: aStop	"performance critical method"	| attributeLocalNamesAndURIs |	"#to:do: for speed"	aStart to: aStop do: [:i | | attribute prefix uri |		attribute := anAttributeCollection at: i.		prefix := attribute xmlPrefixBeforeLocalName.		(uri :=			self				validateAndResolvePrefix: prefix				ofAttribute: attribute) size > 0 "optimization"			ifTrue: [| oldSize |				oldSize :=					(attributeLocalNamesAndURIs						ifNil: [							"not initialized unless needed"							attributeLocalNamesAndURIs := Set new]) size.				(attributeLocalNamesAndURIs					add: (attribute xmlLocalNameAfterPrefix: prefix) -> uri;					size) > oldSize					ifFalse: [						self							errorAttribute: attribute xmlLocalNameAfterPrefix							aliasesURI: uri]]]! !!XMLNamespaceScope methodsFor: 'defaults'!xmlNamespaceURI	^ self class xmlNamespaceURI! !!XMLNamespaceScope methodsFor: 'defaults'!xmlnsNamespaceURI	^ self class xmlnsNamespaceURI! !!XMLNamespaceScopeAllocator methodsFor: 'accessing'!currentScope	| totalScopes |	^ (totalScopes := scopes size) > 0		ifTrue: [scopes at: totalScopes]		ifFalse: [self newEmptyScope]! !!XMLNamespaceScopeAllocator methodsFor: 'accessing'!currentScope: aScope	scopes size > 0		ifTrue: [			scopes				at: scopes size				put: aScope]		ifFalse: [scopes addLast: aScope]! !!XMLNamespaceScopeAllocator methodsFor: 'allocating'!enterScope	^ scopes addLast: self currentScope copy! !!XMLNamespaceScopeAllocator methodsFor: 'allocating'!exitScope	^ scopes removeLast! !!XMLNamespaceScopeAllocator methodsFor: 'testing'!hasCurentScope	^ scopes notEmpty! !!XMLNamespaceScopeAllocator methodsFor: 'initialization'!initialize	super initialize.	scopes := OrderedCollection new: 10.! !!XMLNamespaceScopeAllocator methodsFor: 'instance creation'!newEmptyScope	^ XMLNamespaceScope new! !!XMLNamespaceScopeAllocator methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	self hasCurentScope		ifTrue: [			aStream				nextPut: $(;				print: self currentScope;				nextPut: $)].! !!XMLNamespaceScopeAllocator methodsFor: 'accessing'!scopes	^ scopes! !!XMLNestedStreamReader class methodsFor: 'class initialization'!initialize	"self initialize"	"stored in class vars for faster access"	CRCharacter := Character cr.	LFCharacter := Character lf.	"a null stream that is already #atEnd and can safely be sent	#close repeatedly and #atEnd after"	NullReadStream := XMLNullReadStream new.! !!XMLNestedStreamReader class methodsFor: 'instance creation'!on: aStream	^ self		on: aStream		readLimit: nil! !!XMLNestedStreamReader class methodsFor: 'instance creation'!on: aStream readLimit: anInteger	^ self new		setStream: aStream		readLimit: anInteger! !!XMLNestedStreamReader methodsFor: 'testing'!atEnd	peekChar		ifNotNil: [^ false].	stream atEnd		ifFalse: [^ false].	"use #to:do: for speed"	1 to: nestedStreams size do: [:i |		(nestedStreams at: i) stream atEnd			ifFalse: [^ false]].	^ true.! !!XMLNestedStreamReader methodsFor: 'testing'!atQuote	^ self peek == $"		or: [peekChar == $']! !!XMLNestedStreamReader methodsFor: 'private'!closeStream: aStream	"must use respondsTo: to support streams only implementing the basic protocol"	(aStream respondsTo: #close)		ifTrue: [aStream close].! !!XMLNestedStreamReader methodsFor: 'closing'!closeStreams	"close the streams but do not evaluate their callbacks and	set the current stream to the null stream sending #closeStreams	again won't raise an error"	self		closeStream: stream;		setStreamToNull.	[nestedStreams size > 0]		whileTrue: [self closeStream: nestedStreams removeLast stream].! !!XMLNestedStreamReader methodsFor: 'decoding'!convertFromEncoding: anEncodingName	"Encoding attributes are ignored unless the stream is a converting adapter	that has a null/implicit converter.		This is the safest approach, because the encoding of a file can be easily	changed by a text editor or utility without automatically updating the	<?xml ...?> encoding attribute.		The BOM and out-of-band info (like HTTP headers) should be given precedence."	(stream isXMLConvertingStreamAdapter		and: [stream hasNullStreamConverter			or: [stream hasImplicitStreamConverter]])		ifTrue: [| streamConverter |			(streamConverter := anEncodingName asXMLStreamConverter) isNull				ifTrue: [self errorUnsupportedEncoding: anEncodingName].			self decodeStreamWithConverter: streamConverter]! !!XMLNestedStreamReader methodsFor: 'accessing'!currentColumnNumber	"recording the start pos. of the line and subtracting it from the current	pos. is faster than an explicit column var that would need to be incremented	each time through #next/#skipSeparators"	^ currentLineStartPosition		ifNotNil: [currentPosition - currentLineStartPosition]! !!XMLNestedStreamReader methodsFor: 'accessing'!currentLineNumber	^ currentLineNumber! !!XMLNestedStreamReader methodsFor: 'accessing'!currentPosition	^ currentPosition! !!XMLNestedStreamReader methodsFor: 'decoding'!decodeStreamWithConverter: aStreamConverter	stream isXMLConvertingStreamAdapter		ifTrue: [stream streamConverter: aStreamConverter]		ifFalse: [			stream :=				XMLDecodingReadStreamAdapter					on: stream					streamConverter: aStreamConverter]! !!XMLNestedStreamReader methodsFor: 'decoding'!detectEncoding	stream isXMLConvertingStreamAdapter		ifTrue: [stream detectEncoding]		ifFalse: [			"if it's not already an XMLDecodingReadStreamAdapter, just look			for an obvious leading byte-order mark and convert it if found,			and otherwise just leave it alone"			(XMLEncodingDetector on: stream) streamConverterForEncoding				ifNotNil: [:converter |					self decodeStreamWithConverter: converter]]! !!XMLNestedStreamReader methodsFor: 'private'!errorNestingLimitExceeded	XMLLimitException signal: 'Cannot further nest input streams'! !!XMLNestedStreamReader methodsFor: 'private'!errorReadLimitExceeded	XMLLimitException signal:		'Security input read limit exceeded; ',		'use #documentReadLimit: and #externalSubsetReadLimit: ',		'to change/disable it, or #defaultReadLimit: ',		'to persistently change/disable it'! !!XMLNestedStreamReader methodsFor: 'private'!errorUnsupportedEncoding: anEncodingName	XMLEncodingException		formatSignal: 'Encoding "{1}" is unsupported'		with: anEncodingName! !!XMLNestedStreamReader methodsFor: 'private'!hasNextAfterPoppingStreamsAtEnd	"always pop at least one stream, which makes the new current stream	the null stream if there aren't any nested streams"	self popCurrentStream.	[stream atEnd]		whileTrue: [			nestedStreams size > 0				ifFalse: [^ false].			self popCurrentStream].	^ true.! !!XMLNestedStreamReader methodsFor: 'testing'!hasPushedBackStreams	^ nestedStreams size > 0! !!XMLNestedStreamReader methodsFor: 'testing'!isBinary	^ false! !!XMLNestedStreamReader methodsFor: 'testing'!isStream	^ true! !!XMLNestedStreamReader methodsFor: 'testing'!isXMLBinaryOrExternalStream	^ self isBinary! !!XMLNestedStreamReader methodsFor: 'private'!maxNestedStreams	^ 32! !!XMLNestedStreamReader methodsFor: 'private'!nestedStreamsAddLast: aPushedBackStream	nestedStreams size >= self maxNestedStreams		ifTrue: [self errorNestingLimitExceeded].	nestedStreams addLast: aPushedBackStream.! !!XMLNestedStreamReader methodsFor: 'private'!newWriteStream	^ (self writeStreamCollectionClass new: 128) writeStream! !!XMLNestedStreamReader methodsFor: 'accessing'!next	| nextChar |	peekChar		ifNil: [			stream atEnd				ifTrue: [					self hasNextAfterPoppingStreamsAtEnd						ifFalse: [^ nil]].			nextChar := stream next.			isExternal				ifTrue: [					currentPosition := currentPosition + 1.					nextChar == LFCharacter						ifTrue: [							nextChar := normalizedLineEndingChar.							currentLineNumber := currentLineNumber + 1.							currentLineStartPosition := currentPosition]						ifFalse: [							nextChar == CRCharacter								ifTrue: [									stream atEnd										ifFalse: [											stream peek == LFCharacter												ifTrue: [stream next]].									nextChar := normalizedLineEndingChar.									currentLineNumber := currentLineNumber + 1.									currentLineStartPosition := currentPosition]]]]		ifNotNil: [			nextChar := peekChar.			peekChar := nil.			isExternal				ifTrue: [					currentPosition := currentPosition + 1.					nextChar == normalizedLineEndingChar						ifTrue: [							currentLineNumber := currentLineNumber + 1.							currentLineStartPosition := currentPosition]]].	readLimit		ifNotNil: [			(readLimit := readLimit - 1) >= 0				ifFalse: [self errorReadLimitExceeded]].	^ nextChar.! !!XMLNestedStreamReader methodsFor: 'accessing'!next: anInteger	| writeStream i |	writeStream := self newWriteStream.	i := 0.	[self atEnd		or: [i >= anInteger]]		whileFalse: [			writeStream nextPut: self next.			i := i + 1].	^ writeStream contents.! !!XMLNestedStreamReader methodsFor: 'accessing'!normalizedLineEndingChar	^ normalizedLineEndingChar! !!XMLNestedStreamReader methodsFor: 'accessing'!normalizedLineEndingChar: aCharacter	normalizedLineEndingChar := aCharacter! !!XMLNestedStreamReader methodsFor: 'accessing'!peek	peekChar		ifNotNil: [^ peekChar].	stream atEnd		ifTrue: [			self hasNextAfterPoppingStreamsAtEnd				ifFalse: [^ nil]].	peekChar := stream next.	isExternal		ifTrue: [			peekChar == LFCharacter				ifTrue: [^ peekChar := normalizedLineEndingChar].			peekChar == CRCharacter				ifTrue: [					stream atEnd						ifFalse: [							stream peek == LFCharacter								ifTrue: [stream next]].					^ peekChar := normalizedLineEndingChar]].	^ peekChar.! !!XMLNestedStreamReader methodsFor: 'accessing'!peekFor: aCharacter	(self atEnd not		and: [self peek = aCharacter])		ifTrue: [			self next.			^ true]		ifFalse: [^ false]! !!XMLNestedStreamReader methodsFor: 'private'!popCurrentStream	| callbackOfPoppedStream |	"close the stream first and pop it before evaluating the callback so any	exception it raises won't cause us to leak file streams or double close a	stream when XMLParser>>#handleParserError: sends #closeStreams"	self closeStream: stream.	callbackOfPoppedStream := whenPoppedDo.	nestedStreams size > 0		ifTrue: [| pushedBackStream |			pushedBackStream := nestedStreams removeLast.			stream := pushedBackStream stream.			whenPoppedDo := pushedBackStream whenPoppedDo.			isExternal := pushedBackStream isExternal.			currentPosition := pushedBackStream currentPosition.			currentLineNumber := pushedBackStream currentLineNumber.			currentLineStartPosition := pushedBackStream currentLineStartPosition]		ifFalse: [self setStreamToNull].	"now it's safe to evaluate the callback"	callbackOfPoppedStream		ifNotNil: [callbackOfPoppedStream value].! !!XMLNestedStreamReader methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		print: peekChar; "can be nil"		nextPutAll: '; ';		print: stream;		space;		print: nestedStreams;		nextPut: $).! !!XMLNestedStreamReader methodsFor: 'positioning'!pushBack: aString	aString size > 1		ifTrue: [^ self pushBackStream: aString readStream].	aString size = 1		ifTrue: [self pushBackCharacter: (aString at: 1)]! !!XMLNestedStreamReader methodsFor: 'positioning'!pushBackCharacter: aCharacter	self		pushBackStream: (XMLSingleCharacterReadStream on: aCharacter)		whenPoppedDo: nil		isExternal: false! !!XMLNestedStreamReader methodsFor: 'positioning'!pushBackStream: aStream	self		pushBackStream: aStream		whenPoppedDo: nil		isExternal: false! !!XMLNestedStreamReader methodsFor: 'positioning'!pushBackStream: aStream whenPoppedDo: aBlock isExternal: aBoolean	self nestedStreamsAddLast:		((isExternal			ifTrue: [XMLPushedBackExternalStream]			ifFalse: [XMLPushedBackInternalStream])				stream: stream				whenPoppedDo: whenPoppedDo				currentPosition: currentPosition				currentLineNumber: currentLineNumber				currentLineStartPosition: currentLineStartPosition).	peekChar		ifNotNil: [			self nestedStreamsAddLast:				(XMLPushedBackInternalStream					stream: (XMLSingleCharacterReadStream on: peekChar)					whenPoppedDo: nil					currentPosition: currentPosition					currentLineNumber: currentLineNumber					currentLineStartPosition: currentLineStartPosition).			peekChar := nil].	self stream: aStream.	whenPoppedDo := aBlock.	(isExternal := aBoolean)		ifTrue: [			currentPosition := 0.			currentLineNumber := 1.			currentLineStartPosition := 0].! !!XMLNestedStreamReader methodsFor: 'accessing'!readLimit	^ readLimit! !!XMLNestedStreamReader methodsFor: 'initialization'!setStream: aStream readLimit: anInteger	self stream: aStream.	isExternal := true.	currentPosition := 0.	currentLineNumber := 1.	currentLineStartPosition := 0.	nestedStreams := OrderedCollection new: 5.	readLimit := anInteger.	normalizedLineEndingChar := LFCharacter.! !!XMLNestedStreamReader methodsFor: 'private'!setStreamToNull	stream := NullReadStream.	whenPoppedDo := nil.	"do not reset the other stream properties, including position	and line number, so error messages will be accurate"! !!XMLNestedStreamReader methodsFor: 'positioning'!skip: anInteger	1 to: anInteger do: [:i |		self atEnd			ifTrue: [^ self].		self next]! !!XMLNestedStreamReader methodsFor: 'positioning'!skipSeparators	"This code is heavily optimized."	| isExternalNormalizedLineEnding |	[peekChar		ifNil: [			stream atEnd				ifTrue: [					self hasNextAfterPoppingStreamsAtEnd						ifFalse: [^ self]].			peekChar := stream next.			isExternal				ifTrue: [					peekChar == LFCharacter						ifTrue: [isExternalNormalizedLineEnding := true]						ifFalse: [							peekChar == CRCharacter								ifTrue: [									stream atEnd										ifFalse: [											stream peek == LFCharacter												ifTrue: [stream next]].									isExternalNormalizedLineEnding := true]								ifFalse: [									isExternalNormalizedLineEnding := false.									"nil understands #isXMLSeparator, so it									isn't tested for first"									peekChar isXMLSeparator]]]				ifFalse: [					"nil understands #isXMLSeparator, so it isn't tested for first"					peekChar isXMLSeparator]]			ifNotNil: [				isExternal					ifTrue: [						isExternalNormalizedLineEnding :=							peekChar == normalizedLineEndingChar].				peekChar isXMLSeparator]]		whileTrue: [			"inlined from #next"			peekChar := nil.			isExternal				ifTrue: [					currentPosition := currentPosition + 1.					isExternalNormalizedLineEnding						ifTrue: [							currentLineNumber := currentLineNumber + 1.							currentLineStartPosition := currentPosition].			readLimit				ifNotNil: [					(readLimit := readLimit - 1) >= 0						ifFalse: [self errorReadLimitExceeded]]]]! !!XMLNestedStreamReader methodsFor: 'positioning'!skipTo: aCharacter	[self atEnd]		whileFalse: [			self next = aCharacter				ifTrue: [^ true]].	^ false.! !!XMLNestedStreamReader methodsFor: 'accessing'!stream	^ stream! !!XMLNestedStreamReader methodsFor: 'accessing'!stream: aStream	"if the stream is not already a decoding adapter,	then only assume it needs one if it's binary"	stream := 		aStream isXMLConvertingStreamAdapter			ifTrue: [aStream]			ifFalse: [				(XMLDecodingReadStreamAdapter nonDecodingOnIfBinaryOrExternal: aStream)					ifNil: [aStream]]! !!XMLNestedStreamReader methodsFor: 'accessing'!upTo: aCharacter	| writeStream nextChar |	writeStream := self newWriteStream.	[self atEnd		or: [(nextChar := self next) = aCharacter]]		whileFalse: [writeStream nextPut: nextChar].	^ writeStream contents.! !!XMLNestedStreamReader methodsFor: 'accessing'!upToEnd	| writeStream |	writeStream := self newWriteStream.	[self atEnd]		whileFalse: [writeStream nextPut: self next].	^ writeStream contents.! !!XMLNestedStreamReader methodsFor: 'defaults'!writeStreamCollectionClass	^ String! !!XMLAttribute class methodsFor: 'instance creation'!name: aName	^ self named: aName! !!XMLAttribute class methodsFor: 'instance creation'!name: aName value: aValue	^ self new			setName: aName		value: aValue		element: nil! !!XMLAttribute class methodsFor: 'instance creation'!named: aName	^ self		name: aName		value: ''! !!XMLAttribute methodsFor: 'accessing'!element	"reuse an inst var to save memory"	^ parent! !!XMLAttribute methodsFor: 'accessing'!element: anElement	"reuse an inst var to save memory"	parent := anElement! !!XMLAttribute methodsFor: 'accessing'!expandedName	"Returns the expanded name of the attribute as a string in the form of	'{namespaceURI}localName' if there's a namespace URI or 'localName' if there	isn't"	^ self localName expandWithXMLNamespaceURI: self namespaceURI! !!XMLAttribute methodsFor: 'testing'!hasNamespaceURI	^ self namespaceURI notEmpty! !!XMLAttribute methodsFor: 'testing'!hasPrefix	^ (self name		indexOf: $:		startingAt: 2) > 0! !!XMLAttribute methodsFor: 'testing'!isAttribute	^ true! !!XMLAttribute methodsFor: 'testing'!isInLanguage: aLanguageTag	"Returns true if the receiver is an xml:lang attribute or if its element	or an ancestor element has an xml:lang attribute, and if the value is an IETF	language tag, like 'en-US', that matches aLanguageTag. Matching is	case-insensitive, and aLanguageTag can be partial, like 'en', and use	wildcards, like 'en-*'"	self name = 'xml:lang'		ifTrue: [^ self matchesLanguage: aLanguageTag]		ifFalse: [^ super isInLanguage: aLanguageTag]! !!XMLAttribute methodsFor: 'testing'!isNamed: aName	"Does the receiver's qualified or local name match the argument?"	^ self name isXMLQualifiedOrLocalName: aName! !!XMLAttribute methodsFor: 'testing'!isNamedAny: aNameCollection	"Does the receiver's qualified or local name match any of the names	in aNameCollection?"	^ aNameCollection includesXMLName: self name! !!XMLAttribute methodsFor: 'accessing'!localName	"Returns the local name of the receiver, the name minus any leading	prefix and colon like 'local' in 'prefix:local'"	"this is recomputed from the name to save memory instead of	being stored in an inst var like it is for XMLElement"	^ self name xmlLocalNameAfterPrefix! !!XMLAttribute methodsFor: 'testing'!matchesLanguage: aLanguageTag	"Returns true if the value is an IETF language tag that matches aLanguageTag.	Matching is case-insensitive, and aLanguageTag can be partial, like 'en',	and use wildcards, like 'en-*'"	| sourceLanguageTag targetLanguageTag i |	((sourceLanguageTag := self value asLowercase) isEmpty		or: [(targetLanguageTag := aLanguageTag asLowercase) isEmpty])		ifTrue: [^ false].	sourceLanguageTag = targetLanguageTag		ifTrue: [^ true].	sourceLanguageTag := $- xmlSplit: sourceLanguageTag.	i := 0.	$-		xmlSplit: targetLanguageTag		do: [:each | | sourceLanguageSubTag |			sourceLanguageSubTag :=				sourceLanguageTag					at: (i := i + 1)					ifAbsent: [^ false].			(sourceLanguageSubTag = each				or: [each = '*'])				ifFalse: [^ false]].	^ true.! !!XMLAttribute methodsFor: 'accessing'!name	^ name ifNil: [name := '']! !!XMLAttribute methodsFor: 'accessing'!name: aName	self renameWith: [name := aName]! !!XMLAttribute methodsFor: 'accessing'!namespaceURI	^ self resolvePrefix: self prefix! !!XMLAttribute methodsFor: 'accessing'!prefix	"Returns the prefix of the receiver's name or an empty string if there	isn't one."	"this is recomputed from the qualified name instead of being stored	in an inst var to save memory."	^ self name xmlPrefixBeforeLocalName! !!XMLAttribute methodsFor: 'accessing'!prefix: aPrefix	self renameWith: [name := self localName qualifyWithXMLPrefix:  aPrefix]! !!XMLAttribute methodsFor: 'private'!renameWith: aBlock	| oldName |	oldName := self name.	aBlock value.	(self name ~= oldName		and: [self hasParent])			ifTrue: [				self parent					renamedAttribute: self					from: oldName					to: self name].! !!XMLAttribute methodsFor: 'namespacing'!resolvePrefix: aPrefix	"This resolves the attribute prefix aPrefix or returns an empty string	if aPrefix is empty (attributes must be prefixed to have a namespace) or	undeclared"	^ self		resolvePrefix: aPrefix		ifUnresolvable: ''! !!XMLAttribute methodsFor: 'namespacing'!resolvePrefix: aPrefix ifUnresolvable: aBlock	"This resolves the attribute prefix aPrefix or returns the result of	evaluated aBlock if aPrefix is empty (attributes must be prefixed to have	a namespace) or undeclared"	^ (self hasParent		and: [aPrefix size > 0]) "no default namespace for attributes"		ifTrue: [			self parent				resolvePrefix: aPrefix				ifUnresolvable: aBlock]		ifFalse: [aBlock value]! !!XMLAttribute methodsFor: 'initialization'!setName: aName value: aValue element: anElement	name := aName.	value := aValue.	parent := anElement.! !!XMLAttribute methodsFor: 'accessing'!sortKey	^ self name! !!XMLAttribute methodsFor: 'accessing'!value	^ value ifNil: [value := '']! !!XMLAttribute methodsFor: 'accessing'!value: aString	value := aString! !!XMLAttribute methodsFor: 'printing'!writeXMLOn: aWriter	aWriter		writeStringName: self name;		nextPut: $=;		writeEscapedContentString: self value! !!XMLComment class methodsFor: 'instance creation'!string: aString	^ self new string: aString! !!XMLComment methodsFor: 'visiting'!acceptNodeVisitor: aNodeVisitor	^ aNodeVisitor visitComment: self! !!XMLComment methodsFor: 'testing'!isComment	^ true! !!XMLComment methodsFor: 'accessing'!sortKey	^ self string! !!XMLComment methodsFor: 'accessing'!string	^ string ifNil: [string := '']! !!XMLComment methodsFor: 'accessing'!string: aString	string := aString! !!XMLComment methodsFor: 'printing'!writeXMLOn: aWriter	aWriter comment: self string! !!XMLAttributeDeclaration class methodsFor: 'instance creation'!element: anElementName attribute: anAttributeName type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue	^ self new		element: anElementName;		attribute: anAttributeName;		type: aType;		defaultPragma: aDefaultPragma;		defaultValue: aDefaultValue! !!XMLAttributeDeclaration methodsFor: 'accessing'!attribute	^ attribute ifNil: [attribute := '']! !!XMLAttributeDeclaration methodsFor: 'accessing'!attribute: anAttributeName	attribute := anAttributeName! !!XMLAttributeDeclaration methodsFor: 'accessing'!defaultPragma	^ defaultPragma ifNil: [defaultPragma := '']! !!XMLAttributeDeclaration methodsFor: 'accessing'!defaultPragma: aDefaultPragma	defaultPragma := aDefaultPragma! !!XMLAttributeDeclaration methodsFor: 'accessing'!defaultValue	^ defaultValue ifNil: [defaultValue := '']! !!XMLAttributeDeclaration methodsFor: 'accessing'!defaultValue: aDefaultValue	defaultValue := aDefaultValue! !!XMLAttributeDeclaration methodsFor: 'accessing'!element	^ element ifNil: [element := '']! !!XMLAttributeDeclaration methodsFor: 'accessing'!element: anElementName	element := anElementName! !!XMLAttributeDeclaration methodsFor: 'accessing'!type	^ type ifNil: [type := '']! !!XMLAttributeDeclaration methodsFor: 'accessing'!type: aType 	type := aType! !!XMLAttributeDeclaration methodsFor: 'printing'!writeXMLOn: aWriter	aWriter attributeDeclaration		element: self element;		attribute: self attribute;		type: self type;		defaultPragma: self defaultPragma;		defaultValue: self defaultValue;		write! !!XMLDeclarationNode methodsFor: 'testing'!isDeclaration	^ true! !!XMLElementDeclaration class methodsFor: 'instance creation'!element: anElementName contentModel: aContentModel	^ self new		element: anElementName;		contentModel: aContentModel! !!XMLElementDeclaration methodsFor: 'accessing'!contentModel	^ contentModel ifNil: [contentModel := '']! !!XMLElementDeclaration methodsFor: 'accessing'!contentModel: aContentModel	contentModel := aContentModel! !!XMLElementDeclaration methodsFor: 'accessing'!element	^ element ifNil: [element := '']! !!XMLElementDeclaration methodsFor: 'accessing'!element: anElementName	element := anElementName! !!XMLElementDeclaration methodsFor: 'printing'!writeXMLOn: aWriter	aWriter elementDeclaration		element: self element;		contentModel: self contentModel;		write! !!XMLEntityDeclaration class methodsFor: 'instance creation'!name: aName publicID: aPublicID systemID: aSystemID	^ self new		name: aName;		publicID: aPublicID;		systemID: aSystemID! !!XMLEntityDeclaration class methodsFor: 'instance creation'!name: aName replacement: aReplacement	^ self new		name: aName;		replacement: aReplacement! !!XMLEntityDeclaration methodsFor: 'testing'!isExternal	^ self systemID notEmpty		or: [self publicID notEmpty]! !!XMLEntityDeclaration methodsFor: 'testing'!isParameter	^ false! !!XMLEntityDeclaration methodsFor: 'testing'!isUnparsed	^ false! !!XMLEntityDeclaration methodsFor: 'accessing'!name	^ name ifNil: [name := '']! !!XMLEntityDeclaration methodsFor: 'accessing'!name: aName	name := aName! !!XMLEntityDeclaration methodsFor: 'accessing'!publicID	^ publicID ifNil: [publicID := '']! !!XMLEntityDeclaration methodsFor: 'accessing'!publicID: aPublicID	publicID := aPublicID! !!XMLEntityDeclaration methodsFor: 'accessing'!replacement	^ replacement ifNil: [replacement := '']! !!XMLEntityDeclaration methodsFor: 'accessing'!replacement: aReplacement	replacement := aReplacement! !!XMLEntityDeclaration methodsFor: 'accessing'!systemID	^ systemID ifNil: [systemID := '']! !!XMLEntityDeclaration methodsFor: 'accessing'!systemID: aSystemID	systemID := aSystemID! !!XMLGeneralEntityDeclaration class methodsFor: 'instance creation'!name: aName publicID: aPublicID systemID: aSystemID ndata: aNotationName	^ self new		name: aName;		publicID: aPublicID;		systemID: aSystemID;		ndata: aNotationName! !!XMLGeneralEntityDeclaration methodsFor: 'testing'!isUnparsed	^ self ndata notEmpty! !!XMLGeneralEntityDeclaration methodsFor: 'accessing'!ndata	^ ndata ifNil: [ndata := '']! !!XMLGeneralEntityDeclaration methodsFor: 'accessing'!ndata: aNotationName	ndata := aNotationName! !!XMLGeneralEntityDeclaration methodsFor: 'printing'!writeXMLOn: aWriter	aWriter entityDeclaration		name: self name;		isParameter: false;		replacement: self replacement;		publicID: self publicID;		systemID: self systemID;		ndata: self ndata;		write! !!XMLParameterEntityDeclaration methodsFor: 'testing'!isParameter	^ true! !!XMLParameterEntityDeclaration methodsFor: 'printing'!writeXMLOn: aWriter	aWriter entityDeclaration		name: self name;		isParameter: true;		replacement: self replacement;		publicID: self publicID;		systemID: self systemID;		write! !!XMLNotationDeclaration class methodsFor: 'instance creation'!name: aName publicID: aPublicID systemID: aSystemID	^ self new		name: aName;		publicID: aPublicID;		systemID: aSystemID! !!XMLNotationDeclaration methodsFor: 'accessing'!name	^ name ifNil: [name := '']! !!XMLNotationDeclaration methodsFor: 'accessing'!name: aName	name := aName! !!XMLNotationDeclaration methodsFor: 'accessing'!publicID	^ publicID ifNil: [publicID := '']! !!XMLNotationDeclaration methodsFor: 'accessing'!publicID: aPublicID	publicID := aPublicID! !!XMLNotationDeclaration methodsFor: 'accessing'!systemID	^ systemID ifNil: [systemID := '']! !!XMLNotationDeclaration methodsFor: 'accessing'!systemID: aSystemID	systemID := aSystemID! !!XMLNotationDeclaration methodsFor: 'printing'!writeXMLOn: aWriter	aWriter notationDeclaration		name: self name;		publicID: self publicID;		systemID: self systemID;		write! !!XMLNode methodsFor: 'visiting'!acceptNodeVisitor: aNodeVisitor	^ self! !!XMLNode methodsFor: 'deprecated'!addContent: aStringOrStringNode	"will be deprecated"	XMLDOMException signal: 'Node cannot contain string content'! !!XMLNode methodsFor: 'enumerating'!allNodesDo: aBlock	"evaluates aBlock for the receiver and all of its descendant nodes"	aBlock value: self! !!XMLNode methodsFor: 'accessing'!ancestorElements	"returns a node list with all ancestor elements of the receiver"	| ancestorElements |	ancestorElements := self newListForSelect.	self ancestorElementsDo: [:each | ancestorElements addLast: each].	^ ancestorElements.! !!XMLNode methodsFor: 'enumerating'!ancestorElementsDo: aBlock	| ancestor |	ancestor := self parent.	[ancestor notNil		and: [ancestor isElement]]		whileTrue: [			aBlock value: ancestor.			ancestor := ancestor parent].! !!XMLNode methodsFor: 'accessing'!ancestorNodes	"returns a node list with all ancestor nodes of the receiver"	| ancestors |	ancestors := self newListForSelect.	self ancestorNodesDo: [:each | ancestors addLast: each].	^ ancestors.! !!XMLNode methodsFor: 'enumerating'!ancestorNodesDo: aBlock	| ancestor |	ancestor := self parent.	[ancestor notNil]		whileTrue: [			aBlock value: ancestor.			ancestor := ancestor parent].! !!XMLNode methodsFor: 'converting'!asString	"Returns the full, untruncated XML source string, unlike #printString,	which may truncate long printed representations"		^ String streamContents: [:stream | self printOn: stream]! !!XMLNode methodsFor: 'testing'!canHaveChildren	"returns true if the receiver is a type of node that can have child nodes"	^ false! !!XMLNode methodsFor: 'testing'!canonicallyEquals: aNode	"returns true if the receiver and aNode have the same canonical	representation (http://www.w3.org/TR/xml-c14n)"	^ self canonicallyPrinted = aNode canonicallyPrinted! !!XMLNode methodsFor: 'printing'!canonicallyPrintOn: aStream 	"Prints on aStream as canonical XML (http://www.w3.org/TR/xml-c14n)"	self		printOn: aStream		beforeWritingDo: [:writer | writer isCanonical: true]! !!XMLNode methodsFor: 'printing'!canonicallyPrintToFileNamed: aFileName 	"Prints to the file aFileName as canonical XML (http://www.w3.org/TR/xml-c14n)"	self		printToFileNamed: aFileName		beforeWritingDo: [:writer | writer isCanonical: true]! !!XMLNode methodsFor: 'printing'!canonicallyPrinted 	"Prints as canonical XML (http://www.w3.org/TR/xml-c14n)"	^ String streamContents: [:stream | self canonicallyPrintOn: stream]! !!XMLNode methodsFor: 'accessing'!configuration	^ self parent ifNotNil: [:node | node configuration]! !!XMLNode methodsFor: 'accessing'!contentString 	"Returns a combined string of all descendant string values with spaces inserted	for readability when one string has no trailing space and the next has no	leading space.	See also #rawContentString."	^ String streamContents: [:stream | self printContentOn: stream]! !!XMLNode methodsFor: 'copying'!copy	"returns a deep copy of the receiver, including copies of any descendant nodes,	and copies the config"	^ self shallowCopy postCopy postCopyConfiguration! !!XMLNode methodsFor: 'copying'!copySharingConfiguration		"returns a deep copy of the receiver, including copies of any descendant nodes,	but does not copy the config"	^ self shallowCopy postCopy! !!XMLNode methodsFor: 'enumerating'!descendantNodesDo: aBlock! !!XMLNode methodsFor: 'deprecated'!descendentNodesDo: aBlock	self deprecated: 'use #descendantNodesDo: instead'.	^ self descendantNodesDo: aBlock.! !!XMLNode methodsFor: 'accessing'!document	"returns the document node that the receiver belongs to (the receiver if it's a	document) or nil if there isn't one"	^ self parent ifNotNil: [:node | node document]! !!XMLNode methodsFor: 'accessing'!documentRoot	"returns the root of the DOM tree, a document node if there is one or the	last ancestor or self otherwise"	| documentRoot |	documentRoot := self.	self ancestorNodesDo: [:each | documentRoot := each].	^ documentRoot.! !!XMLNode methodsFor: 'private'!errorXMLWritingUnsupported	XMLDOMException signal: 'The XMLWriter package is required for writng DOM objects'! !!XMLNode methodsFor: 'private'!escapesContentEntitiesWhenWriting	self hasParent		ifTrue: [^ self parent escapesContentEntitiesWhenWriting]		ifFalse: [^ true] "default to escaping"! !!XMLNode methodsFor: 'testing'!hasChildren	"returns true if the receiver has child nodes"	^ false! !!XMLNode methodsFor: 'private'!hasNodeList: aNodeList	^ false! !!XMLNode methodsFor: 'testing'!hasParent	"returns true if the receiver has a parent node"	^ parent notNil! !!XMLNode methodsFor: 'private'!hasParentWithNodeList: aNodeList	"optimized"	parent == nil		ifTrue: [^ false].	^ parent hasNodeList: aNodeList.! !!XMLNode methodsFor: 'private'!initializeFileWriteStream: aWriteStream	"This sets a stream converter on aWriteStream based on the document's encoding	attribute and writes the encoding's byte order mark."	| document |	aWriteStream		streamConverter:			(((document := self document) notNil				and: [document hasEncoding])				ifTrue: [document encoding asXMLStreamConverter]				ifFalse: [XMLStreamConverter default]);		nextPutByteOrderMark! !!XMLNode methodsFor: 'testing'!isAttribute	^ false! !!XMLNode methodsFor: 'testing'!isCData	^ false! !!XMLNode methodsFor: 'private'!isCoalescingStringNode	^ false! !!XMLNode methodsFor: 'testing'!isComment	^ false! !!XMLNode methodsFor: 'testing'!isContentNode	"returns true if the receiver is a content node (an element or string node)"	^ false! !!XMLNode methodsFor: 'testing'!isDeclaration	^ false! !!XMLNode methodsFor: 'testing'!isDocument	^ false! !!XMLNode methodsFor: 'testing'!isElement	^ false! !!XMLNode methodsFor: 'testing'!isElementNamed: aName	"returns true if the receiver is an element whose qualified name or local	name matches aName"	^ false! !!XMLNode methodsFor: 'testing'!isElementNamedAny: aNameCollection	"returns true if the receiver is an element whose qualified name or local	name matches any name in aNameCollection"	^ false! !!XMLNode methodsFor: 'testing'!isInLanguage: aLanguageTag	"Returns true if one of the ancestor elements of the receiver has an xml:lang	attribute, and if the value is an IETF language tag, like 'en-US', that matches	aLanguageTag. Matching is case-insensitive, and aLanguageTag can be partial,	like 'en', and use wildcards, like 'en-*'"	^ self hasParent		and: [self parent isInLanguage: aLanguageTag]! !!XMLNode methodsFor: 'testing'!isPI	"returns true if the receiver is a processing instruction node"	^ false! !!XMLNode methodsFor: 'testing'!isStringNode	^ false! !!XMLNode methodsFor: 'testing'!isStringNode: aStringOrStringNode	^ false! !!XMLNode methodsFor: 'instance creation'!newCData: aString	^ self nodeFactory newCData: aString! !!XMLNode methodsFor: 'instance creation'!newComment: aString	^ self nodeFactory newComment: aString! !!XMLNode methodsFor: 'instance creation'!newDocument	^ self nodeFactory newDocument		configuration: self configuration! !!XMLNode methodsFor: 'instance creation'!newElement	^ self nodeFactory newElement		configuration: self configuration! !!XMLNode methodsFor: 'instance creation'!newElementNamed: aName	^ (self nodeFactory classForElement: aName) new		configuration: self configuration;		name: aName! !!XMLNode methodsFor: 'instance creation'!newElementNamed: aName attributes: anAssociationCollection	^ (self nodeFactory		classForElement: aName		attributes: anAssociationCollection) new			configuration: self configuration;			name: aName;			setAttributes: anAssociationCollection! !!XMLNode methodsFor: 'instance creation'!newElementNamed: aName namespaceURI: aURI	^ (self nodeFactory		classForElement: aName		namespaceURI: aURI) new			configuration: self configuration;			name: aName namespaceURI: aURI! !!XMLNode methodsFor: 'instance creation'!newElementNamed: aName namespaceURI: aURI attributes: anAssociationCollection	^ (self nodeFactory		classForElement: aName		namespaceURI: aURI		attributes: anAssociationCollection) new			configuration: self configuration;			name: aName namespaceURI: aURI;			setAttributes: anAssociationCollection! !!XMLNode methodsFor: 'instance creation'!newListForCollect	"collect can return non-nodes, so a basic ordered list is used"	^ XMLOrderedList new: 10! !!XMLNode methodsFor: 'instance creation'!newListForSelect	"select returns only nodes, so a node list is used"	^ XMLNodeList new: 10! !!XMLNode methodsFor: 'instance creation'!newPI	^ self nodeFactory newPI! !!XMLNode methodsFor: 'instance creation'!newPITarget: aTargetString data: aDataString	^ self nodeFactory		newPITarget: aTargetString		data: aDataString! !!XMLNode methodsFor: 'instance creation'!newStringNode: aString	^ self nodeFactory newStringNode: aString! !!XMLNode methodsFor: 'accessing'!nextNode	"returns the first node after this one that is a child of the same parent (the next	sibling) or nil if there isn't one"	^ self parent ifNotNil: [:node | node nodeAfter: self]! !!XMLNode methodsFor: 'accessing'!nodeFactory	^ self configuration		ifNil: [XMLNodeFactory new]		ifNotNil: [:config | config nodeFactory]! !!XMLNode methodsFor: 'accessing'!parent	"returns the parent node of this node or nil if there isn't one"	^ parent! !!XMLNode methodsFor: 'private'!parent: aNode	parent := aNode! !!XMLNode methodsFor: 'defaults'!parserHandlerClass	^ self configuration		ifNil: [XMLDOMParser]		ifNotNil: [:config | config parserHandlerClass]! !!XMLNode methodsFor: 'copying'!postCopy	super postCopy.	parent := nil.! !!XMLNode methodsFor: 'copying'!postCopyConfiguration! !!XMLNode methodsFor: 'printing'!prettyPrintOn: aStream 	"Prints XML on aStream with whitespace formatting for readability"	self		printOn: aStream		beforeWritingDo: [:writer | writer enablePrettyPrinting]! !!XMLNode methodsFor: 'printing'!prettyPrintToFileNamed: aFileName 	"Prints XML to the file aFileName with whitespace formatting for readability"	self		printToFileNamed: aFileName		beforeWritingDo: [:writer | writer enablePrettyPrinting]! !!XMLNode methodsFor: 'printing'!prettyPrinted 	"Prints XML with whitespace formatting for readability"	^ String streamContents: [:stream | self prettyPrintOn: stream]! !!XMLNode methodsFor: 'accessing'!previousNode	"returns the first node before this one that is a child of the same parent	(the preivous sibling) or nil if there isn't one"	^ self parent ifNotNil: [:node | node nodeBefore: self]! !!XMLNode methodsFor: 'printing'!printContentOn: aStream 	"Prints on aStream the combined content strings of all descendants with	space inserted when one string has no trailing space and the next has	no leading space.	See also #printRawContentOn:"	self printRawContentOn: (XMLNodeContentWriteStreamAdapter on: aStream)! !!XMLNode methodsFor: 'printing'!printOn: aStream	"Uses XMLWriter if supported to print XML on aStream, uses the	basic Object>>printOn: otherwise"	self		withNewXMLWriterOn: aStream		do: [:writer |			self writeXMLOn: writer.			writer write]		whenAbsent: [super printOn: aStream]! !!XMLNode methodsFor: 'printing'!printOn: aStream beforeWritingDo: aBlock	"Prints XML on aStream using an XMLWriter object it creates but first	evaluates aBlock with the XMLWriter so it can be configured before writing.	Raises an error without XMLWriter support."	self		withNewXMLWriterOn: aStream		do: [:writer |			aBlock value: writer.			self writeXMLOn: writer.			writer write]! !!XMLNode methodsFor: 'printing'!printRawContentOn: aStream  	"Prints on aStream the content strings of all descendants	without spaces inserted.	See also #printContentOn:"! !!XMLNode methodsFor: 'printing'!printToFileNamed: aFileName	"Prints XML to the file aFileName. Uses the encoding specified in the	document's encoding attribute if supported or UTF-8 otherwise."	self		withNewWriteStreamOnFileNamed: aFileName		do: [:writeStream |			self				printOn: writeStream				beforeWritingDo: [:writer |					"use the platform's line break because we're writing to a file"					writer enablePlatformSpecificLineBreak]]! !!XMLNode methodsFor: 'printing'!printToFileNamed: aFileName beforeWritingDo: aBlock	"Prints XML to the file aFileName after evaluating aBlock with the XMLWriter.	Uses the encoding specified in the document's encoding attribute if	supported or UTF-8 otherwise."	self		withNewWriteStreamOnFileNamed: aFileName		do: [:writeStream |			self				printOn: writeStream				beforeWritingDo: [:writer |					"use the platform's line break because we're writing to a file"					writer enablePlatformSpecificLineBreak.					aBlock value: writer]]! !!XMLNode methodsFor: 'printing'!printWithoutSelfClosingTagsOn: aStream	"Prints XML on aStream with empty elements rendered as '<empty></empty>'	instead of self-closing '<empty/>' tags"	self		printOn: aStream		beforeWritingDo: [:writer | writer outputsSelfClosingTags: false]! !!XMLNode methodsFor: 'printing'!printWithoutSelfClosingTagsToFileNamed: aFileName	"Prints XML to the file aFileName with empty elements rendered	as '<empty></empty>' instead of self-closing '<empty/>' tags"	self		printToFileNamed: aFileName		beforeWritingDo: [:writer | writer outputsSelfClosingTags: false]! !!XMLNode methodsFor: 'printing'!printedWithoutSelfClosingTags	"Prints XML with empty elements rendered as '<empty></empty>' instead	of self-closing '<empty/>' tags"	^ String streamContents: [:stream | self printWithoutSelfClosingTagsOn: stream]! !!XMLNode methodsFor: 'accessing'!rawContentString 	"Returns a combined string of all descendant string values without any spaces	inserted for readability.		See also #contentString"	^ String streamContents: [:stream | self printRawContentOn: stream]! !!XMLNode methodsFor: 'accessing'!sortKey	"used to compare nodes when sorting"	^ self class name asString! !!XMLNode methodsFor: 'validating'!validate	"revalidate against the DTD it was parsed with (if any)"	self document ifNotNil: [:document | document validate]! !!XMLNode methodsFor: 'validating'!validateWith: aValidator	"revalidate against a custom DTD or other validator"	self document ifNotNil: [:document | document validateWith: aValidator]! !!XMLNode methodsFor: 'private'!withNewWriteStreamOnFileNamed: aFileName do: aBlock	aFileName asXMLFileHandle writeStreamDo: [:writeStream |		self initializeFileWriteStream: writeStream.		aBlock value: writeStream]! !!XMLNode methodsFor: 'private'!withNewXMLWriterOn: aStream do: aOneArgBlock	^ self		withNewXMLWriterOn: aStream		do: aOneArgBlock		whenAbsent: [self errorXMLWritingUnsupported]! !!XMLNode methodsFor: 'private'!withNewXMLWriterOn: aStream do: aOneArgBlock whenAbsent: aZeroArgBlock	| writer |	writer :=		(self xmlWriterClassOrNil			ifNil: [^ aZeroArgBlock value]) on: aStream.	self escapesContentEntitiesWhenWriting		ifFalse: [writer escapesContentEntityReferences: false].	^ aOneArgBlock value: writer.! !!XMLNode methodsFor: 'printing'!writeXMLOn: aWriter	"Template method used by nodes to write themselves on XMLWriters.	Sending with a customized XMLWriter instance as the argument can be used	to customize printing, but #printOn:beforeWritingDo: should be preferred."! !!XMLNode methodsFor: 'defaults'!xmlWriterClassOrNil	"can be overridden to return a custom XMLWriter subclass"	^ XMLClassFinder classNamed: #XMLWriter! !!XMLDoctypeDeclaration class methodsFor: 'instance creation'!root: aRootElementName publicID: aPublicID systemID: aSystemID	^ self new		root: aRootElementName;		publicID: aPublicID;		systemID: aSystemID! !!XMLDoctypeDeclaration methodsFor: 'instance creation'!newListForSelect	^ XMLInternalSubsetList new: 10! !!XMLDoctypeDeclaration methodsFor: 'defaults'!nodeListClass	^ XMLInternalSubsetList! !!XMLDoctypeDeclaration methodsFor: 'accessing'!publicID	^ publicID ifNil: [publicID := '']! !!XMLDoctypeDeclaration methodsFor: 'accessing'!publicID: aPublicID	publicID := aPublicID! !!XMLDoctypeDeclaration methodsFor: 'accessing'!root	^ root ifNil: [root := '']! !!XMLDoctypeDeclaration methodsFor: 'accessing'!root: aRootElementName	root := aRootElementName! !!XMLDoctypeDeclaration methodsFor: 'accessing'!systemID	^ systemID ifNil: [systemID := '']! !!XMLDoctypeDeclaration methodsFor: 'accessing'!systemID: aSystemID	systemID := aSystemID! !!XMLDoctypeDeclaration methodsFor: 'printing'!writeXMLOn: aWriter	aWriter doctype		root: self root;		publicID: self publicID;		systemID: self systemID;		with: [self writeInnerXMLOn: aWriter]! !!XMLNodeWithChildren methodsFor: 'adding'!addComment: aString	^ self addNode: (self newComment: aString)! !!XMLNodeWithChildren methodsFor: 'adding'!addNode: aNode	"Adds aNode to the end of the receiver's node list. Can be used for elements,	comments, and other types of nodes."	^ self nodes addLast: aNode! !!XMLNodeWithChildren methodsFor: 'adding'!addNode: aNode after: aPreviousNode	"Adds aNode to the receiver's node list after aPreviousNode raising an	error if aPreviousNode is absent"	^ self nodes		add: aNode		after: aPreviousNode! !!XMLNodeWithChildren methodsFor: 'adding'!addNode: aNode before: aNextNode	"Adds aNode to the receiver's node list before aNextNode raising an	error if aNextNode is absent"	^ self nodes		add: aNode		before: aNextNode! !!XMLNodeWithChildren methodsFor: 'adding'!addNodeFirst: aNode	"Adds aNode to the begining of the receiver's node list. Can be used for	elements, comments, and other types of nodes."	^ self nodes addFirst: aNode! !!XMLNodeWithChildren methodsFor: 'adding'!addNodes: aNodeCollection	^ self nodes addAll: aNodeCollection! !!XMLNodeWithChildren methodsFor: 'adding'!addPITarget: aTargetString data: aDataString	^ self addNode:		(self			newPITarget: aTargetString			data: aDataString)! !!XMLNodeWithChildren methodsFor: 'notifying'!addedNode: aNode	aNode parent		ifNotNil: [:nodeParent |			nodeParent == self				ifFalse: [nodeParent removeNode: aNode]].	aNode parent: self.! !!XMLNodeWithChildren methodsFor: 'accessing'!allNodes	"returns a node list with the receiver and all of its descendant nodes"	| allNodes |	allNodes := self newListForSelect.	self allNodesDo: [:each | allNodes addLast: each].	^ allNodes.! !!XMLNodeWithChildren methodsFor: 'enumerating'!allNodesCollect: aBlock	"returns an ordered list of the receiver and all of its descendant nodes	evaluated with aBlock"	| collectedObjects |	collectedObjects := self newListForCollect.	self allNodesDo: [:each | collectedObjects addLast: (aBlock value: each)].	^ collectedObjects.! !!XMLNodeWithChildren methodsFor: 'enumerating'!allNodesDetect: aBlock	^ self allNodesDetect: aBlock ifNone: [nil]! !!XMLNodeWithChildren methodsFor: 'enumerating'!allNodesDetect: aBlock ifNone: anExceptionBlock	self allNodesDo: [:each |		(aBlock value: each)			ifTrue: [^ each]].	^ anExceptionBlock value.! !!XMLNodeWithChildren methodsFor: 'enumerating'!allNodesDo: aBlock	"evaluates aBlock for the receiver and all of its descendant nodes"	aBlock value: self.	self hasChildren		ifTrue: [self nodesDo: [:each | each allNodesDo: aBlock]]! !!XMLNodeWithChildren methodsFor: 'enumerating'!allNodesSelect: aBlock	| selectedNodes |	selectedNodes := self newListForSelect.	self allNodesDo: [:each |		(aBlock value: each)			ifTrue: [selectedNodes addLast: each]].	^ selectedNodes.! !!XMLNodeWithChildren methodsFor: 'testing'!canHaveChildren	^ true! !!XMLNodeWithChildren methodsFor: 'accessing'!descendantNodes	"returns a node list with all descendant nodes of the receiver"	| descendentNodes |	descendentNodes := self newListForSelect.	self descendantNodesDo: [:each | descendentNodes addLast: each].	^ descendentNodes.! !!XMLNodeWithChildren methodsFor: 'enumerating'!descendantNodesCollect: aBlock	"returns an ordered list of the values of all descendant nodes of the	receiver evaluated with aBlock"	| collectedObjects |	collectedObjects := self newListForCollect.	self descendantNodesDo: [:each |		collectedObjects addLast: (aBlock value: each)].	^ collectedObjects.! !!XMLNodeWithChildren methodsFor: 'enumerating'!descendantNodesDetect: aBlock	"returns the first descendant node of the receiver that aBlock evaluates	true for or nil if there isn't one"	^ self		descendantNodesDetect: aBlock		ifNone: [nil]! !!XMLNodeWithChildren methodsFor: 'enumerating'!descendantNodesDetect: aBlock ifNone: anExceptionBlock	"returns the first descendant node of the receiver that aBlock evaluates	true for or the value of anExceptionBlock if there isn't one"	self descendantNodesDo: [:each |		(aBlock value: each)			ifTrue: [^ each]].	^ anExceptionBlock value.! !!XMLNodeWithChildren methodsFor: 'enumerating'!descendantNodesDo: aBlock	"evaluates aBlock for all descendant nodes of the receiver"	self hasChildren		ifTrue: [self nodesDo: [:each | each allNodesDo: aBlock]]! !!XMLNodeWithChildren methodsFor: 'enumerating'!descendantNodesSelect: aBlock	"returns a node list of all descendant nodes of the receiver that aBlock	evaluates true for"	| selectedNodes |	selectedNodes := self newListForSelect.	self descendantNodesDo: [:each |		(aBlock value: each)			ifTrue: [selectedNodes addLast: each]].	^ selectedNodes.! !!XMLNodeWithChildren methodsFor: 'deprecated'!descendentNodes	self deprecated: 'use #descendantNodes instead'.	^ self descendantNodes.! !!XMLNodeWithChildren methodsFor: 'deprecated'!descendentNodesCollect: aBlock	self deprecated: 'use #descendantNodesCollect: instead'.	^ self descendantNodesCollect: aBlock.! !!XMLNodeWithChildren methodsFor: 'deprecated'!descendentNodesDetect: aBlock	self deprecated: 'use #descendantNodesDetect: instead'.	^ self descendantNodesDetect: aBlock.! !!XMLNodeWithChildren methodsFor: 'deprecated'!descendentNodesDetect: aBlock ifNone: anExceptionBlock	self deprecated: 'use #descendantNodesDetect:ifNone: instead'.	^ self		descendantNodesDetect: aBlock		ifNone: anExceptionBlock.! !!XMLNodeWithChildren methodsFor: 'deprecated'!descendentNodesSelect: aBlock	self deprecated: 'use #descendantNodesSelect: instead'.	^ self descendantNodesSelect: aBlock.! !!XMLNodeWithChildren methodsFor: 'accessing'!firstNode	"returns the first child node of the receiver if it has one, nil otherwise"	^ self nodes first! !!XMLNodeWithChildren methodsFor: 'testing'!hasChildren	"optimized with nil test and size check to avoid lazy initializing"	nodes == nil		ifTrue: [^ false].	^ nodes size > 0.! !!XMLNodeWithChildren methodsFor: 'private'!hasNodeList: aNodeList	^ nodes == aNodeList! !!XMLNodeWithChildren methodsFor: 'testing'!includesNode: aNode	^ self nodes includes: aNode! !!XMLNodeWithChildren methodsFor: 'accessing'!innerXML	"Returns a string containing the XML source of all descendent nodes.		See #innerXML:"	^ String streamContents: [:stream | self printInnerXMLOn: stream]! !!XMLNodeWithChildren methodsFor: 'accessing'!innerXMLPrettyPrinted	"Pretty print version of #innerXML.		See #innerXML:"	^ String streamContents: [:stream |		self			printInnerXMLOn: stream			beforeWritingDo: [:writer | writer enablePrettyPrinting]]! !!XMLNodeWithChildren methodsFor: 'accessing'!lastNode	"returns the last child node of the receiver if it has one, nil otherwise"	^ self nodes last! !!XMLNodeWithChildren methodsFor: 'accessing'!nodeAfter: aNode	"returns the first child node of the receiver after aNode or nil if there	isn't one"	^ self nodes after: aNode! !!XMLNodeWithChildren methodsFor: 'accessing'!nodeAt: anIndex	"returns the child node at position anIndex or nil if there isn't one"	^ self nodes at: anIndex! !!XMLNodeWithChildren methodsFor: 'accessing'!nodeAt: anIndex ifAbsent: aBlock	"returns the child node at position anIndex or the value of aBlock	if there isn't one"	^ self nodes		at: anIndex		ifAbsent: aBlock! !!XMLNodeWithChildren methodsFor: 'accessing'!nodeAt: anIndex put: aNode	"replaces the child node at anIndex with aNode, raising an error if	anIndex is outside the current range of the node list"	^ self nodes		at: anIndex		put: aNode! !!XMLNodeWithChildren methodsFor: 'accessing'!nodeBefore: aNode	"returns the first child node of the receiver before aNode or nil if there	isn't one"	^ self nodes before: aNode! !!XMLNodeWithChildren methodsFor: 'defaults'!nodeListClass	^ XMLNodeList! !!XMLNodeWithChildren methodsFor: 'accessing'!nodes	"returns the internal node list; safe to modify, but adding or removing nodes	from it will have the effect of adding or removing them from the receiver"	^ nodes ifNil: [nodes := self nodeListClass observer: self]! !!XMLNodeWithChildren methodsFor: 'enumerating'!nodesCollect: aBlock	"returns an ordered list of the values of all node children of the	receiver evaluated with aBlock"	^ self nodes collect: aBlock! !!XMLNodeWithChildren methodsFor: 'enumerating'!nodesDetect: aBlock	^ self nodes detect: aBlock! !!XMLNodeWithChildren methodsFor: 'enumerating'!nodesDetect: aBlock ifNone: anExceptionBlock	^ self nodes detect: aBlock ifNone: anExceptionBlock! !!XMLNodeWithChildren methodsFor: 'enumerating'!nodesDo: aBlock	"evaluates aBlock for all child nodes of the receiver"	self nodes do: aBlock! !!XMLNodeWithChildren methodsFor: 'enumerating'!nodesSelect: aBlock	"returns a node list of all node children of the receiver that aBlock	evaluates true for"	^ self nodes select: aBlock! !!XMLNodeWithChildren methodsFor: 'copying'!postCopy	super postCopy.	nodes		ifNotNil: [| copiedNodes |			copiedNodes := nodes copyEmpty observer: self.			nodes do: [:each |				"copySharingConfiguration is used so the config is only ever copied				once when an element or doc is sent #copy and is done after all of the				descendants have been copied"				copiedNodes addLast: each copySharingConfiguration].			nodes := copiedNodes].! !!XMLNodeWithChildren methodsFor: 'printing'!printInnerXMLOn: aStream	self hasChildren		ifTrue: [			self				withNewXMLWriterOn: aStream				do: [:writer |					self writeInnerXMLOn: writer]]! !!XMLNodeWithChildren methodsFor: 'printing'!printInnerXMLOn: aStream beforeWritingDo: aBlock	self hasChildren		ifTrue: [			self				withNewXMLWriterOn: aStream				do: [:writer |					aBlock value: writer.					self writeInnerXMLOn: writer.					writer write]]! !!XMLNodeWithChildren methodsFor: 'removing'!removeNode: aNode	^ self nodes remove: aNode! !!XMLNodeWithChildren methodsFor: 'removing'!removeNode: aNode ifAbsent: aBlock	^ self nodes remove: aNode ifAbsent: aBlock! !!XMLNodeWithChildren methodsFor: 'removing'!removeNodes	self nodes removeAll! !!XMLNodeWithChildren methodsFor: 'removing'!removeNodes: aNodeCollection	^ self nodes removeAll: aNodeCollection! !!XMLNodeWithChildren methodsFor: 'notifying'!removedNode: aNode	aNode parent: nil! !!XMLNodeWithChildren methodsFor: 'accessing'!replaceNode: aNode with: aReplacementNode	"replaces aNode in the receiver with aReplacementNode, or if aReplacementNode	is already a child of the receiver, just swaps their locations"	| firstIndex secondIndex |	firstIndex := self nodes indexOf: aNode.	(secondIndex := self nodes indexOf: aReplacementNode) > 0		ifTrue: [			self nodes				swap: firstIndex				with: secondIndex]		ifFalse: [			self nodes				at: firstIndex				put: aReplacementNode].	^ aReplacementNode.! !!XMLNodeWithChildren methodsFor: 'printing'!writeInnerXMLOn: aWriter	self nodesDo: [:each | each writeXMLOn: aWriter]! !!XMLNodeWithChildren methodsFor: 'printing'!writeXMLOn: aWriter	self writeInnerXMLOn: aWriter! !!XMLDocument class methodsFor: 'instance creation'!root: aRoot	^ self new root: aRoot! !!XMLDocument methodsFor: 'visiting'!acceptNodeVisitor: aNodeVisitor	^ aNodeVisitor visitDocument: self! !!XMLDocument methodsFor: 'accessing'!doctypeDeclaration	^ doctypeDeclaration! !!XMLDocument methodsFor: 'accessing'!doctypeDeclaration: aDoctypeDeclaration	doctypeDeclaration		ifNotNil: [doctypeDeclaration parent: nil].	aDoctypeDeclaration		ifNotNil: [			aDoctypeDeclaration hasParent				ifTrue: [					"remove it from its current parent"					aDoctypeDeclaration parent doctypeDeclaration: nil].			aDoctypeDeclaration parent: self].	doctypeDeclaration := aDoctypeDeclaration.! !!XMLDocument methodsFor: 'accessing'!doctypeDefinition	^ doctypeDefinition! !!XMLDocument methodsFor: 'accessing'!doctypeDefinition: aDoctypeDefinition	doctypeDefinition := aDoctypeDefinition! !!XMLDocument methodsFor: 'accessing'!document	^ self! !!XMLDocument methodsFor: 'accessing'!documentRoot	"returns the root of the DOM tree"	^ self! !!XMLDocument methodsFor: 'accessing'!encoding		^ encoding ifNil: [encoding := '']! !!XMLDocument methodsFor: 'accessing'!encoding: aString		encoding := aString! !!XMLDocument methodsFor: 'private'!errorCannotHaveNonElementRoot	XMLDOMException signal: 'Cannot have non-element root'! !!XMLDocument methodsFor: 'testing'!hasDoctypeDeclaration	^ self doctypeDeclaration notNil! !!XMLDocument methodsFor: 'testing'!hasDoctypeDefinition	^ self doctypeDefinition notNil! !!XMLDocument methodsFor: 'testing'!hasEncoding	^ self encoding notEmpty! !!XMLDocument methodsFor: 'testing'!hasRoot	^ self root notNil! !!XMLDocument methodsFor: 'private'!innerXMLStateClass	^ XMLPostDoctypeDeclarationState! !!XMLDocument methodsFor: 'testing'!isDocument	^ true! !!XMLDocument methodsFor: 'testing'!isStandalone	^ isStandalone ifNil: [isStandalone := false]! !!XMLDocument methodsFor: 'accessing'!isStandalone: aBoolean	isStandalone := aBoolean! !!XMLDocument methodsFor: 'copying'!postCopy	super postCopy.	doctypeDeclaration		ifNotNil: [doctypeDeclaration := doctypeDeclaration copy].! !!XMLDocument methodsFor: 'accessing'!root	"Returns the current root element or nil if there isn't one"	^ self firstElement! !!XMLDocument methodsFor: 'accessing'!root: anElement	"Replaces the current root element (if any) with anElement,	leaving all other nodes in place"	anElement isElement		ifFalse: [self errorCannotHaveNonElementRoot].	self firstElement		ifNil: [self addNode: anElement]		ifNotNil: [:firstElement |			self				replaceNode: firstElement				with: anElement].! !!XMLDocument methodsFor: 'validating'!validate	"revalidate against the DTD it was parsed with (if any)"	self hasDoctypeDefinition		ifTrue: [			self doctypeDefinition				removeElementIDReferences;				removeElementIDs.			self validateWith: self doctypeDefinition newValidator]! !!XMLDocument methodsFor: 'validating'!validateWith: aValidator	"revalidate against a custom DTD or other validator"	(XMLValidatingNodeVisitor validator: aValidator) visitDocument: self! !!XMLDocument methodsFor: 'accessing'!version		^ version! !!XMLDocument methodsFor: 'accessing'!version: aVersionFloat	version := aVersionFloat! !!XMLDocument methodsFor: 'printing'!writeDoctypeDeclarationOn: aWriter	self hasDoctypeDeclaration		ifTrue: [self doctypeDeclaration writeXMLOn: aWriter]! !!XMLDocument methodsFor: 'printing'!writeXMLDeclarationOn: aWriter	self version		ifNotNil: [			aWriter xml				version: self version;				encoding: self encoding;				standalone: self isStandalone;				write]! !!XMLDocument methodsFor: 'printing'!writeXMLOn: aWriter	self		writeXMLDeclarationOn: aWriter;		writeDoctypeDeclarationOn: aWriter;		writeInnerXMLOn: aWriter! !!XMLElement class methodsFor: 'instance creation'!name: aLocalName	^ self named: aLocalName! !!XMLElement class methodsFor: 'instance creation'!name: aLocalName attributes: anAssociationCollection	"Returns a new element with the specified name and attributes.	Both aLocalName and the attributes must not be prefixed or a namespace	exception will be thrown.	The anAssociationCollection argument can be a dictionary or any collection	of associations."	^ (self named: aLocalName)		setAttributes: anAssociationCollection! !!XMLElement class methodsFor: 'instance creation'!name: aQualifiedName namespaceURI: aURI	"Returns a new element with the specified name and namespace URI.	If aQualifiedName has a prefix, then aURI must be non-empty and the prefix	will be bound to it. Otherwise aURI will be declared as the default namespace."	^ self new		name: aQualifiedName		namespaceURI: aURI! !!XMLElement class methodsFor: 'instance creation'!name: aQualifiedName namespaceURI: aURI attributes: anAssociationCollection	"Returns a new element with the specified name, namespace URI, and attributes.	If aQualifiedName has a prefix, then aURI must be non-empty and the prefix	will be bound to it. Otherwise aURI will be declared as the default namespace.	If the attributes are prefixed, then aQualifiedName must have the same prefix	or a namespace exception will be thrown.	The anAssociationCollection argument can be a dictionary or any collection	of associations."	^ (self		name: aQualifiedName		namespaceURI: aURI)			setAttributes: anAssociationCollection! !!XMLElement class methodsFor: 'instance creation'!name: aQualifiedName namespaces: anAssociationCollection	"Returns a new element with the specified name and namespaces.	If aQualifiedName has a prefix, then anAssociationCollection must contain	an association for it or a namespace exception will be thrown.	The anAssociationCollection argument can be a dictionary or any collection	of associations. An association with an empty string key sets the default	namespace."	^ self new		declareNamespaces: anAssociationCollection;		name: aQualifiedName! !!XMLElement class methodsFor: 'instance creation'!name: aQualifiedName namespaces: aNamespaceAssociationCollection attributes: anAttributeAssociationCollection	"Returns a new element with the specified name, namespaces, and attributes.	If aQualifiedName or one of the attributes has a prefix, then	aNamespaceAssociationCollection must contain an association for it or a	namespace exception will be thrown.	The aNamespaceAssociationCollection and anAttributeAssociationCollection	arguments can be dictionaries or any collection of associations. An	association with an empty string key sets the default namespace."	^ (self		name: aQualifiedName		namespaces: aNamespaceAssociationCollection)			setAttributes: anAttributeAssociationCollection! !!XMLElement class methodsFor: 'instance creation'!named: aLocalName	"Returns a new element with the specified name.	The argument must not be prefixed or a namespace exception will be thrown."	^ self new name: aLocalName! !!XMLElement methodsFor: 'visiting'!acceptNodeVisitor: aNodeVisitor	^ aNodeVisitor visitElement: self! !!XMLElement methodsFor: 'notifying'!addedAttribute: anAttribute	anAttribute element		ifNotNil: [:element |			element == self				ifFalse: [element removeAttributeNode: anAttribute]].	anAttribute element: self.	self validateNamespacePrefixOfAttribute: anAttribute.! !!XMLElement methodsFor: 'private'!addedElement: anElement	(self hasNamespaces		and: [self namespaceScope ~= anElement namespaceScope])		ifTrue: [			anElement allElementsDo: [:each |				each namespaceScope inheritMappingsFrom: self namespaceScope]]! !!XMLElement methodsFor: 'enumerating'!allElementsDo: aBlock	"evaluates aBlock for the receiver and all descendant elements"	aBlock value: self.	self hasChildren		ifTrue: [self elementsDo: [:each | each allElementsDo: aBlock]].! !!XMLElement methodsFor: 'private'!allNamespaceScopesRemapPrefix: aPrefix from: anOldURIOrNil to: aNewURI	(self namespaceScope		prefixMappingAt: aPrefix		ifAbsent: [anOldURIOrNil]) = anOldURIOrNil		ifTrue: [			self namespaceScope				mapPrefix: aPrefix				to: aNewURI.			"we only need to check the attributes if we've remapped an			existing, non-default namespace"			(anOldURIOrNil notNil				and: [aPrefix size > 0])				ifTrue: [self validateNamespacePrefixesOfAttributes].			self elementsDo: [:each |				each					allNamespaceScopesRemapPrefix: aPrefix					from: anOldURIOrNil					to: aNewURI]]! !!XMLElement methodsFor: 'private'!allNamespaceScopesUnmapPrefix: aPrefix mappedTo: aURI	(self namespaceScope		includesPrefix: aPrefix		mappedTo: aURI)		ifTrue: [			self namespaceScope unmapPrefix: aPrefix.			self				validateNamespacePrefix;				validateNamespacePrefixesOfAttributes.			self elementsDo: [:each |				each					allNamespaceScopesUnmapPrefix: aPrefix					mappedTo: aURI]]! !!XMLElement methodsFor: 'accessing'!attributeAssociations	"returns attribute name->value associations"	^ self attributeNodes attributeAssociations! !!XMLElement methodsFor: 'accessing'!attributeAt: aName	"returns the value of the attribute whose full name matches aName or an	empty string if there isn't any"	^ self attributeNodes attributeValueAt: aName! !!XMLElement methodsFor: 'accessing'!attributeAt: aName ifAbsent: aBlock	"returns the value of the attribute whose full name matches aName or the	value of aBlock if there isn't any"	^ self attributeNodes		attributeValueAt: aName		ifAbsent: aBlock! !!XMLElement methodsFor: 'accessing'!attributeAt: aName ifAbsentPut: aBlock	"sets the value of the attribute whose full name matches aName to the value	of aBlock if there isn't one already"	^ self attributeNodes		attributeValueAt: aName		ifAbsentPut: aBlock! !!XMLElement methodsFor: 'accessing'!attributeAt: aName put: aValue	"sets the value of the attribute whose full name matches aName to the value	aValue"	^ self attributeNodes		attributeValueAt: aName		put: aValue! !!XMLElement methodsFor: 'defaults'!attributeListClass	^ self configuration nodeFactory attributeListClass! !!XMLElement methodsFor: 'accessing'!attributeNames	^ self attributeNodes attributeNames! !!XMLElement methodsFor: 'enumerating'!attributeNamesAndValuesDo: aTwoArgumentBlock	self attributeNodes attributeNamesAndValuesDo: aTwoArgumentBlock! !!XMLElement methodsFor: 'enumerating'!attributeNamesDo: aBlock	self attributeNodes attributeNamesDo: aBlock! !!XMLElement methodsFor: 'accessing'!attributeNodeAt: aName	"returns the attribute node whose qualified or local name matches aName	(unlike attributeAt:, which matches the full name exactly), or nil if there	isn't any"	^ self attributeNodes attributeNodeAt: aName! !!XMLElement methodsFor: 'accessing'!attributeNodeAt: aName ifAbsent: aBlock	"returns the attribute node whose qualified or local name matches aName	(unlike attributeAt:ifAbsent:, which matches the full name exactly), or	the value of aBlock if there isn't any"	^ self attributeNodes		attributeNodeAt: aName		ifAbsent: aBlock! !!XMLElement methodsFor: 'accessing'!attributeNodeAt: aName namespaceURI: aURI	"returns the attribute node whose qualified or local name matches aName	(unlike attributeAt:, which matches the full name exactly) and whose	namespace URI matches aURI, or nil if there isn't any"	^ self attributeNodes		attributeNodeAt: aName		namespaceURI: aURI! !!XMLElement methodsFor: 'accessing'!attributeNodeAt: aName namespaceURI: aURI ifAbsent: aBlock	"returns the attribute node whose qualified or local name matches aName	(unlike attributeAt:ifAbsent:, which matches the full name exactly) and	whose namespace URI matches aURI, or the value of aBlock if there isn't any"	^ self attributeNodes		attributeNodeAt: aName		namespaceURI: aURI		ifAbsent: aBlock! !!XMLElement methodsFor: 'accessing'!attributeNodes	"Returns the attribute node list. Can be modified, but adding or removing	attributes also adds or removes them from the element. Copy before	modifying if you don't want that."	^ attributes ifNil: [attributes := self attributeListClass observer: self]! !!XMLElement methodsFor: 'enumerating'!attributeNodesDo: aBlock	self attributeNodes do: aBlock! !!XMLElement methodsFor: 'accessing'!attributes	"returns a new order preserving dictionary of attribute names and values"	^ self attributeNodes attributes! !!XMLElement methodsFor: 'namespacing'!declareNamespaces: anAssociationCollection	self ensureUsesNamespaces.	anAssociationCollection associationsDo: [:each |		self			declarePrefix: each key			uri: each value]! !!XMLElement methodsFor: 'namespacing'!declarePrefix: aPrefix uri: aURI	self ensureUsesNamespaces.	self		allNamespaceScopesRemapPrefix: aPrefix		from:			(self namespaceScope				prefixMappingAt: aPrefix				ifAbsent: [nil])		to: aURI.! !!XMLElement methodsFor: 'namespacing'!declaredPrefixes	^ self usesNamespaces "avoid lazy initializing the scope"		ifTrue: [self namespaceScope mappedPrefixes]		ifFalse: [#()]! !!XMLElement methodsFor: 'testing'!declaresDefaultNamespace	"Did the receiver declare a new default namespace rather than inheriting one?"	^ self namespaceScope hasDefaultNamespace		and: [self isRoot			or: [self defaultNamespace ~= self parent defaultNamespace]]! !!XMLElement methodsFor: 'testing'!declaresPrefix: aPrefix uri: aURI	"Did the receiver declare a new prefix/uri pair rather than inheriting it?"	^ (self isDeclaredPrefix: aPrefix uri: aURI)		and: [self isRoot			or: [(self parent isDeclaredPrefix: aPrefix uri: aURI) not]]! !!XMLElement methodsFor: 'namespacing'!defaultNamespace	^ self usesNamespaces "avoid lazy initializing the scope"		ifTrue: [self namespaceScope defaultNamespace]		ifFalse: ['']! !!XMLElement methodsFor: 'namespacing'!defaultNamespace: aURI	self		declarePrefix: ''		uri: aURI! !!XMLElement methodsFor: 'accessing'!expandedName	"Returns the expanded name of the element as a string in the form of	'{namespaceURI}localName' if there's a namespace URI or 'localName' if there	isn't"	^ self localName expandWithXMLNamespaceURI: self namespaceURI! !!XMLElement methodsFor: 'testing'!hasAttributes	"returns true if this element has attribute"	"optimized to avoid lazy initialization"	attributes == nil		ifTrue: [^ false].	^ attributes size > 0.! !!XMLElement methodsFor: 'testing'!hasID: anID	| document doctypeDefinition attributeValidators |	self hasAttributes		ifFalse: [^ false].	((document := self document) notNil		and: [(doctypeDefinition := document doctypeDefinition) notNil			and: [doctypeDefinition hasAttributeValidators				and: [					(attributeValidators :=						doctypeDefinition attributeValidatorsAt: self name) notNil]]])		ifTrue: [			^ self				hasUndeclaredOrDeclaredID: anID				declaredWith: attributeValidators]		ifFalse: [^ self hasUndeclaredID: anID].! !!XMLElement methodsFor: 'testing'!hasNamespaceURI	^ self namespaceURI notEmpty! !!XMLElement methodsFor: 'testing'!hasNamespaces	"returns true if the receiver declared or inherited namespace declarations"	"optimized to avoid lazy initialization"	namespaceScope == nil		ifTrue: [^ false].	^ namespaceScope hasNamespaces.! !!XMLElement methodsFor: 'testing'!hasPrefix	"returns true if the receiver's name is a qualified name with a prefix"	^ self name size > self localName size! !!XMLElement methodsFor: 'private'!hasUndeclaredID: anID	"just look for an 'xml:id' attribute if there were no declarations"	^ (self		attributeAt: 'xml:id'		ifAbsent: [^ false]) = anID! !!XMLElement methodsFor: 'private'!hasUndeclaredOrDeclaredID: anID declaredWith: anAttributeValidatorDictionary	self attributeNamesAndValuesDo: [:attributeName :attributeValue |		"only check its value if it's been declared as an ID attribute		or if it's named 'xml:id'"		((anAttributeValidatorDictionary			at: attributeName			ifAbsent: [nil])				ifNil: [attributeName = 'xml:id']				ifNotNil: [:attributeValidator | attributeValidator isID])			ifTrue: [				attributeValue = anID					ifTrue: [^ true]]].	^ false.! !!XMLElement methodsFor: 'testing'!includesAttribute: aName	^ self attributeNodes includesAttribute: aName! !!XMLElement methodsFor: 'testing'!includesAttributeNode: aName	^ self attributeNodes includesAttributeNode: aName! !!XMLElement methodsFor: 'testing'!includesAttributeNode: aName namespaceURI: aURI	^ self attributeNodes		includesAttributeNode: aName		namespaceURI: aURI! !!XMLElement methodsFor: 'testing'!isDeclaredPrefix: aPrefix	"is the namespace prefix aPrefix declared for the receiver and its descendants?"	^ self usesNamespaces		and: [self namespaceScope includesPrefix: aPrefix]! !!XMLElement methodsFor: 'testing'!isDeclaredPrefix: aPrefix uri: aURI	"is the namespace prefix aPrefix mapped to aURI for the receiver and	its descendants?"	^ self usesNamespaces		and: [			self namespaceScope				includesPrefix: aPrefix				mappedTo: aURI]! !!XMLElement methodsFor: 'testing'!isElement	^ true! !!XMLElement methodsFor: 'testing'!isElementNamed: aName	"returns true if the receiver's qualified name or local name matches aName"	^ self isNamed: aName! !!XMLElement methodsFor: 'testing'!isElementNamedAny: aNameCollection	"returns true if the receiver's qualified name or local name matches any	name in aNameCollection"	^ self isNamedAny: aNameCollection! !!XMLElement methodsFor: 'testing'!isInLanguage: aLanguageTag	"Returns true if the receiver or one of its ancestors has an xml:lang	attribute, and if the value is an IETF language tag, like 'En-US', that matches	aLanguageTag. Matching is case-insensitive, and aLanguageTag can be partial,	like 'En', and use wildcards, like 'En-*'"	^ (self		attributeNodeAt: 'xml:lang'		ifAbsent: [			^ self hasParent				and: [self parent isInLanguage: aLanguageTag]])			matchesLanguage: aLanguageTag! !!XMLElement methodsFor: 'testing'!isNamed: aName	"Does the receiver's qualified or local name match aName?"	^ self name isXMLQualifiedOrLocalName: aName! !!XMLElement methodsFor: 'testing'!isNamedAny: aNameCollection	"Does the receiver's qualified or local name match any of the names	in aNameCollection?"	^ aNameCollection includesXMLName: self name! !!XMLElement methodsFor: 'testing'!isRoot	"Is the receiver the root element of a DOM tree?"	^ (self hasParent and: [self parent isElement]) not! !!XMLElement methodsFor: 'accessing'!localName	"Returns the local name of the receiver, the name minus any leading	prefix and colon like 'local' in 'prefix:local'"	^ localName ifNil: [localName := self name xmlLocalNameAfterPrefix]! !!XMLElement methodsFor: 'accessing'!name	"returns the full name of the element, either a qualified name if it has a	prefix or just a local name if it doesn't"	^ name ifNil: [name := '']! !!XMLElement methodsFor: 'accessing'!name: aName	"Renames the element. If aName is a qualified name and namespace checking is	enabled (default), then the prefix must already have been declared. This can	be done while renaming using name:namespaceURI."	self renameWith: [		name := aName.		localName := aName xmlLocalNameAfterPrefix]! !!XMLElement methodsFor: 'accessing'!name: aName namespaceURI: aURI	"Renames the element and also declares a namespace URI in one step. If aName	is qualified, then it declares the prefix to be mapped to aURI. If aName has	no prefix, then aURI is declared as the default namespace URI."	self		declarePrefix: (aName xmlPrefixBeforeLocalName) uri: aURI;		name: aName! !!XMLElement methodsFor: 'private'!namespaceScope	^ namespaceScope ifNil: [namespaceScope := XMLNamespaceScope new]! !!XMLElement methodsFor: 'accessing'!namespaceURI	^ self resolvePrefix: self prefix! !!XMLElement methodsFor: 'private'!newNamespaceScopeForAddedElement	^ self usesNamespaces		ifTrue: [self namespaceScope copy]		ifFalse: [nil]! !!XMLElement methodsFor: 'accessing'!nextElement	"returns the first element after the receiver that is a child of the same	parent if there is one, nil otherwise"	^ self parent ifNotNil: [:node | node elementAfter: self]! !!XMLElement methodsFor: 'copying'!postCopy	super postCopy.	namespaceScope		ifNotNil: [namespaceScope := namespaceScope copy].	attributes		ifNotNil: [| copiedAttributes |			copiedAttributes := attributes copyEmpty observer: self.			attributes do: [:each | copiedAttributes addLast: each copy].			attributes := copiedAttributes].! !!XMLElement methodsFor: 'accessing'!prefix	"Returns the prefix of the receiver's name or an empty string if there	isn't one."	"this is recomputed from the qualified and local name instead of being	stored in an inst var to save memory."	^ self name xmlPrefixBeforeLocalName: self localName! !!XMLElement methodsFor: 'accessing'!prefix: aPrefix	"Changes the prefix of the name of the receiver to aPrefix. If namespace	checking is enabled (default) and aPrefix is non-empty, then aPrefix must	have been declared."	self renameWith: [name := self localName qualifyWithXMLPrefix:  aPrefix]! !!XMLElement methodsFor: 'accessing'!previousElement	"returns the first element before the receiver that is a child of the same	parent if there is one, nil otherwise"	^ self parent ifNotNil: [:node | node elementBefore: self]! !!XMLElement methodsFor: 'removing'!removeAttribute: aName	"Removes and returns the value of the attribute whose full name matches	aName or raises an error if it's absent."	^ (self attributeNodes removeAttribute: aName) value.! !!XMLElement methodsFor: 'removing'!removeAttribute: aName ifAbsent: aBlock	"Removes and returns the value of the attribute whose full name matches	aName or returns the value of aBlock if it's absent."	^ self attributeNodes		removeAttribute: aName		ifAbsent: aBlock! !!XMLElement methodsFor: 'removing'!removeAttributeNode: aNode	"Removes and returns the attribute node aNode or raises an error if	it's absent."	^ self attributeNodes remove: aNode! !!XMLElement methodsFor: 'removing'!removeAttributeNode: aNode ifAbsent: aBlock	"Removes and returns the attribute node aNode or returns the value	of aBlock if it's absent."	^ self attributeNodes		remove: aNode		ifAbsent: aBlock! !!XMLElement methodsFor: 'removing'!removeAttributes	self attributeNodes removeAll! !!XMLElement methodsFor: 'notifying'!removedAttribute: anAttribute	anAttribute element: nil! !!XMLElement methodsFor: 'private'!renameWith: aBlock	| oldName |	oldName := self name.	aBlock value.	self name = oldName		ifFalse: [			self validateNamespacePrefix.			self hasParent				ifTrue: [					self parent						renamedElement: self						from: oldName						to: self name]].! !!XMLElement methodsFor: 'notifying'!renamedAttribute: anAttribute from: anOldName to: aNewName	self attributeNodes			renamedAttribute: anAttribute		from: anOldName		to: aNewName.	self validateNamespacePrefixOfAttribute: anAttribute.! !!XMLElement methodsFor: 'namespacing'!resolvePrefix: aPrefix	"Resolves the namespace URI of aPrefix (the defualt namespace URI if aPrefix	is empty), including the predefined 'xml' and 'xmlns' prefixes. Returns an	empty string if aPrefix is unresolvable."	^ self		resolvePrefix: aPrefix		ifUnresolvable: ''! !!XMLElement methodsFor: 'namespacing'!resolvePrefix: aPrefix ifUnresolvable: aBlock	"Resolves the namespace URI of aPrefix (the defualt namespace URI if aPrefix	is empty), including the predefined 'xml' and 'xmlns' prefixes. Returns the	value of aBlock if aPrefix is unresolvable."	^ self hasNamespaces "avoid lazy initializing the scope"		ifTrue: [			self namespaceScope				resolvePrefix: aPrefix				ifUnresolvable: aBlock]		ifFalse: [aBlock value]! !!XMLElement methodsFor: 'namespacing'!resolvePrefixesOfNamespaceURI: aURI	"returns a set of all the namespace prefixes of aURI"	^ self usesNamespaces		ifTrue: [self namespaceScope resolvePrefixesOfNamespaceURI: aURI]		ifFalse: [Set new]! !!XMLElement methodsFor: 'initialization'!setAttributes: anAssociationCollection	self attributeNodes setAttributes: anAssociationCollection! !!XMLElement methodsFor: 'private'!setConfiguration: aConfiguration name: aName localName: aLocalName attributes: anAttributeDictionary namespaceScope: aNamespaceScope	"This should only be sent by DOM parsers/builders, not public API users"	configuration := aConfiguration.	name := aName.	localName := aLocalName.	anAttributeDictionary size > 0 "optimization"		ifTrue: [			"This consumes anAttributeDictionary, so it can never be used			again safely"			(attributes :=				self attributeListClass new: anAttributeDictionary size)				observer: self;				setAttributesFromOrderPreservingDictionary: 					anAttributeDictionary].	namespaceScope := aNamespaceScope.! !!XMLElement methodsFor: 'private'!setNamespaceScope: aNamespaceScope	namespaceScope := aNamespaceScope! !!XMLElement methodsFor: 'accessing'!sortKey	^ self name! !!XMLElement methodsFor: 'namespacing'!undeclareDefaultNamespace	self undeclarePrefix: ''! !!XMLElement methodsFor: 'namespacing'!undeclarePrefix: aPrefix	self ensureUsesNamespaces.	self		allNamespaceScopesUnmapPrefix: aPrefix		mappedTo:			(self namespaceScope				prefixMappingAt: aPrefix				ifAbsent: [^ self]).! !!XMLElement methodsFor: 'namespacing'!undeclarePrefixes	self ensureUsesNamespaces.	self declaredPrefixes do: [:each |		self undeclarePrefix: each].! !!XMLElement methodsFor: 'private'!validateNamespacePrefix	(self usesNamespaces		and: [self hasPrefix])		ifTrue: [			self namespaceScope				validateAndResolvePrefix: self prefix				ofElement: self name]! !!XMLElement methodsFor: 'private'!validateNamespacePrefixOfAttribute: anAttribute	| attributePrefix attributeLocalName attributeNamespaceURI |	self usesNamespaces		ifFalse: [^ self].	attributePrefix := anAttribute prefix.	"send #validateAndResolvePrefix:ofAttribute: even if attributePrefix is	empty, to catch names like ':name', and return if the resolved URI is empty,	since non-default namespace URIs can't be empty, and attribute namespaces	are always non-default"	(attributeNamespaceURI :=		self namespaceScope			validateAndResolvePrefix: attributePrefix			ofAttribute: anAttribute name) size > 0		ifFalse: [^ self].	attributeLocalName :=		anAttribute name xmlLocalNameAfterPrefix: attributePrefix.	self attributeNodesDo: [:each | | eachLocalName |		(each ~= anAttribute			and: [(eachLocalName := each localName) = attributeLocalName])			ifTrue: [				(self namespaceScope resolvePrefix:					(each name xmlPrefixBeforeLocalName: eachLocalName)) =						attributeNamespaceURI					ifTrue: [						self namespaceScope							errorAttribute: each							aliasesURI: attributeNamespaceURI]]].! !!XMLElement methodsFor: 'private'!validateNamespacePrefixesOfAttributes	(self usesNamespaces		and: [self hasAttributes])		ifTrue: [			self namespaceScope validatePrefixesOfAttributes:				self attributeNames]! !!XMLElement methodsFor: 'printing'!writeXMLOn: aWriter	| tagWriter |	tagWriter := aWriter tag: self name.	self hasNamespaces		ifTrue: [			"non-standard setXMLNSDeclarations: use for performance"			tagWriter setXMLNSDeclarations: self namespaceScope prefixMappings].	self hasAttributes		ifTrue: [			"non-standard setAttributes: use for performance"			tagWriter setAttributes: self attributeNodes].	self hasChildren		ifTrue: [tagWriter with: [self writeInnerXMLOn: aWriter]]		ifFalse: [tagWriter write].! !!XMLNodeWithElements methodsFor: 'visiting'!acceptNodeVisitor: aNodeVisitor	^ aNodeVisitor visitNodeWithElements: self! !!XMLNodeWithElements methodsFor: 'adding'!addCData: aString	^ self addNode: (self newCData: aString)! !!XMLNodeWithElements methodsFor: 'deprecated'!addContent: aStringOrStringNode	"will be deprecated; use #addString: instead"	(self hasChildren		and: [self lastNode isCoalescingStringNode])		ifTrue: [self lastNode append: aStringOrStringNode]		ifFalse: [self addNode:			(aStringOrStringNode isString				ifTrue: [self nodeFactory newStringNode: aStringOrStringNode]				ifFalse: [aStringOrStringNode])].	"returns self for backwards compatibility"! !!XMLNodeWithElements methodsFor: 'deprecated'!addElement: anElement	self deprecated:		'Use #addNode: with an element argument or #addElementNamed: instead'.	self addNode: anElement.	"returns self for backwards compatibility"! !!XMLNodeWithElements methodsFor: 'adding'!addElementNamed: aName	"adds and returns a new element with the specified name"	| addedElementNamespaceScope addedElementNamespaceURI addedElement |	addedElementNamespaceScope := self newNamespaceScopeForAddedElement.	addedElementNamespaceURI :=		self			namespaceURIOfAddedElementNamed: aName			withScope: addedElementNamespaceScope.	"added first to inherit the config before setting the name"	addedElement :=		self addNode:			((self nodeFactory				classForElement: aName				namespaceURI: addedElementNamespaceURI) new				setNamespaceScope: addedElementNamespaceScope).	^ addedElement name: aName.! !!XMLNodeWithElements methodsFor: 'adding'!addElementNamed: aName attributes: anAssociationCollection	"adds and returns a new element with the specified name and attributes"	| addedElementNamespaceScope addedElementNamespaceURI addedElementAttributeDictionary addedElement |	addedElementNamespaceScope := self newNamespaceScopeForAddedElement.	addedElementNamespaceURI :=		self			namespaceURIOfAddedElementNamed: aName			withScope: addedElementNamespaceScope.	addedElementAttributeDictionary :=		self			newAttributeDictionaryFrom: anAssociationCollection			forAddedElementWithScope: addedElementNamespaceScope.	"added first to inherit the config before setting the name and attributes"	addedElement :=		self addNode:			((self nodeFactory				classForElement: aName				namespaceURI: addedElementNamespaceURI				attributes: addedElementAttributeDictionary) new				setNamespaceScope: addedElementNamespaceScope).	^ addedElement		name: aName;		setAttributes: addedElementAttributeDictionary.! !!XMLNodeWithElements methodsFor: 'adding'!addElementNamed: aName namespaceURI: aURI	"adds and returns a new element with the specified name and namespace	URI"	| addedElementNamespaceScope addedElement |	addedElementNamespaceScope :=		self			newNamespaceScopeForAddedElementNamed: aName			namespaceURI: aURI.	"added first to inherit the config before setting the name"	addedElement :=		self addNode:			((self nodeFactory				classForElement: aName				namespaceURI: aURI) new				setNamespaceScope: addedElementNamespaceScope).	^ addedElement name: aName.! !!XMLNodeWithElements methodsFor: 'adding'!addElementNamed: aName namespaceURI: aURI attributes: anAssociationCollection	"adds and returns a new element with the specified name, namespace URI,	and attributes"	| addedElementNamespaceScope addedElementAttributeDictionary addedElement |	addedElementNamespaceScope :=		self			newNamespaceScopeForAddedElementNamed: aName			namespaceURI: aURI.	addedElementAttributeDictionary :=		self			newAttributeDictionaryFrom: anAssociationCollection			forAddedElementWithScope: addedElementNamespaceScope.	"added first to inherit the config before setting the name and attributes"	addedElement :=		self addNode:			((self nodeFactory				classForElement: aName				namespaceURI: aURI				attributes: addedElementAttributeDictionary) new				setNamespaceScope: addedElementNamespaceScope).	^ addedElement		name: aName;		setAttributes: addedElementAttributeDictionary.! !!XMLNodeWithElements methodsFor: 'adding'!addString: aString	"Adds a new string node for aString or just appends aString to the	last node if it's a coalescing string node (not CDATA).	Returns the new string node or the string node appeneded to."	| lastNode |	(self hasChildren		and: [(lastNode := self lastNode) isCoalescingStringNode])		ifTrue: [^ lastNode append: aString]		ifFalse: [^ self addNode: (self nodeFactory newStringNode: aString)]! !!XMLNodeWithElements methodsFor: 'private'!addedElement: anElement! !!XMLNodeWithElements methodsFor: 'notifying'!addedNode: aNode	super addedNode: aNode.	aNode isElement		ifTrue: [			aNode configuration: self configuration.			self addedElement: aNode].! !!XMLNodeWithElements methodsFor: 'accessing'!allElements	"returns a node list with all descendant elements (and the receiver if	it's an element)"	| allElements |	allElements := self newListForSelect.	self allElementsDo: [:each | allElements addLast: each].	^ allElements.! !!XMLNodeWithElements methodsFor: 'enumerating'!allElementsCollect: aBlock	"returns an ordered list of the values of evaluating all descendant	elements (and the receiver if it's an element) with aBlock"	| collectedObjects |	collectedObjects := self newListForCollect.	self allElementsDo: [:each | collectedObjects addLast: (aBlock value: each)].	^ collectedObjects.! !!XMLNodeWithElements methodsFor: 'enumerating'!allElementsDetect: aBlock	"Descend depth-first visiting each element with aBlock until one such evaluation	of aBlock with an element is true, then return that element. If no evaluation is	true, then return nil."	^ self allElementsDetect: aBlock ifNone: [nil]! !!XMLNodeWithElements methodsFor: 'enumerating'!allElementsDetect: aBlock ifNone: anExceptionBlock	"Descend depth-first visiting each element with aBlock until one such evaluation	of aBlock with an element is true, then return that element. If no evaluation is	true, then return the value of anExceptionBlock."	self allElementsDo: [:each |		(aBlock value: each)			ifTrue: [^ each]].	^ anExceptionBlock value.! !!XMLNodeWithElements methodsFor: 'enumerating'!allElementsDo: aBlock	"evaluates all descendant elements (and the receiver if it's an	element) with aBlock"	self hasChildren		ifTrue: [self elementsDo: [:each | each allElementsDo: aBlock]]! !!XMLNodeWithElements methodsFor: 'accessing'!allElementsNamed: aName	"returns a node list with all descendant elements (and the receiver if	it's an element) whose qualified or local names match aName"	^ self allElementsSelect: [:each | each isNamed: aName]! !!XMLNodeWithElements methodsFor: 'enumerating'!allElementsNamed: aName do: aBlock	"evaluates all descendant elements (and the receiver if it's an	element) whose qualified or local names match aName with aBlock"	self allElementsDo: [:each |		(each isNamed: aName)			ifTrue: [aBlock value: each]]! !!XMLNodeWithElements methodsFor: 'accessing'!allElementsNamed: aName namespaceURI: aURI	"returns a node list with all descendant elements (and the receiver if	it's an element) whose qualified or local names match aName and whose	namespace URIs matches aURI"	^ self allElementsSelect: [:each |		(each isNamed: aName)			and: [each namespaceURI = aURI]]! !!XMLNodeWithElements methodsFor: 'enumerating'!allElementsSelect: aBlock	"returns a new node list with all descendant elements (and the receiver	if it's an element) that aBlock evaluates true for"	| selectedElements |	selectedElements := self newListForSelect.	self allElementsDo: [:each |		(aBlock value: each)			ifTrue: [selectedElements addLast: each]].	^ selectedElements.! !!XMLNodeWithElements methodsFor: 'accessing'!configuration	^ configuration ifNil: [		self configuration: self configurationClass new.		configuration]! !!XMLNodeWithElements methodsFor: 'accessing'!configuration: aConfiguration	configuration := aConfiguration.	self hasChildren		ifTrue: [			self elementsDo: [:each |				each configuration: aConfiguration]].! !!XMLNodeWithElements methodsFor: 'defaults'!configurationClass	^ XMLDOMConfiguration! !!XMLNodeWithElements methodsFor: 'accessing'!contentNodes	"returns a node list of the receiver's element and string node children"	^ self nodes contentNodes! !!XMLNodeWithElements methodsFor: 'enumerating'!contentNodesDo: aBlock	"evaluates aBlock for all element and string node children of the receiver"	self nodes contentNodesDo: aBlock! !!XMLNodeWithElements methodsFor: 'deprecated'!contentString: aString	"will be deprecated; use #removeNodes and #addString: instead"	self		removeNodes;		addString: aString! !!XMLNodeWithElements methodsFor: 'accessing'!contentStringAt: aName	"Returns the content string of the first element child of the receiver	whose qualified or local name matches aName or an empty string if there	isn't one.	See also #rawContentStringAt:"	^ self nodes contentStringAt: aName! !!XMLNodeWithElements methodsFor: 'accessing'!descendantElements	"returns a node list of all descendant elements"	| descendentElements |	descendentElements := self newListForSelect.	self descendantElementsDo: [:each | descendentElements addLast: each].	^ descendentElements.! !!XMLNodeWithElements methodsFor: 'enumerating'!descendantElementsCollect: aBlock	"returns an ordered list of the values of evaluating all descendant	elements with aBlock"	| collectedObjects |	collectedObjects := self newListForCollect.	self descendantElementsDo: [:each |		collectedObjects addLast: (aBlock value: each)].	^ collectedObjects.! !!XMLNodeWithElements methodsFor: 'enumerating'!descendantElementsDetect: aBlock	"returns the first descendant element that aBlock evaluates true for or	nil if there isn't one"	^ self		descendantElementsDetect: aBlock		ifNone: [nil]! !!XMLNodeWithElements methodsFor: 'enumerating'!descendantElementsDetect: aBlock ifNone: anExceptionBlock	"returns the first descendant element that aBlock evaluates true for or	the value of anExceptionBlock if there isn't one"	self descendantElementsDo: [:each |		(aBlock value: each)			ifTrue: [^ each]].	^ anExceptionBlock value.! !!XMLNodeWithElements methodsFor: 'enumerating'!descendantElementsDo: aBlock	"evaluates all descendant elements with aBlock"	self hasChildren		ifTrue: [self elementsDo: [:each | each allElementsDo: aBlock]]! !!XMLNodeWithElements methodsFor: 'accessing'!descendantElementsNamed: aName	"returns a node list of all descendant elements whose qualified	or local names match aName"	^ self descendantElementsSelect: [:each | each isNamed: aName]! !!XMLNodeWithElements methodsFor: 'enumerating'!descendantElementsNamed: aName do: aBlock	"evaluates all descendant elements whose qualified or local names	match aName with aBlock"	self descendantElementsDo: [:each |		(each isNamed: aName)			ifTrue: [aBlock value: each]]! !!XMLNodeWithElements methodsFor: 'accessing'!descendantElementsNamed: aName namespaceURI: aURI	"returns a node list of all descendant elements whose qualified	or local names match aName and whose namespace URIs match aURI"	^ self descendantElementsSelect: [:each |		(each isNamed: aName)			and: [each namespaceURI = aURI]]! !!XMLNodeWithElements methodsFor: 'enumerating'!descendantElementsSelect: aBlock	"returns a new node list with all descendant elements that aBlock	evaluates true for"	| selectedElements |	selectedElements := self newListForSelect.	self descendantElementsDo: [:each |		(aBlock value: each)			ifTrue: [selectedElements addLast: each]].	^ selectedElements.! !!XMLNodeWithElements methodsFor: 'deprecated'!descendentElements	self deprecated: 'use #descendantElements instead'.	^ self descendantElements.! !!XMLNodeWithElements methodsFor: 'deprecated'!descendentElementsCollect: aBlock	self deprecated: 'use #descendantElementsCollect: instead'.	^ self descendantElementsCollect: aBlock.! !!XMLNodeWithElements methodsFor: 'deprecated'!descendentElementsDetect: aBlock	self deprecated: 'use #descendantElementsDetect: instead'.	^ self descendantElementsDetect: aBlock.! !!XMLNodeWithElements methodsFor: 'deprecated'!descendentElementsDetect: aBlock ifNone: anExceptionBlock	self deprecated: 'use #descendantElementsDetect:ifNone: instead'.	^ self		descendantElementsDetect: aBlock		ifNone: anExceptionBlock.! !!XMLNodeWithElements methodsFor: 'deprecated'!descendentElementsDo: aBlock	self deprecated: 'use #descendantElementsDo: instead'.	^ self descendantElementsDo: aBlock.! !!XMLNodeWithElements methodsFor: 'deprecated'!descendentElementsNamed: aName	self deprecated: 'use #descendantElementsNamed: instead"'.	^ self descendantElementsNamed: aName.! !!XMLNodeWithElements methodsFor: 'deprecated'!descendentElementsNamed: aName do: aBlock	self deprecated: 'use #descendantElementsNamed:do: instead'.	^ self		descendantElementsNamed: aName		do: aBlock.! !!XMLNodeWithElements methodsFor: 'deprecated'!descendentElementsNamed: aName namespaceURI: aURI	self deprecated: 'use #descendantElementsNamed:namespaceURI: instead'.	^ self		descendantElementsNamed: aName		namespaceURI: aURI.! !!XMLNodeWithElements methodsFor: 'deprecated'!descendentElementsSelect: aBlock	self deprecated: 'use #descendantElementsSelect: instead'.	^ self descendantElementsSelect: aBlock.! !!XMLNodeWithElements methodsFor: 'accessing'!elementAfter: anElement	"returns the first element child of the receiver after anElement or nil if	there isn't one"	^ self nodes elementAfter: anElement! !!XMLNodeWithElements methodsFor: 'accessing'!elementAt: aName	"returns the first element child of the receiver whose qualified or	local name matches aName or nil if there isn't one"	^ self nodes elementAt: aName! !!XMLNodeWithElements methodsFor: 'accessing'!elementAt: aName ifAbsent: aBlock	"returns the first element child of the receiver whose qualified or	local name matches aName or the value of aBlock if there isn't one"	^ self nodes		elementAt: aName		ifAbsent: aBlock! !!XMLNodeWithElements methodsFor: 'accessing'!elementAt: aName namespaceURI: aURI	"returns the first element child of the receiver whose qualified or	local name matches aName and whose namespace URI matches aURI or nil	if there isn't one"	^ self nodes		elementAt: aName		namespaceURI: aURI! !!XMLNodeWithElements methodsFor: 'accessing'!elementAt: aName namespaceURI: aURI ifAbsent: aBlock	"returns the first element child of the receiver whose qualified or	local name matches aName and whose namespace URI matches aURI or the	value of aBlock if there isn't one"	^ self nodes		elementAt: aName		namespaceURI: aURI		ifAbsent: aBlock! !!XMLNodeWithElements methodsFor: 'accessing'!elementBefore: anElement	"returns the first element child of the receiver before anElement or	nil if there isn't one"	^ self nodes elementBefore: anElement! !!XMLNodeWithElements methodsFor: 'accessing'!elementNames	^ self nodes elementNames! !!XMLNodeWithElements methodsFor: 'accessing'!elements	"returns a new node list of all of the receiver's elements"	^ self nodes elements! !!XMLNodeWithElements methodsFor: 'accessing'!elementsAt: aName	"returns a node list of all the receiver's elements whose qualified	or local names match aName"	^ self nodes elementsAt: aName! !!XMLNodeWithElements methodsFor: 'enumerating'!elementsAt: aName do: aBlock	"evaluates aBlock for all element children of the receiver whose	qualified or local names match aName"	self nodes		elementsAt: aName		do: aBlock! !!XMLNodeWithElements methodsFor: 'accessing'!elementsAt: aName namespaceURI: aURI	"returns a node list of all the receiver's elements whose qualified	or local names match aName and whose namespace URIs match aURI"	^ self nodes		elementsAt: aName		namespaceURI: aURI! !!XMLNodeWithElements methodsFor: 'enumerating'!elementsCollect: aBlock	"returns an ordered list of the values of evaluating the element	children of the receiver with aBlock"	^ self nodes elementsCollect: aBlock! !!XMLNodeWithElements methodsFor: 'enumerating'!elementsDetect: aBlock	"returns the first element child of the receiver that aBlock evaluates	true for or nil if there isn't one"	^ self nodes elementsDetect: aBlock! !!XMLNodeWithElements methodsFor: 'enumerating'!elementsDetect: aBlock ifNone: anExceptionBlock	"returns the first element child of the receiver that aBlock evaluates	true for or the value of anExceptionBlock if there isn't one"	^ self nodes		elementsDetect: aBlock		ifNone: anExceptionBlock! !!XMLNodeWithElements methodsFor: 'enumerating'!elementsDo: aBlock	"evaluates aBlock for all element children of the receiver"	self nodes elementsDo: aBlock! !!XMLNodeWithElements methodsFor: 'enumerating'!elementsSelect: aBlock	"returns a node list of all element children of the receiver that	aBlock evaluates true for"	^ self nodes elementsSelect: aBlock! !!XMLNodeWithElements methodsFor: 'private'!ensureUsesNamespaces	self usesNamespaces: true! !!XMLNodeWithElements methodsFor: 'private'!errorOuterXMLForAbsentNode	XMLDOMException signal: 'Cannot change outer XML for absent node'! !!XMLNodeWithElements methodsFor: 'private'!escapesContentEntitiesWhenWriting	"avoid initializing config; defualt to true"	^ configuration isNil		or: [configuration replacesContentEntityReferences]! !!XMLNodeWithElements methodsFor: 'searching'!findElementNamed: aName	"searches the receiver and all descendants for the first element whose	qualified or local name matches aName"	^ self allElementsDetect: [:each | each isNamed: aName]! !!XMLNodeWithElements methodsFor: 'searching'!findElementNamed: aName namespaceURI: aURI	"searches the receiver and all descendants for the first element whose	qualified or local name matches aName and whose namespace URI matches aURI"	^ self allElementsDetect: [:each |		(each isNamed: aName)			and: [each namespaceURI = aURI]]! !!XMLNodeWithElements methodsFor: 'searching'!findElementNamed: aName namespaceURI: aURI with: aBlock	"searches the receiver and all descendants for the first element whose	qualified or local name matches aName and whose namespace URI matches	aURI and that aBlock evaluates true for"	^ self allElementsDetect: [:each |		(each isNamed: aName)			and: [each namespaceURI = aURI				and: [aBlock value: each]]]! !!XMLNodeWithElements methodsFor: 'searching'!findElementNamed: aName with: aBlock	"searches the receiver and all descendants for the first element whose	qualified or local name matches aName and aBlock evaluates true for"	^ self allElementsDetect: [:each |		(each isNamed: aName)			and: [aBlock value: each]]! !!XMLNodeWithElements methodsFor: 'searching'!findElementWithID: anID	"Works like XML DOM Level 2's getElementByID(). It will scan attributes	identified as IDs by a DTD with '<!!ATTLIST ...>' declarations or any	attribute named 'xml:id'."	| document doctypeDefinition |		((document := self document) notNil		and: [(doctypeDefinition := document doctypeDefinition) notNil			and: [doctypeDefinition hasAttributeValidators]])		ifTrue: [			self allElementsDo: [:each |				each hasAttributes					ifTrue: [						(doctypeDefinition attributeValidatorsAt: each name)							ifNil: [								(each hasUndeclaredID: anID)									ifTrue: [^ each]]							ifNotNil: [:attributeValidators |								(each									hasUndeclaredOrDeclaredID: anID									declaredWith: attributeValidators)									ifTrue: [^ each]]]]]		ifFalse: [			self allElementsDo: [:each |				(each hasAttributes					and: [each hasUndeclaredID: anID])					ifTrue: [^ each]]].	^ nil.! !!XMLNodeWithElements methodsFor: 'accessing'!firstElement	"returns the first child element of the receiver or nil if there	isn't one"	^ self nodes firstElement! !!XMLNodeWithElements methodsFor: 'testing'!hasContentNodes	^ self nodes hasContentNodes! !!XMLNodeWithElements methodsFor: 'testing'!hasElements	"returns true if the receiver has element children"	"optimized with a nil test to avoid lazy initializing nodes"	nodes == nil		ifTrue: [^ false].	^ nodes hasElements.! !!XMLNodeWithElements methodsFor: 'testing'!hasStringNodes	^ self nodes hasStringNodes! !!XMLNodeWithElements methodsFor: 'testing'!includesElement: aName	"returns true if the receiver has a child element whose qualified or local name	matches aName"	^ self nodes includesElement: aName! !!XMLNodeWithElements methodsFor: 'testing'!includesElement: aName namespaceURI: aURI	"returns true if the receiver has a child element whose qualified or local name	matches aName and whose namespace URI matches aURI"	^ self nodes		includesElement: aName		namespaceURI: aURI! !!XMLNodeWithElements methodsFor: 'parsing'!innerXML: aStringOrStream	"Replaces the node children by parsing new inner XML from a string or stream	argument. By default the same parser configuration will be used to parse the	new inner XML."	self innerXMLParsedWith: (self parserHandlerClass on: aStringOrStream)! !!XMLNodeWithElements methodsFor: 'parsing'!innerXMLParsedWith: aParser	| removedNodes |	removedNodes := self nodes asArray.	self removeNodes.	[aParser		innerXMLRootNode: self;		parseDocument]		on: Error		do: [:error |			self				removeNodes;				addNodes: removedNodes.			error pass].! !!XMLNodeWithElements methodsFor: 'private'!innerXMLStateClass	^ XMLContentState! !!XMLNodeWithElements methodsFor: 'testing'!isContentNode	^ true! !!XMLNodeWithElements methodsFor: 'accessing'!lastElement	"returns the last child element of the receiver or nil if there	isn't one"	^ self nodes lastElement! !!XMLNodeWithElements methodsFor: 'private'!namespaceURIOfAddedElementNamed: aName withScope: aNamespaceScope	^ self usesNamespaces		ifTrue: [aNamespaceScope resolvePrefix: aName xmlPrefixBeforeLocalName]		ifFalse: ['']! !!XMLNodeWithElements methodsFor: 'private'!newAttributeDictionaryFrom: anAssociationCollection forAddedElementWithScope: aNamespaceScope	^ self usesNamespaces		ifTrue: [			(XMLNamespacedAttributeDictionary newFrom: anAssociationCollection)				setNamespaceScope: aNamespaceScope]		ifFalse: [XMLAttributeDictionary newFrom: anAssociationCollection]! !!XMLNodeWithElements methodsFor: 'private'!newInnerXMLState	^ self innerXMLStateClass new! !!XMLNodeWithElements methodsFor: 'private'!newNamespaceScopeForAddedElement	^ self usesNamespaces		ifTrue: [XMLNamespaceScope new]		ifFalse: [nil]! !!XMLNodeWithElements methodsFor: 'private'!newNamespaceScopeForAddedElementNamed: aName namespaceURI: aURI	self ensureUsesNamespaces.	^ self newNamespaceScopeForAddedElement		mapPrefix: aName xmlPrefixBeforeLocalName to: aURI;		yourself.! !!XMLNodeWithElements methodsFor: 'deprecated'!newString: aString	"will be deprecated; use #newStringNode: instead"	^ self newStringNode: aString! !!XMLNodeWithElements methodsFor: 'accessing'!nodeFactory	^ self configuration nodeFactory! !!XMLNodeWithElements methodsFor: 'accessing'!nodeFactory: aNodeFactory	self configuration nodeFactory: aNodeFactory! !!XMLNodeWithElements methodsFor: 'defaults'!nodeListClass	^ self configuration nodeFactory nodeListClass! !!XMLNodeWithElements methodsFor: 'parsing'!outerXML: aStringOrStream forNode: aNode	self		outerXMLForNode: aNode		parsedWith: (self parserHandlerClass on: aStringOrStream)! !!XMLNodeWithElements methodsFor: 'parsing'!outerXMLForNode: aNode parsedWith: aParser	| indexOfNode removedNodes |	indexOfNode :=		self nodes			indexOf: aNode			ifAbsent: [self errorOuterXMLForAbsentNode].	removedNodes :=		self nodes			copyFrom: indexOfNode			to: self nodes size.	self removeNodes: removedNodes.	[aParser		innerXMLRootNode: self;		parseDocument]		on: Error		do: [:error |			[self nodes size >= indexOfNode]				whileTrue: [self nodes removeLast].			self addNodes: removedNodes.			error pass].	2 to: removedNodes size do: [:i |		self addNode: (removedNodes at: i)].! !!XMLNodeWithElements methodsFor: 'defaults'!parserHandlerClass	^ self configuration parserHandlerClass! !!XMLNodeWithElements methodsFor: 'copying'!postCopyConfiguration	configuration		ifNotNil: [self configuration: configuration copy]! !!XMLNodeWithElements methodsFor: 'printing'!printRawContentOn: aStream	self contentNodesDo: [:each | each printRawContentOn: aStream]! !!XMLNodeWithElements methodsFor: 'accessing'!rawContentStringAt: aName	"Returns the raw content string (without space inserted) of the first	element child of the receiver whose qualified or local name matches aName	or an empty string if there isn't one.	See also #contentStringAt:"	^ self nodes rawContentStringAt: aName! !!XMLNodeWithElements methodsFor: 'removing'!removeAllFormattingNodes	"This is a convenience method to remove formatting string nodes from the	receiver and descendant elements. Empty/whitespace string nodes with	element siblings are assumed to be formatting, unless they have at least	one non-empty/non-whitespace sibling string node.	WARNING: 'mixed content' elements that can have both string and element	children, like this:		<row>one<sep/> <sep/>three</row>	aren't properly recognized when all of the string nodes are whitespace,	so this:		<row> <sep/> <sep/> </row>	will become this:		<row><sep/><sep/></row>	which might not be acceptable."	| hasFormattingStringNodes hasElements |	hasFormattingStringNodes := false.	hasElements := false.	self nodesDo: [:each |		each isStringNode			ifTrue: [				(hasFormattingStringNodes :=					each isWhitespace						or: [each isEmpty])					ifFalse: [^ self]]			ifFalse: [				hasElements					ifFalse: [hasElements := each isElement]]].	(hasFormattingStringNodes		and: [hasElements])		ifTrue: [| nodeList |			nodeList := self nodes.			nodeList size to: 1 by: -1 do: [:i | | node |				((node := nodeList at: i) isStringNode					and: [node isWhitespace						or: [node isEmpty]])					ifTrue: [nodeList removeAt: i]]].	hasElements		ifTrue: [			self elementsDo: [:each |				each removeAllFormattingNodes]].! !!XMLNodeWithElements methodsFor: 'notifying'!renamedElement: anElement from: anOldName to: aNewName	self nodes		renamedElement: anElement		from: anOldName		to: aNewName! !!XMLNodeWithElements methodsFor: 'accessing'!stringNodes	"returns a new node list of all string node children of the receiver"	^ self nodes stringNodes! !!XMLNodeWithElements methodsFor: 'enumerating'!stringNodesDo: aBlock	"evaluates each string node child of the receiver with aBlock"	self nodes stringNodesDo: aBlock! !!XMLNodeWithElements methodsFor: 'accessing'!strings	"returns an ordered list of the strings of the string nodes of the receiver"	^ self nodes strings! !!XMLNodeWithElements methodsFor: 'enumerating'!stringsDo: aBlock	"evaluates each string of each string node child of the receiver with	aBlock"	self nodes stringsDo: aBlock! !!XMLNodeWithElements methodsFor: 'testing'!usesNamespaces	"returns true if namespace checking is enabled (default)"	"optimized to avoid lazy initializing the config"	configuration == nil		ifTrue: [^ true].	^ configuration usesNamespaces.! !!XMLNodeWithElements methodsFor: 'accessing'!usesNamespaces: aBoolean	"can be used to disable namespace checking, which is enabled by default"	self configuration usesNamespaces: aBoolean! !!XMLPI class methodsFor: 'instance creation'!target: aTargetString data: aDataString	^ self new		target: aTargetString;		data: aDataString! !!XMLPI methodsFor: 'visiting'!acceptNodeVisitor: aNodeVisitor	^ aNodeVisitor visitPI: self! !!XMLPI methodsFor: 'accessing'!data	^ data ifNil: [data := '']! !!XMLPI methodsFor: 'accessing'!data: aString	data := aString! !!XMLPI methodsFor: 'testing'!hasData	^ self data notEmpty! !!XMLPI methodsFor: 'testing'!isPI	^ true! !!XMLPI methodsFor: 'accessing'!sortKey	^ self target! !!XMLPI methodsFor: 'accessing'!target	^ target ifNil: [target := '']! !!XMLPI methodsFor: 'accessing'!target: aString	target := aString! !!XMLPI methodsFor: 'printing'!writeXMLOn: aWriter	aWriter pi		target: self target;		data: self data;		write! !!XMLCData methodsFor: 'visiting'!acceptNodeVisitor: aNodeVisitor	^ aNodeVisitor visitCData: self! !!XMLCData methodsFor: 'testing'!isCData	^ true! !!XMLCData methodsFor: 'private'!isCoalescingStringNode	"this returns false to stop preserved CDATA nodes from coalescing	together or with ordinary string nodes"	^ false! !!XMLCData methodsFor: 'printing'!writeXMLOn: aWriter	aWriter cdata: self string! !!XMLString class methodsFor: 'instance creation'!string: aString	^ self new string: aString! !!XMLString methodsFor: 'visiting'!acceptNodeVisitor: aNodeVisitor	^ aNodeVisitor visitStringNode: self! !!XMLString methodsFor: 'deprecated'!addContent: aStringOrStringNode	"will be deprecated"	self append: aStringOrStringNode! !!XMLString methodsFor: 'appending/prepending'!append: aStringOrStringNode	string :=		string			ifNil: [aStringOrStringNode asString]			ifNotNil: [string, aStringOrStringNode asString]! !!XMLString methodsFor: 'converting'!asString	^ self string! !!XMLString methodsFor: 'converting'!asXMLEscapedString	^ self string asXMLEscapedString! !!XMLString methodsFor: 'deprecated'!asXMLString	"will be deprecated; use #asXMLStringNode instead"	^ self asXMLStringNode! !!XMLString methodsFor: 'converting'!asXMLStringNode	^ self! !!XMLString methodsFor: 'testing'!beginsWith: aStringOrStringNode	^ self string beginsWith: aStringOrStringNode asString! !!XMLString methodsFor: 'deprecated'!contentString: aString	"will be deprecated; use #string: instead"	self string: aString! !!XMLString methodsFor: 'replacing'!deleteFrom: aStart to: anEnd	self replaceFrom: aStart to: anEnd with: ''! !!XMLString methodsFor: 'testing'!endsWith: aStringOrStringNode	^ self string endsWith: aStringOrStringNode asString! !!XMLString methodsFor: 'testing'!includesSubstring: aStringOrStringNode	"avoid String>>includesSubstring: for backwards compatibility"	^ aStringOrStringNode isEmpty		or: [(self indexOfSubstring: aStringOrStringNode) > 0]! !!XMLString methodsFor: 'accessing'!indexOfSubstring: aStringOrStringNode	^ self string		findString: aStringOrStringNode asString		startingAt: 1! !!XMLString methodsFor: 'private'!isCoalescingStringNode	^ true! !!XMLString methodsFor: 'testing'!isContentNode	^ true! !!XMLString methodsFor: 'testing'!isEmpty	^ self string isEmpty! !!XMLString methodsFor: 'deprecated'!isString: aStringOrStringNode	"will be deprecated; use #isStringNode: instead"	^ self isStringNode: aStringOrStringNode! !!XMLString methodsFor: 'testing'!isStringNode	^ true! !!XMLString methodsFor: 'testing'!isStringNode: aStringOrStringNode	^ self string = aStringOrStringNode asString! !!XMLString methodsFor: 'testing'!isWhitespace	^ self string isXMLWhitespace! !!XMLString methodsFor: 'splitting/merging'!mergeAdjacent	"merges a string node with adjacent string nodes in parent"	| siblingNodes selfIndex adjacentNode |	self hasParent		ifFalse: [^ self].	siblingNodes := self parent nodes.	selfIndex := siblingNodes indexOf: self.	[(adjacentNode := siblingNodes at: selfIndex + 1) notNil		and: [adjacentNode isStringNode]]		whileTrue: [			self append: adjacentNode.			siblingNodes removeAt: selfIndex + 1].	[(adjacentNode := siblingNodes at: selfIndex - 1) notNil		and: [adjacentNode isStringNode]]		whileTrue: [			self prepend: adjacentNode.			siblingNodes removeAt: selfIndex - 1.			selfIndex := selfIndex - 1].! !!XMLString methodsFor: 'testing'!notEmpty	^ self string notEmpty! !!XMLString methodsFor: 'appending/prepending'!prepend: aStringOrStringNode	string :=		string			ifNil: [aStringOrStringNode asString]			ifNotNil: [aStringOrStringNode asString, string]! !!XMLString methodsFor: 'printing'!printRawContentOn: aStream	aStream nextPutAll: self string! !!XMLString methodsFor: 'replacing'!replaceAll: aSource with: aReplacement	"works like copyReplaceAll:with:"	self string:		(self string			copyReplaceAll: aSource asString			with: aReplacement asString)! !!XMLString methodsFor: 'replacing'!replaceFrom: aStart to: aStop with: aReplacement	"works like copyReplaceFrom:to:with: and	can be used to insert, delete, and replace"	| start stop |	start := (aStart max: 1) min: self size + 1.	stop := (aStop max: start - 1) min: self size.	self string:		(self string			copyReplaceFrom: start			to: stop			with: aReplacement asString)! !!XMLString methodsFor: 'accessing'!size	^ self string size! !!XMLString methodsFor: 'accessing'!sortKey	^ self string! !!XMLString methodsFor: 'splitting/merging'!splitAt: anOffset	| newNode |	newNode := self copy.	self replaceFrom: anOffset to: self size with: ''.	newNode replaceFrom: 1 to: anOffset - 1 with: ''.	self hasParent		ifTrue: [self parent addNode: newNode after: self].	^ newNode.! !!XMLString methodsFor: 'accessing'!string	^ string ifNil: [string := '']! !!XMLString methodsFor: 'accessing'!string: aString	string := aString asString! !!XMLString methodsFor: 'printing'!writeXMLOn: aWriter	aWriter string: self string! !!XMLNodeFactory methodsFor: 'converting'!asPluggableNodeFactory	^ XMLPluggableNodeFactory new! !!XMLNodeFactory methodsFor: 'accessing'!attributeDeclarationClass	^ XMLAttributeDeclaration! !!XMLNodeFactory methodsFor: 'accessing'!attributeListClass	^ XMLCachingAttributeList! !!XMLNodeFactory methodsFor: 'accessing'!cdataClass	"Can be overridden to return a custom XMLCData subclass."	^ XMLCData! !!XMLNodeFactory methodsFor: 'accessing'!classForElement: aQualifiedName	^ self elementClass! !!XMLNodeFactory methodsFor: 'accessing'!classForElement: aQualifiedName attributes: anAssociationCollection	^ self elementClass! !!XMLNodeFactory methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI	^ self elementClass! !!XMLNodeFactory methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI attributes: anAssociationCollection	^ self elementClass! !!XMLNodeFactory methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI localName: aLocalName attributes: anAssociationCollection	^ self elementClass! !!XMLNodeFactory methodsFor: 'accessing'!commentClass	"Can be overridden to return a custom XMLComment subclass."	^ XMLComment! !!XMLNodeFactory methodsFor: 'accessing'!doctypeDeclarationClass	^ XMLDoctypeDeclaration! !!XMLNodeFactory methodsFor: 'accessing'!documentClass	"Can be overridden to return a custom XMLDocument subclass."	^ XMLDocument! !!XMLNodeFactory methodsFor: 'accessing'!elementClass	"Can be overridden to return a custom XMLElement subclass."	^ XMLElement! !!XMLNodeFactory methodsFor: 'accessing'!elementDeclarationClass	^ XMLElementDeclaration! !!XMLNodeFactory methodsFor: 'accessing'!generalEntityDeclarationClass	^ XMLGeneralEntityDeclaration! !!XMLNodeFactory methodsFor: 'instance creation'!newCData: aString	^ self cdataClass string: aString! !!XMLNodeFactory methodsFor: 'instance creation'!newComment: aString	^ self commentClass string: aString! !!XMLNodeFactory methodsFor: 'instance creation'!newDocument	^ self documentClass new! !!XMLNodeFactory methodsFor: 'instance creation'!newElement	^ self elementClass new! !!XMLNodeFactory methodsFor: 'instance creation'!newElementNamed: aName	^ (self classForElement: aName)		named: aName! !!XMLNodeFactory methodsFor: 'instance creation'!newElementNamed: aName attributes: anAssociationCollection	^ (self		classForElement: aName		attributes: anAssociationCollection)			name: aName			attributes: anAssociationCollection! !!XMLNodeFactory methodsFor: 'instance creation'!newElementNamed: aName namespaceURI: aURI	^ (self		classForElement: aName		namespaceURI: aURI)			name: aName			namespaceURI: aURI! !!XMLNodeFactory methodsFor: 'instance creation'!newElementNamed: aName namespaceURI: aURI attributes: anAssociationCollection	^ (self		classForElement: aName		namespaceURI: aURI		attributes: anAssociationCollection)			name: aName			namespaceURI: aURI			attributes: anAssociationCollection! !!XMLNodeFactory methodsFor: 'instance creation'!newPI	^ self piClass new! !!XMLNodeFactory methodsFor: 'instance creation'!newPITarget: aTargetString data: aDataString	^ self newPI		target: aTargetString;		data: aDataString! !!XMLNodeFactory methodsFor: 'deprecated'!newString: aString	"will be deprecated; use #newStringNode: instead"	^ self newStringNode: aString! !!XMLNodeFactory methodsFor: 'instance creation'!newStringNode: aString	^ self stringNodeClass new string: aString! !!XMLNodeFactory methodsFor: 'accessing'!nodeListClass	^ XMLNodeList! !!XMLNodeFactory methodsFor: 'accessing'!notationDeclarationClass	^ XMLNotationDeclaration! !!XMLNodeFactory methodsFor: 'accessing'!parameterEntityDeclarationClass	^ XMLParameterEntityDeclaration! !!XMLNodeFactory methodsFor: 'accessing'!piClass	"Can be overridden to return a custom XMLPI subclass."	^ XMLPI! !!XMLNodeFactory methodsFor: 'deprecated'!stringClass	"will be deprecated; use #stringNodeClass instead"	^ XMLString! !!XMLNodeFactory methodsFor: 'accessing'!stringNodeClass	"Can be overridden to return a custom XMLString subclass."	"for now this delegates to the soft-deprecated #stringClass to not	break custom subclasses that override it expecting it to be sent"	^ self stringClass! !!XMLPluggableElementFactory methodsFor: 'accessing'!classForElement: aQualifiedName	^ elementClassMapper		classForElement: aQualifiedName		ifNone: [self elementClass]! !!XMLPluggableElementFactory methodsFor: 'accessing'!classForElement: aQualifiedName attributes: anAssociationCollection	^ elementClassMapper		classForElement: aQualifiedName		attributes: anAssociationCollection		ifNone: [self elementClass]! !!XMLPluggableElementFactory methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI	^ elementClassMapper		classForElement: aQualifiedName		namespaceURI: aURI		ifNone: [self elementClass]! !!XMLPluggableElementFactory methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI attributes: anAssociationCollection	^ elementClassMapper		classForElement: aQualifiedName		namespaceURI: aURI		attributes: anAssociationCollection		ifNone: [self elementClass]! !!XMLPluggableElementFactory methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI localName: aLocalName attributes: anAssociationCollection	^ elementClassMapper		classForElement: aQualifiedName		namespaceURI: aURI		localName: aLocalName		attributes: anAssociationCollection		ifNone: [self elementClass]! !!XMLPluggableElementFactory methodsFor: 'private'!elementClassMapper	^ elementClassMapper! !!XMLPluggableElementFactory methodsFor: 'private'!elementClassMapper: anElementClassMapper	elementClassMapper := anElementClassMapper! !!XMLPluggableElementFactory methodsFor: 'defaults'!elementClassMapperClass	^ XMLBasicElementClassMapper! !!XMLPluggableElementFactory methodsFor: 'handling'!handleElement: anElementName attributes: aCollectionOrAttributeSpec withClass: aClass	"aCollectionOrAttributeSpec can be some kind of XMLAttributeSpec or a	collection of associations of required attribute names and values, and the	required values can be strings, blocks, or nil meaning the attribute is	required but can take any value"	elementClassMapper		mapElement: anElementName		attributeSpec: aCollectionOrAttributeSpec asXMLAttributeSpec		toClass: aClass! !!XMLPluggableElementFactory methodsFor: 'handling'!handleElement: anElementName namespaceURI: aURI attributes: aCollectionOrAttributeSpec withClass: aClass	"aCollectionOrAttributeSpec can be some kind of XMLAttributeSpec or a	collection of associations of required attribute names and values, and the	required values can be strings, blocks, or nil meaning the attribute is	required but can take any value"	elementClassMapper		mapElement: anElementName		namespaceURI: aURI		attributeSpec: aCollectionOrAttributeSpec asXMLAttributeSpec		toClass: aClass! !!XMLPluggableElementFactory methodsFor: 'handling'!handleElement: anElementName namespaceURI: aURI withClass: aClass	elementClassMapper		mapElement: anElementName		namespaceURI: aURI		toClass: aClass! !!XMLPluggableElementFactory methodsFor: 'handling'!handleElement: anElementName withClass: aClass	elementClassMapper		mapElement: anElementName		toClass: aClass! !!XMLPluggableElementFactory methodsFor: 'handling'!handleElements: anElementNameCollection namespaceURI: aNamespaceURI withClass: aClass	elementClassMapper		mapElements: anElementNameCollection		namespaceURI: aNamespaceURI		toClass: aClass! !!XMLPluggableElementFactory methodsFor: 'handling'!handleElements: anElementNameCollection withClass: aClass	elementClassMapper		mapElements: anElementNameCollection		toClass: aClass! !!XMLPluggableElementFactory methodsFor: 'handling'!handleElementsMatchingClass: aClass	"This will handle all elements matching the name of a class with that	class, but igoring the class's prefix and any 'Element' suffix.	For example, it will match MyUserDefinedElement to:		<UserDefined>		<userDefined>		<user-defined>		<user_defined>"	elementClassMapper		mapAllMatchingElementsToClass: aClass		ignoringSuffixes: self ignorableClassNameSuffixes! !!XMLPluggableElementFactory methodsFor: 'handling'!handleElementsMatchingClasses: aClassCollection	"See the comment in #handleElementsMatchingClass:"	elementClassMapper		mapAllMatchingElementsToClasses: aClassCollection		ignoringSuffixes: self ignorableClassNameSuffixes! !!XMLPluggableElementFactory methodsFor: 'defaults'!ignorableClassNameSuffixes	^ #('Element')! !!XMLPluggableElementFactory methodsFor: 'initialization'!initialize	super initialize.	elementClassMapper := self elementClassMapperClass new.! !!XMLPluggableElementFactory methodsFor: 'copying'!postCopy	super postCopy.	elementClassMapper := elementClassMapper copy.! !!XMLPluggableNodeFactory methodsFor: 'converting'!asPluggableNodeFactory	^ self! !!XMLPluggableNodeFactory methodsFor: 'accessing'!attributeListClass	^ attributeListClass! !!XMLPluggableNodeFactory methodsFor: 'accessing'!attributeListClass: aClass	attributeListClass := aClass! !!XMLPluggableNodeFactory methodsFor: 'accessing'!cdataClass	^ cdataClass! !!XMLPluggableNodeFactory methodsFor: 'accessing'!cdataClass: aClass	cdataClass := aClass! !!XMLPluggableNodeFactory methodsFor: 'accessing'!commentClass	^ commentClass! !!XMLPluggableNodeFactory methodsFor: 'accessing'!commentClass: aClass	commentClass := aClass! !!XMLPluggableNodeFactory methodsFor: 'accessing'!documentClass	^ documentClass! !!XMLPluggableNodeFactory methodsFor: 'accessing'!documentClass: aClass	documentClass := aClass! !!XMLPluggableNodeFactory methodsFor: 'accessing'!elementClass	^ elementClass! !!XMLPluggableNodeFactory methodsFor: 'accessing'!elementClass: aClass	elementClass := aClass! !!XMLPluggableNodeFactory methodsFor: 'initialization'!initialize	super initialize.	documentClass := XMLDocument.	elementClass := XMLElement.	stringNodeClass := XMLString.	cdataClass := XMLCData.	commentClass := XMLComment.	piClass := XMLPI.	nodeListClass := XMLNodeList.	attributeListClass := XMLCachingAttributeList.! !!XMLPluggableNodeFactory methodsFor: 'accessing'!nodeListClass	^ nodeListClass! !!XMLPluggableNodeFactory methodsFor: 'accessing'!nodeListClass: aClass	nodeListClass := aClass! !!XMLPluggableNodeFactory methodsFor: 'accessing'!piClass	^ piClass! !!XMLPluggableNodeFactory methodsFor: 'accessing'!piClass: aClass	piClass := aClass! !!XMLPluggableNodeFactory methodsFor: 'deprecated'!stringClass	"will be deprecated; use #stringNodeClass instead"	^ stringNodeClass! !!XMLPluggableNodeFactory methodsFor: 'deprecated'!stringClass: aClass	"will be deprecated; use #stringNodeClass: instead"	stringNodeClass := aClass! !!XMLPluggableNodeFactory methodsFor: 'accessing'!stringNodeClass	^ stringNodeClass! !!XMLPluggableNodeFactory methodsFor: 'accessing'!stringNodeClass: aClass	stringNodeClass := aClass! !!XMLMutatingNodeVisitor methodsFor: 'visiting'!visitNodeWithElements: aNodeWithElements	aNodeWithElements hasChildren		ifTrue: [| oldNodes nodeIndexesToRemove |			oldNodes := aNodeWithElements nodes.			1 to: oldNodes size do: [:i | | oldNode newNode |				oldNode := oldNodes at: i.				(newNode := oldNode acceptNodeVisitor: self) = oldNode					ifFalse: [						newNode							ifNil: [								"only initialize if needed"								(nodeIndexesToRemove									ifNil: [nodeIndexesToRemove := OrderedCollection new])									addLast: i]							ifNotNil: [								"replace it"								oldNodes									at: i									put: newNode]]].			nodeIndexesToRemove				ifNotNil: [					nodeIndexesToRemove reverseDo: [:i |						oldNodes removeAt: i]]].	^ aNodeWithElements.! !!XMLNodeVisitor methodsFor: 'visiting'!visitCData: aCData	^ self visitStringNode: aCData! !!XMLNodeVisitor methodsFor: 'visiting'!visitComment: aComment	^ aComment! !!XMLNodeVisitor methodsFor: 'visiting'!visitDocument: aDocument	^ self visitNodeWithElements: aDocument! !!XMLNodeVisitor methodsFor: 'visiting'!visitElement: anElement	^ self visitNodeWithElements: anElement! !!XMLNodeVisitor methodsFor: 'visiting'!visitNode: aNode	^ aNode acceptNodeVisitor: self! !!XMLNodeVisitor methodsFor: 'visiting'!visitNodeWithElements: aNodeWithElements	aNodeWithElements hasChildren		ifTrue: [			aNodeWithElements nodesDo: [:each |				each acceptNodeVisitor: self]].	^ aNodeWithElements.! !!XMLNodeVisitor methodsFor: 'visiting'!visitPI: aPI	^ aPI! !!XMLNodeVisitor methodsFor: 'visiting'!visitStringNode: aStringNode	^ aStringNode! !!XMLValidatingNodeVisitor class methodsFor: 'instance creation'!validator: aValidator	^ self new validator: aValidator! !!XMLValidatingNodeVisitor methodsFor: 'accessing'!validator	^ validator! !!XMLValidatingNodeVisitor methodsFor: 'accessing'!validator: aValidator	validator := aValidator! !!XMLValidatingNodeVisitor methodsFor: 'visiting'!visitComment: aComment	self validator validateComment: aComment.	^ aComment.! !!XMLValidatingNodeVisitor methodsFor: 'visiting'!visitDocument: aDocument	aDocument root		ifNotNil: [:rootElement |			self validator validateRootElement: rootElement name].	super visitDocument: aDocument.	self validator validateEndDocument.	^ aDocument.! !!XMLValidatingNodeVisitor methodsFor: 'visiting'!visitElement: anElement	| attributeDictionary |	attributeDictionary := 		anElement hasAttributes			ifTrue: [anElement attributeNodes asDictionary]			ifFalse: [Dictionary new].	self validator		validateStartTag: anElement name		attributes: attributeDictionary.	"validation can change/add attribute values"	anElement setAttributes: attributeDictionary.	super visitElement: anElement.	self validator validateEndTag: anElement name.	^ anElement.! !!XMLValidatingNodeVisitor methodsFor: 'visiting'!visitPI: aPI	self validator		validatePI: aPI target		data: aPI data.	^ aPI.! !!XMLValidatingNodeVisitor methodsFor: 'visiting'!visitStringNode: aStringNode	self validator validatePCData: aStringNode string.	^ aStringNode.! !!XMLParser class methodsFor: 'instance creation'!driver: aDriver on: aStringOrStream	^ self new		setDriver: aDriver		tokenizer: (aDriver newTokenizerOn: aStringOrStream)! !!XMLParser methodsFor: 'testing'!atEnd	^ self tokenizer atEnd! !!XMLParser methodsFor: 'accessing'!baseURI	^ self driver baseURI! !!XMLParser methodsFor: 'accessing'!currentColumnNumber	^ self tokenizer currentColumnNumber! !!XMLParser methodsFor: 'accessing'!currentLineNumber	^ self tokenizer currentLineNumber! !!XMLParser methodsFor: 'accessing'!currentPosition	^ self tokenizer currentPosition! !!XMLParser methodsFor: 'accessing'!driver	^ driver! !!XMLParser methodsFor: 'private'!handleParserError: anError	self tokenizer closeStreams.	anError isXMLParserException		ifFalse: [anError pass].	(anError hasLineNumber		or: [self currentLineNumber isNil])		ifFalse: [anError lineNumber: self currentLineNumber].	(anError hasColumnNumber		or: [self currentColumnNumber isNil])		ifFalse: [anError columnNumber: self currentColumnNumber].	(anError hasBaseURI		or: [self baseURI isEmpty])		ifFalse: [anError baseURI: self baseURI].	anError shouldPassOnWhenCaught		ifTrue: [anError pass].! !!XMLParser methodsFor: 'parsing'!parseDocument	[[self tokenizer atEnd]		whileFalse: [self tokenizer nextToken]]		on: Error		do: [:error | self handleParserError: error]! !!XMLParser methodsFor: 'parsing'!parseDocumentUntil: aBlock	[[self tokenizer atEnd or: [aBlock value]]		whileFalse: [self tokenizer nextToken]]		on: Error		do: [:error | self handleParserError: error]! !!XMLParser methodsFor: 'parsing'!parseDocumentWhile: aBlock	[[self tokenizer atEnd not and: [aBlock value]]		whileTrue: [self tokenizer nextToken]]		on: Error		do: [:error | self handleParserError: error]! !!XMLParser methodsFor: 'parsing'!parseToken	^ [self tokenizer nextToken]		on: Error		do: [:error | self handleParserError: error]! !!XMLParser methodsFor: 'initialization'!setDriver: aDriver tokenizer: aTokenizer	driver := aDriver.	tokenizer := aTokenizer.! !!XMLParser methodsFor: 'accessing'!state	^ self tokenizer state! !!XMLParser methodsFor: 'accessing'!state: aTokenState	self tokenizer state: aTokenState! !!XMLParser methodsFor: 'accessing'!tokenizer	^ tokenizer! !!DTDExternalSubsetParserDriver class methodsFor: 'instance creation'!saxDriver: aSAXDriver documentURI: anExternalSubsetURIString	^ self new		setSAXDriver: aSAXDriver		documentURI: anExternalSubsetURIString! !!DTDExternalSubsetParserDriver methodsFor: 'testing'!decodesCharacters	^ self saxDriver decodesCharacters! !!DTDExternalSubsetParserDriver methodsFor: 'accessing'!documentURI	^ documentURI! !!DTDExternalSubsetParserDriver methodsFor: 'accessing'!externalEntityResolver	^ self saxDriver externalEntityResolver! !!DTDExternalSubsetParserDriver methodsFor: 'testing'!hasExternalSubset	^ true! !!DTDExternalSubsetParserDriver methodsFor: 'testing'!hasParameterEntityReferences	^ self saxDriver hasParameterEntityReferences! !!DTDExternalSubsetParserDriver methodsFor: 'testing'!hasSkippedParameterEntityReferences	^ self saxDriver hasSkippedParameterEntityReferences! !!DTDExternalSubsetParserDriver methodsFor: 'accessing'!haveParameterEntityReferences	self saxDriver haveParameterEntityReferences! !!DTDExternalSubsetParserDriver methodsFor: 'accessing'!haveSkippedParameterEntityReferences	self saxDriver haveSkippedParameterEntityReferences! !!DTDExternalSubsetParserDriver methodsFor: 'defaults'!initialStateClass	^ XMLExternalSubsetTextDeclarationState! !!DTDExternalSubsetParserDriver methodsFor: 'testing'!isExternal	"Definition: An external markup declaration is defined as a markup	declaration occurring in the external subset or in a parameter entity	(external or internal, the latter being included because non-validating	processors are not required to read them)"	^ true! !!DTDExternalSubsetParserDriver methodsFor: 'testing'!isStandalone	^ self saxDriver isStandalone! !!DTDExternalSubsetParserDriver methodsFor: 'testing'!isValidating	^ self saxDriver isValidating! !!DTDExternalSubsetParserDriver methodsFor: 'accessing'!maxEntityReplacementDepth	^ self saxDriver maxEntityReplacementDepth! !!DTDExternalSubsetParserDriver methodsFor: 'testing'!preservesUndeclaredEntityReferences	^ self saxDriver preservesUndeclaredEntityReferences! !!DTDExternalSubsetParserDriver methodsFor: 'accessing'!readLimit	^ self externalEntityResolver externalSubsetReadLimit! !!DTDExternalSubsetParserDriver methodsFor: 'testing'!replacesContentEntityReferences	^ self saxDriver replacesContentEntityReferences! !!DTDExternalSubsetParserDriver methodsFor: 'testing'!resolvesExternalEntities	^ true! !!DTDExternalSubsetParserDriver methodsFor: 'accessing'!saxDriver	^ saxDriver! !!DTDExternalSubsetParserDriver methodsFor: 'initialization'!setSAXDriver: aSAXDriver documentURI: anExternalSubsetURIString	saxDriver := aSAXDriver.	documentURI := anExternalSubsetURIString.	doctypeDefinition := aSAXDriver doctypeDefinition.! !!DTDSubsetParserDriver methodsFor: 'accessing'!doctypeDefinition	^ doctypeDefinition! !!DTDSubsetParserDriver methodsFor: 'private'!errorImproperParameterEntityNesting	XMLValidationException signal:		'Improper nesting of parameter entity replacement within DTD subset'! !!DTDSubsetParserDriver methodsFor: 'private'!errorInvalidUndeclaredGeneralEntityReference: aName	XMLValidationException		formatSignal: 'Undeclared general entity reference &{1};'		with: aName! !!DTDSubsetParserDriver methodsFor: 'private'!errorInvalidUndeclaredParameterEntityReference: aName	XMLValidationException		formatSignal: 'Undeclared parameter entity reference %{1};'		with: aName! !!DTDSubsetParserDriver methodsFor: 'private'!errorMultipleDeclarationsForElement: aName	XMLValidationException		formatSignal: 'Multiple declarations for <{1}> element'		with: aName! !!DTDSubsetParserDriver methodsFor: 'private'!errorMultipleDeclarationsForNotation: aName	"Unlike redundant entity declarations which are just ignored,	redundant notation declarations are invalid"	XMLValidationException		formatSignal: 'Multiple declarations for notation "{1}"'		with: aName! !!DTDSubsetParserDriver methodsFor: 'private'!errorReferenceToStandaloneExternalEntity: anEntity	XMLValidationException		formatSignal:			'Internal reference to externally defined ',			'entity {1} in standalone="yes" document'		with: anEntity asReference! !!DTDSubsetParserDriver methodsFor: 'private'!errorUndeclaredGeneralEntityReference: aName	XMLWellFormednessException		formatSignal: 'Undeclared general entity reference &{1};'		with: aName! !!DTDSubsetParserDriver methodsFor: 'accessing'!externalEntityResolver	self subclassResponsibility! !!DTDSubsetParserDriver methodsFor: 'handling - dtd'!handleAttributeDeclaration: anElement name: anAttribute type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue	| newAttributeValidator |	self mustSkipEntityAndAttributeDeclarations		ifTrue: [^ self].	newAttributeValidator :=		self isStandaloneExternal			ifTrue: [				self doctypeDefinition					addStandaloneExternalValidatorForAttributeIn: anElement					named: anAttribute					type: aType					defaultPragma: aDefaultPragma					defaultValue: aDefaultValue]			ifFalse: [				self doctypeDefinition					addValidatorForAttributeIn: anElement					named: anAttribute					type: aType					defaultPragma: aDefaultPragma					defaultValue: aDefaultValue].	(self isValidating		and: [newAttributeValidator notNil])		ifTrue: [newAttributeValidator validateAttributeDeclaration].! !!DTDSubsetParserDriver methodsFor: 'handling - dtd'!handleElementDeclaration: aName contentModel: aContentModel	| newElementValidator |	newElementValidator :=		self isStandaloneExternal			ifTrue: [				self doctypeDefinition					addStandaloneExternalValidatorForElement: aName					contentModel: aContentModel]			ifFalse: [				self doctypeDefinition					addValidatorForElement: aName					contentModel: aContentModel].	self isValidating		ifTrue: [			newElementValidator				ifNil: [self errorMultipleDeclarationsForElement: aName].			newElementValidator validateElementDeclaration].! !!DTDSubsetParserDriver methodsFor: 'handling - dtd'!handleGeneralEntityDeclaration: aName publicID: aPublicID systemID: aSystemID ndata: aNotation	self mustSkipEntityAndAttributeDeclarations		ifTrue: [^ self].	aNotation isEmpty		ifTrue: [			self resolvesExternalEntities				ifTrue: [					self isStandaloneExternal						ifTrue: [							self doctypeDefinition								addStandaloneExternalExternalGeneralEntity: aName								resolver: self externalEntityResolver								publicID: aPublicID								systemID: aSystemID								baseURI: self baseURI]						ifFalse: [							self doctypeDefinition								addExternalGeneralEntity: aName								resolver: self externalEntityResolver								publicID: aPublicID								systemID: aSystemID								baseURI: self baseURI]]				ifFalse: [					self isValidating						ifTrue: [							self doctypeDefinition								addUnresolvableExternalGeneralEntity: aName]]]		ifFalse: [			self doctypeDefinition				addUnparsedEntity: aName				publicID: aPublicID				systemID: aSystemID				ndata: aNotation].! !!DTDSubsetParserDriver methodsFor: 'handling - dtd'!handleGeneralEntityDeclaration: aName replacement: aReplacement	self mustSkipEntityAndAttributeDeclarations		ifTrue: [^ self].	self isStandaloneExternal		ifTrue: [			self doctypeDefinition				addStandaloneExternalInternalGeneralEntity: aName				replacement: aReplacement				baseURI: self baseURI]		ifFalse: [			self doctypeDefinition				addInternalGeneralEntity: aName				replacement: aReplacement				baseURI: self baseURI].! !!DTDSubsetParserDriver methodsFor: 'handling'!handleGeneralEntityReference: aName	| entity |	entity :=		self doctypeDefinition			generalEntityAt: aName			ifAbsent: [				"WFC: In a document without any DTD, a document with only an				internal DTD subset which contains no parameter entity references,				or a document with ''standalone='yes''', for an entity reference				(general) that does not occur within the external subset or a				parameter entity (meaning DTD 'external')"				self isExternal					ifFalse: [						((self hasExternalSubset not							and: [self hasParameterEntityReferences not])								or: [self isStandalone])							ifTrue: [self errorUndeclaredGeneralEntityReference: aName]].				"all general entity refs must be declared when validating"				self isValidating					ifTrue: [self errorInvalidUndeclaredGeneralEntityReference: aName].				^ nil].	"'VC: Standalone Document Declaration		The standalone document declaration MUST have the value 'no' if any		external markup declarations contain declarations of:			...		entities ... if references to those entities appear in the document'	LibXML2 doesn't flag these at all, and Xerces only does for references	in the content, but the specification says in the 'document', so we	consider all non-external references, even inside the DTD internal subset"	(entity isStandaloneExternal		and: [self isValidating			and: [self isExternal not]])		ifTrue: [self errorReferenceToStandaloneExternalEntity: entity].	^ entity.! !!DTDSubsetParserDriver methodsFor: 'handling - dtd'!handleImproperParameterEntityNesting	"this is a validity constraint and is only checked when validating"	self isValidating		ifTrue: [self errorImproperParameterEntityNesting]! !!DTDSubsetParserDriver methodsFor: 'handling - dtd'!handleNotationDeclaration: aName publicID: aPublicID systemID: aSystemID	(self doctypeDefinition		addNotation: aName		publicID: aPublicID		systemID: aSystemID)		ifNil: [			self isValidating				ifTrue: [self errorMultipleDeclarationsForNotation: aName]]! !!DTDSubsetParserDriver methodsFor: 'handling - dtd'!handleParameterEntityDeclaration: aName publicID: aPublicID systemID: aSystemID	self mustSkipEntityAndAttributeDeclarations		ifFalse: [			self resolvesExternalEntities				ifTrue: [					self doctypeDefinition						addExternalParameterEntity: aName						resolver: self externalEntityResolver						publicID: aPublicID						systemID: aSystemID						baseURI: self baseURI]				ifFalse: [					self isValidating						ifTrue: [							self doctypeDefinition								addUnresolvableExternalParameterEntity: aName]]]! !!DTDSubsetParserDriver methodsFor: 'handling - dtd'!handleParameterEntityDeclaration: aName replacement: aReplacement	self mustSkipEntityAndAttributeDeclarations		ifFalse: [			self doctypeDefinition				addInternalParameterEntity: aName				replacement:aReplacement				baseURI: self baseURI]! !!DTDSubsetParserDriver methodsFor: 'handling - dtd'!handleParameterEntityReference: aName	self haveParameterEntityReferences.	^ self doctypeDefinition		parameterEntityAt: aName		ifAbsent: [			self isValidating				ifTrue: [self errorInvalidUndeclaredParameterEntityReference: aName].			self haveSkippedParameterEntityReferences.			nil]! !!DTDSubsetParserDriver methodsFor: 'handling'!handleParseError: aString	XMLWellFormednessException signal: aString! !!DTDSubsetParserDriver methodsFor: 'testing'!hasExternalSubset	self subclassResponsibility! !!DTDSubsetParserDriver methodsFor: 'testing'!hasParameterEntityReferences	self subclassResponsibility! !!DTDSubsetParserDriver methodsFor: 'testing'!hasSkippedParameterEntityReferences	self subclassResponsibility! !!DTDSubsetParserDriver methodsFor: 'accessing'!haveParameterEntityReferences	self subclassResponsibility! !!DTDSubsetParserDriver methodsFor: 'accessing'!haveSkippedParameterEntityReferences	self subclassResponsibility! !!DTDSubsetParserDriver methodsFor: 'testing'!isExternal	"Definition: An external markup declaration is defined as a markup	declaration occurring in the external subset or in a parameter entity	(external or internal, the latter being included because non-validating	processors are not required to read them)"	self subclassResponsibility! !!DTDSubsetParserDriver methodsFor: 'testing'!isStandalone	self subclassResponsibility! !!DTDSubsetParserDriver methodsFor: 'testing'!isStandaloneExternal	^ self isStandalone		and: [self isExternal]! !!DTDSubsetParserDriver methodsFor: 'testing'!isValidating	self subclassResponsibility! !!DTDSubsetParserDriver methodsFor: 'accessing'!maxEntityReplacementDepth	self subclassResponsibility! !!DTDSubsetParserDriver methodsFor: 'testing'!mustSkipEntityAndAttributeDeclarations	"'Except when standalone=''yes'', they (non-validating parsers) MUST NOT	process entity declarations or attribute-list declarations encountered	after a reference to a parameter entity that is not read...'"	^ self isValidating not		and: [self isStandalone not			and: [self hasSkippedParameterEntityReferences]]! !!DTDSubsetParserDriver methodsFor: 'testing'!preservesUndeclaredEntityReferences	self subclassResponsibility! !!DTDSubsetParserDriver methodsFor: 'testing'!replacesContentEntityReferences	self subclassResponsibility! !!DTDSubsetParserDriver methodsFor: 'testing'!resolvesExternalEntities	self subclassResponsibility! !!SAXParserDriver class methodsFor: 'instance creation'!saxHandler: aSAXHandler	^ self new setSAXHandler: aSAXHandler! !!SAXParserDriver methodsFor: 'accessing'!baseURI	"returns a string with the current base URI at this stage of parsing"	self elementNester hasScopedAttributes		ifTrue: [			^ self elementNester				scopedAttributeAt: 'xml:base'				ifAbsent: [super baseURI]]		ifFalse: [^ super baseURI]! !!SAXParserDriver methodsFor: 'private'!checkForReservedAttributesIn: anOrderPreservingDictionary afterIndex: anIndex	"validation may add attributes, so this is used to check if reserved	attributes were added that need handling when there weren't any before"	self hasUnhandledReservedAttributes		ifTrue: [^ self].	anIndex + 1		to: anOrderPreservingDictionary size		do: [:i |			(anOrderPreservingDictionary keyAtIndex: i) isXMLReservedAttributeName				ifTrue: [^ self haveUnhandledReservedAttributes]].! !!SAXParserDriver methodsFor: 'accessing'!currentElement	^ self elementNester currentElement! !!SAXParserDriver methodsFor: 'accessing'!currentElement: anElement	self elementNester currentElement: anElement! !!SAXParserDriver methodsFor: 'accessing'!currentScope	^ self scopeAllocator currentScope! !!SAXParserDriver methodsFor: 'accessing'!currentScope: aNamespaceScope	self scopeAllocator currentScope: aNamespaceScope! !!SAXParserDriver methodsFor: 'private'!declareNamespaces: aSequenceableCollection inScope: aScope	1 to: aSequenceableCollection size do: [:i | | association |		association := aSequenceableCollection at: i.		(aScope resolvePrefix: association key) = association value			ifFalse: [				self saxHandler					startPrefixMapping: association key					uri: association value]].	aScope mapPrefixesAndURIs: aSequenceableCollection.! !!SAXParserDriver methodsFor: 'testing'!decodesCharacters	^ self saxHandler decodesCharacters! !!SAXParserDriver methodsFor: 'defaults'!doctypeDefinitionClass	^ DTDDoctypeDefinition! !!SAXParserDriver methodsFor: 'accessing'!documentReadLimit	^ self saxHandler documentReadLimit! !!SAXParserDriver methodsFor: 'accessing'!documentURI	^ self saxHandler documentURI! !!SAXParserDriver methodsFor: 'accessing'!elementNester	^ elementNester! !!SAXParserDriver methodsFor: 'private'!errorDocumentConstraintsRequired	XMLValidationException signal: 'Document validation constraints required'! !!SAXParserDriver methodsFor: 'accessing'!externalEntityResolver	^ externalEntityResolver		ifNil: [			externalEntityResolver :=				self saxHandler externalEntityResolver					asLimitingExternalEntityResolver]! !!SAXParserDriver methodsFor: 'private'!externalSubsetParserOn: aStringOrStream documentURI: aURIString	^ self saxHandler parserClass		driver:			(DTDExternalSubsetParserDriver				saxDriver: self				documentURI: aURIString)		on: aStringOrStream! !!SAXParserDriver methodsFor: 'accessing'!externalSubsetPublicID	^ externalSubsetPublicID! !!SAXParserDriver methodsFor: 'accessing'!externalSubsetSystemID	^ externalSubsetSystemID! !!SAXParserDriver methodsFor: 'private'!extractNamespacesFromAttributes: anOrderPreservingDictionary	"returns an ordered collection of namespace prefix/uri associations	removed from the attribute dictionary or nil if there aren't any"	| namespaces keysToRemove |	self haveNoUnhandledReservedAttributes.	anOrderPreservingDictionary keysDo: [:name |		"optimized comparison ordering"		(name at: 1) == $x			ifTrue: [				name isXMLNSAttributeName					ifTrue: [						"only initialize when needed"						(namespaces ifNil: [namespaces := OrderedCollection new: 5])							addLast:								(name size > 6 "'xmlns:' size"									ifTrue: [name copyFrom: 7 to: name size]									ifFalse: ['']) ->										(anOrderPreservingDictionary at: name).						"only initialize when needed"						(keysToRemove ifNil: [keysToRemove := OrderedCollection new: 5])							addLast: name]					ifFalse: [						name isXMLReservedAttributeName							ifTrue: [								"at least one xml attr is not an xmlns attr, so there								will still be reserved attrs to handle after extracting								the namespaces"								self haveUnhandledReservedAttributes]]]].	keysToRemove		ifNotNil: [			"use removeKeys: for speed"			anOrderPreservingDictionary removeKeys: keysToRemove].	^ namespaces.! !!SAXParserDriver methodsFor: 'handling - dtd'!handleAttributeDeclaration: anElement name: anAttribute type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue	super		handleAttributeDeclaration: anElement		name: anAttribute		type: aType		defaultPragma: aDefaultPragma		defaultValue: aDefaultValue.	self saxHandler		attributeDeclaration: anElement		name: anAttribute		type: aType		defaultPragma: aDefaultPragma		defaultValue: aDefaultValue.! !!SAXParserDriver methodsFor: 'handling'!handleCData: aString	self isValidating		ifTrue: [self validator validatePCData: aString].	self saxHandler		isInCDataSection: true;		startCData;		characters: aString;		endCData;		isInCDataSection: false.! !!SAXParserDriver methodsFor: 'handling'!handleComment: aString	(self elementNester isInElement		and: [self isValidating])		ifTrue: [self validator validateComment: aString].	self saxHandler comment: aString.! !!SAXParserDriver methodsFor: 'handling - dtd'!handleElementDeclaration: aName contentModel: aContentModel	super		handleElementDeclaration: aName		contentModel: aContentModel.	self saxHandler		elementDeclaration: aName		contentModel: aContentModel.! !!SAXParserDriver methodsFor: 'handling'!handleEndContentEntityReplacement: aName	self saxHandler endEntity: aName! !!SAXParserDriver methodsFor: 'handling - dtd'!handleEndDTD	(self resolvesExternalEntities		and: [self hasExternalSubset			and: [self isValidating				or: [self isStandalone not]]])		ifTrue: [self parseExternalSubset].	self isValidating		ifTrue: [self doctypeDefinition validateCompletedDefinition].	self saxHandler		doctypeDefinition: self doctypeDefinition;		endDTD.! !!SAXParserDriver methodsFor: 'handling'!handleEndDocument	self isValidating		ifTrue: [self validator validateEndDocument].	self saxHandler endDocument.! !!SAXParserDriver methodsFor: 'handling'!handleEndTag: anElement	"performance critical method"	| prefix currentScope |	prefix := anElement xmlPrefixBeforeLocalName.	self saxHandler 		endElement: anElement		prefix: prefix		uri:			(self usesNamespaces				ifTrue: [					(currentScope := self scopeAllocator exitScope)						resolvePrefix: prefix]				ifFalse: [''])		localName: (anElement xmlLocalNameAfterPrefix: prefix).	self usesNamespaces		ifTrue: [			currentScope hasNamespaces				ifTrue: [self undeclareNamespacesInScope: currentScope]].	self isValidating		ifTrue: [self validator validateEndTag: anElement].! !!SAXParserDriver methodsFor: 'handling - dtd'!handleGeneralEntityDeclaration: aName publicID: aPublicID systemID: aSystemID ndata: aNotation	super		handleGeneralEntityDeclaration: aName		publicID: aPublicID		systemID: aSystemID		ndata: aNotation.	self saxHandler		generalEntityDeclaration: aName		publicID: aPublicID		systemID: aSystemID		ndata: aNotation.! !!SAXParserDriver methodsFor: 'handling - dtd'!handleGeneralEntityDeclaration: aName replacement: aReplacement	super		handleGeneralEntityDeclaration: aName		replacement: aReplacement.	self saxHandler		generalEntityDeclaration: aName		replacement: aReplacement.! !!SAXParserDriver methodsFor: 'handling - dtd'!handleNotationDeclaration: aName publicID: aPublicID systemID: aSystemID	super		handleNotationDeclaration: aName		publicID: aPublicID		systemID: aSystemID.	self saxHandler		notationDeclaration: aName		publicID: aPublicID		systemID: aSystemID.! !!SAXParserDriver methodsFor: 'handling'!handlePCData: aString	self isValidating		ifTrue: [self validator validatePCData: aString].	self saxHandler characters: aString.! !!SAXParserDriver methodsFor: 'handling'!handlePI: aTargetString data: aDataString	(self elementNester isInElement		and: [self isValidating])		ifTrue: [			self validator				validatePI: aTargetString				data: aDataString].	self saxHandler 		processingInstruction: aTargetString		data: aDataString.! !!SAXParserDriver methodsFor: 'handling - dtd'!handleParameterEntityDeclaration: aName publicID: aPublicID systemID: aSystemID	super		handleParameterEntityDeclaration: aName		publicID: aPublicID		systemID: aSystemID.	self saxHandler		parameterEntityDeclaration: aName		publicID: aPublicID		systemID: aSystemID.! !!SAXParserDriver methodsFor: 'handling - dtd'!handleParameterEntityDeclaration: aName replacement: aReplacement	super		handleParameterEntityDeclaration: aName		replacement: aReplacement.	self saxHandler		parameterEntityDeclaration: aName		replacement: aReplacement.! !!SAXParserDriver methodsFor: 'private'!handleReservedAttributes: aDictionary	aDictionary		at: 'xml:base'		ifPresent: [:uri |			"expand the new base URI using the current"			aDictionary				at: 'xml:base'				put: (self baseURI asXMLURI / uri) asString].	self isValidating		ifTrue: [self validator validateXMLIDAttributeIn: aDictionary].	self elementNester		setScopedAttributesNamed: self scopedAttributeNames		from: aDictionary.	self haveNoUnhandledReservedAttributes.! !!SAXParserDriver methodsFor: 'handling'!handleStartContent	self saxHandler startContent! !!SAXParserDriver methodsFor: 'handling'!handleStartContentEntityReplacement: aName	self saxHandler startEntity: aName! !!SAXParserDriver methodsFor: 'handling - dtd'!handleStartDTD: aRoot publicID: aPublicID systemID: aSystemID	externalSubsetPublicID := aPublicID.	externalSubsetSystemID := aSystemID.	self doctypeDefinition root: aRoot.	self saxHandler		startDTD: aRoot		publicID: aPublicID		systemID: aSystemID.! !!SAXParserDriver methodsFor: 'handling'!handleStartDocument	self saxHandler startDocument! !!SAXParserDriver methodsFor: 'handling'!handleStartTag: anElement attributes: anAttributeDictionary	"performance critical method"	| prefix totalAttributes namespaceURI currentScope |	prefix := anElement xmlPrefixBeforeLocalName.	totalAttributes := anAttributeDictionary size.	self isValidating		ifTrue: [			self elementNester totalOpenElements > 1				ifFalse: [self validateRootElement: anElement].			self validator				validateStartTag: anElement				attributes: anAttributeDictionary]		ifFalse: [			self doctypeDefinition				processStartTag: anElement				attributes: anAttributeDictionary].	"validation and processing can add attributes"	anAttributeDictionary size > totalAttributes		ifTrue: [			self				checkForReservedAttributesIn: anAttributeDictionary				afterIndex: totalAttributes.			totalAttributes := anAttributeDictionary size].	self usesNamespaces		ifTrue: [			anAttributeDictionary setNamespaceScope:				(currentScope := self scopeAllocator enterScope).			self hasUnhandledReservedAttributes				ifTrue: [					(self extractNamespacesFromAttributes: anAttributeDictionary)						ifNotNil: [:namespaces |							self								declareNamespaces: namespaces								inScope: currentScope.							totalAttributes := anAttributeDictionary size]].			self saxHandler startScope: currentScope.			namespaceURI :=				currentScope					validateAndResolvePrefix: prefix					ofElement: anElement.			totalAttributes > 0				ifTrue: [					"anAttributeDictionary is an XMLAttributeDictionary, which					is an OrderPreservingStringDictionary, so use its internal					#orderedKeys over #keys for speed"					currentScope						validatePrefixesOfAttributes: anAttributeDictionary orderedKeys						from: 1						to: totalAttributes]].	self hasUnhandledReservedAttributes		ifTrue: [self handleReservedAttributes: anAttributeDictionary].	self saxHandler		startElement: anElement		prefix: prefix		uri: (namespaceURI ifNil: [''])		localName: (anElement xmlLocalNameAfterPrefix: prefix)		attributes: anAttributeDictionary.! !!SAXParserDriver methodsFor: 'handling'!handleUnreplacedGeneralEntityReference: aName	self saxHandler skippedEntity: aName! !!SAXParserDriver methodsFor: 'handling'!handleWhitespace: aString	self isValidating		ifTrue: [			self validator isCurrentElementWhitespaceIgnorable				ifTrue: [					(self elementNester hasScopedAttributes						and: [							(self elementNester scopedAttributeAt: 'xml:space') =								'preserve'])						ifTrue: [self saxHandler characters: aString]						ifFalse: [self saxHandler ignorableWhitespace: aString].					^ self]				ifFalse: [					"only validate if it's not ignorable"					self validator validatePCData: aString]].	self saxHandler characters: aString.! !!SAXParserDriver methodsFor: 'handling'!handleXMLVersion: aVersion encoding: anEncoding standalone: aYesOrNo	isStandalone := aYesOrNo = 'yes'.	self saxHandler		xmlVersion: (self versionFloatFromString: aVersion)		encoding: anEncoding		standalone: isStandalone.! !!SAXParserDriver methodsFor: 'testing'!hasExternalSubset	^ self externalSubsetPublicID notEmpty		or: [self externalSubsetSystemID notEmpty]! !!SAXParserDriver methodsFor: 'testing'!hasParameterEntityReferences	^ hasParameterEntityReferences! !!SAXParserDriver methodsFor: 'testing'!hasSkippedParameterEntityReferences	^ hasSkippedParameterEntityReferences! !!SAXParserDriver methodsFor: 'testing'!hasUnhandledReservedAttributes	^ hasUnhandledReservedAttributes! !!SAXParserDriver methodsFor: 'accessing'!haveNoUnhandledReservedAttributes	hasUnhandledReservedAttributes := false! !!SAXParserDriver methodsFor: 'accessing'!haveParameterEntityReferences	hasParameterEntityReferences := true! !!SAXParserDriver methodsFor: 'accessing'!haveSkippedParameterEntityReferences	hasSkippedParameterEntityReferences := true! !!SAXParserDriver methodsFor: 'accessing'!haveUnhandledReservedAttributes	hasUnhandledReservedAttributes := true! !!SAXParserDriver methodsFor: 'testing'!isExternal	"Definition: An external markup declaration is defined as a markup	declaration occurring in the external subset or in a parameter entity	(external or internal, the latter being included because non-validating	processors are not required to read them)"	"returning #isParameter instead of 'self currentEntity notNil'	ensures the correct result when parsing content"	^ self currentEntity		ifNil: [false]		ifNotNil: [:entity | entity isParameter]! !!SAXParserDriver methodsFor: 'testing'!isStandalone	^ isStandalone! !!SAXParserDriver methodsFor: 'accessing'!isStandalone: aBoolean	isStandalone := aBoolean! !!SAXParserDriver methodsFor: 'testing'!isValidating	^ isValidating! !!SAXParserDriver methodsFor: 'accessing'!maxEntityReplacementDepth	^ self saxHandler maxEntityReplacementDepth! !!SAXParserDriver methodsFor: 'instance creation'!newAttributeDictionary	^ (self usesNamespaces		ifTrue: [XMLNamespacedAttributeDictionary]		ifFalse: [XMLAttributeDictionary]) new! !!SAXParserDriver methodsFor: 'instance creation'!newEmptyAttributeDictionary	^ (self usesNamespaces		ifTrue: [XMLLazyNamespacedAttributeDictionary]		ifFalse: [XMLLazyAttributeDictionary]) new! !!SAXParserDriver methodsFor: 'private'!parseExternalSubset	| externalSubsetURI |	externalSubsetURI :=		self externalEntityResolver			externalEntityURIFromPublicID: self externalSubsetPublicID			systemID: self externalSubsetSystemID			baseURI: self baseURI.	"External subsets are stream-resolved so if they are local (stored on disk),	they aren't kept entirely in memory during parsing. HTTP entities will be	kept in memory regardless and this will just return a read stream on them."	(self		externalSubsetParserOn:			(self externalEntityResolver streamResolveExternalEntityURI:				externalSubsetURI)		documentURI: externalSubsetURI asString)		parseDocument.! !!SAXParserDriver methodsFor: 'testing'!preservesUndeclaredEntityReferences	^ self saxHandler preservesUndeclaredEntityReferences! !!SAXParserDriver methodsFor: 'accessing'!readLimit	^ self documentReadLimit! !!SAXParserDriver methodsFor: 'testing'!replacesContentEntityReferences	^ self saxHandler replacesContentEntityReferences! !!SAXParserDriver methodsFor: 'testing'!resolvesExternalEntities	^ self saxHandler resolvesExternalEntities! !!SAXParserDriver methodsFor: 'accessing'!saxHandler	^ saxHandler! !!SAXParserDriver methodsFor: 'accessing'!scopeAllocator	^ scopeAllocator ifNil: [scopeAllocator := XMLNamespaceScopeAllocator new]! !!SAXParserDriver methodsFor: 'private'!scopedAttributeNames	"the scoped attributes tracked by this driver"	^ #('xml:space' 'xml:base')! !!SAXParserDriver methodsFor: 'initialization'!setSAXHandler: aSAXHandler	saxHandler := aSAXHandler.	doctypeDefinition := self doctypeDefinitionClass new.	validator := (aSAXHandler schema ifNil: [doctypeDefinition]) newValidator.	elementNester := self newElementNester.	externalSubsetPublicID := ''.	externalSubsetSystemID := ''.	"these are copied to inst vars for faster access"	isValidating := aSAXHandler isValidating.	usesNamespaces := aSAXHandler usesNamespaces.	isStandalone := false.	hasParameterEntityReferences := false.	hasSkippedParameterEntityReferences := false.	hasUnhandledReservedAttributes := false.! !!SAXParserDriver methodsFor: 'private'!undeclareNamespacesInScope: anExitedScope	| currentScope |	currentScope := self scopeAllocator currentScope.	anExitedScope prefixesAndURIsDo: [:prefix :uri |		(currentScope resolvePrefix: prefix) = uri			ifFalse: [self saxHandler endPrefixMapping: prefix]].! !!SAXParserDriver methodsFor: 'testing'!usesNamespaces	^ usesNamespaces! !!SAXParserDriver methodsFor: 'private'!validateRootElement: anElement	self saxHandler requiresSchema		ifTrue: [			(self validator hasElementValidators				or: [self validator hasAttributeValidators])				ifFalse: [self errorDocumentConstraintsRequired]].	self validator validateRootElement: anElement.! !!SAXParserDriver methodsFor: 'accessing'!validator	^ validator! !!SAXParserDriver methodsFor: 'private'!versionFloatFromString: aString	aString size = 3		ifTrue: [			aString = '1.0'				ifTrue: [^ 1.0].			aString = '1.1'				ifTrue: [^ 1.1]].	^ Float readFrom: aString readStream.! !!XMLParserDriver methodsFor: 'accessing'!baseURI	"returns a string with the current base URI at this stage of parsing"	^ baseURI ifNil: [baseURI := self documentURI]! !!XMLParserDriver methodsFor: 'accessing'!baseURI: aURI	baseURI := aURI! !!XMLParserDriver methodsFor: 'accessing'!currentEntity	^ currentEntity! !!XMLParserDriver methodsFor: 'accessing'!currentEntity: anEntity	currentEntity := anEntity! !!XMLParserDriver methodsFor: 'testing'!decodesCharacters	^ true! !!XMLParserDriver methodsFor: 'accessing'!documentURI	^ nil! !!XMLParserDriver methodsFor: 'accessing'!elementNester	^ self newElementNester! !!XMLParserDriver methodsFor: 'defaults'!elementNesterClass	^ XMLElementNester! !!XMLParserDriver methodsFor: 'handling - dtd'!handleAttributeDeclaration: anElement name: anAttribute type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue! !!XMLParserDriver methodsFor: 'handling'!handleCData: aString! !!XMLParserDriver methodsFor: 'handling'!handleComment: aString! !!XMLParserDriver methodsFor: 'handling - dtd'!handleElementDeclaration: aName contentModel: aContentModel! !!XMLParserDriver methodsFor: 'handling'!handleEndContentEntityReplacement: aName! !!XMLParserDriver methodsFor: 'handling - dtd'!handleEndDTD! !!XMLParserDriver methodsFor: 'handling'!handleEndDocument! !!XMLParserDriver methodsFor: 'handling'!handleEndTag: anElement! !!XMLParserDriver methodsFor: 'handling - dtd'!handleGeneralEntityDeclaration: aName publicID: aPublicID systemID: aSystemID ndata: aNotation! !!XMLParserDriver methodsFor: 'handling - dtd'!handleGeneralEntityDeclaration: aName replacement: aReplacement! !!XMLParserDriver methodsFor: 'handling'!handleGeneralEntityReference: aName	^ nil! !!XMLParserDriver methodsFor: 'handling - dtd'!handleNotationDeclaration: aName publicID: aPublicID systemID: aSystemID! !!XMLParserDriver methodsFor: 'handling'!handlePCData: aString! !!XMLParserDriver methodsFor: 'handling'!handlePI: aTargetString data: aDataString! !!XMLParserDriver methodsFor: 'handling - dtd'!handleParameterEntityDeclaration: aName publicID: aPublicID systemID: aSystemID! !!XMLParserDriver methodsFor: 'handling - dtd'!handleParameterEntityDeclaration: aName replacement: aReplacement! !!XMLParserDriver methodsFor: 'handling - dtd'!handleParameterEntityReference: aName	^ nil! !!XMLParserDriver methodsFor: 'handling'!handleParseError: aString! !!XMLParserDriver methodsFor: 'handling'!handleStartContent! !!XMLParserDriver methodsFor: 'handling'!handleStartContentEntityReplacement: aName! !!XMLParserDriver methodsFor: 'handling - dtd'!handleStartDTD: aRoot publicID: aPublicID systemID: aSystemID! !!XMLParserDriver methodsFor: 'handling'!handleStartDocument! !!XMLParserDriver methodsFor: 'handling'!handleStartTag: anElement attributes: anAttributeDictionary! !!XMLParserDriver methodsFor: 'handling'!handleUnreplacedGeneralEntityReference: aName! !!XMLParserDriver methodsFor: 'handling'!handleWhitespace: aString! !!XMLParserDriver methodsFor: 'handling'!handleXMLVersion: aVersion encoding: anEncoding standalone: aYesOrNo! !!XMLParserDriver methodsFor: 'defaults'!initialStateClass	^ XMLXMLDeclarationState! !!XMLParserDriver methodsFor: 'instance creation'!newElementNester	^ self elementNesterClass new! !!XMLParserDriver methodsFor: 'instance creation'!newInitialState	^ self initialStateClass new! !!XMLParserDriver methodsFor: 'instance creation'!newTokenizerOn: aStringOrStream	^ self tokenizerClass		driver: self		on: aStringOrStream		readLimit: self readLimit! !!XMLParserDriver methodsFor: 'accessing'!readLimit	^ nil! !!XMLParserDriver methodsFor: 'defaults'!tokenizerClass	^ XMLWellFormedParserTokenizer! !!XMLParserLimits class methodsFor: 'defaults'!defaultDocumentReadLimit	^ self defaultReadLimit! !!XMLParserLimits class methodsFor: 'defaults'!defaultMaxEntityReplacementDepth	^ 10! !!XMLParserLimits class methodsFor: 'accessing'!defaultReadLimit	^ DefaultReadLimit		ifNil: [DefaultReadLimit := 10000000]! !!XMLParserLimits class methodsFor: 'accessing'!defaultReadLimit: aDefaultLimit	"can be used to change the default read limit instances start with"	DefaultReadLimit := aDefaultLimit! !!XMLParserLimits methodsFor: 'accessing'!documentReadLimit	^ documentReadLimit! !!XMLParserLimits methodsFor: 'accessing'!documentReadLimit: anInteger	documentReadLimit := anInteger! !!XMLParserLimits methodsFor: 'initialization'!initialize	super initialize.	documentReadLimit := self class defaultDocumentReadLimit.	maxEntityReplacementDepth := self class defaultMaxEntityReplacementDepth.! !!XMLParserLimits methodsFor: 'accessing'!maxEntityReplacementDepth	^ maxEntityReplacementDepth! !!XMLParserLimits methodsFor: 'accessing'!maxEntityReplacementDepth: anInteger	maxEntityReplacementDepth := anInteger! !!XMLParserLimits methodsFor: 'removing'!removeAll	documentReadLimit := nil.	maxEntityReplacementDepth := nil.! !!XMLParserTokenizer class methodsFor: 'instance creation'!driver: aDriver on: aStringOrStream	^self		driver: aDriver		on: aStringOrStream		readLimit: nil! !!XMLParserTokenizer class methodsFor: 'instance creation'!driver: aDriver on: aStringOrStream readLimit: anInteger	^self new		setDriver: aDriver		stream:			(aStringOrStream isStream				ifTrue: [aStringOrStream]				ifFalse: [aStringOrStream readStream])		readLimit: anInteger! !!XMLParserTokenizer class methodsFor: 'class initialization'!initialize	"self initialize"	"assign after with #yourself to avoid possible race	conditions when reinitializing the class"	PredefinedEntities :=		Dictionary new			at: 'lt' put: $<;			at: 'gt' put: $>;			at: 'amp' put: $&;			at: 'apos' put: $';			at: 'quot' put: $";			yourself! !!XMLParserTokenizer class methodsFor: 'accessing'!predefinedEntities	^ PredefinedEntities! !!XMLParserTokenizer methodsFor: 'testing'!atEnd	^ state isTerminatedState! !!XMLParserTokenizer methodsFor: 'decoding'!characterFromCodePoint: aCodePoint	(aCodePoint notNil		and: [aCodePoint > 0			and: [aCodePoint <= 16r10FFFF]])		ifTrue: [			^ [Character value: aCodePoint]				on: Error				do: [:error | nil]]		ifFalse: [^ nil]! !!XMLParserTokenizer methodsFor: 'closing'!closeStreams	streamReader closeStreams! !!XMLParserTokenizer methodsFor: 'decoding'!convertFromEncoding: anEncodingName	driver decodesCharacters		ifTrue: [streamReader convertFromEncoding: anEncodingName]! !!XMLParserTokenizer methodsFor: 'accessing'!currentColumnNumber	^ streamReader currentColumnNumber! !!XMLParserTokenizer methodsFor: 'accessing'!currentLineNumber	^ streamReader currentLineNumber! !!XMLParserTokenizer methodsFor: 'accessing'!currentPosition	^ streamReader currentPosition! !!XMLParserTokenizer methodsFor: 'accessing'!driver	^ driver! !!XMLParserTokenizer methodsFor: 'accessing'!elementNester	^ elementNester! !!XMLParserTokenizer methodsFor: 'errors'!errorExpected: aDescription	self parseError: 'Expected ', aDescription! !!XMLParserTokenizer methodsFor: 'errors'!errorExpected: aDescription butGot: aCharacterOrString	self		formatParseError: 'Expected {1} but got "{2}" instead'		with: aDescription		with: aCharacterOrString! !!XMLParserTokenizer methodsFor: 'errors'!errorExpectedLiteral: aCharacterOrString	self		errorExpectedLiteral: aCharacterOrString		butGot: nil! !!XMLParserTokenizer methodsFor: 'errors'!errorExpectedLiteral: anExpectedCharacterOrString butGot: aReceivedCharacterOrString	self		formatParseError: 'Expected "{1}" but got "{2}" instead' 		with: anExpectedCharacterOrString		with: aReceivedCharacterOrString! !!XMLParserTokenizer methodsFor: 'tokenizing - expecting'!expectNext: aCharacter	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing - expecting'!expectNextAll: aString	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'errors'!formatParseError: aString with: aFirstValue	self		formatParseError: aString		withArguments: (Array with: aFirstValue)! !!XMLParserTokenizer methodsFor: 'errors'!formatParseError: aString with: aFirstValue with: aSecondValue	self		formatParseError: aString		withArguments:			(Array				with: aFirstValue				with: aSecondValue)! !!XMLParserTokenizer methodsFor: 'errors'!formatParseError: aString with: aFirstValue with: aSecondValue with: aThirdValue	self		formatParseError: aString		withArguments:			(Array				with: aFirstValue				with: aSecondValue				with: aThirdValue)! !!XMLParserTokenizer methodsFor: 'errors'!formatParseError: aString with: aFirstValue with: aSecondValue with: aThirdValue with: aFourthValue	self		formatParseError: aString		withArguments:			(Array				with: aFirstValue				with: aSecondValue				with: aThirdValue				with: aFourthValue)! !!XMLParserTokenizer methodsFor: 'errors'!formatParseError: aString withArguments: aValueCollection	self parseError:		(aString format:			"convert nils to empty strings, so nil values are			not printed as 'nil' in error messsages"			(aValueCollection collect: [:each |				each ifNil: ['']]))! !!XMLParserTokenizer methodsFor: 'defaults'!hexCharacterValueLiteralPrefixes	^ 'x'! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextCDataSection	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'decoding'!nextCharacterValueLiteral	^ self nextCharacterValueLiteralPrintedOn: nil! !!XMLParserTokenizer methodsFor: 'decoding'!nextCharacterValueLiteralPrintedOn: aStream	"do not limit the number of chars read, because char values can	have an arbitrary number of leading zeros"	^ (XMLSmallIntegerReader on: streamReader)		printStream: aStream;		nextIntegerWithBase: 16			andPrefixes: self hexCharacterValueLiteralPrefixes			orBase: 10! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextContentMarkupToken	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextContentToken	streamReader peek == $<		ifTrue: [			streamReader next.			^ self nextContentMarkupToken].	elementNester isInElement		ifTrue: [^ self nextPCDataToken].	self nextNonElementWhitespace.! !!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!nextDoctypeDeclaration	| root publicID systemID |	state := state doctypeDeclarationState.	self		expectNextAll: 'DOCTYPE';		nextSeparators.	root := self nextElementName.	(streamReader peek == $[		or: [streamReader peek == $>])		ifFalse: [			self nextSeparators.			streamReader peek == $P				ifTrue: [					publicID := self nextPublicID.					self nextSeparators.					systemID := self nextSystemIDLiteral]				ifFalse: [					streamReader peek == $S						ifTrue: [systemID := self nextSystemID]]].	driver		handleStartDTD: root		publicID: (publicID ifNil: [''])		systemID: (systemID ifNil: ['']).	streamReader skipSeparators.	streamReader peek == $[		ifTrue: [self nextStartInternalSubset]		ifFalse: [self nextEndDoctypeDeclaration].! !!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!nextDoctypeDeclarationTerminator	self expectNext: $>! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextElementName	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!nextEndDoctypeDeclaration	self nextDoctypeDeclarationTerminator.	state := state postDoctypeDeclarationState.	driver handleEndDTD.! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextEndDocument	state isTerminatedState		ifFalse: [			self closeStreams.			state := state terminatedState.			driver handleEndDocument]! !!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!nextEndInternalSubset	"skip ]"	streamReader		next;		skipSeparators.	self nextEndDoctypeDeclaration.! !!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!nextInternalSubsetToken	streamReader skipSeparators.	streamReader peek == $%		ifTrue: [			streamReader next.			^ self nextParameterEntityReference].	streamReader peek == $]		ifTrue: [^ self nextEndInternalSubset].	self nextSubsetMarkupToken.! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextNonElementWhitespace	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextNonPIPrologOrContentMarkupToken	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextPCDataToken	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextPI	"skip ?"	streamReader next.	self nextPIWithTarget: self nextPITarget.! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextPIData	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextPITarget	"should return a PI target string or nil if it's the start of	an '<?xml ...?>' declaration"	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextPITerminator	self expectNext: $>! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextPIWithTarget: aTarget	streamReader peek == $?		ifTrue: [			streamReader next.			self nextPITerminator.			driver				handlePI: aTarget				data: '']		ifFalse: [			self nextSeparators.			driver				handlePI: aTarget				data: self nextPIData].! !!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!nextParameterEntityReference	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextPrologToken	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!nextPublicID	^ self		expectNextAll: 'PUBLIC';		nextSeparators;		nextPublicIDLiteral! !!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!nextPublicIDLiteral	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextSeparators	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextStartContent	state := state contentState.	elementNester := driver elementNester.	driver handleStartContent.! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextStartDocument	self state: driver newInitialState.	driver handleStartDocument.! !!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!nextStartInternalSubset	"skip ["	streamReader next.	state := state internalSubsetState.! !!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!nextSubsetMarkupToken	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!nextSystemID	^ self		expectNextAll: 'SYSTEM';		nextSeparators;		nextSystemIDLiteral! !!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!nextSystemIDLiteral	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextToken	streamReader atEnd		ifTrue: [			state isInitializedState				ifTrue: [^ self nextEndDocument]].	^ state nextTokenFrom: self.! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextXMLAttributeEqualsSeparator	streamReader skipSeparators.	self expectNext: $=.	streamReader skipSeparators.! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextXMLAttributeName: aName	self expectNextAll: aName! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextXMLDeclaration	| version encoding |	self nextSeparators.	version := self nextXMLVersionAttributeRequired: true.	streamReader peek == $?		ifFalse: [self nextSeparators].	(encoding := self nextXMLEncodingAttributeRequired: false) isEmpty		ifFalse: [			self convertFromEncoding: encoding.			streamReader peek == $?				ifFalse: [self nextSeparators]].	driver		handleXMLVersion: version		encoding: encoding		standalone: self nextXMLStandaloneAttribute.	streamReader skipSeparators.	self nextXMLDeclarationTerminator.	state := state prologState.! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextXMLDeclarationOrPrologToken	streamReader peek == $<		ifTrue: [			streamReader next.			streamReader peek == $?				ifTrue: [					streamReader next.					self nextPITarget						ifNil: [^ self nextXMLDeclaration]						ifNotNil: [:target |							state := state prologState.							^ self nextPIWithTarget: target]].			state := state prologState.			^ self nextNonPIPrologOrContentMarkupToken].	"other prolog tokens can have whitespace before them, so the doc	does not need to start with an '<' for them"	state := state prologState.	self nextPrologToken.! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextXMLDeclarationTerminator	self expectNextAll: '?>'! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextXMLEncodingAttributeRequired: aBoolean	(aBoolean		or: [streamReader peek == $e])		ifTrue: [				^ self				nextXMLAttributeName: 'encoding';				nextXMLAttributeEqualsSeparator;				nextXMLEncodingAttributeValue]		ifFalse: [^ '']! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextXMLEncodingAttributeValue	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextXMLStandaloneAttribute	"always optional"	(streamReader peek == $s)		ifTrue: [			^ self				nextXMLAttributeName: 'standalone';				nextXMLAttributeEqualsSeparator;				nextXMLStandaloneAttributeValue]		ifFalse: [^ '']! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextXMLStandaloneAttributeValue	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextXMLVersionAttributeRequired: aBoolean	(aBoolean		or: [streamReader peek == $v])		ifTrue: [			^ self				nextXMLAttributeName: 'version';				nextXMLAttributeEqualsSeparator;				nextXMLVersionAttributeValue]		ifFalse: [^ '']! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextXMLVersionAttributeValue	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'accessing'!normalizedLineEndingChar	^ streamReader normalizedLineEndingChar! !!XMLParserTokenizer methodsFor: 'accessing'!normalizedLineEndingChar: aCharacter	streamReader normalizedLineEndingChar: aCharacter! !!XMLParserTokenizer methodsFor: 'errors'!parseError: aString	driver handleParseError: aString! !!XMLParserTokenizer methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		print: state;		nextPutAll: '; ';		print: streamReader;		nextPut: $).! !!XMLParserTokenizer methodsFor: 'initialization'!setDriver: aDriver stream: aStream readLimit: anInteger	state := XMLUninitializedState new.	driver := aDriver.	streamReader :=		self streamReaderClass			on: aStream			readLimit: anInteger.	"must use #writeStream instead of 'WriteStream on:' to get 0-based	streams on Gemstone"	nameStream := (String new: 16) writeStream.	"this separate stream is needed because XML text delcarations can occur	in the replacement of external general entity references in PCDATA and	external parameter entity references within declarations in the external	subset or external entities, and characterStream would already be in use	in both cases"	xmlDeclarationStream := (String new: 8) writeStream.	characterStream := (String new: 128) writeStream.! !!XMLParserTokenizer methodsFor: 'accessing'!state	^ state! !!XMLParserTokenizer methodsFor: 'accessing'!state: aTokenState	(state := aTokenState) isContentState		ifTrue: [elementNester := driver elementNester].	(driver decodesCharacters		and: [state supportsEncodingDetection])		ifTrue: [streamReader detectEncoding].! !!XMLParserTokenizer methodsFor: 'accessing'!streamReader	^ streamReader! !!XMLParserTokenizer methodsFor: 'defaults'!streamReaderClass	^ XMLNestedStreamReader! !!XMLWellFormedParserTokenizer class methodsFor: 'class initialization'!initialize	"self initialize"	self		initializeNormalizedSpace;		initializePublicIDChars;		initializeEncodingNameStartChars;		initializeEncodingNameChars;		initializeVersionNumChars! !!XMLWellFormedParserTokenizer class methodsFor: 'class initialization'!initializeEncodingNameChars	"EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*"	"assign the fully initialized object with #yourself to avoid	possible race conditions when reinitialization the class"	EncodingNameChars :=		BitmapCharacterSet new			addRangeFrom: $a to: $z;			addRangeFrom: $A to: $Z;			addRangeFrom: $0 to: $9;			addAll: '-_.';			yourself! !!XMLWellFormedParserTokenizer class methodsFor: 'class initialization'!initializeEncodingNameStartChars	"Character>>isLetter is not used because it may return true for non-ASCII	letters depending on the locale.		EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*"	"assign the fully initialized object with #yourself to avoid	possible race conditions when reinitialization the class"	EncodingNameStartChars :=		BitmapCharacterSet new			addRangeFrom: $a to: $z;			addRangeFrom: $A to: $Z;			yourself! !!XMLWellFormedParserTokenizer class methodsFor: 'class initialization'!initializeNormalizedSpace	"stored in a class var for faster access"	NormalizedSpace := Character space! !!XMLWellFormedParserTokenizer class methodsFor: 'class initialization'!initializePublicIDChars	"PubidChar ::= #x20 | #xD | #xA | [a-zA-Z0-9] | [-'()+,./:=?;!!*#@$_%]"	"assign the fully initialized object with #yourself to avoid	possible race conditions when reinitialization the class"	PublicIDChars :=		BitmapCharacterSet new			add: 16r20 asCharacter;			add: 16rD asCharacter;			add: 16rA asCharacter;			addRangeFrom: $a to: $z;			addRangeFrom: $A to: $Z;			addRangeFrom: $0 to: $9;			addAll: '-''()+,./:=?;!!*#@$_%';			yourself! !!XMLWellFormedParserTokenizer class methodsFor: 'class initialization'!initializeVersionNumChars	"VersionNum ::= '1.' [0-9]+"	"assign the fully initialized object with #yourself to avoid	possible race conditions when reinitialization the class"	VersionNumChars :=		BitmapCharacterSet new			addRangeFrom: $0 to: $9;			add: $.;			yourself! !!XMLWellFormedParserTokenizer methodsFor: 'entity replacing'!addPushedBackEntity: aPushedBackEntity	(self hasPushedBackEntity: aPushedBackEntity)		ifTrue: [self errorSelfReferentialEntity: aPushedBackEntity].	self maxEntityReplacementDepth		ifNotNil: [:maxDepth |			self pushedBackEntities size >= maxDepth				ifTrue: [self errorEntityDepthLimitExceeded]].		self pushedBackEntities addLast: aPushedBackEntity.	driver currentEntity: aPushedBackEntity entity.	aPushedBackEntity isExternal		ifTrue: [driver baseURI: aPushedBackEntity uri].	^ aPushedBackEntity.! !!XMLWellFormedParserTokenizer methodsFor: 'decoding'!characterFromCodePoint: aCodePoint	| character |	"nil understands isXMLChar so it does not need to be tested for"	(character := super characterFromCodePoint: aCodePoint) isXMLChar		ifTrue: [^ character]		ifFalse: [^ nil].! !!XMLWellFormedParserTokenizer methodsFor: 'entity replacing'!constructLiteralReplacementForEntity: anEntity	| wasIgnoringLiteralValueTerminator |	wasIgnoringLiteralValueTerminator := isIgnoringLiteralValueTerminator.	isIgnoringLiteralValueTerminator := true.	self		pushBackEntity: anEntity		whenPoppedDo: [			isIgnoringLiteralValueTerminator := wasIgnoringLiteralValueTerminator].! !!XMLWellFormedParserTokenizer methodsFor: 'entity replacing'!constructReplacementForGeneralEntity: anEntity	isInLiteralValue		ifTrue: [			anEntity isExternal				ifTrue: [self errorLiteralReferenceToExternalGeneralEntity: anEntity].			self constructLiteralReplacementForEntity: anEntity]		ifFalse: [			driver handleStartContentEntityReplacement: anEntity name.			self				pushBackEntity: anEntity				whenPoppedDo: [driver handleEndContentEntityReplacement: anEntity name]]! !!XMLWellFormedParserTokenizer methodsFor: 'entity replacing'!constructReplacementForParameterEntity: anEntity	isInLiteralValue		ifTrue: [self constructLiteralReplacementForEntity: anEntity]		ifFalse: [			"the trailing space"			streamReader pushBackCharacter: NormalizedSpace.			self				pushBackEntity: anEntity				whenPoppedDo: nil.			"the leading space"			streamReader pushBackCharacter: NormalizedSpace]! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorDuplicateAttribute: anAttribute	self		formatParseError: 'Duplicate attribute "{1}" in start tag'		with: anAttribute! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorEntityDepthLimitExceeded	XMLLimitException signal: 		'Cannot further nest entity replacements; ',		'use #maxEntityReplacementDepth: to change or disable'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedAttributeEqualsSeparatorFor: anAttributeType butGot: aCharacter	self		formatParseError:			'Expected {1} attribute name-value "=" separator but got "{2}" instead'		with: anAttributeType		with: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedAttributeName	self errorExpected: 'attribute name'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedAttributeValueEnd: aQuote butGot: aCharacter	aCharacter == $<		ifTrue: [self parseError: 'Attribute value contains illegal "<" character']		ifFalse: [			self				errorExpectedQuote: aQuote				ending: 'attribute value'				butGot: aCharacter]! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedAttributeValueStartButGot: aCharacter	self		errorExpectedQuoteStarting: 'attribute value'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedCDataSectionTerminator	self errorExpected: 'end of CDATA section "]]>" terminator'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedCharacterReferenceTerminatorButGot: aCharacter	self		errorExpectedReferenceTerminatorFor: 'character'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedCommentStartButGot: aCharacter	self		formatParseError:			'Expected comment starting "<--" sequence but got "<-{1}" instead'		with: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedCommentTerminator	self errorExpected: 'comment "-->" terminator'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedCommentTerminatorButGot: aCharacter	self		formatParseError:			'Comments cannot contain "--" sequences',			(aCharacter				ifNil: ['']				ifNotNil: [', like "--{1}",']),			' and any "--" must be followed by ">" to terminate the comment'		with: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedDeclarationTerminatorButGot: aCharacter	self		errorExpectedMarkupTerminatorFor: 'declaration'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedDoctypeDeclarationTerminatorButGot: aCharacter	self		errorExpectedMarkupTerminatorFor: 'doctype declaration'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedElementAttributeEqualsSeparatorButGot: aCharacter	self		errorExpectedAttributeEqualsSeparatorFor: 'element'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedElementName	self errorExpected: 'element name'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedEncodingName	self errorExpected: 'encoding name in <?xml ...?> encoding attribute'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedEndTag: anExpectedEndTag butGot: aCharacter at: aCharacterPosition	| receivedEndTag |	"try to get the entire unexpected name"	nameStream reset.	1 to: aCharacterPosition - 1 do: [:i |		nameStream nextPut: (anExpectedEndTag at: i)].	"nil understands isXMLNameChar so it is not tested for"	aCharacter isXMLNameChar		ifTrue: [			nameStream nextPut: aCharacter.			[streamReader peek isXMLNameChar]				whileTrue: [nameStream nextPut: streamReader next]].	(receivedEndTag := nameStream contents) size > 0		ifTrue: [			(elementNester hasOpenElement: receivedEndTag)				ifTrue: [self errorUnterminatedElementsInElement: receivedEndTag]				ifFalse: [self errorTerminatingUnstartedElement: receivedEndTag]]		ifFalse: [self errorExpectedElementName].! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedEntityName	self errorExpected: 'entity name'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedEntityReferenceTerminatorButGot: aCharacter	self		errorExpectedReferenceTerminatorFor: 'entity'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedEntityValueEnd: aQuote butGot: aCharacter	self		errorExpectedQuote: aQuote		ending: 'entity value'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedIncludeSectionTerminatorButGot: aFirstCharacter followedBy: aSecondCharacter	self		formatParseError:			'Expected include section "]]>" terminator ',			'but got "]{1}{2}" instead'		with: aFirstCharacter		with: aSecondCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedIntegerCharacterReference	self errorExpected:		'decimal or hex integer after "&#" character reference start'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedLiteral: aString butGot: aCharacter at: aStringPosition	| receivedString |	receivedString :=		(aString			copyReplaceFrom: aStringPosition			to: aString size			with:				(aCharacter ifNil: ['']) asString,				(streamReader next: aString size - aStringPosition)).	self		errorExpectedLiteral: aString		butGot: receivedString.! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedMarkupTerminatorFor: aDescription butGot: aCharacter	self		formatParseError:			'Expected ">" {1} terminator but got "{2}" instead'		with: aDescription		with: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedNmtoken	self errorExpected: 'an XML Nmtoken name'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedNotationName	self errorExpected: 'notation name'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedPITarget	self errorExpected:		(state isXMLDeclarationState			ifTrue: [				'"xml" to start an <?xml ...?> declaration or a ',				'processing instruction target']			ifFalse: ['processing instruction target'])! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedPITerminatorButGot: aCharacter	self		errorExpectedMarkupTerminatorFor: 'processing instruction'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedPublicIDLiteralEnd: aQuote butGot: aCharacter	self		errorExpectedQuote: aQuote		ending: 'public ID literal'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedPublicIDLiteralStartButGot: aCharacter	self		errorExpectedQuoteStarting: 'public ID literal'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedQuote: aQuote ending: aDescription butGot: aCharacter	self		formatParseError:			'Expected end of {1} ({2}) quoted {3} but got "{4}" instead'		with:			(aQuote == $'				ifTrue: ['single']				ifFalse: ['double'])		with: aQuote		with: aDescription		with: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedQuoteStarting: aDescription butGot: aCharacter	self		formatParseError:			'Expected start of double (") or single ('') ',			'quoted {1} but got "{2}" instead'		with: aDescription		with: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedReferenceTerminatorFor: aDescription butGot: aCharacter	self		formatParseError:			'Expected {1} reference ";" terminator but got "{2}" instead'		with: aDescription		with: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedSeparators	self errorExpected: 'one or more whitespace characters'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedStartMarkupTokenButGot: aCharacter	self		errorExpected: '"<" start of markup'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedSubsetDeclaration	self errorExpected:		'DTD subset ELEMENT, ATTLIST, ENTITY, or NOTATION declaration'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedSystemIDLiteralEnd: aQuote butGot: aCharacter	self		errorExpectedQuote: aQuote		ending: 'system ID literal'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedSystemIDLiteralStartButGot: aCharacter	self		errorExpectedQuoteStarting: 'system ID literal'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedTagTerminatorButGot: aCharacter	self		errorExpectedMarkupTerminatorFor: 'tag'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedXMLAttributeEqualsSeparatorButGot: aCharacter	self		errorExpectedAttributeEqualsSeparatorFor: '<?xml ...?>'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedXMLDeclarationTerminatorButGot: aFirstCharacter followedBy: aSecondCharacter	self		formatParseError:			'Expected "<?xml ...?>" declaration "?>" terminator ',			'but got "{1}{2}" instead'		with: aFirstCharacter		with: aSecondCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedXMLEncodingValueEnd: aQuote butGot: aCharacter	self		errorExpectedQuote: aQuote		ending: '<?xml ...?> encoding value'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedXMLEncodingValueStartButGot: aCharacter	self		errorExpectedQuoteStarting: '<?xml ...?> encoding value'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedXMLStandaloneValueEnd: aQuote butGot: aCharacter	self		errorExpectedQuote: aQuote		ending: '<?xml ...?> standalone value'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedXMLStandaloneValueStartButGot: aCharacter	self		errorExpectedQuoteStarting: '<?xml ...?> standalone value'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedXMLVersionNumberButGot: aString	self		errorExpected:			'<?xml ...?> version number "1.x" (where "x" is one or more digits)'		butGot: aString! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedXMLVersionValueEnd: aQuote butGot: aCharacter	self		errorExpectedQuote: aQuote		ending: '<?xml ...?> version value'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedXMLVersionValueStartButGot: aCharacter	self		errorExpectedQuoteStarting: '<?xml ...?> version value'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorImproperGeneralEntityNesting	self parseError:		'Markup tokens must start and end in the same general entity replacement'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorInputTerminatedPrematurely	self parseError: 'Input terminated prematurely'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorInternalDeclarationParameterEntityReference	self parseError: 'Parameter entity reference within internal subset declaration'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorInternalSubsetConditionalSection	self parseError:		'Cannot have <!![INCLUDE[...]> or <!![IGNORE[...]> sections in internal subset'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorInvalidCharacterReferenceCodePoint: aCodePoint	self		formatParseError: 'Invalid character reference to U+{1} code point'		with: aCodePoint printStringHex! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorLiteralReferenceToExternalGeneralEntity: anEntity	self		formatParseError:			'External general entity reference {1} in attribute value'		with: anEntity asReference! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorMultipleDoctypeDeclarations	self parseError: 'Multiple <!!DOCTYPE ...> declarations'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorMultipleDocumentRootElements	self parseError: 'Document cannot have multiple root elements'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorNonChar: aCharacter in: aDescription	self		formatParseError: 'Invalid character U+{1} in {2}'		with: aCharacter asciiValue printStringHex		with: aDescription! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorNonCharInAttributeValue: aCharacter	self		errorNonChar: aCharacter		in: 'attribute value'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorNonCharInCDataSection: aCharacter	self		errorNonChar: aCharacter		in: '<!![CDATA[...]]> section'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorNonCharInComment: aCharacter	self		errorNonChar: aCharacter		in: 'comment'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorNonCharInEntityValue: aCharacter	self		errorNonChar: aCharacter		in: 'entity value'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorNonCharInPCData: aCharacter	self		errorNonChar: aCharacter		in: 'PCDATA'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorNonCharInPIValue: aCharacter	self		errorNonChar: aCharacter		in: 'processing instruction value'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorNonCharInSystemID: aCharacter	self		errorNonChar: aCharacter		in: 'system ID'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorNonElementGeneralEntityOrCharacterReference	self parseError:		'Unexpected "&" starting general entity or character reference after content'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorNonElementPCDataCharacter: aCharacter	aCharacter == $&		ifTrue: [self errorNonElementGeneralEntityOrCharacterReference]		ifFalse: [			self				formatParseError: 'Character data "{1}" outside of element'				with: aCharacter]! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorParameterEntityTerminatingSubset	self parseError:		'Parameter entity replacement cannot terminate internal subset'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorReferenceToUnparsedGeneralEntity: anEntity	self		formatParseError: 'Illegal unparsed general entity reference {1}'		with: anEntity asReference! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorReservedPITarget: aTarget	self		formatParseError: 'Processing instruction target "{1}" is reserved'		with: aTarget! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorSelfReferentialEntity: anEntity	self		formatParseError: 'Illegal self-referential {1} entity'		with: anEntity asReference! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorTerminatingUnstartedElement: anElement	self		formatParseError: 'End tag </{1}> with no corresponding <{1}> start tag'		with: anElement! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorURIFragmentInSystemID	self parseError: 'Illegal "#" URI fragment in system ID'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorUnexpectedCDataTerminator	self parseError: 'Unexpected CDATA "]]>" terminator in PCDATA'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorUnexpectedEndConditionalSection	self parseError: 'Unexpected "]" end of conditional section in external entity'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorUnexpectedEndTag: anElement	self		formatParseError: 'Unexpected end tag </{1}> before any start tag'		with: anElement! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorUnexpectedMarkupDeclarationInContent	self parseError: 'Unexpected "<!!" markup declaration in content'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorUnterminatedElements	self		formatParseError: 'Unterminated elements: {1}'		with: elementNester printedElements! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorUnterminatedElementsInElement: anElement	self		formatParseError: '<{1}> element ended before enclosed element(s) {2}'		with: anElement		with: (elementNester printedElementsEnclosedBy: anElement)! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorUnterminatedIgnoreSections	self parseError: 'Unterminated <!![IGNORE[...]]> section(s) in external entity'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorUnterminatedIncludeSections	self parseError: 'Unterminated <!![INCLUDE[...]]> section(s) in external entity'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorXMLDeclarationNotAtStart	self parseError: 'XML declaration can only occur at the start of a document'! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - expecting'!expectNext: aCharacter	| nextChar |	"use #= for pre-SpurVM compatibility where wide chars aren't #=="	(nextChar := streamReader next) = aCharacter		ifFalse: [			self				errorExpectedLiteral: aCharacter				butGot: nextChar].	^ nextChar.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - expecting'!expectNextAll: aString	"uses to:do: and not implemented in terms of #expectNextAll:startingAt:	for speed"	1 to: aString size do: [:i | | nextChar |		"use #= for pre-SpurVM compatibility where wide chars aren't #=="		(nextChar := streamReader next) = (aString at: i)			ifFalse: [				self					errorExpectedLiteral: aString					butGot: nextChar					at: i]].	^ aString.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - expecting'!expectNextAll: aString startingAt: aPosition	"to:do: for speed"	aPosition to: aString size do: [:i | | nextChar |		"use #= for pre-SpurVM compatibility where wide chars aren't #=="		(nextChar := streamReader next) = (aString at: i)			ifFalse: [				self					errorExpectedLiteral: aString					butGot: nextChar					at: i]].	^ aString.! !!XMLWellFormedParserTokenizer methodsFor: 'testing'!hasOpenIncludeSections	totalOpenIncludeSections == nil		ifTrue: [^ false].	^ totalOpenIncludeSections > 0.! !!XMLWellFormedParserTokenizer methodsFor: 'testing'!hasPushedBackEntities	pushedBackEntities == nil		ifTrue: [^ false].	^ pushedBackEntities size > 0.! !!XMLWellFormedParserTokenizer methodsFor: 'testing'!hasPushedBackEntity: aPushedBackEntity	self hasPushedBackEntities		ifFalse: [^ false].	self pushedBackEntities do: [:each |		each entity = aPushedBackEntity entity			ifTrue: [^ true]].	^ false.! !!XMLWellFormedParserTokenizer methodsFor: 'testing'!isInExternalSubsetOrExternalEntity	"This is used to check for conditional sections and parameter entity	refs within declarations in the internal subset, which is disallowed.		The way the spec is written and the way Xerces behaves, internal	entities defined in external entities DO NOT count as 'external'	for this purpose, even though they were defined externally to	the document."	^ state isExternalSubsetState		or: [self topPushedBackExternalEntity notNil]! !!XMLWellFormedParserTokenizer methodsFor: 'accessing'!maxEntityReplacementDepth	^ driver maxEntityReplacementDepth! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextAttlistDeclaration	| element defaultPragma |	self		expectNextAll: 'ATTLIST';		nextSeparatorsInDeclaration.	element := self nextElementName.	[streamReader peek == $>		or: [			self nextSeparatorsInDeclaration.			streamReader peek == $>]]		whileFalse: [			driver				handleAttributeDeclaration: element				name: self nextAttributeName				type: self nextAttributeType				defaultPragma:					(defaultPragma := self nextAttributeDefaultPragma)				defaultValue:					(self nextAttributeDefaultValueForPragma: defaultPragma)].	self nextDeclarationTerminator.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextAttributeDefaultPragma	self nextSeparatorsInDeclaration.	streamReader peek == $#		ifFalse: [^ ''].	streamReader next.	streamReader peek == $R		ifTrue: [^ self expectNextAll: 'REQUIRED'].	streamReader peek == $I		ifTrue: [^ self expectNextAll: 'IMPLIED'].	^ self expectNextAll: 'FIXED'.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextAttributeDefaultValueForPragma: aPragma	| previousState attributeValue |	aPragma isEmpty		ifFalse: [			(aPragma first == $F) "FIXED"				ifFalse: [^ ''].			self nextSeparatorsInDeclaration].	previousState := state.	state := state contentState.	attributeValue := self nextAttributeValue.	state := previousState.	^ attributeValue.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextAttributeEntityType	self expectNextAll: 'ENTIT'.	streamReader peek == $Y		ifFalse: [			^ self				expectNextAll: 'ENTITIES'				startingAt: 6 "'ENTIT' size + 1"].	streamReader next.	^ 'ENTITY'.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextAttributeEnumerationType	characterStream		reset;		nextPut: (self expectNext: $().	"must have at least one value in the enumeration"	self		skipSeparatorsInDeclaration;		nextNmtokenOnCharacterStream.	[self skipSeparatorsInDeclaration.		streamReader peek == $)]		whileFalse: [			characterStream nextPut: (self expectNext: $|).			self				skipSeparatorsInDeclaration;				nextNmtokenOnCharacterStream].	^ characterStream		nextPut: streamReader next;		contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextAttributeIDOrIDRefType	self expectNextAll: 'ID'.	streamReader peek == $R		ifFalse: [^ 'ID'].		self		expectNextAll: 'IDREF'		startingAt: 3.	streamReader peek == $S		ifFalse: [^ 'IDREF'].	streamReader next.	^ 'IDREFS'.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextAttributeName	| nextChar |	"nil understands #isXMLNameStartChar so it does not need to be tested for"	(nextChar := streamReader next) isXMLNameStartChar		ifFalse: [self errorExpectedAttributeName].	nameStream		reset;		nextPut: nextChar.	"nil understands #isXMLNameChar so it does not need to be tested for"	[streamReader peek isXMLNameChar]		whileTrue: [nameStream nextPut: streamReader next].	^ nameStream contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextAttributeNotationEnumerationOrNmtokenType	"skip the N"	streamReader next.	streamReader peek == $O		ifTrue: [^ self nextAttributeNotationEnumerationType].	self		expectNextAll: 'NMTOKEN'		startingAt: 2.	streamReader peek == $S		ifFalse: [^ 'NMTOKEN'].	streamReader next.	^ 'NMTOKENS'.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextAttributeNotationEnumerationType	characterStream		reset;		nextPutAll:			(self				expectNextAll: 'NOTATION'				startingAt: 2). "the 'N' was already read"	self		nextSeparatorsInDeclaration;		expectNext: $(.	characterStream nextPutAll: ' ('.	"must have at least one declaration name in the enumeration"	self		skipSeparatorsInDeclaration;		nextNotationNameOnCharacterStream.	[self skipSeparatorsInDeclaration.		streamReader peek == $)]		whileFalse: [			characterStream nextPut: (self expectNext: $|).			self				skipSeparatorsInDeclaration;				nextNotationNameOnCharacterStream].		^ characterStream		nextPut: streamReader next;		contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextAttributeType	| nextChar |	self nextSeparatorsInDeclaration.	(nextChar := streamReader peek) == $C		ifTrue: [^ self expectNextAll: 'CDATA'].	nextChar == $I		ifTrue: [^ self nextAttributeIDOrIDRefType].	nextChar == $E		ifTrue: [^ self nextAttributeEntityType].	nextChar == $N		ifTrue: [^ self nextAttributeNotationEnumerationOrNmtokenType].	^ self nextAttributeEnumerationType.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextAttributeValue	| quote nextChar |	((quote := streamReader next) == $"		or: [quote == $'])		ifFalse: [self errorExpectedAttributeValueStartButGot: quote].		isInLiteralValue := true.	characterStream reset.	[((nextChar := streamReader next) == quote		and: [isIgnoringLiteralValueTerminator not])			or: [nextChar == $<				or: [nextChar == nil]]]		whileFalse: [			nextChar == $&				ifTrue: [					"char refs should be ignored by whitespace normalization"					self nextGeneralEntityOrCharacterReferenceOnCharacterStream]				ifFalse: [					nextChar isXMLSeparator						ifTrue: [nextChar := NormalizedSpace]						ifFalse: [							nextChar isXMLChar								ifFalse: [self errorNonCharInAttributeValue: nextChar]].					characterStream nextPut: nextChar]].	isInLiteralValue := false.	nextChar == quote		ifFalse: [			self				errorExpectedAttributeValueEnd: quote				butGot: nextChar].	^ characterStream contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextCDataSection	| closingBracketsRead nextChar |	self expectNextAll: '[CDATA['.	characterStream reset.	closingBracketsRead := 0.	[(nextChar := streamReader next) == nil		or: [closingBracketsRead == 2			and: [nextChar == $>]]]		whileFalse: [			nextChar == $]				ifTrue: [					closingBracketsRead == 2						ifTrue: [characterStream nextPut: $]]						ifFalse: [closingBracketsRead := closingBracketsRead + 1]]				ifFalse: [					closingBracketsRead == 0						ifFalse: [							characterStream nextPut: $].							closingBracketsRead == 2								ifTrue: [characterStream nextPut: $]].							closingBracketsRead := 0].					nextChar isXMLChar						ifFalse: [self errorNonCharInCDataSection: nextChar].					characterStream nextPut: nextChar]].	nextChar		ifNil: [self errorExpectedCDataSectionTerminator].	driver handleCData: characterStream contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextCharacterReferenceOnCharacterStream	"returns the character written to 'characterStream' or $& if	it wasn't replaced"	| codePoint |	"skip #"	streamReader next.	(state isContentState		and: [driver replacesContentEntityReferences not])		ifTrue: [			nameStream reset.			(codePoint := self nextCharacterValueLiteralPrintedOn: nameStream)				ifNil: [self errorExpectedIntegerCharacterReference].			(self characterFromCodePoint: codePoint)				ifNil: [self errorInvalidCharacterReferenceCodePoint: codePoint].			self nextCharacterReferenceTerminator.			characterStream				nextPutAll: '&#';				nextPutAll: nameStream contents;				nextPut: $;.			^ $&]		ifFalse: [| character |			(codePoint := self nextCharacterValueLiteral)				ifNil: [self errorExpectedIntegerCharacterReference].			(character := self characterFromCodePoint: codePoint)				ifNil: [self errorInvalidCharacterReferenceCodePoint: codePoint].			self nextCharacterReferenceTerminator.			characterStream nextPut: character.			^ character].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextCharacterReferenceTerminator	| nextChar |	(nextChar := streamReader next) == $;		ifFalse: [self errorExpectedCharacterReferenceTerminatorButGot: nextChar]! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextComment	| nextChar |	"Skip first -"	streamReader next.	(nextChar := streamReader next) == $-		ifFalse: [self errorExpectedCommentStartButGot: nextChar].	"xml comments can't have '--' in them; any '--' must be followed	by the terminating '>'"	characterStream reset.	[(nextChar := streamReader next) == nil		or: [nextChar == $-			and: [streamReader peek == $-]]]		whileFalse: [			nextChar isXMLChar				ifFalse: [self errorNonCharInComment: nextChar].			characterStream nextPut: nextChar].	nextChar		ifNil: [self errorExpectedCommentTerminator]		ifNotNil: [			streamReader next. "skip second $-"			(nextChar := streamReader next) == $>				ifFalse: [self errorExpectedCommentTerminatorButGot: nextChar]].	driver handleComment: characterStream contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextConditionalSectionFromEntity: aPushedBackParameterEntity	"skip ["	streamReader next.	self		skipSeparatorsInDeclaration;		expectNext: $I.	streamReader peek == $N		ifTrue: [self nextStartIncludeSectionFromEntity: aPushedBackParameterEntity]		ifFalse: [self nextIgnoreSectionFromEntity: aPushedBackParameterEntity].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextContentMarkupToken	self topPushedBackEntity		ifNil: [			streamReader peek == $?				ifTrue: [^ self nextPI].			streamReader peek == $!!				ifTrue: [					streamReader next.					streamReader peek == $-						ifTrue: [^ self nextComment].					elementNester isInElement						ifTrue: [^ self nextCDataSection].					self errorUnexpectedMarkupDeclarationInContent].			self nextTag]		ifNotNil: [:pushedBackGeneralEntity |			self nextContentMarkupTokenFromEntity: pushedBackGeneralEntity]! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextContentMarkupTokenFromEntity: aPushedBackGeneralEntity	streamReader peek == $?		ifTrue: [self nextPI]		ifFalse: [			streamReader peek == $!!				ifTrue: [					streamReader next.					streamReader peek == $-						ifTrue: [self nextComment]						ifFalse: [							elementNester isInElement								ifTrue: [self nextCDataSection]								ifFalse: [									self errorUnexpectedMarkupDeclarationInContent]]]				ifFalse: [| oldTotalOpenElements newTotalOpenElements |					oldTotalOpenElements := elementNester totalOpenElements.					self nextTag.					newTotalOpenElements := elementNester totalOpenElements.					newTotalOpenElements < oldTotalOpenElements						ifTrue: [							aPushedBackGeneralEntity endElement.							aPushedBackGeneralEntity totalOpenElements >= 0								ifFalse: [self errorImproperGeneralEntityNesting]]						ifFalse: [							newTotalOpenElements > oldTotalOpenElements								ifTrue: [aPushedBackGeneralEntity startElement]]]].	self topPushedBackEntity == aPushedBackGeneralEntity		ifFalse: [self errorImproperGeneralEntityNesting].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextContentModel	| pushedBackParameterEntity |	self nextSeparatorsInDeclaration.	streamReader peek == $A		ifTrue: [^ self expectNextAll: 'ANY'].	streamReader peek == $E		ifTrue: [^ self expectNextAll: 'EMPTY'].		characterStream		reset;		nextPut: (self expectNext: $().	pushedBackParameterEntity := self topPushedBackEntity.	self skipSeparatorsInDeclaration.	streamReader peek == $#		ifTrue: [			self nextMixedContentListOnCharacterStreamFromEntity:				pushedBackParameterEntity]		ifFalse: [			self nextContentModelChoiceOrSequenceOnCharacterStreamFromEntity:				pushedBackParameterEntity].	^ characterStream contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextContentModelChoiceOrSequenceOnCharacterStreamFromEntity: aPushedBackParameterEntity	self		nextContentModelParticleOnCharacterStream;		skipSeparatorsInDeclaration.	streamReader peek == $|		ifTrue: [			characterStream nextPut: streamReader next.			self nextContentModelParticleOnCharacterStream.			[self skipSeparatorsInDeclaration.				streamReader peek == $)]				whileFalse: [					characterStream nextPut: (self expectNext: $|).					self nextContentModelParticleOnCharacterStream].			characterStream nextPut: streamReader next]		ifFalse: [			streamReader peek == $,				ifTrue: [					characterStream nextPut: streamReader next.					self nextContentModelParticleOnCharacterStream.					[self skipSeparatorsInDeclaration.						streamReader peek == $)]						whileFalse: [							characterStream nextPut: (self expectNext: $,).							self nextContentModelParticleOnCharacterStream].					characterStream nextPut: streamReader next]				ifFalse: [characterStream nextPut: (self expectNext: $))]].	self topPushedBackEntity == aPushedBackParameterEntity		ifFalse: [driver handleImproperParameterEntityNesting].	self nextContentModelUnaryOperatorOnCharacterStream.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextContentModelParticleOnCharacterStream	self skipSeparatorsInDeclaration.	streamReader peek == $(		ifTrue: [			characterStream nextPut: streamReader next.			self nextContentModelChoiceOrSequenceOnCharacterStreamFromEntity:				self topPushedBackEntity]		ifFalse: [			self				nextElementNameOnCharacterStream;				nextContentModelUnaryOperatorOnCharacterStream]! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextContentModelUnaryOperatorOnCharacterStream	| nextChar |	((nextChar := streamReader peek) == $?		or: [nextChar == $*			or: [nextChar == $+]])		ifTrue: [characterStream nextPut: streamReader next]! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextDeclarationTerminator	| nextChar |	(nextChar := streamReader next) == $>		ifFalse: [self errorExpectedDeclarationTerminatorButGot: nextChar]! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextDoctypeDeclarationOrComment	"skip !!"	streamReader next.	streamReader peek == $-		ifTrue: [^ self nextComment].	state isPostDoctypeDeclarationState		ifTrue: [self errorMultipleDoctypeDeclarations].	self nextDoctypeDeclaration.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextDoctypeDeclarationTerminator	| nextChar |	(nextChar := streamReader next) == $>		ifFalse: [self errorExpectedDoctypeDeclarationTerminatorButGot: nextChar]! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextElementDeclaration	self		expectNextAll: 'ELEMENT'		startingAt: 2. "the 'E' was already read"	self nextSeparatorsInDeclaration.	driver		handleElementDeclaration: self nextElementName		contentModel: self nextContentModel.	self		skipSeparatorsInDeclaration;		nextDeclarationTerminator.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextElementName	| nextChar |	"nil understands #isXMLNameStartChar so it does not need to be tested for"	(nextChar := streamReader next) isXMLNameStartChar		ifFalse: [self errorExpectedElementName].	nameStream		reset;		nextPut: nextChar.	"nil understands #isXMLNameChar so it does not need to be tested for"	[streamReader peek isXMLNameChar]		whileTrue: [nameStream nextPut: streamReader next].	^ nameStream contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextElementNameOnCharacterStream	| nextChar |	"nil understands #isXMLNameStartChar so it does not need to be tested for"	(nextChar := streamReader next) isXMLNameStartChar		ifFalse: [self errorExpectedElementName].	characterStream nextPut: nextChar.	"nil understands #isXMLNameChar so it does not need to be tested for"	[streamReader peek isXMLNameChar]		whileTrue: [characterStream nextPut: streamReader next].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextEndDocument	state canTerminateInput		ifFalse: [self errorInputTerminatedPrematurely].	state isContentState		ifTrue: [			elementNester hasOpenElements				ifTrue: [self errorUnterminatedElements]]		ifFalse: [			self hasOpenIncludeSections				ifTrue: [self errorUnterminatedIncludeSections]].	super nextEndDocument.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextEndIncludeSection	| secondChar thirdChar |	"skip ]"	streamReader next.	secondChar := streamReader next.	thirdChar := streamReader next. 	(secondChar == $]		and: [thirdChar == $>])		ifFalse: [			self				errorExpectedIncludeSectionTerminatorButGot: secondChar				followedBy: thirdChar].	totalOpenIncludeSections := self totalOpenIncludeSections - 1.	self topPushedBackEntity		ifNotNil: [:pushedBackParameterEntity |			pushedBackParameterEntity endIncludeSection.			pushedBackParameterEntity totalOpenIncludeSections >= 0				ifFalse: [driver handleImproperParameterEntityNesting]].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextEndInternalSubset	self hasOpenIncludeSections		ifTrue: [^ self nextEndIncludeSection].	"skip ]"	streamReader next.	self hasPushedBackEntities		ifTrue: [self errorParameterEntityTerminatingSubset].	streamReader skipSeparators.	self nextEndDoctypeDeclaration.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextEndTag	| tagName nextChar |	"Skip /"	streamReader next.	(tagName := elementNester currentElement)		ifNil: [self errorUnexpectedEndTag: self nextElementName].	1 to: tagName size do: [:i |		"can't use #== here because wide chars aren't an immediate type		in pre-Spur VMs"		(nextChar := streamReader next) = (tagName at: i)			ifFalse: [				self					errorExpectedEndTag: tagName					butGot: nextChar					at: i]].	elementNester endCurrentElement.	driver handleEndTag: tagName.	streamReader skipSeparators.	(nextChar := streamReader next) == $>		ifFalse: [self errorExpectedTagTerminatorButGot: nextChar].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextEntityDeclaration	| isParameterEntity name |	self		expectNextAll: 'ENTITY'		startingAt: 2. "the 'E' was already read"	self isInExternalSubsetOrExternalEntity		ifTrue: [			"this is to distinguish a parameter reference from declaration"			[isParameterEntity isNil]				whileTrue: [					streamReader skipSeparators.					streamReader peek == $%						ifTrue: [							streamReader next.							"nil understands isXMLSeparator so no nil test is needed"							streamReader peek isXMLSeparator								ifTrue: [									isParameterEntity := true.									self nextSeparatorsInDeclaration]								ifFalse: [self nextParameterEntityReference]]						ifFalse: [isParameterEntity := false]]]		ifFalse: [			self nextSeparators.			(isParameterEntity := (streamReader peek == $%))				ifTrue: [					streamReader next.					self nextSeparators]].	name := self nextEntityName.	self nextSeparatorsInDeclaration.	streamReader atQuote		ifTrue: [			self				nextInternalEntityDeclaration: name				isParameterEntity: isParameterEntity]		ifFalse: [			self				nextExternalEntityDeclaration: name				isParameterEntity: isParameterEntity].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextEntityName	| nextChar |	"nil understands #isXMLNameStartChar so it does not need to be tested for"	(nextChar := streamReader next) isXMLNameStartChar		ifFalse: [self errorExpectedEntityName].	nameStream		reset;		nextPut: nextChar.	"nil understands #isXMLNameChar so it does not need to be tested for"	[streamReader peek isXMLNameChar]		whileTrue: [nameStream nextPut: streamReader next].	^ nameStream contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextEntityNameOnCharacterStream	| nextChar |	"nil understands #isXMLNameStartChar so it does not need to be tested for"	(nextChar := streamReader next) isXMLNameStartChar		ifFalse: [self errorExpectedEntityName].	characterStream nextPut: nextChar.	"nil understands #isXMLNameChar so it does not need to be tested for"	[streamReader peek isXMLNameChar]		whileTrue: [characterStream nextPut: streamReader next].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextEntityReferenceTerminator	| nextChar |	(nextChar := streamReader next) == $;		ifFalse: [self errorExpectedEntityReferenceTerminatorButGot: nextChar]! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextEntityValue	| quote nextChar |	quote := streamReader next.	isInLiteralValue := true.	characterStream reset.	[((nextChar := streamReader next) == quote		and: [isIgnoringLiteralValueTerminator not])			or: [nextChar == nil]]		whileFalse: [			nextChar == $&				ifTrue: [					streamReader peek == $#						ifTrue: [							"character refs are replaced in entity values"							self nextCharacterReferenceOnCharacterStream]						ifFalse: [							"general entity refs aren't replaced but must be complete"							characterStream nextPut: $&.							self								nextEntityNameOnCharacterStream;								nextEntityReferenceTerminator.							characterStream nextPut: $;]]				ifFalse: [					nextChar == $%						ifTrue: [							self isInExternalSubsetOrExternalEntity								ifFalse: [									self										errorInternalDeclarationParameterEntityReference].							self nextParameterEntityReferenceOnCharacterStream]						ifFalse: [							nextChar isXMLChar								ifFalse: [self errorNonCharInEntityValue: nextChar].							characterStream nextPut: nextChar]]].	isInLiteralValue := false.	nextChar == quote		ifFalse: [			self				errorExpectedEntityValueEnd: quote				butGot: nextChar].	^ characterStream contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextExternalEntityDeclaration: aName isParameterEntity: aBoolean	| publicID systemID notation |	streamReader peek == $P		ifTrue: [			publicID := self nextPublicIDInDeclaration.			self nextSeparatorsInDeclaration.			systemID := self nextSystemIDLiteralWithoutURIFragment]		ifFalse: [			publicID := ''.			systemID := self nextSystemIDInDeclarationWithoutURIFragment].	aBoolean		ifTrue: [			self				skipSeparatorsInDeclaration;				nextDeclarationTerminator.			driver				handleParameterEntityDeclaration: aName				publicID: publicID				systemID: systemID]		ifFalse: [			(streamReader peek == $>				or: [					self nextSeparatorsInDeclaration.					streamReader peek == $>])				ifTrue: [						streamReader next.					notation := '']				ifFalse: [					self						expectNextAll: 'NDATA';						nextSeparatorsInDeclaration.					notation := self nextNotationName.					self						skipSeparatorsInDeclaration;						nextDeclarationTerminator].			driver				handleGeneralEntityDeclaration: aName				publicID: publicID				systemID: systemID				ndata: notation].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextExternalSubsetToken	streamReader skipSeparators.	streamReader atEnd		ifTrue: [^ self].	streamReader peek == $%		ifTrue: [			streamReader next.			^ self nextParameterEntityReference].	streamReader peek == $]		ifTrue: [			self hasOpenIncludeSections				ifFalse: [self errorUnexpectedEndConditionalSection].			^ self nextEndIncludeSection].	self nextSubsetMarkupToken.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextGeneralEntityOrCharacterReferenceOnCharacterStream	"returns the character written to 'characterStream' if any, nil otherwise"	| pushedBackGeneralEntity result |	pushedBackGeneralEntity := self topPushedBackEntity.	result :=		streamReader peek == $#			ifTrue: [self nextCharacterReferenceOnCharacterStream]			ifFalse: [self nextGeneralEntityReferenceOnCharacterStream].	pushedBackGeneralEntity		ifNotNil: [			(self pushedBackEntities includes: pushedBackGeneralEntity)				ifFalse: [self errorImproperGeneralEntityNesting]].	^ result.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextGeneralEntityReferenceOnCharacterStream	"returns the (first) character written to 'characterStream' if any,	nil otherwise"	| name |	name := self nextEntityName.	self nextEntityReferenceTerminator.	PredefinedEntities		at: name		ifPresent: [:character |			driver replacesContentEntityReferences				ifFalse: [					^ self nextUnreplacedGeneralEntityOnCharacterStreamNamed: name].			characterStream nextPut: character.			^ character].	(driver handleGeneralEntityReference: name)		ifNil: [			(driver replacesContentEntityReferences not				or: [driver preservesUndeclaredEntityReferences])				ifTrue: [					^ self nextUnreplacedGeneralEntityOnCharacterStreamNamed: name].			driver handleUnreplacedGeneralEntityReference: name]		ifNotNil: [:entity |			entity isUnparsed				ifTrue: [self errorReferenceToUnparsedGeneralEntity: entity].			driver replacesContentEntityReferences				ifFalse: [					^ self nextUnreplacedGeneralEntityOnCharacterStreamNamed: name].			self constructReplacementForGeneralEntity: entity].	^ nil.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextIgnoreSectionFromEntity: aPushedBackParameterEntity	| openSections firstChar secondChar nextChar |	self		expectNextAll: 'IGNORE'		startingAt: 2. "the 'I' was already read"	streamReader skipSeparators.	self expectNext: $[.	"the 'IGNORE' can be in the replacement of an entity, like	in '<!![%entity[...]]>', but after it the entity that started	the declaration must be current"	self topPushedBackEntity == aPushedBackParameterEntity		ifFalse: [driver handleImproperParameterEntityNesting].	"From the spec:	The contents of an ignored conditional section MUST be parsed by	ignoring all characters after the '[' following the keyword, except	conditional section starts '<!![' and ends ']]>', until the matching	conditional section end is found. Parameter entity references MUST	NOT be recognized in this process."	openSections := 1.	[openSections == 0		or: [(nextChar := streamReader next) == nil]]		whileFalse: [			nextChar == $>				ifTrue: [					(secondChar == $]						and: [firstChar == $]])						ifTrue: [openSections := openSections - 1]]				ifFalse: [					nextChar == $[						ifTrue: [							(secondChar == $!!								and: [firstChar == $<])								ifTrue: [openSections := openSections + 1]]].			firstChar := secondChar.			secondChar := nextChar].	openSections == 0		ifFalse: [self errorUnterminatedIgnoreSections].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextInternalEntityDeclaration: aName isParameterEntity: aBoolean	| value |	value := self nextEntityValue.	self		skipSeparatorsInDeclaration;		nextDeclarationTerminator.	aBoolean		ifTrue: [			driver				handleParameterEntityDeclaration: aName				replacement: value]		ifFalse: [			driver				handleGeneralEntityDeclaration: aName				replacement: value].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextMixedContentListOnCharacterStreamFromEntity: aPushedBackParameterEntity	| hasElements |	hasElements := false.	characterStream nextPutAll: (self expectNextAll: '#PCDATA').	[self skipSeparatorsInDeclaration.		streamReader peek == $)]		whileFalse: [			characterStream nextPut: (self expectNext: $|).			hasElements := true.			self				skipSeparatorsInDeclaration;				nextElementNameOnCharacterStream].	characterStream nextPut: streamReader next.	self topPushedBackEntity == aPushedBackParameterEntity		ifFalse: [driver handleImproperParameterEntityNesting].	streamReader peek == $*		ifTrue: [characterStream nextPut: streamReader next]		ifFalse: [			hasElements				ifTrue: [self errorExpectedLiteral: $*]].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextNmtokenOnCharacterStream	"matches the Nmtoken production"	| nextChar |	"nil understands #isXMLNameChar so it does not need to be tested for"	(nextChar := streamReader next) isXMLNameChar		ifFalse: [self errorExpectedNmtoken].	characterStream nextPut: nextChar.	"nil understands #isXMLNameChar so it does not need to be tested for"	[streamReader peek isXMLNameChar]		whileTrue: [characterStream nextPut: streamReader next].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextNonElementWhitespace	| nextChar |	"nil understands isXMLSeparator so it is not tested for first"	[(nextChar := streamReader peek) isXMLSeparator]		whileTrue: [streamReader next].	(nextChar == $<		or: [nextChar == nil])		ifFalse: [self errorNonElementPCDataCharacter: streamReader next].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextNonPIPrologOrContentMarkupToken	streamReader peek == $!!		ifTrue: [^ self nextDoctypeDeclarationOrComment].	self		nextStartContent;		nextTag.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextNotationDeclaration	| name publicID systemID |	self		expectNextAll: 'NOTATION';		nextSeparatorsInDeclaration.	name := self nextNotationName.	self nextSeparatorsInDeclaration.	streamReader peek == $P		ifTrue: [			publicID := self nextPublicIDInDeclaration.			(streamReader peek == $>				or: [					self nextSeparatorsInDeclaration.					streamReader peek == $>])				ifFalse: [systemID := self nextSystemIDLiteral]]		ifFalse: [systemID := self nextSystemIDInDeclaration].	self		skipSeparatorsInDeclaration;		nextDeclarationTerminator.	driver		handleNotationDeclaration: name		publicID: (publicID ifNil: [''])		systemID: (systemID ifNil: ['']).! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextNotationName	| nextChar |	"nil understands #isXMLNameStartChar so it does not need to be tested for"	(nextChar := streamReader next) isXMLNameStartChar		ifFalse: [self errorExpectedNotationName].	nameStream		reset;		nextPut: nextChar.	"nil understands #isXMLNameChar so it does not need to be tested for"	[streamReader peek isXMLNameChar]		whileTrue: [nameStream nextPut: streamReader next].	^ nameStream contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextNotationNameOnCharacterStream	| nextChar |	"nil understands #isXMLNameStartChar so it does not need to be tested for"	(nextChar := streamReader next) isXMLNameStartChar		ifFalse: [self errorExpectedNotationName].	characterStream nextPut: nextChar.	"nil understands #isXMLNameChar so it does not need to be tested for"	[streamReader peek isXMLNameChar]		whileTrue: [characterStream nextPut: streamReader next].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextPCDataToken	| isWhitespace nextChar closingBracketsRead |	isWhitespace := true.	characterStream reset.	closingBracketsRead := 0.	[(nextChar := streamReader peek) == $<		or: [nextChar == nil]]		whileFalse: [			streamReader next == $&				ifTrue: [					self nextGeneralEntityOrCharacterReferenceOnCharacterStream						ifNotNil: [:writtenChar |							isWhitespace								ifTrue: [isWhitespace := writtenChar isXMLSeparator]]]				ifFalse: [					(isWhitespace						and: [isWhitespace := nextChar isXMLSeparator])						ifFalse: [							nextChar == $]								ifTrue: [									isWhitespace := false.									closingBracketsRead := closingBracketsRead + 1]								ifFalse: [									closingBracketsRead == 0										ifFalse: [											(closingBracketsRead >= 2												and: [nextChar == $>])												ifTrue: [													self errorUnexpectedCDataTerminator].											closingBracketsRead := 0].									nextChar isXMLChar										ifFalse: [self errorNonCharInPCData: nextChar]]].					characterStream nextPut: nextChar]].	isWhitespace		ifTrue: [			characterStream position == 0				ifFalse: [driver handleWhitespace: characterStream contents]]		ifFalse: [driver handlePCData: characterStream contents].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextPIData	| nextChar |	characterStream reset.	[(nextChar := streamReader next) == nil		or: [nextChar == $?			and: [streamReader peek == $>]]]		whileFalse: [			nextChar isXMLChar				ifFalse: [self errorNonCharInPIValue: nextChar].			characterStream nextPut: nextChar].	self nextPITerminator.	^ characterStream contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextPITarget	"PITarget	   ::=   	Name - (('X' | 'x') ('M' | 'm') ('L' | 'l'))"	| nextChar isReservedTarget isLowercaseReservedTarget length |	nameStream reset.	(nextChar := streamReader next) == $x		ifTrue: [			isReservedTarget := true.			isLowercaseReservedTarget := true]		ifFalse:[			nextChar == $X				ifTrue: [isReservedTarget := true]				ifFalse: [					"nil understands #isXMLNameStartChar so it does					not need to be tested for"					nextChar isXMLNameStartChar						ifFalse: [self errorExpectedPITarget].					isReservedTarget := false].			isLowercaseReservedTarget := false].	nameStream nextPut: nextChar.	length := 1.	"nil understands #isXMLNameChar so it does not need to be tested for"	[streamReader peek isXMLNameChar]		whileTrue: [			nextChar := streamReader next.			length := length + 1.			isReservedTarget				ifTrue: [					(length <= 3						and: [							nextChar == ('xml' at: length)								or: [									isLowercaseReservedTarget := false.									nextChar == ('XML' at: length)]])						ifFalse: [							isReservedTarget := false.							isLowercaseReservedTarget := false]].			nameStream nextPut: nextChar].		(isReservedTarget		and: [length = 3])		ifTrue: [			isLowercaseReservedTarget				ifTrue: [					state isXMLDeclarationState						ifFalse: [self errorXMLDeclarationNotAtStart].					"return nil to indicate it's an XML declaration, not a PI"					^ nil].			"a reserved target other than lowercase 'xml' for XML declarations			is never allowed"			self errorReservedPITarget: nameStream contents].	^ nameStream contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextPITerminator	| nextChar |	(nextChar := streamReader next) == $>		ifFalse: [self errorExpectedPITerminatorButGot: nextChar]! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextParameterEntityReference	| pushedBackParameterEntity name |	pushedBackParameterEntity := self topPushedBackEntity.	name := self nextEntityName.	self nextEntityReferenceTerminator.	self topPushedBackEntity == pushedBackParameterEntity		ifFalse: [driver handleImproperParameterEntityNesting].	(driver handleParameterEntityReference: name)		ifNotNil: [:entity | self constructReplacementForParameterEntity: entity].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextParameterEntityReferenceInDeclaration	self isInExternalSubsetOrExternalEntity		ifFalse: [self errorInternalDeclarationParameterEntityReference].	self nextParameterEntityReference.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextParameterEntityReferenceOnCharacterStream	| pushedBackParameterEntity name |	pushedBackParameterEntity := self topPushedBackEntity.	name := self nextEntityName.	self nextEntityReferenceTerminator.	self topPushedBackEntity == pushedBackParameterEntity		ifFalse: [driver handleImproperParameterEntityNesting].		(driver handleParameterEntityReference: name)		ifNil: [			driver preservesUndeclaredEntityReferences				ifTrue: [					characterStream						nextPut: $%;						nextPutAll: name;						nextPut: $;.					^ $%]]		ifNotNil: [:entity |			self constructReplacementForParameterEntity: entity].	^ nil.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextPrologToken	streamReader skipSeparators.	self nextStartMarkupToken.	streamReader peek == $?		ifTrue: [^ self nextPI].	self nextNonPIPrologOrContentMarkupToken.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextPublicIDInDeclaration	^ self		expectNextAll: 'PUBLIC';		nextSeparatorsInDeclaration;		nextPublicIDLiteral! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextPublicIDLiteral	"this returns the pubid with leading and trailing whitespace removed	and all other whitespace sequences converted to single spaces"	| quote isInWhitespace nextChar |	((quote := streamReader next) == $"		or: [quote == $'])		ifFalse: [self errorExpectedPublicIDLiteralStartButGot: quote].	characterStream reset.	isInWhitespace := false.	"it's not enough to test for nil and PublicIDChars inclusion because	(PublicIDChars includes: $') = true (double quoted pubids can contain	single quotes), so the terminating quote must be tested for first to	handle single quoted pubids correctly"	[(nextChar := streamReader next) == nil		or: [nextChar == quote			or: [(PublicIDChars includes: nextChar) not]]]		whileFalse: [			nextChar isXMLSeparator				ifTrue: [					isInWhitespace						ifFalse: [isInWhitespace := true]]				ifFalse: [					isInWhitespace						ifTrue: [							characterStream position > 0								ifTrue: [characterStream nextPut: NormalizedSpace].							isInWhitespace := false].					characterStream nextPut: nextChar]].	nextChar == quote		ifFalse: [			self				errorExpectedPublicIDLiteralEnd: quote				butGot: nextChar].	^ characterStream contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextSeparators	"nil understands isXMLSeparator so no nil test is needed"	streamReader next isXMLSeparator		ifTrue: [streamReader skipSeparators]		ifFalse: [self errorExpectedSeparators]! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextSeparatorsInDeclaration	"this can be used to replace entity references within declarations"	[streamReader peek == $%]		whileTrue: [			streamReader next.			self nextParameterEntityReferenceInDeclaration].	self nextSeparators.	[streamReader peek == $%]		whileTrue: [			streamReader next.			self nextParameterEntityReferenceInDeclaration.			streamReader skipSeparators].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextStartExternalEntity	driver decodesCharacters		ifTrue: [streamReader detectEncoding].	self nextXMLTextDeclaration.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextStartExternalSubset	self nextXMLTextDeclaration.	state := state externalSubsetState.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextStartIncludeSectionFromEntity: aPushedBackParameterEntity	self		expectNextAll: 'INCLUDE'		startingAt: 2. "the 'I' was already read"	streamReader skipSeparators.	self expectNext: $[.	"the 'INCLUDE' can be in the replacement of an entity, like	in '<!![%entity[...]]>', but after it the entity that started	the declaration must be current"	self topPushedBackEntity == aPushedBackParameterEntity		ifFalse: [driver handleImproperParameterEntityNesting].	totalOpenIncludeSections := self totalOpenIncludeSections + 1.	aPushedBackParameterEntity		ifNotNil: [aPushedBackParameterEntity startIncludeSection].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextStartMarkupToken	| nextChar |	(nextChar := streamReader next) == $<		ifFalse: [self errorExpectedStartMarkupTokenButGot: nextChar]! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextSubsetDeclaration	streamReader peek == $E		ifTrue: [			streamReader next.			streamReader peek == $N				ifTrue: [^ self nextEntityDeclaration]				ifFalse: [^ self nextElementDeclaration]].	streamReader peek == $A		ifTrue: [^ self nextAttlistDeclaration].	streamReader peek == $N		ifTrue: [^ self nextNotationDeclaration].	self errorExpectedSubsetDeclaration.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextSubsetMarkupToken	| pushedBackParameterEntity |	self nextStartMarkupToken.	pushedBackParameterEntity := self topPushedBackEntity.	streamReader peek == $?		ifTrue: [self nextPI]		ifFalse: [			self expectNext: $!!.			streamReader peek == $-				ifTrue: [self nextComment]				ifFalse: [					streamReader peek == $[						ifTrue: [							self isInExternalSubsetOrExternalEntity								ifFalse: [self errorInternalSubsetConditionalSection].							self nextConditionalSectionFromEntity:								pushedBackParameterEntity]						ifFalse: [self nextSubsetDeclaration]]].	self topPushedBackEntity == pushedBackParameterEntity		ifFalse: [driver handleImproperParameterEntityNesting].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextSystemIDInDeclaration	^ self		expectNextAll: 'SYSTEM';		nextSeparatorsInDeclaration;		nextSystemIDLiteral! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextSystemIDInDeclarationWithoutURIFragment	^ self		expectNextAll: 'SYSTEM';		nextSeparatorsInDeclaration;		nextSystemIDLiteralWithoutURIFragment! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextSystemIDLiteral	^ self nextSystemIDLiteralWithoutURIFragment: false! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextSystemIDLiteralWithoutURIFragment	^ self nextSystemIDLiteralWithoutURIFragment: true! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextSystemIDLiteralWithoutURIFragment: aBoolean	"Returns the system ID literal.	If aBoolean is true, it disallows '#' URI fragments."	| quote nextChar |	((quote := streamReader next) == $"		or: [quote == $'])		ifFalse: [self errorExpectedSystemIDLiteralStartButGot: quote].	characterStream reset.	[(nextChar := streamReader next) == nil		or: [nextChar == quote]]		whileFalse: [			nextChar isXMLChar				ifFalse: [self errorNonCharInSystemID: nextChar].			aBoolean				ifTrue: [					nextChar == $#						ifTrue: [self errorURIFragmentInSystemID]].			characterStream nextPut: nextChar].	nextChar == quote		ifFalse: [			self				errorExpectedSystemIDLiteralEnd: quote				butGot: nextChar].	^ characterStream contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextTag	"performance critical method"	| tagName attributes nextChar |	(streamReader peek == $/)		ifTrue: [^ self nextEndTag].	tagName := self nextElementName.	"nil understands isXMLSeparator so is not tested for"	[(nextChar := streamReader peek) isXMLSeparator		and: [			streamReader				next;				skipSeparators.			((nextChar := streamReader peek) == $>				or: [nextChar == $/]) not]]		whileTrue: [| attributeName |			attributeName := self nextAttributeName.			streamReader skipSeparators.			(nextChar := streamReader next) == $=				ifFalse: [					self errorExpectedElementAttributeEqualsSeparatorButGot: nextChar].			streamReader skipSeparators.			"delay initializing 'attributes' until now to know for sure if it			needs a non-zero capacity, otherwise use the lazy version"			((attributes				ifNil: [attributes := driver newAttributeDictionary])				at: attributeName				newPut: self nextAttributeValue)				ifFalse: [self errorDuplicateAttribute: attributeName].			"the ordering of these tests is optimized"			(attributeName at: 1) == $x				ifTrue: [					driver hasUnhandledReservedAttributes						ifFalse: [							attributeName isXMLReservedAttributeName								ifTrue: [driver haveUnhandledReservedAttributes]]]].	elementNester wasRootElementEnded		ifTrue: [self errorMultipleDocumentRootElements].	elementNester startElement: tagName.	driver		handleStartTag: tagName		attributes:			(attributes				ifNil: [driver newEmptyAttributeDictionary]).	nextChar == $/		ifTrue: [			streamReader next.			elementNester endCurrentElement.			driver handleEndTag: tagName].	(nextChar := streamReader next) == $>		ifFalse: [self errorExpectedTagTerminatorButGot: nextChar].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextUnreplacedGeneralEntityOnCharacterStreamNamed: aName	driver handleUnreplacedGeneralEntityReference: aName.	characterStream		nextPut: $&;		nextPutAll: aName;		nextPut: $;.	^ $&.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextXMLAttributeEqualsSeparator	| nextChar |	streamReader skipSeparators.	(nextChar := streamReader next) == $=		ifFalse: [self errorExpectedXMLAttributeEqualsSeparatorButGot: nextChar].	streamReader skipSeparators.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextXMLDeclarationTerminator	| firstChar secondChar |	firstChar := streamReader next.	secondChar := streamReader next.	(firstChar == $?		and: [secondChar == $>])		ifFalse: [			self				errorExpectedXMLDeclarationTerminatorButGot: firstChar				followedBy: secondChar].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextXMLEncodingAttributeValue	| quote nextChar |	((quote := streamReader next) == $"		or: [quote == $'])		ifFalse: [self errorExpectedXMLEncodingValueStartButGot: quote].	((nextChar := streamReader next) notNil		and: [EncodingNameStartChars includes: nextChar])		ifFalse: [self errorExpectedEncodingName].	xmlDeclarationStream		reset;		nextPut: nextChar.	[(nextChar := streamReader next) == nil		or: [(EncodingNameChars includes: nextChar) not]]		whileFalse: [xmlDeclarationStream nextPut: nextChar].	nextChar == quote		ifFalse: [			self				errorExpectedXMLEncodingValueEnd: quote				butGot: nextChar].	^ xmlDeclarationStream contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextXMLStandaloneAttributeValue	| quote yesOrNo nextChar |	((quote := streamReader next) == $"		or: [quote == $'])		ifFalse: [self errorExpectedXMLStandaloneValueStartButGot: quote].	yesOrNo := 		streamReader peek == $y			ifTrue: [self expectNextAll: 'yes']			ifFalse: [self expectNextAll: 'no'].	(nextChar := streamReader next) == quote		ifFalse: [			self				errorExpectedXMLStandaloneValueEnd: quote				butGot: nextChar].	^ yesOrNo.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextXMLTextDeclaration	| encoding |		1 to: 5 "'<?xml' size" do: [:i |		streamReader peek == ('<?xml' at: i)			ifFalse: [				i > 1					ifTrue: [						streamReader pushBack:							('<?xml'								copyFrom: 1								to: i - 1)].				^ self].		streamReader next].	self nextSeparators.	(self nextXMLVersionAttributeRequired: false) isEmpty		ifFalse: [self nextSeparators].	(encoding := self nextXMLEncodingAttributeRequired: true) isEmpty		ifFalse: [self convertFromEncoding: encoding].	streamReader skipSeparators.	self nextXMLDeclarationTerminator.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextXMLVersionAttributeValue	| quote nextChar length isValid |	((quote := streamReader next) == $"		or: [quote == $'])		ifFalse: [self errorExpectedXMLVersionValueStartButGot: quote].	length := 0.	isValid := true.	xmlDeclarationStream reset.	[(nextChar := streamReader next) == nil		or: [(VersionNumChars includes: nextChar) not]]		whileFalse: [			xmlDeclarationStream nextPut: nextChar.			length := length + 1.			isValid				ifTrue: [isValid := (length == 2) == (nextChar == $.)]].	(isValid		and: [length >= 3])		ifFalse: [			self errorExpectedXMLVersionNumberButGot:				xmlDeclarationStream contents].	nextChar == quote		ifFalse: [			self				errorExpectedXMLVersionValueEnd: quote				butGot: nextChar].	^ xmlDeclarationStream contents.! !!XMLWellFormedParserTokenizer methodsFor: 'entity replacing'!pushBackEntity: anEntity whenPoppedDo: aBlock	anEntity hasReplacement		ifTrue: [| pushedBackEntity |			pushedBackEntity :=				self addPushedBackEntity: anEntity asPushedBackEntity.			streamReader				pushBackStream: pushedBackEntity replacementStream				whenPoppedDo: [					self removePushedBackEntity: pushedBackEntity.					aBlock						ifNotNil: [aBlock value]]				isExternal: pushedBackEntity isExternal.			pushedBackEntity isExternal				ifTrue: [self nextStartExternalEntity]]		ifFalse: [			aBlock				ifNotNil: [aBlock value]]! !!XMLWellFormedParserTokenizer methodsFor: 'accessing'!pushedBackEntities	^ pushedBackEntities		ifNil: [pushedBackEntities := OrderedCollection new: 5]! !!XMLWellFormedParserTokenizer methodsFor: 'entity replacing'!removePushedBackEntity: aPushedBackEntity	self pushedBackEntities remove: aPushedBackEntity.	driver currentEntity: self topPushedBackEntity.	aPushedBackEntity isExternal		ifTrue: [			self topPushedBackExternalEntity				ifNil: [					driver baseURI: nil]				ifNotNil: [:pushedBackExternalEntity |					driver baseURI: pushedBackExternalEntity uri]].	^ aPushedBackEntity poppedByTokenizer: self.! !!XMLWellFormedParserTokenizer methodsFor: 'initialization'!setDriver: aDriver stream: aStream readLimit: anInteger	super		setDriver: aDriver		stream: aStream		readLimit: anInteger.	isInLiteralValue := false.	isIgnoringLiteralValueTerminator := false.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!skipSeparatorsInDeclaration	"this can be used to replace references within declarations"	streamReader skipSeparators.	[streamReader peek == $%]		whileTrue: [			streamReader next.			self nextParameterEntityReferenceInDeclaration.			streamReader skipSeparators].! !!XMLWellFormedParserTokenizer methodsFor: 'accessing'!topPushedBackEntity	"heavily optimized"	pushedBackEntities == nil		ifTrue: [^ nil].	pushedBackEntities size > 0		ifFalse: [^ nil].	^ pushedBackEntities at: pushedBackEntities size.! !!XMLWellFormedParserTokenizer methodsFor: 'accessing'!topPushedBackExternalEntity	self pushedBackEntities reverseDo: [:each |		each isExternal			ifTrue: [^ each]].	^ nil.! !!XMLWellFormedParserTokenizer methodsFor: 'accessing'!totalOpenIncludeSections	^ totalOpenIncludeSections ifNil: [totalOpenIncludeSections := 0]! !!XMLPushedBackEntity class methodsFor: 'instance creation'!entity: anEntity	^ self new entity: anEntity! !!XMLPushedBackEntity methodsFor: 'converting'!asPushedBackEntity	^ self! !!XMLPushedBackEntity methodsFor: 'converting'!asReference	^ entity asReference! !!XMLPushedBackEntity methodsFor: 'accessing'!entity	^ entity! !!XMLPushedBackEntity methodsFor: 'accessing'!entity: anEntity	entity := anEntity! !!XMLPushedBackEntity methodsFor: 'testing'!hasReplacement	^ entity hasReplacement! !!XMLPushedBackEntity methodsFor: 'testing'!isExternal	^ entity isExternal! !!XMLPushedBackEntity methodsFor: 'testing'!isParameter	^ entity isParameter! !!XMLPushedBackEntity methodsFor: 'testing'!isStandaloneExternal	^ entity isStandaloneExternal! !!XMLPushedBackEntity methodsFor: 'testing'!isUnparsed	^ entity isUnparsed! !!XMLPushedBackEntity methodsFor: 'accessing'!name	^ entity name! !!XMLPushedBackEntity methodsFor: 'nesting'!poppedByTokenizer: aTokenizer	self subclassResponsibility! !!XMLPushedBackEntity methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		print: entity;		nextPut: $).! !!XMLPushedBackEntity methodsFor: 'accessing'!replacement	^ entity replacement! !!XMLPushedBackEntity methodsFor: 'accessing'!replacementStream	^ entity replacementStream! !!XMLPushedBackEntity methodsFor: 'accessing'!uri	^ entity uri! !!XMLPushedBackGeneralEntity methodsFor: 'nesting'!endElement	totalOpenElements := self totalOpenElements - 1! !!XMLPushedBackGeneralEntity methodsFor: 'nesting'!poppedByTokenizer: aTokenizer	totalOpenElements		ifNotNil: [			totalOpenElements = 0				ifFalse: [aTokenizer errorImproperGeneralEntityNesting]]! !!XMLPushedBackGeneralEntity methodsFor: 'nesting'!startElement	totalOpenElements := self totalOpenElements + 1! !!XMLPushedBackGeneralEntity methodsFor: 'accessing'!totalOpenElements	^ totalOpenElements ifNil: [totalOpenElements := 0]! !!XMLPushedBackParameterEntity methodsFor: 'nesting'!endIncludeSection	totalOpenIncludeSections := self totalOpenIncludeSections - 1! !!XMLPushedBackParameterEntity methodsFor: 'nesting'!poppedByTokenizer: aTokenizer	totalOpenIncludeSections		ifNotNil: [			totalOpenIncludeSections = 0				ifFalse: [aTokenizer driver handleImproperParameterEntityNesting]]! !!XMLPushedBackParameterEntity methodsFor: 'nesting'!startIncludeSection	totalOpenIncludeSections := self totalOpenIncludeSections + 1! !!XMLPushedBackParameterEntity methodsFor: 'accessing'!totalOpenIncludeSections	^ totalOpenIncludeSections ifNil: [totalOpenIncludeSections := 0]! !!XMLPushedBackExternalStream methodsFor: 'testing'!isExternal	^ true! !!XMLPushedBackStream class methodsFor: 'instance creation'!stream: aStream whenPoppedDo: aBlock currentPosition: aPosition currentLineNumber: aLineNumber currentLineStartPosition: aStartPosition	^ self new		setStream: aStream		whenPoppedDo: aBlock		currentPosition: aPosition		currentLineNumber: aLineNumber		currentLineStartPosition: aStartPosition! !!XMLPushedBackStream methodsFor: 'accessing'!currentLineNumber	^ currentLineNumber! !!XMLPushedBackStream methodsFor: 'accessing'!currentLineStartPosition	^ currentLineStartPosition! !!XMLPushedBackStream methodsFor: 'accessing'!currentPosition	^ currentPosition! !!XMLPushedBackStream methodsFor: 'testing'!isExternal	^ false! !!XMLPushedBackStream methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		print: stream;		nextPut: $).! !!XMLPushedBackStream methodsFor: 'initialization'!setStream: aStream whenPoppedDo: aBlock currentPosition: aPosition currentLineNumber: aLineNumber currentLineStartPosition: aStartPosition	stream := aStream.	whenPoppedDo := aBlock.	currentPosition := aPosition.	currentLineNumber := aLineNumber.	currentLineStartPosition := aStartPosition.! !!XMLPushedBackStream methodsFor: 'accessing'!stream	^ stream! !!XMLPushedBackStream methodsFor: 'accessing'!whenPoppedDo	^ whenPoppedDo! !!XMLDecodingReadStreamAdapter class methodsFor: 'instance creation'!nonDecodingOn: aStream	^ self		on: aStream		streamConverter: XMLStreamConverter null! !!XMLDecodingReadStreamAdapter class methodsFor: 'instance creation'!nonDecodingOnIfBinaryOrExternal: aStream	^ aStream isXMLBinaryOrExternalStream		ifTrue: [			self				on: aStream				streamConverter: XMLStreamConverter null]		ifFalse: [nil]! !!XMLDecodingReadStreamAdapter class methodsFor: 'instance creation'!on: aStream	^ self		on: aStream		streamConverter: XMLStreamConverter default! !!XMLDecodingReadStreamAdapter class methodsFor: 'instance creation'!on: aStream streamConverter: aStreamConverter	^ (self basicOn: aStream)		streamConverter: aStreamConverter! !!XMLDecodingReadStreamAdapter methodsFor: 'testing'!atEnd	^ peekChar == nil		and: [stream atEnd]! !!XMLDecodingReadStreamAdapter methodsFor: 'decoding'!detectEncoding	prePeekStreamPosition := nil.	peekChar := nil.	stream reset.	(((self hasNullStreamConverter		or: [self hasImplicitStreamConverter])		ifTrue: [XMLImplicitEncodingDetector]		ifFalse: [XMLEncodingDetector])			on: stream) streamConverterForEncoding				ifNotNil: [:converter |					self streamConverter: converter].! !!XMLDecodingReadStreamAdapter methodsFor: 'testing'!hasDefaultStreamConverter	^ streamConverter isDefault! !!XMLDecodingReadStreamAdapter methodsFor: 'testing'!hasImplicitStreamConverter	^ streamConverter isImplicit! !!XMLDecodingReadStreamAdapter methodsFor: 'testing'!hasNullStreamConverter	^ streamConverter isNull! !!XMLDecodingReadStreamAdapter methodsFor: 'testing'!isXMLConvertingStreamAdapter	^ true! !!XMLDecodingReadStreamAdapter methodsFor: 'accessing'!next	peekChar		ifNil: [^ streamConverter nextFromStream: stream]		ifNotNil: [:nextChar |			prePeekStreamPosition := nil.			peekChar := nil.			^ nextChar]! !!XMLDecodingReadStreamAdapter methodsFor: 'accessing'!peek	^ peekChar		ifNil: [			prePeekStreamPosition := stream position.			peekChar := streamConverter nextFromStream: stream]! !!XMLDecodingReadStreamAdapter methodsFor: 'positioning'!position	^ prePeekStreamPosition ifNil: [stream position]! !!XMLDecodingReadStreamAdapter methodsFor: 'positioning'!position: anInteger	prePeekStreamPosition := nil.	peekChar := nil.	stream position: anInteger.! !!XMLDecodingReadStreamAdapter methodsFor: 'printing'!printStreamOn: aStream	streamConverter		printWithConvertableStream: stream		on: aStream! !!XMLDecodingReadStreamAdapter methodsFor: 'positioning'!reset	prePeekStreamPosition := nil.	peekChar := nil.	stream reset.! !!XMLDecodingReadStreamAdapter methodsFor: 'accessing'!streamConverter	^ streamConverter! !!XMLDecodingReadStreamAdapter methodsFor: 'accessing'!streamConverter: aStreamConverter	streamConverter :=		aStreamConverter ifNil: [XMLStreamConverter null].	peekChar		ifNotNil: [			stream position: prePeekStreamPosition.			prePeekStreamPosition := nil.			peekChar := nil].! !!XMLLimitedReadStreamAdapter class methodsFor: 'accessing'!defaultLimit	^ 1014! !!XMLLimitedReadStreamAdapter class methodsFor: 'instance creation'!on: aStream	^ self		on: aStream		limit: self defaultLimit! !!XMLLimitedReadStreamAdapter class methodsFor: 'instance creation'!on: aStream limit: aLimit	^ (self basicOn: aStream)		limit: aLimit! !!XMLLimitedReadStreamAdapter methodsFor: 'testing'!atEnd	^ stream atEnd		or: [limit <= 0]! !!XMLLimitedReadStreamAdapter methodsFor: 'testing'!atLimitedEnd	^ limit <= 0		and: [stream atEnd not]! !!XMLLimitedReadStreamAdapter methodsFor: 'accessing'!limit	^ limit! !!XMLLimitedReadStreamAdapter methodsFor: 'accessing'!limit: anInteger	limit := anInteger! !!XMLLimitedReadStreamAdapter methodsFor: 'accessing'!next	(stream atEnd		or: [limit <= 0])		ifTrue: [^ nil]		ifFalse: [			limit := limit - 1.			^ stream next]! !!XMLLimitedReadStreamAdapter methodsFor: 'accessing'!peek	(stream atEnd		or: [limit <= 0])		ifTrue: [^ nil]		ifFalse: [^ stream peek]! !!XMLLimitedReadStreamAdapter methodsFor: 'positioning'!position: anInteger	| netPosition |	(netPosition := anInteger - stream position) > limit		ifTrue: [			"skip as far ahead as allowed"			self skip: limit]		ifFalse: [			limit := (limit - netPosition) max: 0.			stream position: anInteger]! !!XMLLimitedReadStreamAdapter methodsFor: 'positioning'!reset	| oldPosition |	oldPosition := stream position.	stream reset.	limit := limit + (oldPosition - stream position).! !!XMLPercentDecodingReadStreamAdapter methodsFor: 'testing'!atEnd	^ stream atEnd		or: [stream peek ~~ $%]! !!XMLPercentDecodingReadStreamAdapter methodsFor: 'testing'!isBinary	"this stream is binary, because it reads percent-encoded octets	character sequences like '%HH' and returns the octet values as	SmallIntegers"	^ true! !!XMLPercentDecodingReadStreamAdapter methodsFor: 'accessing'!next	| byte |	(stream atEnd not		and: [stream peek == $%])		ifTrue: [			stream next.			byte :=				(XMLSmallIntegerReader					readFrom: stream					withBase: 16					upToLimit: 2)						ifNil: [37] "$% asciiValue"].	^ byte.! !!XMLPercentDecodingReadStreamAdapter methodsFor: 'accessing'!peek	| byte |	stream atEnd		ifFalse: [| oldPosition |			oldPosition := stream position.			byte := self next.			stream position: oldPosition].	^ byte.! !!XMLReadStreamAdapter class methodsFor: 'instance creation'!onIfBinaryOrExternal: aStream	^ aStream isXMLBinaryOrExternalStream		ifTrue: [self on: aStream]		ifFalse: [nil]! !!XMLReadStreamAdapter methodsFor: 'testing'!atEnd	^ stream atEnd! !!XMLReadStreamAdapter methodsFor: 'accessing'!contents	| oldPosition contents |	oldPosition := self position.	self reset.	contents := self upToEnd.	self position: oldPosition.	^ contents.! !!XMLReadStreamAdapter methodsFor: 'private'!newWriteStream	^ (self writeStreamCollectionClass new: 128) writeStream! !!XMLReadStreamAdapter methodsFor: 'accessing'!next	stream atEnd		ifTrue: [^ nil]		ifFalse: [^ stream next]! !!XMLReadStreamAdapter methodsFor: 'accessing'!next: anInteger	| writeStream i |	writeStream := self newWriteStream.	i := 0.	[self atEnd		or: [i >= anInteger]]		whileFalse: [			writeStream nextPut: self next.			i := i + 1].	^ writeStream contents.! !!XMLReadStreamAdapter methodsFor: 'accessing'!peek	stream atEnd		ifTrue: [^ nil]		ifFalse: [^ stream peek]! !!XMLReadStreamAdapter methodsFor: 'accessing'!peekFor: anObject	(self atEnd not		and: [self peek = anObject])		ifTrue: [			self next.			^ true]		ifFalse: [^ false]! !!XMLReadStreamAdapter methodsFor: 'positioning'!position	^ stream position! !!XMLReadStreamAdapter methodsFor: 'positioning'!position: anInteger	stream position: anInteger! !!XMLReadStreamAdapter methodsFor: 'positioning'!reset	stream reset! !!XMLReadStreamAdapter methodsFor: 'positioning'!skip: anInteger	"only supports skipping forwards"	1 to: anInteger do: [:i |		self atEnd			ifTrue: [^ self].		self next]! !!XMLReadStreamAdapter methodsFor: 'positioning'!skipSeparators	"we use #isXMLWhitespace instead of the narrower, XML-specific	#isXMLSeparator, because this class supports non-XML input too"	[self atEnd not		and: [self peek isXMLWhitespace]]		whileTrue: [self next]! !!XMLReadStreamAdapter methodsFor: 'positioning'!skipTo: anObject	[self atEnd]		whileFalse: [			self next = anObject				ifTrue: [^ true]].	^ false.! !!XMLReadStreamAdapter methodsFor: 'accessing'!upTo: anObject	| writeStream next |	writeStream := self newWriteStream.	[self atEnd		or: [(next := self next) = anObject]]		whileFalse: [writeStream nextPut: next].	^ writeStream contents.! !!XMLReadStreamAdapter methodsFor: 'accessing'!upToEnd	| writeStream |	writeStream := self newWriteStream.	[self atEnd]		whileFalse: [writeStream nextPut: self next].	^ writeStream contents.! !!XMLReadStreamAdapter methodsFor: 'defaults'!writeStreamCollectionClass	self isBinary		ifTrue: [^ ByteArray]		ifFalse: [^ String]! !!XMLStringReadStreamAdapter methodsFor: 'testing'!isBinary	"this stream is binary, because it converts characters to integers"	^ true! !!XMLStringReadStreamAdapter methodsFor: 'accessing'!next	stream atEnd		ifTrue: [^ nil]		ifFalse: [^ stream next asInteger]! !!XMLStringReadStreamAdapter methodsFor: 'accessing'!peek	stream atEnd		ifTrue: [^ nil]		ifFalse: [^ stream peek asInteger]! !!XMLStreamAdapter class methodsFor: 'basic'!basicOn: aStream	^ self basicNew initialize on: aStream! !!XMLStreamAdapter class methodsFor: 'instance creation'!new	self shouldNotImplement! !!XMLStreamAdapter class methodsFor: 'instance creation'!on: aStream	^ self basicOn: aStream! !!XMLStreamAdapter methodsFor: 'closing'!close	"must use respondsTo: to support streams only implementing the basic protocol"	(stream respondsTo: #close)		ifTrue: [stream close]! !!XMLStreamAdapter methodsFor: 'accessing'!contents	self subclassResponsibility! !!XMLStreamAdapter methodsFor: 'testing'!isBinary	^ false! !!XMLStreamAdapter methodsFor: 'testing'!isStream	^ true! !!XMLStreamAdapter methodsFor: 'testing'!isXMLBinaryOrExternalStream	^ self isBinary! !!XMLStreamAdapter methodsFor: 'initialization'!on: aStream	stream := aStream! !!XMLStreamAdapter methodsFor: 'positioning'!position	self subclassResponsibility! !!XMLStreamAdapter methodsFor: 'positioning'!position: anInteger	self subclassResponsibility! !!XMLStreamAdapter methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self printStreamOn: aStream.	aStream nextPut: $).! !!XMLStreamAdapter methodsFor: 'printing'!printStreamOn: aStream	aStream print: stream! !!XMLStreamAdapter methodsFor: 'positioning'!reset	self subclassResponsibility! !!XMLStreamAdapter methodsFor: 'accessing'!stream	^ stream! !!XMLEncodingWriteStreamAdapter class methodsFor: 'instance creation'!on: aStream	^ self		on: aStream		streamConverter: XMLStreamConverter default! !!XMLEncodingWriteStreamAdapter class methodsFor: 'instance creation'!on: aStream streamConverter: aStreamConverter	^ (self basicOn:		(aStream isXMLBinaryOrExternalStream			ifTrue: [aStream]			ifFalse: [XMLStringWriteStreamAdapter on: aStream]))		streamConverter: aStreamConverter! !!XMLEncodingWriteStreamAdapter methodsFor: 'testing'!hasDefaultStreamConverter	^ streamConverter isDefault! !!XMLEncodingWriteStreamAdapter methodsFor: 'testing'!hasImplicitStreamConverter	^ streamConverter isImplicit! !!XMLEncodingWriteStreamAdapter methodsFor: 'testing'!hasNullStreamConverter	^ streamConverter isNull! !!XMLEncodingWriteStreamAdapter methodsFor: 'testing'!isXMLConvertingStreamAdapter	^ true! !!XMLEncodingWriteStreamAdapter methodsFor: 'accessing'!nextPut: aCharacter	streamConverter		nextPut: aCharacter		toStream: stream.	^ aCharacter.! !!XMLEncodingWriteStreamAdapter methodsFor: 'accessing'!nextPutAll: aCollection	"can't use #to:do: here because other #nextPutAll: implementations	support non-sequenceable collection arguments wtih #do:"	aCollection do: [:each |		streamConverter			nextPut: each			toStream: stream].	^ aCollection.! !!XMLEncodingWriteStreamAdapter methodsFor: 'accessing'!nextPutByteOrderMark	streamConverter nextPutByteOrderMarkToStream: stream! !!XMLEncodingWriteStreamAdapter methodsFor: 'printing'!printStreamOn: aStream	streamConverter		printWithConvertableStream: stream		on: aStream! !!XMLEncodingWriteStreamAdapter methodsFor: 'accessing'!streamConverter	^ streamConverter! !!XMLEncodingWriteStreamAdapter methodsFor: 'accessing'!streamConverter: aStreamConverter	streamConverter :=		aStreamConverter ifNil: [XMLStreamConverter null]! !!XMLNodeContentWriteStreamAdapter methodsFor: 'private'!insertSpaceBefore: aCharacter	(lastChar == nil		or: [lastChar isXMLWhitespace			or: [aCharacter isXMLWhitespace]])		ifFalse: [stream nextPut: SpaceCharacter]! !!XMLNodeContentWriteStreamAdapter methodsFor: 'accessing'!nextPut: aCharacter	self insertSpaceBefore: aCharacter.	stream nextPut: aCharacter.	^ lastChar := aCharacter.! !!XMLNodeContentWriteStreamAdapter methodsFor: 'accessing'!nextPutAll: aString	aString size > 0 "optimization"		ifTrue: [			self insertSpaceBefore: aString first.			stream nextPutAll: aString.			lastChar := aString last].	^ aString.! !!XMLPercentEncodingWriteStreamAdapter methodsFor: 'testing'!isBinary	"this stream is binary, because it accepts binary octet values	and percent-encodes them as '%HH' character sequences"	^ true! !!XMLPercentEncodingWriteStreamAdapter methodsFor: 'accessing'!nextPut: anObject	| byte |	stream nextPut: $%.	"pad it if needed"	(byte := anObject asInteger) < 16r10		ifTrue: [stream nextPut: $0].	"On GS, #printOn:base: shows the radix, so #printOn:base:showRadix:	is used instead"	byte		printOn: stream		base: 16		showRadix: false.	^ anObject.! !!XMLPercentEncodingWriteStreamAdapter methodsFor: 'accessing'!nextPutAll: aCollection	"can't use #to:do: here because other #nextPutAll: implementations	support non-sequenceable collection arguments wtih #do:"	aCollection do: [:each |		self nextPut: each].	^ aCollection.! !!XMLStringWriteStreamAdapter methodsFor: 'accessing'!nextPut: anObject	stream nextPut: anObject asCharacter! !!XMLStringWriteStreamAdapter methodsFor: 'accessing'!nextPutAll: aCollection	"can't use #to:do: here because other #nextPutAll: implementations	support non-sequenceable collection arguments wtih #do:"	aCollection do: [:each |		stream nextPut: each asCharacter].	^ aCollection.! !!XMLWriteStreamAdapter class methodsFor: 'class initialization'!initialize	"self initialize"	"stored in class vars for faster access"	SpaceCharacter := Character space.	TabCharacter := Character tab.	CRCharacter := Character cr.	LFCharacter := Character lf.! !!XMLWriteStreamAdapter methodsFor: 'basic'!basicNextPut: anObject 	^ self nextPut: anObject! !!XMLWriteStreamAdapter methodsFor: 'accessing'!contents	^ stream contents! !!XMLWriteStreamAdapter methodsFor: 'character writing'!cr	^ self nextPut: CRCharacter! !!XMLWriteStreamAdapter methodsFor: 'character writing'!lf	^ self nextPut: LFCharacter! !!XMLWriteStreamAdapter methodsFor: 'accessing'!nextPut: anObject	stream nextPut: anObject.	^ anObject.! !!XMLWriteStreamAdapter methodsFor: 'accessing'!nextPutAll: aCollection	stream nextPutAll: aCollection.	^ aCollection.! !!XMLWriteStreamAdapter methodsFor: 'positioning'!position	^ stream position! !!XMLWriteStreamAdapter methodsFor: 'positioning'!position: anInteger	stream position: anInteger! !!XMLWriteStreamAdapter methodsFor: 'positioning'!reset	stream reset! !!XMLWriteStreamAdapter methodsFor: 'character writing'!space	^ self nextPut: SpaceCharacter! !!XMLWriteStreamAdapter methodsFor: 'character writing'!tab	^ self nextPut: TabCharacter! !!XMLASCIIStreamConverter class methodsFor: 'basic'!basicEncodingNames	^ #('ASCII' 'US-ASCII' 'USASCII')! !!XMLASCIIStreamConverter methodsFor: 'decoding'!nextFromStream: aStream	| byte |	aStream atEnd		ifTrue: [^ nil].	(byte := aStream next asInteger) > 127		ifTrue: [self errorBadCharacterValue: byte].	^ byte asCharacter.! !!XMLASCIIStreamConverter methodsFor: 'encoding'!nextPut: aCharacter toStream: aStream	| codePoint |	(codePoint := aCharacter asInteger) > 127		ifTrue: [self errorBadCharacterValue: codePoint].	aStream nextPut: codePoint.! !!XMLLatin1StreamConverter class methodsFor: 'basic'!basicEncodingNames	^ #('Latin-1' 'Latin1'			'CP-819' 'CP819'			'IBM-819' 'IBM819'			'ISO-8859-1' 'ISO8859-1' 'ISO-88591' 'ISO88591'			'ISO-IR-100' 'ISOIR-100' 'ISO-IR100' 'ISOIR100'			'L1'			'csISOLatin1')! !!XMLLatin1StreamConverter methodsFor: 'decoding'!nextFromStream: aStream	| byte |	aStream atEnd		ifTrue: [^ nil].	(byte := aStream next asInteger) > 255		ifTrue: [self errorBadCharacterValue: byte].	^ byte asCharacter.! !!XMLLatin1StreamConverter methodsFor: 'encoding'!nextPut: aCharacter toStream: aStream	| codePoint |	(codePoint := aCharacter asInteger) > 255		ifTrue: [self errorBadCharacterValue: codePoint].	aStream nextPut: codePoint.! !!XMLNullStreamConverter methodsFor: 'testing'!isNull	^ true! !!XMLNullStreamConverter methodsFor: 'decoding'!nextFromStream: aStream	aStream atEnd		ifTrue: [^ nil]		ifFalse: [^ aStream next asCharacter]! !!XMLNullStreamConverter methodsFor: 'encoding'!nextPut: aCharacter toStream: aStream	aStream nextPut: aCharacter asInteger! !!XMLStatelessStreamConverter class methodsFor: 'defaults'!abstractClass	^ XMLStatelessStreamConverter! !!XMLStatelessStreamConverter class methodsFor: 'accessing'!instance	^ instance ifNil: [instance := self basicNew initialize]! !!XMLStatelessStreamConverter class methodsFor: 'instance creation'!new	"all subclasses are stateless and have a single, immutable, shared instance"	^ self instance! !!XMLImplicitUTF16BigEndianStreamConverter class methodsFor: 'testing'!isImplicit	^ true! !!XMLUTF16BigEndianStreamConverter class methodsFor: 'basic'!basicByteOrderMarkBytes	^ #[16rFE 16rFF]! !!XMLUTF16BigEndianStreamConverter class methodsFor: 'basic'!basicEncodingNames	^ #('UTF-16' 'UTF16'			'UTF-16-BE' 'UTF16-BE' 'UTF-16BE' 'UTF16BE')! !!XMLUTF16BigEndianStreamConverter methodsFor: 'testing'!isBigEndian	^ true! !!XMLUTF16BigEndianStreamConverter methodsFor: 'basic'!nextPutTwoBytes: anInteger toStream: aStream	aStream		nextPut: ((anInteger bitShift: -8) bitAnd: 16rFF);		nextPut: (anInteger bitAnd: 16rFF)! !!XMLUTF16BigEndianStreamConverter methodsFor: 'basic'!nextTwoBytesFromStream: aStream	| firstByte |	firstByte := aStream next asInteger bitShift: 8.	aStream atEnd		ifTrue: [self errorBadCharacterEncoding].	^ firstByte + aStream next asInteger.! !!XMLImplicitUTF16LittleEndianStreamConverter class methodsFor: 'testing'!isImplicit	^ true! !!XMLUTF16LittleEndianStreamConverter class methodsFor: 'basic'!basicByteOrderMarkBytes	^ #[16rFF 16rFE]! !!XMLUTF16LittleEndianStreamConverter class methodsFor: 'basic'!basicEncodingNames	^ #('UTF-16-LE' 'UTF16-LE' 'UTF-16LE' 'UTF16LE')! !!XMLUTF16LittleEndianStreamConverter methodsFor: 'testing'!isBigEndian	^ false! !!XMLUTF16LittleEndianStreamConverter methodsFor: 'basic'!nextPutTwoBytes: anInteger toStream: aStream	aStream		nextPut: (anInteger bitAnd: 16rFF);		nextPut: ((anInteger bitShift: -8) bitAnd: 16rFF)! !!XMLUTF16LittleEndianStreamConverter methodsFor: 'basic'!nextTwoBytesFromStream: aStream	| firstByte |	firstByte := aStream next asInteger.	aStream atEnd		ifTrue: [self errorBadCharacterEncoding].	^ firstByte + (aStream next asInteger bitShift: 8).! !!XMLUTF16StreamConverter class methodsFor: 'defaults'!abstractClass	^ XMLUTF16StreamConverter! !!XMLUTF16StreamConverter methodsFor: 'testing'!isBigEndian	self subclassResponsibility! !!XMLUTF16StreamConverter methodsFor: 'basic'!nextCodePointFromStream: aStream	| codePoint lowSurrogate |	aStream atEnd		ifTrue: [^ nil].	"code points U+10000 to U+10FFFF are encoded with surrogate pairs,	while those < U+10000 are encoded directly"	((codePoint := self nextTwoBytesFromStream: aStream) < 16rD800		or: [codePoint > 16rDFFF])		ifTrue: [			codePoint > 16r10FFFF				ifTrue: [self errorBadCharacterValue: codePoint].			^ codePoint].	codePoint > 16rDBFF "max high surrogate"		ifTrue: [self errorBadCharacterEncoding].	aStream atEnd		ifTrue: [self errorBadCharacterEncoding].	(lowSurrogate := self nextTwoBytesFromStream: aStream)		ifNil: [self errorBadCharacterEncoding].	(lowSurrogate < 16rDC00 "min low surrogate"		or: [lowSurrogate > 16rDFFF]) "max low surrogate"		ifTrue: [self errorBadCharacterEncoding].	"A code point > U+10FFFF isn't checked for here because it can't	be encoded with UTF-16. The maximum surrogate pairs can encode is:		(16r10000 + (16r3FF bitShift: 10) + 16r3FF) = 16r10FFFF"	^ ((codePoint bitAnd: 16r3FF) bitShift: 10) +		(lowSurrogate bitAnd: 16r3FF) +		16r10000.! !!XMLUTF16StreamConverter methodsFor: 'encoding'!nextPut: aCharacter toStream: aStream	| codePoint |	(codePoint := aCharacter asInteger) < 16r10000		ifTrue: [			"check for the reserved surrogate pair code points"			(codePoint >= 16rD800				and: [codePoint <= 16rDFFF])				ifTrue: [self errorBadCharacterValue: codePoint].			self				nextPutTwoBytes: codePoint				toStream: aStream]		ifFalse: [			codePoint > 16r10FFFF "max code point"				ifTrue: [self errorBadCharacterValue: codePoint].			codePoint := codePoint - 16r10000.			"the 10 high-order bits"			self				nextPutTwoBytes: 16rD800 + ((codePoint bitShift: -10) bitAnd: 16r3FF)				toStream: aStream.			"the 10 low-order bits"			self				nextPutTwoBytes: 16rDC00 + (codePoint bitAnd: 16r3FF)				toStream: aStream]! !!XMLUTF16StreamConverter methodsFor: 'basic'!nextPutTwoBytes: anInteger toStream: aStream	self subclassResponsibility! !!XMLUTF16StreamConverter methodsFor: 'basic'!nextTwoBytesFromStream: aStream	self subclassResponsibility! !!XMLImplicitUTF32BigEndianStreamConverter class methodsFor: 'testing'!isImplicit	^ true! !!XMLUTF32BigEndianStreamConverter class methodsFor: 'basic'!basicByteOrderMarkBytes	^ #[16r00 16r00 16rFE 16rFF]! !!XMLUTF32BigEndianStreamConverter class methodsFor: 'basic'!basicEncodingNames	^ #('UTF-32' 'UTF32'			'UTF-32-BE' 'UTF32-BE' 'UTF-32BE' 'UTF32BE')! !!XMLUTF32BigEndianStreamConverter methodsFor: 'testing'!isBigEndian	^ true! !!XMLUTF32BigEndianStreamConverter methodsFor: 'basic'!nextFourBytesFromStream: aStream	| firstByte secondByte thirdByte |	firstByte := aStream next asInteger bitShift: 24.	aStream atEnd		ifTrue: [self errorBadCharacterEncoding].	secondByte := aStream next asInteger bitShift: 16.	aStream atEnd		ifTrue: [self errorBadCharacterEncoding].	thirdByte := aStream next asInteger bitShift: 8.	aStream atEnd		ifTrue: [self errorBadCharacterEncoding].	^ firstByte + secondByte + thirdByte + aStream next asInteger.! !!XMLUTF32BigEndianStreamConverter methodsFor: 'basic'!nextPutFourBytes: anInteger toStream: aStream	aStream		nextPut: ((anInteger bitShift: -24) bitAnd: 16rFF);		nextPut: ((anInteger bitShift: -16) bitAnd: 16rFF);		nextPut: ((anInteger bitShift: -8) bitAnd: 16rFF);		nextPut: (anInteger bitAnd: 16rFF)! !!XMLImplicitUTF32LittleEndianStreamConverter class methodsFor: 'testing'!isImplicit	^ true! !!XMLUTF32LittleEndianStreamConverter class methodsFor: 'basic'!basicByteOrderMarkBytes	^ #[16rFF 16rFE 16r00 16r00]! !!XMLUTF32LittleEndianStreamConverter class methodsFor: 'basic'!basicEncodingNames	^ #('UTF-32-LE' 'UTF32-LE' 'UTF-32LE' 'UTF32LE')! !!XMLUTF32LittleEndianStreamConverter methodsFor: 'testing'!isBigEndian	^ false! !!XMLUTF32LittleEndianStreamConverter methodsFor: 'basic'!nextFourBytesFromStream: aStream	| firstByte secondByte thirdByte |	firstByte := aStream next asInteger.	aStream atEnd		ifTrue: [self errorBadCharacterEncoding].	secondByte := aStream next asInteger bitShift: 8.	aStream atEnd		ifTrue: [self errorBadCharacterEncoding].	thirdByte := aStream next asInteger bitShift: 16.	aStream atEnd		ifTrue: [self errorBadCharacterEncoding].	^ firstByte + secondByte + thirdByte + (aStream next asInteger bitShift: 24).! !!XMLUTF32LittleEndianStreamConverter methodsFor: 'basic'!nextPutFourBytes: anInteger toStream: aStream	aStream		nextPut: (anInteger bitAnd: 16rFF);		nextPut: ((anInteger bitShift: -8) bitAnd: 16rFF);		nextPut: ((anInteger bitShift: -16) bitAnd: 16rFF);		nextPut: ((anInteger bitShift: -24) bitAnd: 16rFF)! !!XMLUTF32StreamConverter class methodsFor: 'defaults'!abstractClass	^ XMLUTF32StreamConverter! !!XMLUTF32StreamConverter methodsFor: 'testing'!isBigEndian	self subclassResponsibility! !!XMLUTF32StreamConverter methodsFor: 'basic'!nextCodePointFromStream: aStream	| codePoint |	aStream atEnd		ifTrue: [^ nil].	"check for the reserved surrogate pair code points and code points	greater than the max code point"	(codePoint := self nextFourBytesFromStream: aStream) >= 16rD800		ifTrue: [			(codePoint <= 16rDFFF				or: [codePoint > 16r10FFFF])				ifTrue: [self errorBadCharacterValue: codePoint]].	^ codePoint.! !!XMLUTF32StreamConverter methodsFor: 'basic'!nextFourBytesFromStream: aStream	self subclassResponsibility! !!XMLUTF32StreamConverter methodsFor: 'encoding'!nextPut: aCharacter toStream: aStream	| codePoint |	codePoint := aCharacter asInteger.	"check for the reserved surrogate pair code points and code points	greater than the max code point"	(codePoint >= 16rD800		and: [codePoint <= 16rDFFF			or: [codePoint > 16r10FFFF]])		ifTrue: [self errorBadCharacterValue: codePoint].	self		nextPutFourBytes: codePoint		toStream: aStream.! !!XMLUTF32StreamConverter methodsFor: 'basic'!nextPutFourBytes: anInteger toStream: aStream	self subclassResponsibility! !!XMLImplicitUTF8StreamConverter class methodsFor: 'testing'!isImplicit	^ true! !!XMLUTF8StreamConverter class methodsFor: 'basic'!basicByteOrderMarkBytes	^ #[16rEF 16rBB 16rBF]! !!XMLUTF8StreamConverter class methodsFor: 'basic'!basicEncodingNames	^ #('UTF-8' 'UTF8')! !!XMLUTF8StreamConverter methodsFor: 'private'!errorOverlongCodePoint: aCodePoint	XMLEncodingException		formatSignal: 'Illegal overlong UTF-8 encoding for U+{1} code point'		with: aCodePoint printStringHex! !!XMLUTF8StreamConverter methodsFor: 'basic'!nextCodePointFromStream: aStream	self shouldNotImplement! !!XMLUTF8StreamConverter methodsFor: 'decoding'!nextFromStream: aStream	"an attempt was made at porting Bjoern Hoehrmann's DFA-based decoder	(with transitions pre-multiplied by 16), but it was slightly slower	than this implementation and needed significant modification to report	errors the same way, so it was scrapped"	| firstByte codePoint |	aStream atEnd		ifTrue: [^ nil].	(firstByte := aStream next asInteger) < 16r80 "single byte character"		ifTrue: [^ firstByte asCharacter].	codePoint :=		self			nextMultiByteCodePointStartingWith: firstByte			fromStream: aStream.	[codePoint == 16rFEFF] "the BOM code point"		whileTrue: [			aStream atEnd				ifTrue: [^ nil].			(firstByte := aStream next asInteger) < 16r80 "single byte character"				ifTrue: [^ firstByte asCharacter].			codePoint :=				self					nextMultiByteCodePointStartingWith: firstByte					fromStream: aStream].	^ codePoint asCharacter.! !!XMLUTF8StreamConverter methodsFor: 'basic'!nextMultiByteCodePointStartingWith: aFirstByte fromStream: aStream	| secondByte thirdByte codePoint |	aStream atEnd		ifTrue: [self errorBadCharacterEncoding].	secondByte := aStream next asInteger.	(secondByte bitAnd: 16rC0) == 16r80		ifFalse: [self errorBadCharacterEncoding].	(aFirstByte bitAnd: 16rE0) == 16rC0 "two bytes"		ifTrue: [			codePoint :=				((aFirstByte bitAnd: 16r1F) bitShift: 6) +				(secondByte bitAnd: 16r3F).			codePoint >= 16r80				ifFalse: [self errorOverlongCodePoint: codePoint].			^ codePoint].	aStream atEnd		ifTrue: [self errorBadCharacterEncoding].	thirdByte := aStream next asInteger.	(thirdByte bitAnd: 16rC0) == 16r80		ifFalse: [self errorBadCharacterEncoding].	(aFirstByte bitAnd: 16rF0) == 16rE0 "three bytes"		ifTrue: [			codePoint :=				((aFirstByte bitAnd: 16r0F) bitShift: 12) +				((secondByte bitAnd: 16r3F) bitShift: 6) +				(thirdByte bitAnd: 16r3F).			"check for the reserved surrogate pair code points"			codePoint >= 16rD800				ifTrue: [					codePoint <= 16rDFFF						ifTrue: [self errorBadCharacterValue: codePoint]]				ifFalse: [					codePoint >= 16r800						ifFalse: [self errorOverlongCodePoint: codePoint]].			^ codePoint].	(aFirstByte bitAnd: 16rF8) == 16rF0		ifTrue: [| fourthByte |			aStream atEnd				ifTrue: [self errorBadCharacterEncoding].			fourthByte := aStream next asInteger.			(fourthByte bitAnd: 16rC0) == 16r80				ifFalse: [self errorBadCharacterEncoding].			codePoint :=				((aFirstByte bitAnd: 16r07) bitShift: 18) +				((secondByte bitAnd: 16r3F) bitShift: 12) +				((thirdByte bitAnd: 16r3F) bitShift: 6) +				(fourthByte bitAnd: 16r3F).			codePoint > 16r10FFFF "max code point"				ifTrue: [self errorBadCharacterValue: codePoint].			codePoint >= 16r10000				ifFalse: [self errorOverlongCodePoint: codePoint].			^ codePoint].	"the first byte is malformed"	self errorBadCharacterEncoding.! !!XMLUTF8StreamConverter methodsFor: 'encoding'!nextPut: aCharacter toStream: aStream	| codePoint |	(codePoint := aCharacter asInteger) < 16r80		ifTrue: [			aStream nextPut: codePoint.			^ self].	codePoint < 16r800		ifTrue: [			aStream				nextPut: 16rC0 + (codePoint bitShift: -6);				nextPut: 16r80 + (codePoint bitAnd: 16r003F).			^ self].	codePoint < 16r10000		ifTrue: [			"check for the reserved surrogate pair code points"			(codePoint >= 16rD800				and: [codePoint <= 16rDFFF])				ifTrue: [self errorBadCharacterValue: codePoint].			aStream				nextPut: 16rE0 + (codePoint bitShift: -12);				nextPut: 16r80 + ((codePoint bitShift: -6) bitAnd: 16r3F);				nextPut: 16r80 + (codePoint bitAnd: 16r3F).			^ self].	codePoint <= 16r10FFFF  "max code point"		ifTrue: [			aStream				nextPut: 16rF0 + (codePoint bitShift: -18);				nextPut: 16r80 + ((codePoint bitShift: -12) bitAnd: 16r3F);				nextPut: 16r80 + ((codePoint bitShift: -6) bitAnd: 16r3F);				nextPut: 16r80 + (codePoint bitAnd: 16r3F).			^ self].	self errorBadCharacterValue: codePoint.! !!XMLUTFStreamConverter class methodsFor: 'defaults'!abstractClass	^ XMLUTFStreamConverter! !!XMLUTFStreamConverter methodsFor: 'private'!errorBadCharacterValue: aValue	XMLEncodingException		formatSignal: 'Invalid {1} code point U+{1}'		with: self encoding		with: aValue printStringHex! !!XMLUTFStreamConverter methodsFor: 'basic'!nextCodePointFromStream: aStream	self subclassResponsibility! !!XMLUTFStreamConverter methodsFor: 'decoding'!nextFromStream: aStream	| codePoint |	codePoint := self nextCodePointFromStream: aStream.	[codePoint == 16rFEFF] "the BOM code point"		whileTrue: [			aStream atEnd				ifTrue: [^ nil].			codePoint := self nextCodePointFromStream: aStream].	^ codePoint		ifNotNil: [codePoint asCharacter].! !!XMLStreamConverter class methodsFor: 'defaults'!abstractClass	^ XMLStreamConverter! !!XMLStreamConverter class methodsFor: 'basic'!basicByteOrderMarkBytes	^ #[]! !!XMLStreamConverter class methodsFor: 'basic'!basicCanConvertEncoding: anEncodingName	^ self encodingNames includes: anEncodingName! !!XMLStreamConverter class methodsFor: 'basic'!basicEncodingNames	"encodingNames will have these names + upper/lowercase versions"	^ #()! !!XMLStreamConverter class methodsFor: 'accessing'!byteOrderMark	"avoid #asString and #newFrom: for GS portability"	^ String streamContents: [:stream |		self byteOrderMarkBytes do: [:each |			stream nextPut: each asCharacter]]! !!XMLStreamConverter class methodsFor: 'accessing'!byteOrderMarkBytes	^ self basicByteOrderMarkBytes asByteArray! !!XMLStreamConverter class methodsFor: 'testing'!canConvertEncoding: anEncodingName	"Returns true if the receiver can decode the encoding anEncodingName.	Lookup is case-insensitive."	"we could remove whitespace from anEncodingName too, but the	production rule for <?xml ...?> 'encoding' attributes disallows	whitespace, and the HTML parser removes it from <meta> charset	attributes before converting, so we just convert it to lowercase"	^ self isAbstractClass not		and: [self basicCanConvertEncoding: anEncodingName asLowercase]! !!XMLStreamConverter class methodsFor: 'accessing'!classForEncoding: anEncodingName	"avoid #at:ifAbsent: and #at:ifAbsentPut: so the cache isn't locked	during the class lookup, which could stall other processes"	self encodingNamesAndClassesCache		at: anEncodingName		ifPresent: [:classForEncoding | ^ classForEncoding].	"this will store the class as nil if it wasn't found to prevent future lookup"	^ self encodingNamesAndClassesCache		at: anEncodingName		put: (self findClassForEncoding: anEncodingName).! !!XMLStreamConverter class methodsFor: 'convenience'!decode: aStringOrByteArray	^ self new decode: aStringOrByteArray! !!XMLStreamConverter class methodsFor: 'convenience'!decodingOn: aReadStream	^ self new decodingOn: aReadStream! !!XMLStreamConverter class methodsFor: 'instance creation'!default	^ self defaultClass new! !!XMLStreamConverter class methodsFor: 'defaults'!defaultClass	^ XMLImplicitUTF8StreamConverter! !!XMLStreamConverter class methodsFor: 'defaults'!defaultEncoding	^ self defaultClass primaryEncodingName! !!XMLStreamConverter class methodsFor: 'convenience'!encode: aString	^ self new encode: aString! !!XMLStreamConverter class methodsFor: 'accessing'!encodingNames	^ encodingNames		ifNil: [			"assign the fully initialized object with #yourself to avoid			possible race conditions when reinitialization the class"			encodingNames :=				Set new					addAll: self basicEncodingNames;					addAll:						(self basicEncodingNames collect: [:each | each asLowercase]);					addAll:						(self basicEncodingNames collect: [:each | each asUppercase]);					yourself]! !!XMLStreamConverter class methodsFor: 'accessing'!encodingNames: aCollectionOrNil	encodingNames :=		aCollectionOrNil			ifNotNil: [aCollectionOrNil asSet]! !!XMLStreamConverter class methodsFor: 'private'!encodingNamesAndClassesCache	"a class variable so it's shared by all subclasses, but lazy initialized	so it isn't initialized unless needed"	^ EncodingNamesAndClassesCache		ifNil: [EncodingNamesAndClassesCache := XMLKeyValueCache maxSize: 128]! !!XMLStreamConverter class methodsFor: 'convenience'!encodingOn: aReadStream	^ self new encodingOn: aReadStream! !!XMLStreamConverter class methodsFor: 'private'!findClassForEncoding: anEncodingName	"check preferred classes first"	self preferredClasses do: [:each |		(each canConvertEncoding: anEncodingName)			ifTrue: [^ each]].	"avoid #withAllSubclassesDo: because it does not enumerate the receiver first"	(self isNonPreferredClassForEncoding: anEncodingName)		ifTrue: [^ self].	self allSubclassesDo: [:each |		(each isNonPreferredClassForEncoding: anEncodingName)			ifTrue: [^ each]].	^ nil.! !!XMLStreamConverter class methodsFor: 'class initialization'!initialize	"self initialize"	PreferredClasses := nil.	"reset to nil instead of just clearing to get full reinitialization"	EncodingNamesAndClassesCache := nil.! !!XMLStreamConverter class methodsFor: 'testing'!isAbstractClass	^ self == self abstractClass! !!XMLStreamConverter class methodsFor: 'testing'!isDefaultClass	^ self == self defaultClass! !!XMLStreamConverter class methodsFor: 'testing'!isImplicit	^ false! !!XMLStreamConverter class methodsFor: 'testing'!isNonPreferredClassForEncoding: anEncoding	^ self isPreferredClass not		and: [self canConvertEncoding: anEncoding]! !!XMLStreamConverter class methodsFor: 'testing'!isPreferredClass	^ self preferredClasses includes: self! !!XMLStreamConverter class methodsFor: 'instance creation'!newForEncoding: anEncodingName	(self classForEncoding: anEncodingName)		ifNil: [^ self null]		ifNotNil: [:converterClass |			^ converterClass new initializeForEncoding: anEncodingName]! !!XMLStreamConverter class methodsFor: 'instance creation'!null	^ self nullClass new! !!XMLStreamConverter class methodsFor: 'defaults'!nullClass	^ XMLNullStreamConverter! !!XMLStreamConverter class methodsFor: 'accessing'!preferredClasses	"A class var because it should be shared by all subclasses.	Assign the fully initialized object with #yourself to avoid	possible race conditions when reinitialization the class."	^ PreferredClasses		ifNil: [			PreferredClasses :=				IdentitySet new					addAll:						(XMLUTFStreamConverter allSubclasses reject: [:each |							each isAbstractClass								or: [each isImplicit]]);					add: XMLLatin1StreamConverter;					add: XMLASCIIStreamConverter;					yourself]! !!XMLStreamConverter class methodsFor: 'accessing'!preferredClasses: aCollectionOrNil	PreferredClasses :=		aCollectionOrNil			ifNotNil: [aCollectionOrNil asSet]! !!XMLStreamConverter class methodsFor: 'accessing'!primaryEncodingName	^ self basicEncodingNames		at: 1		ifAbsent: ['']! !!XMLStreamConverter methodsFor: 'converting'!asXMLStreamConverter	^ self! !!XMLStreamConverter methodsFor: 'convenience'!decode: aStringOrByteArray	^ (XMLDecodingReadStreamAdapter		on: aStringOrByteArray readStream		streamConverter: self)			contents! !!XMLStreamConverter methodsFor: 'convenience'!decodingOn: aReadStream	^ XMLDecodingReadStreamAdapter		on: aReadStream		streamConverter: self! !!XMLStreamConverter methodsFor: 'convenience'!encode: aString	^ (self encodingOn: (ByteArray new: aString size) writeStream)		nextPutAll: aString;		contents! !!XMLStreamConverter methodsFor: 'accessing'!encoding	^ self class primaryEncodingName! !!XMLStreamConverter methodsFor: 'convenience'!encodingOn: aWriteStream	^ (XMLEncodingWriteStreamAdapter		on: aWriteStream		streamConverter: self)			nextPutByteOrderMark;			yourself! !!XMLStreamConverter methodsFor: 'private'!errorBadCharacterEncoding	XMLEncodingException		formatSignal: 'Invalid {1} encoding for character'		with: self encoding! !!XMLStreamConverter methodsFor: 'private'!errorBadCharacterValue: aValue	XMLEncodingException		formatSignal: 'Invalid character 0x{1} for {2} encoding'		with: aValue printStringHex		with: self encoding! !!XMLStreamConverter methodsFor: 'initialization'!initializeForEncoding: anEncodingName! !!XMLStreamConverter methodsFor: 'testing'!isDefault	^ self class isDefaultClass! !!XMLStreamConverter methodsFor: 'testing'!isImplicit	^ self class isImplicit! !!XMLStreamConverter methodsFor: 'testing'!isNull	^ false! !!XMLStreamConverter methodsFor: 'decoding'!nextFromStream: aStream	self subclassResponsibility! !!XMLStreamConverter methodsFor: 'encoding'!nextPut: aCharacter toStream: aStream	self subclassResponsibility! !!XMLStreamConverter methodsFor: 'encoding'!nextPutByteOrderMarkToStream: aStream	self class byteOrderMarkBytes do: [:each |		aStream nextPut: each]! !!XMLStreamConverter methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: self encoding;		nextPut: $).! !!XMLStreamConverter methodsFor: 'printing'!printWithConvertableStream: aConvertableStream on: aPrintStream	aPrintStream		print: self;		nextPut: $(;		print: aConvertableStream;		nextPut: $)! !!XMLZincByteEncoderStreamConverter class methodsFor: 'basic'!basicCanConvertEncoding: anEncodingName	^ XMLClassFinder		classNamed: #ZnByteEncoder		ifPresent: [:zincByteEncoderClass |			zincByteEncoderClass handlesEncoding: anEncodingName]		ifAbsent: [false]! !!XMLZincByteEncoderStreamConverter class methodsFor: 'class initialization'!initialize	"self initialize"	NullReadStream := XMLNullReadStream new! !!XMLZincByteEncoderStreamConverter methodsFor: 'initialization'!initializeForEncoding: anEncodingName	zincByteEncoder :=		(XMLClassFinder classNamed: #ZnByteEncoder) newForEncoding: anEncodingName.	"we use an XMLStringReadStreamAdapter to transparently handle non-binary	character streams for ZnByteEncoder, which exepcts binary streams, and	since it's only ever set to a non-null stream during #nextFromStream:,	instances can still be shared by multiple streams, just not re-entrently,	which is OK since this class is explicitly stateful and so not	automatically thread-safe."	stringReadStreamAdapter :=		XMLStringReadStreamAdapter on: NullReadStream.! !!XMLZincByteEncoderStreamConverter methodsFor: 'decoding'!nextFromStream: aStream	"ZnByteEncoder does not check for #atEnd before sending #next"	aStream atEnd		ifTrue: [^ nil]		ifFalse: [| nextChar |			nextChar :=				zincByteEncoder nextFromStream:					(stringReadStreamAdapter on: aStream).			stringReadStreamAdapter on: NullReadStream.			^ nextChar]! !!XMLZincByteEncoderStreamConverter methodsFor: 'encoding'!nextPut: aCharacter toStream: aStream	zincByteEncoder		nextPut: aCharacter		toStream: aStream! !!XMLContentState methodsFor: 'testing'!isContentState	^ true! !!XMLContentState methodsFor: 'tokenizing'!nextTokenFrom: aTokenizer	^ aTokenizer nextContentToken! !!XMLExternalSubsetState methodsFor: 'testing'!isExternalSubsetState	^ true! !!XMLExternalSubsetState methodsFor: 'tokenizing'!nextTokenFrom: aTokenizer	^ aTokenizer nextExternalSubsetToken! !!XMLExternalSubsetTextDeclarationState methodsFor: 'tokenizing'!nextTokenFrom: aTokenizer	^ aTokenizer nextStartExternalSubset! !!XMLExternalSubsetTextDeclarationState methodsFor: 'testing'!supportsEncodingDetection	^ true! !!XMLDoctypeDeclarationState methodsFor: 'testing'!isDoctypeDeclarationState	^ true! !!XMLInternalSubsetState methodsFor: 'testing'!isInternalSubsetState	^ true! !!XMLInternalSubsetState methodsFor: 'tokenizing'!nextTokenFrom: aTokenizer	^ aTokenizer nextInternalSubsetToken! !!XMLPostDoctypeDeclarationState methodsFor: 'testing'!isPostDoctypeDeclarationState	^ true! !!XMLPrologState methodsFor: 'testing'!canTerminateInput	^ false! !!XMLPrologState methodsFor: 'testing'!isPrologState	^ true! !!XMLPrologState methodsFor: 'tokenizing'!nextTokenFrom: aTokenizer	^ aTokenizer nextPrologToken! !!XMLXMLDeclarationState methodsFor: 'testing'!isXMLDeclarationState	^ true! !!XMLXMLDeclarationState methodsFor: 'tokenizing'!nextTokenFrom: aTokenizer	^ aTokenizer nextXMLDeclarationOrPrologToken! !!XMLXMLDeclarationState methodsFor: 'testing'!supportsEncodingDetection	^ true! !!XMLTerminatedState methodsFor: 'testing'!isTerminatedState	^ true! !!XMLTerminatedState methodsFor: 'tokenizing'!nextTokenFrom: aTokenizer	^ aTokenizer nextEndDocument! !!XMLTokenizerState class methodsFor: 'accessing'!instance	^ instance		ifNil: [instance := self basicNew initialize]! !!XMLTokenizerState class methodsFor: 'instance creation'!new	"all subclasses are stateless and have a single, immutable, shared instance"	^ self instance! !!XMLTokenizerState methodsFor: 'testing'!canTerminateInput	^ true! !!XMLTokenizerState methodsFor: 'changing'!contentState	^ XMLContentState new! !!XMLTokenizerState methodsFor: 'changing'!doctypeDeclarationState	^ XMLDoctypeDeclarationState new! !!XMLTokenizerState methodsFor: 'changing'!externalSubsetState	^ XMLExternalSubsetState new! !!XMLTokenizerState methodsFor: 'changing'!internalSubsetState	^ XMLInternalSubsetState new! !!XMLTokenizerState methodsFor: 'testing'!isContentState	^ false! !!XMLTokenizerState methodsFor: 'testing'!isDoctypeDeclarationState	^ false! !!XMLTokenizerState methodsFor: 'testing'!isExternalSubsetState	^ false! !!XMLTokenizerState methodsFor: 'testing'!isInitializedState	^ true! !!XMLTokenizerState methodsFor: 'testing'!isInternalSubsetState	^ false! !!XMLTokenizerState methodsFor: 'testing'!isPostDoctypeDeclarationState	^ false! !!XMLTokenizerState methodsFor: 'testing'!isPrologState	^ false! !!XMLTokenizerState methodsFor: 'testing'!isTerminatedState	^ false! !!XMLTokenizerState methodsFor: 'testing'!isXMLDeclarationState	^ false! !!XMLTokenizerState methodsFor: 'tokenizing'!nextTokenFrom: aTokenizer	self subclassResponsibility! !!XMLTokenizerState methodsFor: 'changing'!postDoctypeDeclarationState	^ XMLPostDoctypeDeclarationState new! !!XMLTokenizerState methodsFor: 'changing'!prologState	^ XMLPrologState new! !!XMLTokenizerState methodsFor: 'testing'!supportsEncodingDetection	^ false! !!XMLTokenizerState methodsFor: 'changing'!terminatedState	^ XMLTerminatedState new! !!XMLUninitializedState methodsFor: 'testing'!isInitializedState	^ false! !!XMLUninitializedState methodsFor: 'tokenizing'!nextTokenFrom: aTokenizer	^ aTokenizer nextStartDocument! !!XMLURI class methodsFor: 'instance creation'!fromStream: aStream	"streams must be parsed eagerly (because the stream might be read from	or closed after), unlike strings"	^ self basicNew initialize parseURIStream: aStream! !!XMLURI class methodsFor: 'instance creation'!fromString: aString	^ self basicNew initialize uriString: aString! !!XMLURI class methodsFor: 'class initialization'!initialize	"self initialize"	"Assign the fully initialized object with #yourself to avoid	possible race conditions when reinitialization the class."	UnreservedCharacters :=		BitmapCharacterSet new			addRangeFrom: $a to: $z;			addRangeFrom: $A to: $Z;			addRangeFrom: $0 to: $9;			addAll: '-._~';			yourself! !!XMLURI class methodsFor: 'instance creation'!new	^ self fromString: ''! !!XMLURI class methodsFor: 'instance creation'!readFrom: aStringOrStream	aStringOrStream isStream		ifTrue: [^ self fromStream: aStringOrStream]		ifFalse: [^ self fromString: aStringOrStream]! !!XMLURI methodsFor: 'combining'!/ aURIOrURIString	"Returns the argument URI if it is absolute or the argument resolved in the	context of the receiver if it is relative, to do relative path resolution	or replace hosts, query strings, and other components."	^ self combinedWith: aURIOrURIString! !!XMLURI methodsFor: 'comparing'!= anObject	self == anObject		ifTrue: [^ true].	self species == anObject species		ifFalse: [^ false].	self scheme = anObject scheme		ifFalse: [^ false].	"#has* tests are used as an optimization to skip direclty comparing	components unless needed when doing so would require additional	decoding of the raw components"	self hasUserInfo		ifTrue: [			(anObject hasUserInfo				and: [self userInfo = anObject userInfo])				ifFalse: [^ false]]		ifFalse: [			anObject hasUserInfo				ifTrue: [^ false]].	self hasHost		ifTrue: [			(anObject hasHost				and: [self host = anObject host])				ifFalse: [^ false]]		ifFalse: [			anObject hasHost				ifTrue: [^ false]].	self port = anObject port		ifFalse: [^ false].	self hasPath		ifTrue: [			(anObject hasPath				and: [self pathSegments = anObject pathSegments])				ifFalse: [^ false]]		ifFalse: [			anObject hasPath				ifTrue: [^ false]].	self hasQuery		ifTrue: [			(anObject hasQuery				and: [self query = anObject query])				ifFalse: [^ false]]		ifFalse: [			anObject hasQuery				ifTrue: [^ false]].	self hasFragment		ifTrue: [			(anObject hasFragment				and: [self fragment = anObject fragment])				ifFalse: [^ false]]		ifFalse: [			anObject hasFragment				ifTrue: [^ false]].	^ true.! !!XMLURI methodsFor: 'private'!addRawDotPathSegment	self hasNonDirectoryPath		ifTrue: [self haveDirectoryPath]! !!XMLURI methodsFor: 'private'!addRawDoubleDotPathSegment	self hasPath		ifFalse: [^ self].	self hasRootPath		ifTrue: [self removeRawPathSegments]		ifFalse: [| hadAbsolutePath |			hadAbsolutePath := self hasAbsolutePath.			self hasDirectoryPath				ifTrue: [self removeLastRawPathSegment].			self hasPath				ifTrue: [					self removeLastRawPathSegment.					(self hasPath						or: [hadAbsolutePath])						ifTrue: [self haveDirectoryPath]]].! !!XMLURI methodsFor: 'private'!addRawPathSegment: aString	aString = '.'		ifTrue: [^ self addRawDotPathSegment].	aString = '..'		ifTrue: [^ self addRawDoubleDotPathSegment].	self hasPath		ifTrue: [			(self hasDirectoryPath				and: [self rawPathSegments size > 1])				ifTrue: [self removeLastRawPathSegment]]		ifFalse: [			self hasHost				ifTrue: [self rawPathSegments addLast: '']].	self rawPathSegments addLast: aString.! !!XMLURI methodsFor: 'private'!addRawPathSegmentsFrom: aURI	"copy before modifying"	self rawPathSegments: self rawPathSegments copy.	aURI hasAbsolutePath		ifTrue: [self removeRawPathSegments]		ifFalse: [			self hasNonDirectoryPath				ifTrue: [					self removeLastRawPathSegment.					self hasPath						ifTrue: [self haveDirectoryPath]]].	aURI rawPathSegments do: [:each | self addRawPathSegment: each].! !!XMLURI methodsFor: 'converting'!asRetrievableResource	^ self isLocal		ifTrue: [self asXMLFileHandle]		ifFalse: [self asXMLHTTPRequest]! !!XMLURI methodsFor: 'converting'!asString	"Returns the full, untruncated URI string, unlike #printString, which	may truncate"	^ self uriString		ifNil: [| writeStream |			writeStream := (String new: 64) writeStream.			self				printSchemeOn: writeStream;				printAuthorityPrefixOn: writeStream;				printAuthorityOn: writeStream;				printPathPrefixOn: writeStream;				printPathOn: writeStream;				printQueryOn: writeStream;				printFragmentOn: writeStream;				uriString: writeStream contents;				uriString]! !!XMLURI methodsFor: 'converting'!asXMLFileHandle	self isLocal		ifFalse: [self errorCannotConvertURIToFileHandle].	^ self path asXMLFileHandle.! !!XMLURI methodsFor: 'converting'!asXMLHTTPRequest	(self isHTTP		or: [self isHTTPS			or: [self isRelative]])		ifFalse: [self errorCannotConvertURIToHTTPRequest].	^ self asString asXMLHTTPRequest.! !!XMLURI methodsFor: 'converting'!asXMLURI	^ self! !!XMLURI methodsFor: 'combining'!combinedWith: aURIOrURIString	"Returns the argument URI if it is absolute or the argument resolved in the	context of the receiver if it is relative, to do relative path resolution	or replace hosts, query strings, and other components."	| uriToCombineWith |	(uriToCombineWith := aURIOrURIString asXMLURI) isEmpty		ifFalse: [			(uriToCombineWith isRelative)				ifTrue: [^ self combinedWithRelativeURI: uriToCombineWith]				ifFalse: [^ uriToCombineWith]]! !!XMLURI methodsFor: 'private'!combinedWithRelativeURI: aRelativeURI	| copy |	copy := self copy.	aRelativeURI hasUserInfo		ifTrue: [			^ copy				rawUserInfo: aRelativeURI rawUserInfo;				rawHost: aRelativeURI rawHost;				port: aRelativeURI port;				rawPathSegments: aRelativeURI rawPathSegments;				rawQuery: aRelativeURI rawQuery;				rawFragment: aRelativeURI rawFragment].	aRelativeURI hasHost		ifTrue: [			^ copy				rawHost: aRelativeURI rawHost;				port: aRelativeURI port;				rawPathSegments: aRelativeURI rawPathSegments;				rawQuery: aRelativeURI rawQuery;				rawFragment: aRelativeURI rawFragment].	aRelativeURI hasPort		ifTrue: [			^ copy				port: aRelativeURI port;				rawPathSegments: aRelativeURI rawPathSegments;				rawQuery: aRelativeURI rawQuery;				rawFragment: aRelativeURI rawFragment].	aRelativeURI hasPath		ifTrue: [			^ copy				addRawPathSegmentsFrom: aRelativeURI;				rawQuery: aRelativeURI rawQuery;				rawFragment: aRelativeURI rawFragment].	aRelativeURI hasQuery		ifTrue: [			^ copy				rawQuery: aRelativeURI rawQuery;				rawFragment: aRelativeURI rawFragment].	aRelativeURI hasFragment		ifTrue: [^ copy rawFragment: aRelativeURI rawFragment].! !!XMLURI methodsFor: 'copying'!copyWithFragment: aString	^ self copy rawFragment: (self percentEncode: aString)! !!XMLURI methodsFor: 'copying'!copyWithHost: aString	| copy |	copy := self copy.	(aString size > 0		and: [aString first == $[			and: [aString last == $]]])		ifTrue: [copy rawHost: aString]		ifFalse: [copy rawHost: (self percentEncode: aString)].	^ copy.! !!XMLURI methodsFor: 'copying'!copyWithPath: aString	| newRawPathSegments |	newRawPathSegments := self rawPathSegments copyEmpty.	$/		xmlSplit: aString		do: [:each |			newRawPathSegments addLast: (self percentEncode: each)].	^ self copy rawPathSegments: newRawPathSegments.! !!XMLURI methodsFor: 'copying'!copyWithPathSegments: aCollection	| newRawPathSegments |	newRawPathSegments := self rawPathSegments copyEmpty.	aCollection do: [:each |		newRawPathSegments addLast: (self percentEncode: each)].	^ self copy rawPathSegments: newRawPathSegments.! !!XMLURI methodsFor: 'copying'!copyWithPort: anInteger	^ self copy port: anInteger! !!XMLURI methodsFor: 'copying'!copyWithQuery: anAssociationCollection	| newRawQuery |	newRawQuery := OrderedCollection new: anAssociationCollection size.	anAssociationCollection associationsDo: [:each |		newRawQuery addLast:			(self percentAndPlusEncode: each key) ->				(self percentAndPlusEncode: each value)].	^ self copy rawQuery: newRawQuery.! !!XMLURI methodsFor: 'copying'!copyWithScheme: aString	^ self copy		scheme: aString;		hasAuthorityPrefix:			(self hasAuthorityPrefix				or: [self hasScheme not])! !!XMLURI methodsFor: 'copying'!copyWithUserInfo: aString	^ self copy rawUserInfo: (self percentEncode: aString)! !!XMLURI methodsFor: 'private'!errorCannotConvertURIToFileHandle	XMLFileException		formatSignal: 'Cannot convert non-local URI to file handle: {1}'		with: self asString! !!XMLURI methodsFor: 'private'!errorCannotConvertURIToHTTPRequest	XMLHTTPException		formatSignal: 'Cannot convert URI to HTTP request: {1}'		with: self asString! !!XMLURI methodsFor: 'accessing'!fragment	"Returns the percent-decoded URI fragment (everything after the '#') or	an empty string if there isn't one"	^ self percentDecode: self rawFragment! !!XMLURI methodsFor: 'resolving'!get	^ self asRetrievableResource get! !!XMLURI methodsFor: 'resolving'!getUpToLimit: aMaxSize decoding: aBoolean	^ self asRetrievableResource		getUpToLimit: aMaxSize		decoding: aBoolean! !!XMLURI methodsFor: 'testing'!hasAbsolutePath	^ self hasPath		and: [self rawPathSegments first isEmpty]! !!XMLURI methodsFor: 'testing'!hasAuthority	^ self hasUserInfo		or: [self hasHost			or: [self hasPort]]! !!XMLURI methodsFor: 'testing'!hasAuthorityPrefix	self parseURIStringIfUnparsed.	^ hasAuthorityPrefix.! !!XMLURI methodsFor: 'private'!hasAuthorityPrefix: aBoolean	hasAuthorityPrefix := aBoolean! !!XMLURI methodsFor: 'testing'!hasDirectoryPath	^ self hasPath		and: [self rawPathSegments last isEmpty]! !!XMLURI methodsFor: 'testing'!hasFragment	^ self rawFragment notEmpty! !!XMLURI methodsFor: 'testing'!hasHost	^ self rawHost notEmpty! !!XMLURI methodsFor: 'testing'!hasIPv6Host	^ self hasHost		and: [self rawHost first == $[			and: [self rawHost last == $]]]! !!XMLURI methodsFor: 'testing'!hasNonDirectoryPath	^ self hasPath		and: [self hasDirectoryPath not]! !!XMLURI methodsFor: 'testing'!hasPath	^ self rawPathSegments notEmpty! !!XMLURI methodsFor: 'testing'!hasPort	^ self port notNil! !!XMLURI methodsFor: 'testing'!hasQuery	^ self rawQuery notEmpty! !!XMLURI methodsFor: 'testing'!hasRootPath	^ self rawPathSegments size = 2		and: [self rawPathSegments allSatisfy: [:each | each isEmpty]]! !!XMLURI methodsFor: 'testing'!hasScheme	^ self scheme notEmpty! !!XMLURI methodsFor: 'testing'!hasUserInfo	^ self rawUserInfo notEmpty! !!XMLURI methodsFor: 'comparing'!hash	"ignores user-info and ports"	^ ((((self species hash bitXor:		self scheme hash) bitXor:			self host hash) bitXor:				self pathSegments hash) bitXor:					self query hash) bitXor:						self fragment hash! !!XMLURI methodsFor: 'private'!haveDirectoryPath	self hasPath		ifFalse: [self rawPathSegments addLast: ''].	self rawPathSegments addLast: ''.! !!XMLURI methodsFor: 'accessing'!host	"Returns the percent-decoded host or IPv6-style host or an empty string	if there isn't one"	self hasIPv6Host		ifTrue: [^ self rawHost]		ifFalse: [^ (self percentDecode: self rawHost) asLowercase]! !!XMLURI methodsFor: 'testing'!isEmpty	self hasScheme		ifTrue: [^ false].	self hasAuthority		ifTrue: [^ false].	self hasPath		ifTrue: [^ false].	self hasQuery		ifTrue: [^ false].	self hasFragment		ifTrue: [^ false].	^ true.! !!XMLURI methodsFor: 'testing'!isFile	^ self scheme = 'file'! !!XMLURI methodsFor: 'deprecated'!isFileURI	self deprecated: 'use #isFile instead'.	^ self isFile.! !!XMLURI methodsFor: 'testing'!isHTTP	^ self scheme = 'http'! !!XMLURI methodsFor: 'testing'!isHTTPS	^ self scheme = 'https'! !!XMLURI methodsFor: 'testing'!isLocal	^ self isFile		or: [self isRelative			and: [self hasHost not]]! !!XMLURI methodsFor: 'deprecated'!isLocalURI	self deprecated: 'use #isLocal instead'.	^ self isLocal.! !!XMLURI methodsFor: 'testing'!isRelative	^ self hasScheme not! !!XMLURI methodsFor: 'testing'!notEmpty	^ self isEmpty not! !!XMLURI methodsFor: 'private'!parseURIStream: aStream	| parser |	parser := XMLURIParser on: aStream.	self		scheme: parser parseScheme;		hasAuthorityPrefix: parser parseAuthorityPrefix.	(self hasScheme		or: [self hasAuthorityPrefix])		ifTrue: [			self				rawUserInfo: parser parseUserInfo;				rawHost: parser parseHost;				port: parser parsePort]		ifFalse: [			self				rawUserInfo: '';				rawHost: ''].	self		rawPathSegments: parser parsePathSegments;		rawQuery: parser parseQuery;		rawFragment: parser parseFragment.! !!XMLURI methodsFor: 'private'!parseURIStringIfUnparsed	scheme		ifNil: [self parseURIStream: self uriString readStream]! !!XMLURI methodsFor: 'accessing'!path	"Returns the percent-decoded path as a string"	self hasPath		ifTrue: [| writeStream |			writeStream := (String new: self rawPathSegments size * 10) writeStream.			self rawPathSegments				do: [:each | writeStream nextPutAll: (self percentDecode: each)]				separatedBy: [writeStream nextPut: $/].			^ writeStream contents]		ifFalse: [^ '']! !!XMLURI methodsFor: 'accessing'!pathSegments	"Returns a temporary OrderedCollection of percent-decoded path segments"	^ self rawPathSegments collect: [:each | self percentDecode: each]! !!XMLURI methodsFor: 'enumerating'!pathSegmentsDo: aBlock	self rawPathSegments do: [:each |		aBlock value: (self percentDecode: each)]! !!XMLURI methodsFor: 'private'!percentAndPlusDecode: aString	| readStream writeStream |	((aString includes: $%)		or: [aString includes: $+])		ifFalse: [^ aString].	readStream := aString readStream.	writeStream := (String new: aString size) writeStream.	[readStream atEnd]		whileFalse: [			readStream peek == $%				ifTrue: [					self						percentDecodeNextFrom: readStream						on: writeStream]				ifFalse: [| nextChar |					(nextChar := readStream next) == $+						ifTrue: [writeStream nextPut: Character space]						ifFalse: [writeStream nextPut: nextChar]]].	^ writeStream contents.! !!XMLURI methodsFor: 'private'!percentAndPlusEncode: aString	| writeStream |	writeStream := (String new: aString size) writeStream.	"use #to:do: for speed"	1 to: aString size do: [:i | | nextChar |		(UnreservedCharacters includes: (nextChar := aString at: i))			ifTrue: [					nextChar asciiValue = 32 "Character space asciiValue"					ifTrue: [writeStream nextPut: $+]					ifFalse: [writeStream nextPut: nextChar]]			ifFalse: [				(XMLEncodingWriteStreamAdapter on:					(XMLPercentEncodingWriteStreamAdapter on: writeStream))						nextPut: nextChar]].	^ writeStream contents.! !!XMLURI methodsFor: 'private'!percentDecode: aString	| readStream writeStream |	(aString includes: $%)		ifFalse: [^ aString].	readStream := aString readStream.	writeStream := (String new: aString size) writeStream.	[readStream atEnd]		whileFalse: [			readStream peek == $%				ifTrue: [					self						percentDecodeNextFrom: readStream						on: writeStream]				ifFalse: [writeStream nextPut: readStream next]].	^ writeStream contents.! !!XMLURI methodsFor: 'private'!percentDecodeNextFrom: aReadStream on: aWriteStream	| readStreamAdapter |	readStreamAdapter :=		XMLDecodingReadStreamAdapter			on: (XMLPercentDecodingReadStreamAdapter on: aReadStream).	[readStreamAdapter atEnd]		whileFalse: [aWriteStream nextPut: readStreamAdapter next].! !!XMLURI methodsFor: 'private'!percentEncode: aString	| writeStream |	writeStream := (String new: aString size) writeStream.	"use #to:do: for speed"	1 to: aString size do: [:i | | nextChar |		(UnreservedCharacters includes: (nextChar := aString at: i))			ifTrue: [writeStream nextPut: nextChar]			ifFalse: [				(XMLEncodingWriteStreamAdapter on:					(XMLPercentEncodingWriteStreamAdapter on: writeStream))					nextPut: nextChar]].	^ writeStream contents.! !!XMLURI methodsFor: 'accessing'!port	"Returns the integer port or nil if there isn't one"	self parseURIStringIfUnparsed.	^ port.! !!XMLURI methodsFor: 'private'!port: anInteger	port := anInteger! !!XMLURI methodsFor: 'copying'!postCopy	"the copyWith* methods modify copies, so any URI string of a copy must be parsed	if it hasn't been already and then cleared because it will be obsolete after a	URI component is changed"	self		parseURIStringIfUnparsed;		uriString: nil! !!XMLURI methodsFor: 'printing'!printAuthorityOn: aStream	self hasAuthority		ifTrue: [			self				printUserInfoOn: aStream;				printHostOn: aStream;				printPortOn: aStream]! !!XMLURI methodsFor: 'printing'!printAuthorityPrefixOn: aStream	(self hasAuthorityPrefix		or: [self hasScheme not and: [self hasAuthority]])		ifTrue: [aStream nextPutAll: '//']! !!XMLURI methodsFor: 'printing'!printFragmentOn: aStream	self hasFragment		ifTrue: [			aStream				nextPut: $#;				nextPutAll: self rawFragment]! !!XMLURI methodsFor: 'printing'!printHostOn: aStream	self hasHost		ifTrue: [aStream nextPutAll: self rawHost]! !!XMLURI methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self asString! !!XMLURI methodsFor: 'printing'!printPathOn: aStream	self rawPathSegments		do: [:each | aStream nextPutAll: each]		separatedBy: [aStream nextPut: $/]! !!XMLURI methodsFor: 'printing'!printPathPrefixOn: aStream	(self hasPath		and: [self hasAbsolutePath not			and: [self hasScheme or: [self hasAuthority]]])		ifTrue: [aStream nextPut: $/]! !!XMLURI methodsFor: 'printing'!printPortOn: aStream	self hasPort		ifTrue: [			aStream nextPut: $:.			port printOn: aStream]! !!XMLURI methodsFor: 'printing'!printQueryOn: aStream	| atBeginning |	self hasQuery		ifFalse: [^ self].		aStream nextPut: $?.	atBeginning := true.	self rawQuery do: [:each |		atBeginning			ifTrue: [atBeginning := false]			ifFalse: [aStream nextPut: $&].		aStream			nextPutAll: each key;			nextPut: $=;			nextPutAll: each value].! !!XMLURI methodsFor: 'printing'!printSchemeOn: aStream	self hasScheme		ifTrue: [			aStream				nextPutAll: self scheme;				nextPut: $:]! !!XMLURI methodsFor: 'printing'!printUserInfoOn: aStream	self hasUserInfo		ifTrue: [			aStream				nextPutAll: self rawUserInfo;				nextPut: $@]! !!XMLURI methodsFor: 'accessing'!query	"Returns a temporary OrderedCollection of percent/plus-decoded	query string key=value pairs"	^ self rawQuery collect: [:each |		(self percentAndPlusDecode: each key) ->			(self percentAndPlusDecode: each value)]! !!XMLURI methodsFor: 'accessing'!queryAt: aKey	"Returns the last percent/plus-decoded value of the query string	parameter aKey or an empty string if there isn't one"	^ self		queryAt: aKey		ifAbsent: ['']! !!XMLURI methodsFor: 'accessing'!queryAt: aKey ifAbsent: aBlock	"Returns the first percent/plus-decoded value of the query string	parameter aKey or the value of aBlock if there isn't one"	self rawQuery do: [:each |		(self percentAndPlusDecode: each key) = aKey			ifTrue: [^ self percentAndPlusDecode: each value]].	^ aBlock value.! !!XMLURI methodsFor: 'testing'!queryIncludesKey: aKey	self		queryAt: aKey		ifAbsent: [^ false].	^ true.! !!XMLURI methodsFor: 'accessing'!queryKeys	"Returns a SequenceableCollection of the unique percent/plus-decoded	query string parameter keys"	| keys |	keys := OrderedCollection new: self rawQuery size.	self queryKeysDo: [:each |		keys addLast: each].	^ keys.! !!XMLURI methodsFor: 'enumerating'!queryKeysAndValuesDo: aTwoArgumentBlock	self rawQuery do: [:each |		aTwoArgumentBlock			value: (self percentAndPlusDecode: each key)			value: (self percentAndPlusDecode: each value)]! !!XMLURI methodsFor: 'enumerating'!queryKeysDo: aBlock	self rawQuery do: [:each |		aBlock value: (self percentAndPlusDecode: each key)]! !!XMLURI methodsFor: 'accessing'!queryValuesAt: aKey	"Returns the percent/plus-decoded values of the query string parameter	aKey or an empty collection if there aren't any"	^ self		queryValuesAt: aKey		ifAbsent: [OrderedCollection new]! !!XMLURI methodsFor: 'enumerating'!queryValuesAt: aKey do: aBlock	self queryKeysAndValuesDo: [:key :value |		key = aKey			ifTrue: [aBlock value: value]]! !!XMLURI methodsFor: 'accessing'!queryValuesAt: aKey ifAbsent: aBlock	"Returns the percent/plus-decoded values of the query string parameter	aKey or the value of aBlock if there aren't any"	| values |	self		queryValuesAt: aKey		do: [:each |			"only initialize if needed"			(values ifNil: [values := OrderedCollection new])				addLast: each].	^ values ifNil: [aBlock value].! !!XMLURI methodsFor: 'accessing'!rawFragment	"Returns the raw URI fragment (everything after the '#') without	percent-decoding or an empty string if there isn't one"	self parseURIStringIfUnparsed.	^ rawFragment.! !!XMLURI methodsFor: 'private'!rawFragment: aString	rawFragment := aString! !!XMLURI methodsFor: 'accessing'!rawHost	"Returns the raw host without percent-decoding or the IPv6-style host	or an empty string if there isn't one"	self parseURIStringIfUnparsed.	^ rawHost.! !!XMLURI methodsFor: 'private'!rawHost: aString	rawHost := aString! !!XMLURI methodsFor: 'accessing'!rawPathSegments	"Returns an OrderedCollection of raw path segments without	percent-decoding"	self parseURIStringIfUnparsed.	^ rawPathSegments.! !!XMLURI methodsFor: 'private'!rawPathSegments: aPathSegmentCollection	rawPathSegments := aPathSegmentCollection! !!XMLURI methodsFor: 'accessing'!rawQuery	"Returns an OrderedCollection of raw query string key=value pairs	without percent/plus-decoding"	self parseURIStringIfUnparsed.	^ rawQuery.! !!XMLURI methodsFor: 'private'!rawQuery: anOrderedCollection	rawQuery := anOrderedCollection! !!XMLURI methodsFor: 'accessing'!rawUserInfo	self parseURIStringIfUnparsed.	^ rawUserInfo.! !!XMLURI methodsFor: 'private'!rawUserInfo: aString	rawUserInfo := aString! !!XMLURI methodsFor: 'private'!removeLastRawPathSegment	^ self rawPathSegments removeLast! !!XMLURI methodsFor: 'private'!removeRawPathSegments	self rawPathSegments removeAll! !!XMLURI methodsFor: 'accessing'!scheme	"Returns the URI scheme or an empty string if there isn't one"	self parseURIStringIfUnparsed.	^ scheme.! !!XMLURI methodsFor: 'private'!scheme: aString	scheme := aString! !!XMLURI methodsFor: 'resolving'!streamGet	^ self asRetrievableResource streamGet! !!XMLURI methodsFor: 'resolving'!streamGetUpToLimit: aMaxSize decoding: aBoolean	^ self asRetrievableResource		streamGetUpToLimit: aMaxSize		decoding: aBoolean! !!XMLURI methodsFor: 'private'!uriString	^ uriString! !!XMLURI methodsFor: 'private'!uriString: aString	uriString := aString! !!XMLURI methodsFor: 'accessing'!userInfo	^ self percentDecode: self rawUserInfo! !!XMLUnparsedEntityValidator class methodsFor: 'instance creation'!unparsedEntities: anUnparsedEntityDictionary notations: aNotationDictionary	^ self new		setUnparsedEntities: anUnparsedEntityDictionary		notations: aNotationDictionary! !!XMLUnparsedEntityValidator methodsFor: 'private'!errorMultipleDeclarationsForNotation: aNotation	XMLValidationException		formatSignal: 'Multiple declarations for notation "{1}"'		with: aNotation! !!XMLUnparsedEntityValidator methodsFor: 'private'!errorMultipleNotationAttributesForElement: anElement	XMLValidationException		formatSignal: 'Element <{1}> has multiple NOTATION list attributes'		with: anElement! !!XMLUnparsedEntityValidator methodsFor: 'private'!errorUndeclaredNotation: aNotation inAttribute: anAttribute	XMLValidationException		formatSignal: 'Undeclared notation "{1}" in NOTATION (...) attribute "{2}"'		with: aNotation		with: anAttribute! !!XMLUnparsedEntityValidator methodsFor: 'private'!errorUndeclaredNotation: aNotation inEntity: anEntity	XMLValidationException		formatSignal: 'Undeclared notation "{1}" referenced by <!!ENTITY {2} ...> declaration'		with: aNotation		with: anEntity! !!XMLUnparsedEntityValidator methodsFor: 'private'!errorUndeclaredUnparsedEntityReference: anEntity inAttribute: anAttriubute	XMLValidationException		formatSignal: 'Undeclared unparsed entity "{1}" in "{2}" attribute'		with: anEntity		with: anAttriubute! !!XMLUnparsedEntityValidator methodsFor: 'testing'!hasNotationAttributeValidators	"direct access to avoid lazy initialization"	^ notationAttributeValidators notNil		and: [notationAttributeValidators notEmpty]! !!XMLUnparsedEntityValidator methodsFor: 'accessing'!notationAttributeValidators	^ notationAttributeValidators ifNil: [notationAttributeValidators := Dictionary new]! !!XMLUnparsedEntityValidator methodsFor: 'accessing'!notations	^ notations ifNil: [notations := Dictionary new]! !!XMLUnparsedEntityValidator methodsFor: 'initialization'!setUnparsedEntities: anUnparsedEntityDictionary notations: aNotationDictionary	unparsedEntities := anUnparsedEntityDictionary.	notations := aNotationDictionary.! !!XMLUnparsedEntityValidator methodsFor: 'accessing'!unparsedEntities	^ unparsedEntities ifNil: [unparsedEntities := Dictionary new]! !!XMLUnparsedEntityValidator methodsFor: 'validating'!validateEntityReference: anEntity inAttribute: anAttribute	(self unparsedEntities includesKey: anEntity)		ifFalse: [			self				errorUndeclaredUnparsedEntityReference: anEntity				inAttribute: anAttribute]! !!XMLUnparsedEntityValidator methodsFor: 'validating'!validateNotationAttributeDeclaration: aNotationAttributeValidator	| oldSize |	"checking size after is faster than includes:"	oldSize := self notationAttributeValidators size.	(self notationAttributeValidators		at: aNotationAttributeValidator element		put: aNotationAttributeValidator;		size) > oldSize		ifFalse: [			self errorMultipleNotationAttributesForElement:				aNotationAttributeValidator element].! !!XMLUnparsedEntityValidator methodsFor: 'validating'!validateNotationAttributeDeclarationDefaults	"this validation has to be delayed until the entire DTD	is processed so notation attributes can be declared before	the notations referenced in their enumeration list are"	self notationAttributeValidators valuesDo: [:validator |		validator allowedValues do: [:each |			(self notations includesKey: each)				ifFalse: [					self						errorUndeclaredNotation: each						inAttribute: validator attribute]]]! !!XMLUnparsedEntityValidator methodsFor: 'validating'!validateUnparsedEntityDeclarations	"this validation has to be delayed until the entire DTD	is processed so unparsed entities can be declared before	the notation they reference are"	self unparsedEntities valuesDo: [:each |		(self notations includesKey: each ndata)			ifFalse: [				self					errorUndeclaredNotation: each ndata					inEntity: each name]]! !!XMLAttributeDictionary methodsFor: 'converting'!asXMLAttributeDictionary	^ self! !!XMLAttributeDictionary methodsFor: 'accessing'!associationAtName: aQualifiedOrLocalName	^ self		associationAtName: aQualifiedOrLocalName		ifAbsent: [nil]! !!XMLAttributeDictionary methodsFor: 'accessing'!associationAtName: aQualifiedOrLocalName ifAbsent: aBlock	^ self		associationAt: aQualifiedOrLocalName		ifAbsent: [			aQualifiedOrLocalName xmlPrefixBeforeLocalName isEmpty				ifTrue: [					self keysDo: [:each |						(each isXMLQualifiedOrLocalName: aQualifiedOrLocalName)							ifTrue: [^ self associationAt: each]]].			aBlock value]! !!XMLAttributeDictionary methodsFor: 'accessing'!associationAtName: aQualifiedOrLocalName namespaceURI: aURI	^ self		associationAtName: aQualifiedOrLocalName		namespaceURI: aURI		ifAbsent: [nil]! !!XMLAttributeDictionary methodsFor: 'accessing'!associationAtName: aQualifiedOrLocalName namespaceURI: aURI ifAbsent: aBlock	| namePrefix |	(namePrefix := aQualifiedOrLocalName xmlPrefixBeforeLocalName) isEmpty		ifTrue: [			"aQualifiedOrLocalName has no prefix, so check for an			attribute with a matching local name and namespace URI"			self keysDo: [:each |				(each isXMLQualifiedOrLocalName: aQualifiedOrLocalName)					ifTrue: [| keyPrefix |						(keyPrefix := each xmlPrefixBeforeLocalName) isEmpty							ifTrue: [								"unprefixed attribute have no namespace URI"								aURI isEmpty									ifTrue: [^ self associationAt: each]]							ifFalse: [								(self resolvePrefix: keyPrefix) = aURI									ifTrue: [^ self associationAt: each]]]]]		ifFalse: [			"aQualifiedOrLocalName is a qualified name, look it up exactly"			(self resolvePrefix: namePrefix) = aURI				ifTrue: [					^ self						associationAt: aQualifiedOrLocalName						ifAbsent: aBlock]].	^ aBlock value.! !!XMLAttributeDictionary methodsFor: 'private'!at: aKey newPut: aValue	"should be identical to StandardOrderedDictionary>>#at:put: except	it returns a boolean to tell if the key is new"	| oldSize |	oldSize := dictionary size.	dictionary		at: aKey		put: aValue.	dictionary size > oldSize		ifTrue: [			orderedKeys size > oldSize				ifFalse: [self growOrderedKeys].			orderedKeys at: oldSize + 1 put: aKey.			^ true].	^ false.! !!XMLAttributeDictionary methodsFor: 'accessing'!atName: aQualifiedOrLocalName	^ self		atName: aQualifiedOrLocalName		ifAbsent: ['']! !!XMLAttributeDictionary methodsFor: 'accessing'!atName: aQualifiedOrLocalName ifAbsent: aBlock	^ (self		associationAtName: aQualifiedOrLocalName		ifAbsent: [^ aBlock value])		ifNil: [aBlock value]		ifNotNil: [:association | association value]! !!XMLAttributeDictionary methodsFor: 'accessing'!atName: aQualifiedOrLocalName namespaceURI: aURI	^ self		atName: aQualifiedOrLocalName		namespaceURI: aURI		ifAbsent: ['']! !!XMLAttributeDictionary methodsFor: 'accessing'!atName: aQualifiedOrLocalName namespaceURI: aURI ifAbsent: aBlock	^ (self		associationAtName: aQualifiedOrLocalName		namespaceURI: aURI)		ifNil: [aBlock value]		ifNotNil: [:association | association value]! !!XMLAttributeDictionary methodsFor: 'private'!namespaceScope	^ nil! !!XMLAttributeDictionary methodsFor: 'accessing'!namespaceURIOf: aKey	"Returns the namespace URI of the attribute name aKey"	| prefix |	^ (self usesNamespaces		and: [(prefix := aKey xmlPrefixBeforeLocalName) notEmpty])		ifTrue: [self resolvePrefix: prefix]		ifFalse: ['']! !!XMLAttributeDictionary methodsFor: 'private'!resolvePrefix: aPrefix	^ self		resolvePrefix: aPrefix		ifUnresolvable: ''! !!XMLAttributeDictionary methodsFor: 'private'!resolvePrefix: aPrefix ifUnresolvable: aBlock	^ aBlock value! !!XMLAttributeDictionary methodsFor: 'initialization'!setNamespaceScope: aNamespaceScope! !!XMLAttributeDictionary methodsFor: 'testing'!usesNamespaces	^ false! !!XMLNamespacedAttributeDictionary methodsFor: 'private'!namespaceScope	^ namespaceScope ifNil: [namespaceScope := XMLNamespaceScope new]! !!XMLNamespacedAttributeDictionary methodsFor: 'private'!resolvePrefix: aPrefix ifUnresolvable: aBlock	^ self namespaceScope		resolvePrefix: aPrefix		ifUnresolvable: aBlock! !!XMLNamespacedAttributeDictionary methodsFor: 'initialization'!setNamespaceScope: aNamespaceScope	namespaceScope := aNamespaceScope! !!XMLNamespacedAttributeDictionary methodsFor: 'testing'!usesNamespaces	^ true! !!String methodsFor: '*XML-Parser'!asXMLEscapedString	"returns a copy of self with &, <, and > escaped with &amp;, &lt;, and &gt;"	| stream |	stream := (self class new: self size) writeStream.	"to:do: for performance"	1 to: self size do: [:i | | nextChar |		(nextChar := self at: i) == $<			ifTrue: [stream nextPutAll: '&lt;']			ifFalse: [				nextChar == $> "needed to escape ]]> in PCDATA"					ifTrue: [stream nextPutAll: '&gt;']					ifFalse: [						nextChar == $&							ifTrue: [stream nextPutAll: '&amp;']							ifFalse: [stream nextPut: nextChar]]]].	^ stream contents.! !!String methodsFor: '*XML-Parser'!asXMLFileHandle	^ XMLFileHandle path: self! !!String methodsFor: '*XML-Parser'!asXMLHTTPRequest	^ XMLHTTPRequest url: self! !!String methodsFor: '*XML-Parser'!asXMLStreamConverter	^ XMLStreamConverter newForEncoding: self! !!String methodsFor: '*XML-Parser'!asXMLString	"will be deprecated; use #asXMLStringNode instead"	^ self asXMLStringNode! !!String methodsFor: '*XML-Parser'!asXMLStringNode	^ XMLString string: self! !!String methodsFor: '*XML-Parser'!asXMLURI	^ XMLURI fromString: self! !!String methodsFor: '*XML-Parser'!expandWithXMLNamespaceURI: aURI	"optimized"	aURI size == 0		ifTrue: [^ self]		ifFalse: [^ 'Q{', aURI, '}', self]! !!String methodsFor: '*XML-Parser'!isXMLNCName	"optimized"	self size == 0		ifTrue: [^ false].	(self at: 1) isXMLNCNameStartChar		ifFalse: [^ false].	2 to: self size do: [:i |		(self at: i) isXMLNCNameChar			ifFalse: [^ false]].	^ true.! !!String methodsFor: '*XML-Parser'!isXMLNSAttributeName	"optimized"	self size >= 5		ifFalse: [^ false].	(self at: 1) == $x		ifFalse: [^ false].	(self at: 2) == $m		ifFalse: [^ false].	(self at: 3) == $l		ifFalse: [^ false].	(self at: 4) == $n		ifFalse: [^ false].	(self at: 5) == $s		ifFalse: [^ false].	self size == 5		ifTrue: [^ true].	^ (self at: 6) == $:.! !!String methodsFor: '*XML-Parser'!isXMLName	"optimized"	self size == 0		ifTrue: [^ false].	(self at: 1) isXMLNameStartChar		ifFalse: [^ false].	2 to: self size do: [:i |		(self at: i) isXMLNameChar			ifFalse: [^ false]].	^ true.! !!String methodsFor: '*XML-Parser'!isXMLNmtoken	"optimized"	self size == 0		ifTrue: [^ false].	1 to: self size do: [:i |		(self at: i) isXMLNameChar			ifFalse: [^ false]].	^ true.! !!String methodsFor: '*XML-Parser'!isXMLQualifiedOrLocalName: aQualifiedOrLocalName	"returns true if self and aQualifiedOrLocalName are the	same QName or if self is a QName and aQualifiedOrLocalName	is the local part, or if they are the same NCName."	| i |	i := aQualifiedOrLocalName size.	self size to: 1 by: -1 do: [:j |		i == 0			ifTrue: [^ (self at: j) == $:].		"avoid #== for compatibility with pre-Spur VMs where wide chars		aren't an immediate type"		(aQualifiedOrLocalName at: i) = (self at: j)			ifFalse: [^ false].		i := i - 1].	^ i == 0.! !!String methodsFor: '*XML-Parser'!isXMLReservedAttributeName	"optimized"	self size > 3		ifFalse: [^ false].	(self at: 1) == $x		ifFalse: [^ false].	(self at: 2) == $m		ifFalse: [^ false].	^ (self at: 3) == $l.! !!String methodsFor: '*XML-Parser'!isXMLWhitespace	"optimized"	self size == 0		ifTrue: [^ false].	1 to: self size do: [:i |		(self at: i) isXMLWhitespace			ifFalse: [^ false]].	^ true.! !!String methodsFor: '*XML-Parser'!parseXML	^ XMLDOMParser parse: self! !!String methodsFor: '*XML-Parser'!qualifyWithXMLPrefix: aPrefix	"optimized"	aPrefix size == 0		ifTrue: [^ self]		ifFalse: [^ (aPrefix copyWith: $:), self]! !!String methodsFor: '*XML-Parser'!xmlCopyWithoutWhitespace	^ self reject: [:each | each isXMLWhitespace]! !!String methodsFor: '*XML-Parser'!xmlLocalNameAfterPrefix	^ self xmlLocalNameAfterPrefix: self xmlPrefixBeforeLocalName! !!String methodsFor: '*XML-Parser'!xmlLocalNameAfterPrefix: aPrefix	"optimized"	| prefixSize |	(prefixSize := aPrefix size) == 0		ifTrue: [^ self]		ifFalse: [^ self copyFrom: prefixSize + 2 to: self size]! !!String methodsFor: '*XML-Parser'!xmlPrefixBeforeLocalName	"optimized"	| i |	i := self size.	[i == 0]		whileFalse: [			((self at: i) == $:)				ifTrue: [^ (self copyFrom: 1 to: i - 1)].			i := i - 1].	^ ''.! !!String methodsFor: '*XML-Parser'!xmlPrefixBeforeLocalName: aLocalName	"optimized"	| prefixSize |	(prefixSize := self size - aLocalName size - 1) > 0		ifTrue: [^ self copyFrom: 1 to: prefixSize]		ifFalse: [^ '']! !!UndefinedObject methodsFor: '*XML-Parser'!isXMLChar	"hack optimization to avoid testing for nil before sending	this to objects from streams in XMLParser"	^ false! !!UndefinedObject methodsFor: '*XML-Parser'!isXMLNCNameChar	"hack optimization to avoid testing for nil before sending	this to objects from streams in XMLParser"	^ false! !!UndefinedObject methodsFor: '*XML-Parser'!isXMLNCNameStartChar	"hack optimization to avoid testing for nil before sending	this to objects from streams in XMLParser"	^ false! !!UndefinedObject methodsFor: '*XML-Parser'!isXMLNameChar	"hack optimization to avoid testing for nil before sending	this to objects from streams in XMLParser"	^ false! !!UndefinedObject methodsFor: '*XML-Parser'!isXMLNameStartChar	"hack optimization to avoid testing for nil before sending	this to objects from streams in XMLParser"	^ false! !!UndefinedObject methodsFor: '*XML-Parser'!isXMLSeparator	"hack optimization to avoid testing for nil before sending	this to objects from streams in XMLParser"	^ false! !!UndefinedObject methodsFor: '*XML-Parser'!isXMLWhitespace	"hack optimization to avoid testing for nil before sending	this to objects from streams in XMLParser"	^ false! !!Character class methodsFor: '*XML-Parser'!xmlSeparators	^ String		with: 32 asCharacter "space"		with: 10 asCharacter "lf"		with: 9 asCharacter "tab"		with: 13 asCharacter "cr"! !!Character class methodsFor: '*XML-Parser'!xmlWhitespace	^ self xmlSeparators copyWith: 12 asCharacter "form feed"! !!Character methodsFor: '*XML-Parser'!isXMLChar	"Range tests are faster and use less memory than a BitmapCharacterSet, and	a temp is used because Character in newer SpurVM images has no 'value'	inst var.		Char ::=		#x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]"	| tempValue |	(tempValue := self asciiValue) >= 16r20		ifTrue: [			"most chars should be in the range 16r20-16rD7FF"			tempValue <= 16rD7FF				ifTrue: [^ true].				tempValue <= 16rFFFD				ifTrue: [^ tempValue >= 16rE000].			tempValue >= 16r10000				ifFalse: [^ false].			^ tempValue <= 16r10FFFF].	tempValue == 16r9		ifTrue: [^ true].	tempValue == 16rA		ifTrue: [^ true].	^ tempValue == 16rD.! !!Character methodsFor: '*XML-Parser'!isXMLNCNameChar	"should be the same as isXMLNameChar except without a test for $:"	| tempValue |	(tempValue := self asciiValue) <= 16r7A "$z asciiValue hex"		ifTrue: [			tempValue >= 16r61 "$a asciiValue hex"				ifTrue: [^ true].			tempValue >= 16r41 "$A asciiValue hex"				ifTrue: [					tempValue <= 16r5A "$Z asciiValue hex"						ifTrue: [^ true].					^ tempValue == 16r5F]. "$_ asciiValue hex"			tempValue >= 16r30 "$0 asciiValue hex"				ifTrue: [^ tempValue <= 16r39]. "$9 asciiValue hex; no $: test"			tempValue == 16r2D "$- asciiValue hex"				ifTrue: [^ true].			^ tempValue == 16r2E]. "$. asciiValue hex"	tempValue <= 16r2040		ifTrue: [			tempValue <= 16r36F				ifTrue: [						tempValue <= 16rF6						ifTrue: [							tempValue <= 16rD6								ifFalse: [^ tempValue >= 16rD8].							tempValue >= 16rC0								ifTrue: [^ true].							^ tempValue == 16rB7]						ifFalse: [							tempValue <= 16r2FF								ifTrue: [^ tempValue >= 16rF8].							^ tempValue >= 16r300]]				ifFalse: [					tempValue <= 16r1FFF						ifTrue: [								tempValue <= 16r37D								ifFalse: [^ tempValue >= 16r37F].							^ tempValue >= 16r370]						ifFalse: [							tempValue <= 16r200D								ifTrue: [^ tempValue >= 16r200C].							^ tempValue >= 16r203F]]]	ifFalse: [		tempValue <= 16rD7FF			ifTrue: [				tempValue >= 16r2C00					ifTrue: [						tempValue >= 16r3001							ifTrue: [^ true].						^ tempValue <= 16r2FEF]					ifFalse: [						tempValue <= 16r218F							ifFalse: [^ false].						^ tempValue >= 16r2070]]			ifFalse: [				tempValue <= 16rFFFD					ifTrue: [						tempValue <= 16rFDCF							ifTrue: [^ tempValue >= 16rF900].						^ tempValue >= 16rFDF0]					ifFalse: [						tempValue >= 16r10000							ifFalse: [^ false].						^ tempValue <= 16rEFFFF]]].! !!Character methodsFor: '*XML-Parser'!isXMLNCNameStartChar	"should be the same as isXMLNameStartChar except without a test for $:"	| tempValue |	(tempValue := self asciiValue) <= 16r7A "$z asciiValue hex"		ifTrue: [			tempValue >= 16r61 "$a asciiValue hex"				ifTrue: [^ true].			tempValue <= 16r5A "$Z asciiValue hex"				ifTrue: [^ tempValue >= 16r41]. "$A asciiValue hex"			^ tempValue == 16r5F]. "$_ asciiValue hex; no $: test"	tempValue <= 16r200D		ifTrue: [			tempValue <= 16r2FF				ifTrue: [					tempValue >= 16rD8						ifTrue: [							tempValue >= 16rF8								ifTrue: [^ true].							^ tempValue <= 16rF6]						ifFalse: [							tempValue >= 16rC0								ifFalse: [^ false].							^ tempValue <= 16rD6]]				ifFalse: [					tempValue >= 16r37F						ifTrue: [							tempValue >= 16r200C								ifTrue: [^ true].							^ tempValue <= 16r1FFF]						ifFalse: [							tempValue <= 16r37D								ifFalse: [^ false].							^ tempValue >= 16r370]]]	ifFalse: [		tempValue <= 16rD7FF			ifTrue: [				tempValue >= 16r2C00					ifTrue: [						tempValue >= 16r3001							ifTrue: [^ true].						^ tempValue <= 16r2FEF]					ifFalse: [						tempValue <= 16r218F							ifFalse: [^ false].						^ tempValue >= 16r2070]]			ifFalse: [				tempValue >= 16rFDF0					ifTrue: [						tempValue >= 16r10000							ifTrue: [^ tempValue <= 16rEFFFF].						^ tempValue <= 16rFFFD]					ifFalse: [						tempValue <= 16rFDCF							ifFalse: [^ false].						^ tempValue >= 16rF900]]].! !!Character methodsFor: '*XML-Parser'!isXMLNameChar	"Range tests are faster and use less memory than a BitmapCharacterSet, and	a temp is used because Character in newer SpurVM images has no 'value'	inst var.		NameStartChar ::=		':' | [A-Z] | '_' | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] |		[#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] |		[#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] |		[#x10000-#xEFFFF]	NameChar ::=		NameStartChar | '-' | '.' | [0-9] | #xB7 | [#x0300-#x036F] |		[#x203F-#x2040]"	| tempValue |	(tempValue := self asciiValue) <= 16r7A "$z asciiValue hex"		ifTrue: [			tempValue >= 16r61 "$a asciiValue hex"				ifTrue: [^ true].			tempValue >= 16r41 "$A asciiValue hex"				ifTrue: [					tempValue <= 16r5A "$Z asciiValue hex"						ifTrue: [^ true].					^ tempValue == 16r5F]. "$_ asciiValue hex"			tempValue >= 16r30 "$0 asciiValue hex"				ifTrue: [					tempValue <= 16r39 "$9 asciiValue hex"						ifTrue: [^ true].					^ tempValue == 16r3A]. "$: asciiValue hex"			tempValue == 16r2D "$- asciiValue hex"				ifTrue: [^ true].			^ tempValue == 16r2E]. "$. asciiValue hex"	tempValue <= 16r2040		ifTrue: [			tempValue <= 16r36F				ifTrue: [						tempValue <= 16rF6						ifTrue: [							tempValue <= 16rD6								ifFalse: [^ tempValue >= 16rD8].							tempValue >= 16rC0								ifTrue: [^ true].							^ tempValue == 16rB7]						ifFalse: [							tempValue <= 16r2FF								ifTrue: [^ tempValue >= 16rF8].							^ tempValue >= 16r300]]				ifFalse: [					tempValue <= 16r1FFF						ifTrue: [								tempValue <= 16r37D								ifFalse: [^ tempValue >= 16r37F].							^ tempValue >= 16r370]						ifFalse: [							tempValue <= 16r200D								ifTrue: [^ tempValue >= 16r200C].							^ tempValue >= 16r203F]]]	ifFalse: [		tempValue <= 16rD7FF			ifTrue: [				tempValue >= 16r2C00					ifTrue: [						tempValue >= 16r3001							ifTrue: [^ true].						^ tempValue <= 16r2FEF]					ifFalse: [						tempValue <= 16r218F							ifFalse: [^ false].						^ tempValue >= 16r2070]]			ifFalse: [				tempValue <= 16rFFFD					ifTrue: [						tempValue <= 16rFDCF							ifTrue: [^ tempValue >= 16rF900].						^ tempValue >= 16rFDF0]					ifFalse: [						tempValue >= 16r10000							ifFalse: [^ false].						^ tempValue <= 16rEFFFF]]].! !!Character methodsFor: '*XML-Parser'!isXMLNameStartChar	"Range tests are faster and use less memory than a BitmapCharacterSet, and	a temp is used because Character in newer SpurVM images has no 'value'	inst var.		NameStartChar ::=		':' | [A-Z] | '_' | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] |		[#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] |		[#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] |		[#x10000-#xEFFFF]"	| tempValue |	(tempValue := self asciiValue) <= 16r7A "$z asciiValue hex"		ifTrue: [			tempValue >= 16r61 "$a asciiValue hex"				ifTrue: [^ true].			tempValue >= 16r41 "$A asciiValue hex"				ifTrue: [					tempValue <= 16r5A "$Z asciiValue hex"						ifTrue: [^ true].					^ tempValue == 16r5F]. "$_ asciiValue hex"				^ tempValue == 16r3A]. "$: asciiValue hex"	tempValue <= 16r200D		ifTrue: [			tempValue <= 16r2FF				ifTrue: [					tempValue >= 16rD8						ifTrue: [							tempValue >= 16rF8								ifTrue: [^ true].							^ tempValue <= 16rF6]						ifFalse: [							tempValue >= 16rC0								ifFalse: [^ false].							^ tempValue <= 16rD6]]				ifFalse: [					tempValue >= 16r37F						ifTrue: [							tempValue >= 16r200C								ifTrue: [^ true].							^ tempValue <= 16r1FFF]						ifFalse: [							tempValue <= 16r37D								ifFalse: [^ false].							^ tempValue >= 16r370]]]	ifFalse: [		tempValue <= 16rD7FF			ifTrue: [				tempValue >= 16r2C00					ifTrue: [						tempValue >= 16r3001							ifTrue: [^ true].						^ tempValue <= 16r2FEF]					ifFalse: [						tempValue <= 16r218F							ifFalse: [^ false].						^ tempValue >= 16r2070]]			ifFalse: [				tempValue >= 16rFDF0					ifTrue: [						tempValue >= 16r10000							ifTrue: [^ tempValue <= 16rEFFFF].						^ tempValue <= 16rFFFD]					ifFalse: [						tempValue <= 16rFDCF							ifFalse: [^ false].						^ tempValue >= 16rF900]]].! !!Character methodsFor: '*XML-Parser'!isXMLSeparator	"a temp is used because Character in newer SpurVM images	has no 'value' inst var"	| tempValue |	(tempValue := self asciiValue) == 32 "space"		ifTrue: [^ true].	tempValue == 10 "line feed"		ifTrue: [^ true].	tempValue == 9 "tab"		ifTrue: [^ true].	^ tempValue == 13. "carriage return; no form feeds"! !!Character methodsFor: '*XML-Parser'!isXMLWhitespace	"a temp is used because Character in newer SpurVM images	has no 'value' inst var"	| tempValue |	(tempValue := self asciiValue) == 32 "space"		ifTrue: [^ true].	tempValue == 10 "line feed"		ifTrue: [^ true].	tempValue == 9 "tab"		ifTrue: [^ true].	tempValue == 13 "carriage return"		ifTrue: [^ true].	^ tempValue == 12. "form feed"! !!Character methodsFor: '*XML-Parser'!xmlSplit: aString	"faster, portable version"	| parts |	parts := OrderedCollection new.	self		xmlSplit: aString		do: [:each | parts addLast: each].	^ parts.! !!Character methodsFor: '*XML-Parser'!xmlSplit: aString do: aBlock	"faster, portable version"	| start |	start := 1.	1 to: aString size do: [:end |		"avoid #== for compatibility with pre-Spur VMs where wide chars		aren't an immediate type"		(aString at: end) = self			ifTrue: [				aBlock value: (aString copyFrom: start to: end - 1).				start := end + 1]].	start > aString size		ifTrue: [			"either aString is empty or it ends with self"			aBlock value: '']		ifFalse: [aBlock value: (aString copyFrom: start to: aString size)].! !!Error methodsFor: '*XML-Parser'!isXMLParserException	^ false! !!XMLException class methodsFor: 'signalling'!formatSignal: aString with: aFirstValue	^ self new		formatSignal: aString		with: aFirstValue! !!XMLException class methodsFor: 'signalling'!formatSignal: aString with: aFirstValue with: aSecondValue	^ self new		formatSignal: aString		with: aFirstValue		with: aSecondValue! !!XMLException class methodsFor: 'signalling'!formatSignal: aString with: aFirstValue with: aSecondValue with: aThirdValue	^ self new		formatSignal: aString		with: aFirstValue		with: aSecondValue		with: aThirdValue! !!XMLException class methodsFor: 'signalling'!formatSignal: aString with: aFirstValue with: aSecondValue with: aThirdValue with: aFourthValue	^ self new		formatSignal: aString		with: aFirstValue		with: aSecondValue		with: aThirdValue		with: aFourthValue! !!XMLException class methodsFor: 'signalling'!formatSignal: aString withArguments: anArray	^ self new		formatSignal: aString		withArguments: anArray! !!XMLException class methodsFor: 'signalling'!signalMessageFrom: anException	^ self new signalMessageFrom: anException! !!XMLException methodsFor: 'accessing'!formatMessage: aString with: aFirstValue	self		formatMessage: aString		withArguments: (Array with: aFirstValue)! !!XMLException methodsFor: 'accessing'!formatMessage: aString with: aFirstValue with: aSecondValue	self		formatMessage: aString		withArguments:			(Array				with: aFirstValue				with: aSecondValue)! !!XMLException methodsFor: 'accessing'!formatMessage: aString with: aFirstValue with: aSecondValue with: aThirdValue	self		formatMessage: aString		withArguments:			(Array				with: aFirstValue				with: aSecondValue				with: aThirdValue)! !!XMLException methodsFor: 'accessing'!formatMessage: aString with: aFirstValue with: aSecondValue with: aThirdValue with: aFourthValue	self		formatMessage: aString		withArguments:			(Array				with: aFirstValue				with: aSecondValue				with: aThirdValue				with: aFourthValue)! !!XMLException methodsFor: 'accessing'!formatMessage: aString withArguments: anArray	self messageText: (aString format: anArray)! !!XMLException methodsFor: 'signaling'!formatSignal: aString with: aFirstValue	self		formatMessage: aString		with: aFirstValue.	^ self signal.! !!XMLException methodsFor: 'signaling'!formatSignal: aString with: aFirstValue with: aSecondValue	self		formatMessage: aString		with: aFirstValue		with: aSecondValue.	^ self signal.! !!XMLException methodsFor: 'signaling'!formatSignal: aString with: aFirstValue with: aSecondValue with: aThirdValue	self		formatMessage: aString		with: aFirstValue		with: aSecondValue		with: aThirdValue.	^ self signal.! !!XMLException methodsFor: 'signaling'!formatSignal: aString with: aFirstValue with: aSecondValue with: aThirdValue with: aFourthValue	self		formatMessage: aString		with: aFirstValue		with: aSecondValue		with: aThirdValue		with: aFourthValue.	^ self signal.! !!XMLException methodsFor: 'signaling'!formatSignal: aString withArguments: anArray	self		formatMessage: aString		withArguments: anArray.	^ self signal.! !!XMLException methodsFor: 'accessing'!inheritMessageFrom: anException	self		formatMessage: '({1}) {2}'		with: anException class name		with: anException messageText! !!XMLException methodsFor: 'signaling'!signalMessageFrom: anException	self inheritMessageFrom: anException.	^  self signal.! !!XMLParserException methodsFor: 'accessing'!baseURI	^ baseURI ifNil: [baseURI := '']! !!XMLParserException methodsFor: 'accessing'!baseURI: aURIString	baseURI := aURIString! !!XMLParserException methodsFor: 'accessing'!columnNumber	^ columnNumber! !!XMLParserException methodsFor: 'accessing'!columnNumber: aColumnNumber	columnNumber := aColumnNumber! !!XMLParserException methodsFor: 'testing'!hasBaseURI	^ self baseURI notEmpty! !!XMLParserException methodsFor: 'testing'!hasColumnNumber	^ self columnNumber notNil! !!XMLParserException methodsFor: 'testing'!hasLineNumber	^ self lineNumber notNil! !!XMLParserException methodsFor: 'testing'!isXMLParserException	^ true! !!XMLParserException methodsFor: 'accessing'!lineNumber	^ lineNumber! !!XMLParserException methodsFor: 'accessing'!lineNumber: aLineNumber	lineNumber := aLineNumber! !!XMLParserException methodsFor: 'accessing'!messageText	| rawMessageText messageTextStream |	rawMessageText := super messageText.	(self hasLineNumber		or: [self hasBaseURI])		ifFalse: [^ rawMessageText].	(messageTextStream := (String new: rawMessageText size * 2) writeStream)		nextPutAll: rawMessageText;		nextPutAll: ' ('.	self hasLineNumber		ifTrue: [			messageTextStream				nextPutAll: 'near line ';				nextPutAll: self lineNumber asString.			self hasColumnNumber				ifTrue: [					messageTextStream						nextPutAll: ', column ';						nextPutAll: self columnNumber asString]].	self hasBaseURI		ifTrue: [			messageTextStream				nextPutAll:					(self hasLineNumber						ifTrue: [' in ']						ifFalse: ['in ']);				nextPutAll: self baseURI].				^ messageTextStream		nextPut: $);		contents.! !!XMLParserException methodsFor: 'testing'!shouldPassOnWhenCaught	^ true! !!XMLParsingInterruptException methodsFor: 'testing'!shouldPassOnWhenCaught	^ false! !!Stream methodsFor: '*XML-Parser'!isXMLBinaryOrExternalStream	^ self isBinary! !!Stream methodsFor: '*XML-Parser'!parseXML	^ XMLDOMParser parse: self! !!Collection methodsFor: '*XML-Parser'!asXMLAttributeDictionary	^ XMLAttributeDictionary newFrom: self! !!Collection methodsFor: '*XML-Parser'!asXMLAttributeSpec	^ XMLBasicAttributeSpec attributes: self! !!Collection methodsFor: '*XML-Parser'!includesXMLName: aName	"optimized with do: instead of anySatisfy:"	self do: [:each |		(aName isXMLQualifiedOrLocalName: each)			ifTrue: [^ true]].	^ false.! !!XMLLazyAttributeDictionary class methodsFor: 'private'!emptyAttributeDictionary	^ emptyAttributeDictionary! !!XMLLazyAttributeDictionary class methodsFor: 'private'!emptyAttributeDictionaryClass	^ XMLAttributeDictionary! !!XMLLazyAttributeDictionary class methodsFor: 'class initialization'!initialize	"self initialize"	self initializeEmptyAttributeDictionary! !!XMLLazyAttributeDictionary class methodsFor: 'class initialization'!initializeEmptyAttributeDictionary	"explictly initialized class inst vars are used for the empty	dictionaries to simplify class initialization (on GS) and to	speed up lazy dictionary instance creation"	emptyAttributeDictionary := self emptyAttributeDictionaryClass new! !!XMLLazyAttributeDictionary class methodsFor: 'instance creation'!new	^ self basicNew setAttributeDictionary: emptyAttributeDictionary! !!XMLLazyAttributeDictionary class methodsFor: 'instance creation'!new: aCapacity	^ self new! !!XMLLazyAttributeDictionary class methodsFor: 'instance creation'!newFrom: anAssociationCollection	^ self basicNew setAttributeDictionary:		(self emptyAttributeDictionaryClass newFrom:			anAssociationCollection)! !!XMLLazyAttributeDictionary class methodsFor: 'instance creation'!newFromPairs: aSequenceableCollection	^ self basicNew setAttributeDictionary:		(self emptyAttributeDictionaryClass newFromPairs:			aSequenceableCollection)! !!XMLLazyAttributeDictionary methodsFor: 'comparing'!= anObject	^ attributeDictionary = anObject! !!XMLLazyAttributeDictionary methodsFor: 'adding'!add: anAssociation	^ self copiedAttributeDictionary add: anAssociation! !!XMLLazyAttributeDictionary methodsFor: 'adding'!addAll: anAssociationCollection	^ self copiedAttributeDictionary addAll: anAssociationCollection! !!XMLLazyAttributeDictionary methodsFor: 'converting'!asXMLAttributeDictionary	^ self! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!associationAt: aKey	^ attributeDictionary associationAt: aKey! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!associationAt: aKey ifAbsent: aBlock	^ attributeDictionary		associationAt: aKey		ifAbsent: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!associationAt: aKey ifPresent: aBlock	^ attributeDictionary		associationAt: aKey		ifPresent: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!associationAtName: aQualifiedOrLocalName	^ attributeDictionary associationAtName: aQualifiedOrLocalName! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!associationAtName: aKey ifAbsent: aBlock	^ attributeDictionary		associationAtName: aKey		ifAbsent: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!associationAtName: aQualifiedOrLocalName namespaceURI: aURI	^ attributeDictionary		associationAtName: aQualifiedOrLocalName		namespaceURI: aURI! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!associationAtName: aKey namespaceURI: aURI ifAbsent: aBlock	^ attributeDictionary		associationAtName: aKey		namespaceURI: aURI		ifAbsent: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!associations	^ attributeDictionary associations! !!XMLLazyAttributeDictionary methodsFor: 'enumerating'!associationsDo: aBlock	attributeDictionary associationsDo: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'enumerating'!associationsSelect: aBlock	^ self copyEmpty setAttributeDictionary:		(attributeDictionary associationsSelect: aBlock)! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!at: aKey	^ attributeDictionary at: aKey! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!at: aKey ifAbsent: aBlock	^ attributeDictionary		at: aKey		ifAbsent: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!at: aKey ifAbsentPut: aBlock	^ self copiedAttributeDictionary		at: aKey		ifAbsentPut: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!at: aKey ifPresent: aBlock	^ attributeDictionary		at: aKey		ifPresent: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!at: aKey ifPresent: aPresentBlock ifAbsent: anAbsentBlock	^ attributeDictionary		at: aKey		ifPresent: aPresentBlock		ifAbsent: anAbsentBlock! !!XMLLazyAttributeDictionary methodsFor: 'private'!at: aKey newPut: aValue	"added to be consistent with XMLAttributeDictionary,	but it shouldn't be needed"	^ self copiedAttributeDictionary		at: aKey		newPut: aValue! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!at: aKey put: aValue	^ self copiedAttributeDictionary		at: aKey		put: aValue! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!atName: aQualifiedOrLocalName	^ attributeDictionary atName: aQualifiedOrLocalName! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!atName: aQualifiedOrLocalName ifAbsent: aBlock	^ attributeDictionary		atName: aQualifiedOrLocalName		ifAbsent: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!atName: aQualifiedOrLocalName namespaceURI: aURI	^ attributeDictionary		atName: aQualifiedOrLocalName		namespaceURI: aURI! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!atName: aQualifiedOrLocalName namespaceURI: aURI ifAbsent: aBlock	^ attributeDictionary		atName: aQualifiedOrLocalName		namespaceURI: aURI		ifAbsent: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'private'!attributeDictionary	^ attributeDictionary! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!capacity	^ attributeDictionary capacity! !!XMLLazyAttributeDictionary methodsFor: 'enumerating'!collect: aBlock	^ self copyEmpty setAttributeDictionary:		(attributeDictionary collect: aBlock)! !!XMLLazyAttributeDictionary methodsFor: 'private'!copiedAttributeDictionary	"replaces the shared, empty order-preserving dictionary with a new	mutable one ready for modification"	^ attributeDictionary == self emptyAttributeDictionary		ifTrue: [attributeDictionary := self copyEmptyAttributeDictionary]		ifFalse: [attributeDictionary]! !!XMLLazyAttributeDictionary methodsFor: 'copying'!copyEmpty	"Squeak and GS don't have Collection>>#copyEmpty, so it is	reimplemented for portability"	^ self species new! !!XMLLazyAttributeDictionary methodsFor: 'private'!copyEmptyAttributeDictionary	^ attributeDictionary copy! !!XMLLazyAttributeDictionary methodsFor: 'private'!dictionary	^ attributeDictionary dictionary! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!dictionaryClass	^ attributeDictionary dictionaryClass! !!XMLLazyAttributeDictionary methodsFor: 'enumerating'!do: aBlock	attributeDictionary do: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'private'!emptyAttributeDictionary	^ self class emptyAttributeDictionary! !!XMLLazyAttributeDictionary methodsFor: 'comparing'!hash	^ attributeDictionary hash! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!identityIndexOfKey: aKey	^ attributeDictionary identityIndexOfKey: aKey! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!identityIndexOfKey: aKey ifAbsent: aBlock	^ attributeDictionary		identityIndexOfKey: aKey		ifAbsent: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'testing'!includesAssociation: anAssociation	^ attributeDictionary includesAssociation: anAssociation! !!XMLLazyAttributeDictionary methodsFor: 'testing'!includesIdentity: anObject	^ attributeDictionary includesIdentity: anObject! !!XMLLazyAttributeDictionary methodsFor: 'testing'!includesKey: aKey	^ attributeDictionary includesKey: aKey! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!indexOfKey: aKey	^ attributeDictionary indexOfKey: aKey! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!indexOfKey: aKey ifAbsent: aBlock	^ attributeDictionary		indexOfKey: aKey		ifAbsent: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'testing'!isDictionary	^ true! !!XMLLazyAttributeDictionary methodsFor: 'testing'!isEmpty	"Squeak's Collection>>#isEmpty is inefficient"	^ attributeDictionary isEmpty! !!XMLLazyAttributeDictionary methodsFor: 'testing'!isIdentityDictionary	^ attributeDictionary isIdentityDictionary! !!XMLLazyAttributeDictionary methodsFor: 'testing'!isOrderPreservingDictionary	^ true! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!keyAtIdentityValue: aValue	^ attributeDictionary keyAtIdentityValue: aValue! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!keyAtIdentityValue: aValue ifAbsent: aBlock	^ attributeDictionary		keyAtIdentityValue: aValue		ifAbsent: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!keyAtIndex: anIndex	^ attributeDictionary keyAtIndex: anIndex! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!keyAtIndex: anIndex ifAbsent: aBlock	^ attributeDictionary		keyAtIndex: anIndex		ifAbsent: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!keyAtValue: anObject	^ attributeDictionary keyAtValue: anObject! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!keyAtValue: anObject ifAbsent: aBlock	^ attributeDictionary		keyAtValue: anObject		ifAbsent: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!keyForIdentity: anObject	^ attributeDictionary keyForIdentity: anObject! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!keys	^ attributeDictionary keys! !!XMLLazyAttributeDictionary methodsFor: 'enumerating'!keysAndValuesDo: aBlock	attributeDictionary keysAndValuesDo: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'removing'!keysAndValuesRemove: aTwoArgumentBlock	self copiedAttributeDictionary keysAndValuesRemove: aTwoArgumentBlock! !!XMLLazyAttributeDictionary methodsFor: 'enumerating'!keysDo: aBlock	attributeDictionary keysDo: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!keysSortedSafely	^ attributeDictionary keysSortedSafely! !!XMLLazyAttributeDictionary methodsFor: 'private'!namespaceScope	^ attributeDictionary namespaceScope! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!namespaceURIOf: aKey	^ attributeDictionary namespaceURIOf: aKey! !!XMLLazyAttributeDictionary methodsFor: 'private'!orderedKeys	^ attributeDictionary orderedKeys! !!XMLLazyAttributeDictionary methodsFor: 'copying'!postCopy	attributeDictionary == self emptyAttributeDictionary		ifFalse: [attributeDictionary := attributeDictionary copy]! !!XMLLazyAttributeDictionary methodsFor: 'printing'!printElementsOn: aStream	attributeDictionary printElementsOn: aStream! !!XMLLazyAttributeDictionary methodsFor: 'removing'!remove: anObject ifAbsent: aBlock	self shouldNotImplement! !!XMLLazyAttributeDictionary methodsFor: 'removing'!removeAll	attributeDictionary := self emptyAttributeDictionary! !!XMLLazyAttributeDictionary methodsFor: 'removing'!removeKey: aKey	^ self copiedAttributeDictionary removeKey: aKey! !!XMLLazyAttributeDictionary methodsFor: 'removing'!removeKey: aKey ifAbsent: aBlock	^ self copiedAttributeDictionary		removeKey: aKey		ifAbsent: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'removing'!removeKeys: aKeyCollection	self copiedAttributeDictionary removeKeys: aKeyCollection! !!XMLLazyAttributeDictionary methodsFor: 'private'!resolvePrefix: aPrefix	^ attributeDictionary resolvePrefix: aPrefix! !!XMLLazyAttributeDictionary methodsFor: 'private'!resolvePrefix: aPrefix ifUnresolvable: aBlock	^ attributeDictionary		resolvePrefix: aPrefix		ifUnresolvable: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'enumerating'!select: aBlock	^ self copyEmpty setAttributeDictionary:		(attributeDictionary select: aBlock)! !!XMLLazyAttributeDictionary methodsFor: 'initialization'!setAttributeDictionary: anAttributeDictionary	attributeDictionary := anAttributeDictionary! !!XMLLazyAttributeDictionary methodsFor: 'initialization'!setNamespaceScope: aNamespaceScope! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!size	^ attributeDictionary size! !!XMLLazyAttributeDictionary methodsFor: 'testing'!usesNamespaces	^ attributeDictionary usesNamespaces! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!values	^ attributeDictionary values! !!XMLLazyAttributeDictionary methodsFor: 'enumerating'!valuesDo: aBlock	attributeDictionary valuesDo: aBlock! !!XMLLazyNamespacedAttributeDictionary class methodsFor: 'private'!emptyAttributeDictionaryClass	^ XMLNamespacedAttributeDictionary! !!XMLLazyNamespacedAttributeDictionary class methodsFor: 'class initialization'!initialize	"self initialize"	self initializeEmptyAttributeDictionary! !!XMLLazyNamespacedAttributeDictionary methodsFor: 'private'!copyEmptyAttributeDictionary	^ super copyEmptyAttributeDictionary setNamespaceScope: self namespaceScope! !!XMLLazyNamespacedAttributeDictionary methodsFor: 'private'!namespaceScope	^ namespaceScope		ifNil: [			namespaceScope :=				attributeDictionary == self emptyAttributeDictionary					ifTrue: [XMLNamespaceScope new]					ifFalse: [attributeDictionary namespaceScope]]! !!XMLLazyNamespacedAttributeDictionary methodsFor: 'initialization'!setNamespaceScope: aNamespaceScope	namespaceScope := aNamespaceScope! !!XMLNFAStateSet class methodsFor: 'instance creation'!new	^ self new: 5! !!XMLNFAStateSet class methodsFor: 'instance creation'!new: aCapacity	^ self basicNew initialize: aCapacity! !!XMLNFAStateSet class methodsFor: 'instance creation'!newFrom: aCollection	"for GS portability"	^ self withAll: aCollection! !!XMLNFAStateSet methodsFor: 'copying'!, aCollection	"GS doesn't define #, for non-Sequenceable collections"	^ self copy		addAll: aCollection;		yourself! !!XMLNFAStateSet methodsFor: 'comparing'!= anObject	self == anObject		ifTrue: [^ true].	(self species == anObject species		and: [self size = anObject size])		ifFalse: [^ false].	"use #do: instead of #allSatisfy: for speed"	self do: [:each |		(anObject includes: each)			ifFalse: [^ false]].	^ true.! !!XMLNFAStateSet methodsFor: 'adding'!add: aState	isAccepting		ifFalse: [isAccepting := aState isAccepting].	^ set add: aState.! !!XMLNFAStateSet methodsFor: 'converting'!asDFAState	^ self asDFAStateWithStateCache: nil! !!XMLNFAStateSet methodsFor: 'converting'!asDFAStateWithStateCache: aDFAStateCache	^ XMLDFAState		nfaStates: self		dfaStateCache: aDFAStateCache! !!XMLNFAStateSet methodsFor: 'accessing'!capacity	^ set capacity! !!XMLNFAStateSet methodsFor: 'enumerating'!do: aBlock	set do: aBlock! !!XMLNFAStateSet methodsFor: 'comparing'!hash	| hash |	hash := self species hash.	self size > 5		ifFalse: [			self do: [:each |				hash := hash bitXor: each hash]].	^ hash bitXor: self size hash.! !!XMLNFAStateSet methodsFor: 'testing'!includes: aState	^ set includes: aState! !!XMLNFAStateSet methodsFor: 'initialization'!initialize: aCapacity	set := IdentitySet new: aCapacity.	isAccepting := false.! !!XMLNFAStateSet methodsFor: 'testing'!isAccepting	^ isAccepting! !!XMLNFAStateSet methodsFor: 'testing'!isEmpty	"Squeak's Collection>>#isEmpty is inefficient"	^ self size = 0! !!XMLNFAStateSet methodsFor: 'copying'!postCopy	set := set copy! !!XMLNFAStateSet methodsFor: 'removing'!remove: aState ifAbsent: aBlock	set		remove: aState		ifAbsent: [^ aBlock value].	isAccepting		ifTrue: [isAccepting := set anySatisfy: [:each | each isAccepting]].	^ aState.! !!XMLNFAStateSet methodsFor: 'removing'!removeAll	"Redefined because Collection>>#removeAll assumes the collection can	be safely modified while iterating it with #do:, and 'set removeAll'	is not used because GS's Set/IdentitySet don't implement it"	self initialize: self capacity! !!XMLNFAStateSet methodsFor: 'private'!set	^ set! !!XMLNFAStateSet methodsFor: 'accessing'!size	^ set size! !!XMLAttributeList class methodsFor: 'instance creation'!new	^ self new: 5! !!XMLAttributeList methodsFor: 'adding'!addAttributeAssociation: anAssociation	^ self		addAttributeName: anAssociation key		value: anAssociation value! !!XMLAttributeList methodsFor: 'adding'!addAttributeName: aName value: aValue	^ self addLast:		(self attributeClass			name: aName			value: aValue)! !!XMLAttributeList methodsFor: 'private'!afterAdding: aNode at: anIndex	(self		removeDuplicateOf: aNode		notAt: anIndex)		ifNotNil: [:duplicate |			duplicate = aNode				ifTrue: [^ self]].	observer		ifNotNil: [observer addedAttribute: aNode].! !!XMLAttributeList methodsFor: 'private'!afterAddingLast: aNode	(self		removeDuplicateOf: aNode		notAt: self size)		ifNotNil: [:duplicate |			duplicate = aNode				ifTrue: [^ self]].	observer		ifNotNil: [observer addedAttribute: aNode].! !!XMLAttributeList methodsFor: 'private'!afterAddingToCopyLast: aNode	observer		ifNotNil: [observer addedAttribute: aNode]! !!XMLAttributeList methodsFor: 'private'!afterRemoving: aNode	observer		ifNotNil: [observer removedAttribute: aNode].! !!XMLAttributeList methodsFor: 'converting'!asDictionary	^ self attributes! !!XMLAttributeList methodsFor: 'accessing'!attributeAssociations	^ self collect: [:each | each name -> each value]! !!XMLAttributeList methodsFor: 'accessing'!attributeAt: aName	^ self attributeValueAt: aName! !!XMLAttributeList methodsFor: 'accessing'!attributeAt: aName ifAbsent: aBlock	^ self		attributeValueAt: aName		ifAbsent: aBlock! !!XMLAttributeList methodsFor: 'accessing'!attributeAt: aName ifAbsentPut: aBlock	^ self		attributeValueAt: aName		ifAbsentPut: aBlock! !!XMLAttributeList methodsFor: 'accessing'!attributeAt: aName put: aValue	^ self		attributeValueAt: aName		put: aValue! !!XMLAttributeList methodsFor: 'defaults'!attributeClass	"Can be overridden in subclasses to use a custom attribute class"	^ XMLAttribute! !!XMLAttributeList methodsFor: 'accessing'!attributeNames	^ self collect: [:each | each name]! !!XMLAttributeList methodsFor: 'enumerating'!attributeNamesAndValuesDo: aTwoArgumentBlock	self do: [:each |		aTwoArgumentBlock			value: each name			value: each value]! !!XMLAttributeList methodsFor: 'enumerating'!attributeNamesDo: aBlock	self do: [:each | aBlock value: each name]! !!XMLAttributeList methodsFor: 'accessing'!attributeNodeAt: aName	^ self		attributeNodeAt: aName		ifAbsent: [self defaultValue]! !!XMLAttributeList methodsFor: 'accessing'!attributeNodeAt: aName ifAbsent: aBlock	self do: [:each |		(each isNamed: aName)			ifTrue: [^ each]].	^ aBlock value.! !!XMLAttributeList methodsFor: 'accessing'!attributeNodeAt: aName namespaceURI: aURI	^ self		attributeNodeAt: aName		namespaceURI: aURI		ifAbsent: [self defaultValue]! !!XMLAttributeList methodsFor: 'accessing'!attributeNodeAt: aName namespaceURI: aURI ifAbsent: aBlock	self do: [:each |		((each isNamed: aName)			and: [each namespaceURI = aURI])			ifTrue: [^ each]].	^ aBlock value.! !!XMLAttributeList methodsFor: 'private'!attributeValueAt: aName	^ self		attributeValueAt: aName		ifAbsent: ['']! !!XMLAttributeList methodsFor: 'private'!attributeValueAt: aName ifAbsent: aBlock	| i |	^ (i := self indexOfAttributeValueAt: aName) > 0		ifTrue: [(self at: i) value]		ifFalse: [aBlock value]! !!XMLAttributeList methodsFor: 'private'!attributeValueAt: aName ifAbsentPut: aBlock	^ self		attributeValueAt: aName		ifAbsent: [			"use #addToCopyLast:, since we know it's not in the collection"			(self addToCopyLast:				(self attributeClass					name: aName					value: aBlock value)) value]! !!XMLAttributeList methodsFor: 'private'!attributeValueAt: aName put: aValue	| i |	(i := self indexOfAttributeValueAt: aName) > 0		ifTrue: [(self at: i) value: aValue]		ifFalse: [			"use #addToCopyLast: since we know it's not already in the collection"			self addToCopyLast:				(self attributeClass					name: aName					value: aValue)].	^ aValue.! !!XMLAttributeList methodsFor: 'accessing'!attributes	| dictionary |	dictionary := self attributesClass new: self size.	self do: [:each |		dictionary			at: each name			put: each value].	^ dictionary.! !!XMLAttributeList methodsFor: 'defaults'!attributesClass	"Can be overridden in subclasses to use a custom collection	class for #attributes to use when returning attribute associations"	^ OrderPreservingStringDictionary! !!XMLAttributeList methodsFor: 'private'!duplicateIndexOf: aNode notAt: anIndex	"like the superclass version, but it considers nodes with	the same name to be duplicates"	1 to: anIndex - 1 do: [:i | | node |		(node := collection at: i) name = aNode name			ifTrue: [^ i]].	anIndex + 1 to: collection size do: [:i | | node |		(node := collection at: i) name = aNode name			ifTrue: [^ i]].	^ 0.! !!XMLAttributeList methodsFor: 'testing'!includesAttribute: aName	^ (self indexOfAttributeValueAt: aName) > 0! !!XMLAttributeList methodsFor: 'testing'!includesAttributeNode: aName	self		attributeNodeAt: aName		ifAbsent: [^ false].	^ true.! !!XMLAttributeList methodsFor: 'testing'!includesAttributeNode: aName namespaceURI: aURI	self		attributeNodeAt: aName		namespaceURI: aURI		ifAbsent: [^ false].	^ true.! !!XMLAttributeList methodsFor: 'private'!indexOfAttributeValueAt: aName	"Returns the index of the attribute value with the exact name of aName"	"this needs to be fast, for #attributeValueAt:... methods, so	use #to:do: for speed"	1 to: collection size do: [:i | | node |		(node := collection at: i) name = aName			ifTrue: [^ i]].	^ 0.! !!XMLAttributeList methodsFor: 'removing'!removeAttribute: aName	^ (self removeAt: (self indexOfAttributeValueAt: aName)) value! !!XMLAttributeList methodsFor: 'removing'!removeAttribute: aName ifAbsent: aBlock	| i |	(i := self indexOfAttributeValueAt: aName) > 0		ifTrue: [^ (self removeAt: i) value]		ifFalse: [^ aBlock value].! !!XMLAttributeList methodsFor: 'notifying'!renamedAttribute: anAttribute from: anOldName to: aNewName	self		removeDuplicateOf: anAttribute		notAt: (self indexOf: anAttribute)! !!XMLAttributeList methodsFor: 'initialization'!setAttributes: anAssociationCollection	self removeAll.	anAssociationCollection associationsDo: [:each |		self addAttributeAssociation: each].! !!XMLAttributeList methodsFor: 'private'!setAttributesFromOrderPreservingDictionary: anOrderPreservingDictionary	"This should only be sent by DOM parsers/builders, not public API users"	| orderedKeys |	"Add the XMLAttributes in order directly to the collection to avoid	sending notifications that would do unneeded, costly namespace prefix	revalidation.	Use the internal #orderedKeys with #to:do: to create an inlined #keysDo:	without block closure overhead."	orderedKeys := anOrderPreservingDictionary orderedKeys.	1 to: anOrderPreservingDictionary size do: [:i | | key |		key := orderedKeys at: i.		collection addLast: 			(self attributeClass new				setName: key				value:					"use dictionary at:ifAbsent: for speed over at:"					(anOrderPreservingDictionary						at: key						ifAbsent: nil)				element: observer)].! !!XMLAttributeList methodsFor: 'sorting'!sort	self sort: [:a :b | a sortKey <= b sortKey]! !!XMLAttributeList methodsFor: 'private'!writeAttributesOn: aWriter	"use #to:do: with direct access for fast writing"	1 to: collection size do: [:i | | attribute |		attribute := collection at: i.		aWriter			writeAttributeName: attribute name			value: attribute value]! !!XMLAttributeList methodsFor: 'private'!writeCanonicalAttributesOn: aWriter	| sortedAttributes |	(sortedAttributes := self asArray) sort: [:a :b | | prefixOfA prefixOfB |		prefixOfA := a prefix.		prefixOfB := b prefix.		prefixOfA = prefixOfB			ifTrue: [				(a name xmlLocalNameAfterPrefix: prefixOfA)					<= (b name xmlLocalNameAfterPrefix: prefixOfB)]			ifFalse: [| uriOfA uriOfB |				"the namespace URI is the primary key and				the local name is the secondary key"				uriOfA := a resolvePrefix: prefixOfA.				uriOfB := b resolvePrefix: prefixOfB.				uriOfA < uriOfB					or: [						uriOfA = uriOfB							and: [								(a name xmlLocalNameAfterPrefix: prefixOfA)									<= (b name xmlLocalNameAfterPrefix: prefixOfB)]]]].	"use #to:do: for fast writing"	1 to: sortedAttributes size do: [:i | | attribute |		attribute := sortedAttributes at: i.		aWriter			writeAttributeName: attribute name			value: attribute value].! !!XMLCachingAttributeList methodsFor: 'private'!afterAdding: aNode at: anIndex	self attributeNodesByName		at: aNode name ifPresent: [:duplicate |			self				removeDuplicateOf: aNode				notAt: anIndex.			duplicate = aNode				ifTrue: [^ self]];		at: aNode name put: aNode.	observer		ifNotNil: [observer addedAttribute: aNode].! !!XMLCachingAttributeList methodsFor: 'private'!afterAddingLast: aNode	self attributeNodesByName		at: aNode name ifPresent: [:duplicate |			self				removeDuplicateOf: aNode				notAt: self size.			duplicate = aNode				ifTrue: [^ self]];		at: aNode name put: aNode.	observer		ifNotNil: [observer addedAttribute: aNode].! !!XMLCachingAttributeList methodsFor: 'private'!afterAddingToCopyLast: aNode	self attributeNodesByName		at: aNode name		put: aNode.	observer		ifNotNil: [observer addedAttribute: aNode].! !!XMLCachingAttributeList methodsFor: 'private'!afterRemoving: aNode	self attributeNodesByName removeKey: aNode name.	observer		ifNotNil: [observer removedAttribute: aNode].! !!XMLCachingAttributeList methodsFor: 'private'!attributeNodesByName	^ attributeNodesByName		ifNil: [attributeNodesByName := Dictionary new: self capacity]! !!XMLCachingAttributeList methodsFor: 'private'!attributeValueAt: aName ifAbsent: aBlock	^ (self attributeNodesByName		at: aName		ifAbsent: [^ aBlock value]) value! !!XMLCachingAttributeList methodsFor: 'private'!attributeValueAt: aName put: aValue	(self attributeNodesByName		at: aName		ifAbsent: [			"use #addToCopyLast: since we know it's not already in the collection"			self addToCopyLast:				(self attributeClass					name: aName					value: aValue).			^ aValue]) value: aValue.	^ aValue.! !!XMLCachingAttributeList methodsFor: 'defaults'!copyClass	"use the non-caching superclass for copies for performance"	^ XMLAttributeList! !!XMLCachingAttributeList methodsFor: 'testing'!includes: aNode	^ aNode isAttribute		and: [			(self attributeNodesByName				at: aNode name				ifAbsent: [^ false]) = aNode]! !!XMLCachingAttributeList methodsFor: 'testing'!includesAttribute: aName	^ self attributeNodesByName includesKey: aName! !!XMLCachingAttributeList methodsFor: 'private'!indexOfAttributeValueAt: aName	^ (self attributeNodesByName includesKey: aName)		ifTrue: [super indexOfAttributeValueAt: aName]		ifFalse: [0]! !!XMLCachingAttributeList methodsFor: 'removing'!removeAttribute: aName	^ (self remove: (self attributeNodesByName at: aName)) value! !!XMLCachingAttributeList methodsFor: 'removing'!removeAttribute: aName ifAbsent: aBlock	^ (self remove:		(self attributeNodesByName			at: aName			ifAbsent: [^ aBlock value])) value! !!XMLCachingAttributeList methodsFor: 'notifying'!renamedAttribute: anAttribute from: anOldName to: aNewName	self attributeNodesByName		removeKey: anOldName;		at: aNewName ifPresent: [:duplicate |			self				removeDuplicateOf: anAttribute				notAt: (self indexOf: anAttribute)];		at: aNewName put: anAttribute! !!XMLCachingAttributeList methodsFor: 'private'!setAttributesFromOrderPreservingDictionary: anOrderPreservingDictionary	"This should only be sent by DOM parsers/builders, not public API users"	| orderedKeys |	"Hack to reuse its internal dictionary for speed, which we will	modify the association values of. This is safe because the DOM	parser/builder will never use it again."	attributeNodesByName := anOrderPreservingDictionary dictionary.	"Add the XMLAttributes in order directly to the collection to avoid	sending notifications that would do unneeded, costly namespace prefix	revalidation and also replace the value in the attributeNodesByName	association with the new XMLAttribute.	Use the internal #orderedKeys with #to:do: to create an inlined #keysDo:	without block closure overhead."	orderedKeys := anOrderPreservingDictionary orderedKeys.	1 to: anOrderPreservingDictionary size do: [:i | | key association |		key := orderedKeys at: i.		"use associationAt:ifAbsent: for speed over associationAt:"		association :=			attributeNodesByName				associationAt: key				ifAbsent: nil.		"replace its string value with the new XMLAttribute"		association value:			(collection addLast: 				(self attributeClass new					setName: key					value: association value					element: observer))].! !!XMLInternalSubsetList methodsFor: 'private'!afterAdding: aNode at: anIndex	(aNode hasParentWithNodeList: self)		ifTrue: [			self				removeDuplicateOf: aNode				notAt: anIndex]		ifFalse: [			observer				ifNotNil: [observer addedNode: aNode]]! !!XMLInternalSubsetList methodsFor: 'private'!afterAddingLast: aNode	(aNode hasParentWithNodeList: self)		ifTrue: [			self				removeDuplicateOf: aNode				notAt: self size]		ifFalse: [			observer				ifNotNil: [observer addedNode: aNode]]! !!XMLInternalSubsetList methodsFor: 'private'!afterAddingToCopyLast: aNode	observer		ifNotNil: [observer addedNode: aNode]! !!XMLInternalSubsetList methodsFor: 'private'!afterRemoving: aNode	observer ifNotNil: [observer removedNode: aNode]! !!XMLInternalSubsetList methodsFor: 'sorting'!sort	self sort: [:a :b | a sortKey <= b sortKey]! !!XMLCachingNodeList methodsFor: 'private'!afterAdding: aNode at: anIndex	(aNode hasParentWithNodeList: self)		ifTrue: [			self				removeDuplicateOf: aNode				notAt: anIndex.			aNode isElement				ifTrue: [self rebuildCachedElements]]		ifFalse: [			aNode isElement				ifTrue: [					self						cacheElement: aNode						addedAt: anIndex].			observer				ifNotNil: [observer addedNode: aNode]]! !!XMLCachingNodeList methodsFor: 'private'!afterAddingLast: aNode	(aNode hasParentWithNodeList: self)		ifTrue: [			self				removeDuplicateOf: aNode				notAt: self size.			aNode isElement				ifTrue: [self rebuildCachedElements]]		ifFalse: [			aNode isElement				ifTrue: [self cacheElementAddedLast: aNode].			observer				ifNotNil: [observer addedNode: aNode]]! !!XMLCachingNodeList methodsFor: 'private'!afterAddingToCopyLast: aNode	aNode isElement		ifTrue: [self cacheElementAddedLast: aNode].	observer		ifNotNil: [observer addedNode: aNode].! !!XMLCachingNodeList methodsFor: 'private'!afterRemoving: aNode	aNode isElement		ifTrue: [self uncacheElement: aNode].	observer		ifNotNil: [observer removedNode: aNode].! !!XMLCachingNodeList methodsFor: 'private'!cacheElement: anElement addedAt: anIndex	anIndex = self size		ifTrue: [^ self cacheElementAddedLast: anElement].	(self findElementAfterIndex: anIndex)		ifNil: [self cachedElements addLast: anElement]		ifNotNil: [:elementAfter |			self cachedElements				add: anElement				before: elementAfter].	self		cachedElementsByNameAt: anElement name		add: anElement		beforeNextAfterIndex: anIndex.	anElement hasPrefix		ifTrue: [			self				cachedElementsByNameAt: anElement localName				add: anElement				beforeNextAfterIndex: anIndex].! !!XMLCachingNodeList methodsFor: 'private'!cacheElementAddedLast: anElement	self cachedElements addLast: anElement.	self		cachedElementsByNameAt: anElement name		addLast: anElement.	anElement hasPrefix		ifTrue: [			self				cachedElementsByNameAt: anElement localName				addLast: anElement].! !!XMLCachingNodeList methodsFor: 'private'!cachedElements	^ cachedElements ifNil: [cachedElements := OrderedCollection new]! !!XMLCachingNodeList methodsFor: 'private'!cachedElementsByName	^ cachedElementsByName ifNil: [cachedElementsByName := Dictionary new]! !!XMLCachingNodeList methodsFor: 'private'!cachedElementsByNameAt: aName add: anElement beforeNextAfterIndex: anIndex	| elementAfter elementsWithName |	(elementAfter :=		self			findElementAfterIndex: anIndex			named: aName)		ifNil: [			^ self				cachedElementsByNameAt: aName				addLast: anElement].	(elementsWithName := self cachedElementsByName at: aName) isCollection		ifTrue: [elementsWithName add: anElement before: elementAfter]		ifFalse: [			self cachedElementsByName				at: aName				put: (OrderedCollection with: anElement with: elementAfter)].! !!XMLCachingNodeList methodsFor: 'private'!cachedElementsByNameAt: aName addLast: anElement	| elementsWithName |	elementsWithName :=		self cachedElementsByName			at: aName			ifAbsent: [				self cachedElementsByName at: aName put: anElement.				^ self].	 elementsWithName isCollection		ifTrue: [elementsWithName addLast: anElement]		ifFalse: [			self cachedElementsByName				at: aName				put: (OrderedCollection with: elementsWithName with: anElement)].! !!XMLCachingNodeList methodsFor: 'private'!cachedElementsByNameAt: aName remove: anElement	| elementsWithName |	(elementsWithName := self cachedElementsByName at: aName) isCollection		ifTrue: [			elementsWithName remove: anElement.			elementsWithName isEmpty				ifTrue: [self cachedElementsByName removeKey: aName]]		ifFalse: [self cachedElementsByName removeKey: aName]! !!XMLCachingNodeList methodsFor: 'defaults'!copyClass	"use the non-caching superclass for copies for performance"	^ XMLNodeList! !!XMLCachingNodeList methodsFor: 'accessing'!elementAt: aName ifAbsent: aBlock	| elementsWithName |	(elementsWithName :=		self cachedElementsByName			at: aName			ifAbsent: [^ aBlock value]) isCollection		ifTrue: [^ elementsWithName first]		ifFalse: [^ elementsWithName]! !!XMLCachingNodeList methodsFor: 'accessing'!elements	^ self copyEmpty		addAll: self cachedElements;		yourself! !!XMLCachingNodeList methodsFor: 'accessing'!elementsAt: aName	| elementsWithName copiedElements |	copiedElements := self copyEmpty.	(elementsWithName :=		self cachedElementsByName			at: aName			ifAbsent: [^ copiedElements]) isCollection		ifTrue: [			elementsWithName do: [:each |				copiedElements addToCopyLast: each]]		ifFalse: [			copiedElements addToCopyLast: elementsWithName].	^ copiedElements.! !!XMLCachingNodeList methodsFor: 'enumerating'!elementsAt: aName do: aBlock	| elementsWithName |	(elementsWithName :=		self cachedElementsByName			at: aName			ifAbsent: [^ self]) isCollection		ifTrue: [elementsWithName do: aBlock]		ifFalse: [aBlock value: elementsWithName]! !!XMLCachingNodeList methodsFor: 'enumerating'!elementsDo: aBlock	self cachedElements do: aBlock! !!XMLCachingNodeList methodsFor: 'private'!findElementAfterIndex: anIndex	anIndex + 1 to: self size do: [:i | | node |		node := self at: i.		node isElement			ifTrue: [^ node]].	^ nil.! !!XMLCachingNodeList methodsFor: 'private'!findElementAfterIndex: anIndex named: aName	anIndex + 1 to: self size do: [:i | | node |		node := self at: i.		(node isElement			and: [node isNamed: aName])			ifTrue: [^ node]].	^ nil.! !!XMLCachingNodeList methodsFor: 'accessing'!firstElement	^ self cachedElements		at: 1		ifAbsent: [self defaultValue]! !!XMLCachingNodeList methodsFor: 'testing'!hasElements	^ cachedElements notNil and: [cachedElements notEmpty]! !!XMLCachingNodeList methodsFor: 'testing'!includesElement: aName	^ self cachedElementsByName includesKey: aName! !!XMLCachingNodeList methodsFor: 'accessing'!lastElement	^ self cachedElements		at: self cachedElements size		ifAbsent: [self defaultValue]! !!XMLCachingNodeList methodsFor: 'private'!rebuildCachedElements	self cachedElements removeAll.	self cachedElementsByName removeAll.	self do: [:each |		each isElement			ifTrue: [self cacheElementAddedLast: each]].! !!XMLCachingNodeList methodsFor: 'notifying'!renamedElement: anElement from: anOldName to: aNewName	| oldPrefix index |	self		cachedElementsByNameAt: anOldName		remove: anElement.	(oldPrefix := anOldName xmlPrefixBeforeLocalName) notEmpty		ifTrue: [			self				cachedElementsByNameAt: (anOldName xmlLocalNameAfterPrefix: oldPrefix)				remove: anElement].	index := self indexOf: anElement.	self		cachedElementsByNameAt: anElement name		add: anElement		beforeNextAfterIndex: index.	anElement hasPrefix		ifTrue: [			self				cachedElementsByNameAt: anElement localName				add: anElement				beforeNextAfterIndex: index].! !!XMLCachingNodeList methodsFor: 'sorting'!sort: aSortBlock	super sort: aSortBlock.	self cachedElements sort: aSortBlock.	self cachedElementsByName valuesDo: [:each |		each isCollection			ifTrue: [each sort: aSortBlock]].! !!XMLCachingNodeList methodsFor: 'accessing'!swap: aFirstIndex with: aSecondIndex	super swap: aFirstIndex with: aSecondIndex.	((self at: aFirstIndex) isElement		or: [(self at: aSecondIndex) isElement])		ifTrue: [self rebuildCachedElements].! !!XMLCachingNodeList methodsFor: 'private'!uncacheElement: anElement	self cachedElements remove: anElement.	self		cachedElementsByNameAt: anElement name		remove: anElement.	anElement hasPrefix		ifTrue: [			self				cachedElementsByNameAt: anElement localName				remove: anElement].! !!XMLNodeList class methodsFor: 'instance creation'!new	^ self new: 5! !!XMLNodeList methodsFor: 'private'!afterAdding: aNode at: anIndex	(aNode hasParentWithNodeList: self)		ifTrue: [			self				removeDuplicateOf: aNode				notAt: anIndex]		ifFalse: [			observer				ifNotNil: [observer addedNode: aNode]]! !!XMLNodeList methodsFor: 'private'!afterAddingLast: aNode	(aNode hasParentWithNodeList: self)		ifTrue: [			self				removeDuplicateOf: aNode				notAt: self size]		ifFalse: [			observer				ifNotNil: [observer addedNode: aNode]]! !!XMLNodeList methodsFor: 'private'!afterAddingToCopyLast: aNode	observer		ifNotNil: [observer addedNode: aNode]! !!XMLNodeList methodsFor: 'private'!afterRemoving: aNode	observer		ifNotNil: [observer removedNode: aNode]! !!XMLNodeList methodsFor: 'accessing'!contentNodes	^ self select: [:each | each isContentNode]! !!XMLNodeList methodsFor: 'enumerating'!contentNodesDo: aBlock	self do: [:each |		each isContentNode			ifTrue: [aBlock value: each]]! !!XMLNodeList methodsFor: 'accessing'!contentStringAt: aName	^ (self		elementAt: aName		ifAbsent: [^ '']) contentString! !!XMLNodeList methodsFor: 'accessing'!elementAfter: anElement	| last |	self elementsDo: [:each |		last = anElement			ifTrue: [^ each].		last := each].	^ self defaultValue.! !!XMLNodeList methodsFor: 'accessing'!elementAt: aName	^ self		elementAt: aName		ifAbsent: [self defaultValue]! !!XMLNodeList methodsFor: 'accessing'!elementAt: aName ifAbsent: aBlock	self elementsDo: [:each |		(each isNamed: aName)			ifTrue: [^ each]].	^ aBlock value.! !!XMLNodeList methodsFor: 'accessing'!elementAt: aName namespaceURI: aURI	^ self		elementAt: aName		namespaceURI: aURI		ifAbsent: [self defaultValue]! !!XMLNodeList methodsFor: 'accessing'!elementAt: aName namespaceURI: aURI ifAbsent: aBlock	self		elementsAt: aName		do: [:each |			each namespaceURI = aURI				ifTrue: [^ each]].	^ aBlock value.! !!XMLNodeList methodsFor: 'accessing'!elementBefore: anElement	| last |	last := self defaultValue.	self elementsDo: [:each |		each = anElement			ifTrue: [^ last].		last := each].	^ self defaultValue.! !!XMLNodeList methodsFor: 'accessing'!elementNames	^ self elementsCollect: [:each | each name]! !!XMLNodeList methodsFor: 'accessing'!elements	^ self select: [:each | each isElement]! !!XMLNodeList methodsFor: 'accessing'!elementsAt: aName	^ self elementsSelect: [:each | each isNamed: aName]! !!XMLNodeList methodsFor: 'enumerating'!elementsAt: aName do: aBlock	self elementsDo: [:each |		(each isNamed: aName)			ifTrue: [aBlock value: each]]! !!XMLNodeList methodsFor: 'accessing'!elementsAt: aName namespaceURI: aURI	^ self elementsSelect: [:each |		(each isNamed: aName)			and: [each namespaceURI = aURI]]! !!XMLNodeList methodsFor: 'enumerating'!elementsCollect: aBlock	| collectedElements |	"implementing with #elementsDo: benefits the caching subclass because	of its fast #elementsDo: implementation"	collectedElements := self copyEmptyForCollect.	self elementsDo: [:each |		collectedElements addLast: (aBlock value: each)].	^ collectedElements.! !!XMLNodeList methodsFor: 'enumerating'!elementsDetect: aBlock	^ self		elementsDetect: aBlock		ifNone: [self defaultValue]! !!XMLNodeList methodsFor: 'enumerating'!elementsDetect: aBlock ifNone: anExceptionBlock	"implementing with #elementsDo: benefits the caching subclass because	of its fast #elementsDo: implementation"	self elementsDo: [:each |		(aBlock value: each)			ifTrue: [^ each]].	^ anExceptionBlock value.! !!XMLNodeList methodsFor: 'enumerating'!elementsDo: aBlock	"use #to:do: for performance, because so many methods rely on this"	1 to: collection size do: [:i | | node |		(node := collection at: i) isElement			ifTrue: [aBlock value: node]]! !!XMLNodeList methodsFor: 'enumerating'!elementsSelect: aBlock	| selectedElements |	"implementing with #elementsDo: benefits the caching subclass because	of its fast #elementsDo: implementation"	selectedElements := self copyEmpty.	self elementsDo: [:each |		(aBlock value: each)			ifTrue: [selectedElements addToCopyLast: each]].	^ selectedElements.! !!XMLNodeList methodsFor: 'accessing'!firstElement	self elementsDo: [:each | ^ each].	^ self defaultValue.! !!XMLNodeList methodsFor: 'testing'!hasContentNodes	^ self anySatisfy: [:each | each isContentNode]! !!XMLNodeList methodsFor: 'testing'!hasElements	^ self anySatisfy: [:each | each isElement]! !!XMLNodeList methodsFor: 'testing'!hasStringNodes	^ self anySatisfy: [:each | each isStringNode]! !!XMLNodeList methodsFor: 'testing'!includesElement: aName	self		elementAt: aName		ifAbsent: [^ false].	^ true.! !!XMLNodeList methodsFor: 'testing'!includesElement: aName namespaceURI: aURI	self		elementAt: aName		namespaceURI: aURI		ifAbsent: [^ false].	^ true.! !!XMLNodeList methodsFor: 'accessing'!lastElement	self reverseDo: [:each |		each isElement			ifTrue: [^ each]].	^ self defaultValue.! !!XMLNodeList methodsFor: 'accessing'!rawContentStringAt: aName	^ (self		elementAt: aName		ifAbsent: [^ '']) rawContentString! !!XMLNodeList methodsFor: 'notifying'!renamedElement: anElement from: anOldName to: aNewName! !!XMLNodeList methodsFor: 'sorting'!sort	self sort: [:a :b | a sortKey <= b sortKey]! !!XMLNodeList methodsFor: 'accessing'!stringNodes	^ self select: [:each | each isStringNode]! !!XMLNodeList methodsFor: 'enumerating'!stringNodesDo: aBlock	self do: [:each |		each isStringNode			ifTrue: [aBlock value: each]]! !!XMLNodeList methodsFor: 'accessing'!strings	^ self		select: [:each | each isStringNode]		thenCollect: [:each | each string]! !!XMLNodeList methodsFor: 'enumerating'!stringsDo: aBlock	self stringNodesDo: [:each | aBlock value: each string]! !!XMLObservableList class methodsFor: 'instance creation'!observer: anObserver	^ self new observer: anObserver! !!XMLObservableList class methodsFor: 'instance creation'!ofSize: aSize	self shouldNotImplement! !!XMLObservableList methodsFor: 'adding'!add: anObject after: aPreviousObject	^ self		add: anObject		afterIndex:			(collection				indexOf: aPreviousObject				ifAbsent: [-1])! !!XMLObservableList methodsFor: 'adding'!add: anObject afterIndex: anIndex	collection		add: anObject		afterIndex: anIndex.	self		afterAdding: anObject		at: anIndex + 1.	^ anObject.! !!XMLObservableList methodsFor: 'adding'!add: anObject before: aNextObject	^ self		add: anObject		beforeIndex:			(collection				indexOf: aNextObject				ifAbsent: [-1])! !!XMLObservableList methodsFor: 'adding'!add: anObject beforeIndex: anIndex	collection		add: anObject		beforeIndex: anIndex.	self		afterAdding: anObject		at: anIndex.	^ anObject.! !!XMLObservableList methodsFor: 'adding'!addFirst: anObject	collection addFirst: anObject.	self afterAdding: anObject at: 1.	^ anObject.! !!XMLObservableList methodsFor: 'adding'!addLast: anObject	collection addLast: anObject.	self afterAddingLast: anObject.	^ anObject.! !!XMLObservableList methodsFor: 'private'!addToCopyLast: anObject	collection addLast: anObject.	self afterAddingToCopyLast: anObject.	^ anObject.! !!XMLObservableList methodsFor: 'private'!afterAdding: anObject at: anIndex	observer		ifNotNil: [			observer				added: anObject				to: self]! !!XMLObservableList methodsFor: 'private'!afterAddingLast: anObject	"can be used to handle appending separately and more efficiently than	insertion"	self		afterAdding: anObject		at: self size! !!XMLObservableList methodsFor: 'private'!afterAddingToCopyLast: anObject	"can be used to handle appending existing elements to a copy separately and	more efficiently than #afterAddingLast: so not as much checking needs to be	done (because no new elements are being added to the copy)"	self afterAddingLast: anObject! !!XMLObservableList methodsFor: 'private'!afterRemoving: anObject	observer		ifNotNil: [			observer				removed: anObject				from: self]! !!XMLObservableList methodsFor: 'accessing'!at: anIndex put: anObject	| oldObject |	"Gemstone's OrderedCollection>>#at:put: allows the index to be	just after the last, treating it like addLast:, so this is needed	for compatbility"	anIndex = (self size + 1)		ifTrue: [^ self addLast: anObject].	"this will raise an error if the index is invalid"	oldObject := collection at: anIndex.	"remove the old object and notify any observer"	collection at: anIndex put: nil.	oldObject		ifNotNil: [self afterRemoving: oldObject].		"now add the new object and notify any observer"	collection at: anIndex put: anObject.	self		afterAdding: anObject		at: anIndex.	^ anObject.! !!XMLObservableList methodsFor: 'private'!duplicateIndexOf: anObject notAt: anIndex	"to:do: for speed because some subclasses need this to be fast"	1 to: anIndex - 1 do: [:i |		(collection at: i) = anObject			ifTrue: [^ i]].	"to:do: for speed because some subclasses need this to be fast"	anIndex + 1 to: collection size do: [:i |		(collection at: i) = anObject			ifTrue: [^ i]].	^ 0.! !!XMLObservableList methodsFor: 'observing'!observer	^ observer! !!XMLObservableList methodsFor: 'observing'!observer: anObserver	observer := anObserver! !!XMLObservableList methodsFor: 'removing'!remove: anObject ifAbsent: aBlock	collection remove: anObject ifAbsent: [^ aBlock value].	self afterRemoving: anObject.	^ anObject.! !!XMLObservableList methodsFor: 'removing'!removeAt: anIndex	| removed |	removed := super removeAt: anIndex.	self afterRemoving: removed.	^ removed.! !!XMLObservableList methodsFor: 'private'!removeDuplicateOf: anObject notAt: anIndex	"Removes a duplicate of anObject at any index besides anIndex and	returns the removed duplicate or nil if there isn't one."	| duplicateIndex |	(duplicateIndex := 		self			duplicateIndexOf: anObject			notAt: anIndex) > 0		ifTrue: [| duplicate |			(duplicate := collection removeAt: duplicateIndex) = anObject				ifFalse: [					"subclasses may implement #duplicateIndexOf:notAt: to test					for duplicates not with #=, so 'duplicate' can be a					distinct object from 'anObject' that's been removed"					self afterRemoving: duplicate].			^ duplicate]		ifFalse: [^ nil]! !!XMLObservableList methodsFor: 'removing'!reset	| removed |	removed := collection copy.	collection reset.	removed reverseDo: [:each |		self afterRemoving: each].! !!XMLOrderedList class methodsFor: 'private'!collection: aCollection	^ self basicNew setCollection: aCollection! !!XMLOrderedList class methodsFor: 'defaults'!collectionClass	^ OrderedCollection! !!XMLOrderedList class methodsFor: 'inspecting'!inspectorClass	"for pre-GTInspector Pharo"	^ self collectionClass inspectorClass! !!XMLOrderedList class methodsFor: 'instance creation'!new	^ self new: 10! !!XMLOrderedList class methodsFor: 'instance creation'!new: aCapacity	^ self basicNew setCollection: (self collectionClass new: aCapacity)! !!XMLOrderedList class methodsFor: 'instance creation'!new: aSize withAll: anObject	| newList |	"reimplement for portability"	newList := self new: aSize.	1 to: aSize do: [:i | newList addLast: anObject].	^ newList.! !!XMLOrderedList class methodsFor: 'instance creation'!newFrom: aCollection	^ (self new: aCollection size)		addAll: aCollection;		yourself! !!XMLOrderedList class methodsFor: 'instance creation'!ofSize: aSize	^ self new: aSize withAll: nil! !!XMLOrderedList methodsFor: 'copying'!, aCollection	"GS doesn't define #, for non-Sequenceable collections"	^ self copy		addAll: aCollection;		yourself! !!XMLOrderedList methodsFor: 'comparing'!= anObject	"Returns true if anObject is any kind of XMLOrderedList (not just the	class of the receiver) and it and the receiver have the same items	in the same order."	self == anObject		ifTrue: [^ true].	(self species == anObject species		and: [collection size = anObject size])		ifFalse: [^ false].	"Test each position with #= using #to:do: for speed instead of	just 'collection = anObject collection' because that would	make equality depend on the internal collection types instead	of just their items."	1 to: collection size do: [:i |		(collection at: i) = (anObject at: i)			ifFalse: [^ false]].	^ true.! !!XMLOrderedList methodsFor: 'adding'!add: anObject	^ self addLast: anObject! !!XMLOrderedList methodsFor: 'adding'!add: anObject after: aPreviousObject	^ collection add: anObject after: aPreviousObject! !!XMLOrderedList methodsFor: 'adding'!add: anObject afterIndex: anIndex	^ collection add: anObject afterIndex: anIndex! !!XMLOrderedList methodsFor: 'adding'!add: anObject before: aNextObject	^ collection add: anObject before: aNextObject! !!XMLOrderedList methodsFor: 'adding'!add: anObject beforeIndex: anIndex	^ collection add: anObject beforeIndex: anIndex! !!XMLOrderedList methodsFor: 'adding'!addAll: aCollection	^ self addAllLast: aCollection! !!XMLOrderedList methodsFor: 'adding'!addAllFirst: aCollection	aCollection reverseDo: [:each | self addFirst: each].	^ aCollection.! !!XMLOrderedList methodsFor: 'adding'!addAllLast: aCollection	aCollection do: [:each | self addLast: each].	^ aCollection.! !!XMLOrderedList methodsFor: 'adding'!addFirst: anObject	^ collection addFirst: anObject! !!XMLOrderedList methodsFor: 'adding'!addLast: anObject	^ collection addLast: anObject! !!XMLOrderedList methodsFor: 'private'!addToCopyLast: anObject	"this is used to efficiently append to copies for methods like #copy,	#copyWithout:, #select:, and #reject: that create copies with no new elements	(only old ones) so duplicate or other constraint checking can be skipped	by subclasses"	^ collection addLast: anObject! !!XMLOrderedList methodsFor: 'accessing'!after: anObject	^ self after: anObject ifAbsent: [self defaultValue]! !!XMLOrderedList methodsFor: 'accessing'!after: anObject ifAbsent: aBlock	^ collection after: anObject ifAbsent: aBlock! !!XMLOrderedList methodsFor: 'accessing'!allButFirst	^ self allButFirst: 1! !!XMLOrderedList methodsFor: 'accessing'!allButFirst: anInteger	^ self copyFrom: anInteger + 1 to: self size! !!XMLOrderedList methodsFor: 'enumerating'!allButFirstDo: aBlock	"reimplemented for portability"	2 to: collection size do: [:i |		aBlock value: (collection at: i)]! !!XMLOrderedList methodsFor: 'accessing'!allButLast	^ self allButLast: 1! !!XMLOrderedList methodsFor: 'accessing'!allButLast: anInteger	^ self copyFrom: 1 to: self size - anInteger! !!XMLOrderedList methodsFor: 'enumerating'!allButLastDo: aBlock	"reimplemented for portability"	1 to: collection size - 1 do: [:i |		aBlock value: (collection at: i)]! !!XMLOrderedList methodsFor: 'accessing'!anyOne	^ self first! !!XMLOrderedList methodsFor: 'converting'!asArray	"use withAll: not newFrom: for portability"	^ Array withAll: collection! !!XMLOrderedList methodsFor: 'converting'!asOrderedCollection	"use withAll: not newFrom: for portability"	^ OrderedCollection withAll: collection! !!XMLOrderedList methodsFor: 'converting'!asString	"don't assume Object>>#asString is defined, for portability"	^ self printString! !!XMLOrderedList methodsFor: 'accessing'!at: anIndex	"optimized"	(anIndex > 0 and: [anIndex <= collection size])		ifTrue: [^ collection at: anIndex]		ifFalse: [^ self defaultValue]! !!XMLOrderedList methodsFor: 'accessing'!at: anIndex ifAbsent: aBlock	^ collection at: anIndex ifAbsent: aBlock! !!XMLOrderedList methodsFor: 'accessing'!at: anIndex put: aValue	"treats index = size + 1 as addLast: gemstone compatibility"	anIndex = (collection size + 1)		ifTrue: [^ collection addLast: aValue]		ifFalse: [^ collection at: anIndex put: aValue]! !!XMLOrderedList methodsFor: 'accessing'!atLast: anIndexFromEnd	^ self atLast: anIndexFromEnd ifAbsent: [self defaultValue]! !!XMLOrderedList methodsFor: 'accessing'!atLast: anIndexFromEnd ifAbsent: aBlock	^ collection atLast: anIndexFromEnd ifAbsent: aBlock! !!XMLOrderedList methodsFor: 'accessing'!before: anObject	^ self before: anObject ifAbsent: [self defaultValue]! !!XMLOrderedList methodsFor: 'accessing'!before: anObject ifAbsent: aBlock	 ^ collection before: anObject ifAbsent: aBlock! !!XMLOrderedList methodsFor: 'testing'!beginsWith: aCollection	^ collection beginsWith: aCollection! !!XMLOrderedList methodsFor: 'accessing'!capacity	^ collection capacity! !!XMLOrderedList methodsFor: 'enumerating'!collect: aBlock	| collected |	collected := self copyEmptyForCollect.	"use #to:do: for speed"	1 to: collection size do: [:i |		collected addLast: (aBlock value: (collection at: i))].	^ collected.! !!XMLOrderedList methodsFor: 'enumerating'!collect: aCollectBlock thenSelect: aSelectBlock	| selected |	selected := self copyEmpty.	"use #to:do: for speed"	1 to: collection size do: [:i | | item |		item := aCollectBlock value: (collection at: i).		(aSelectBlock value: item)			ifTrue: [selected addLast: item]].	^ selected.! !!XMLOrderedList methodsFor: 'private'!collection	^ collection! !!XMLOrderedList methodsFor: 'copying'!copy	| copy |	copy := self copyEmpty.	"use #to:do: for speed with direct access"	1 to: collection size do: [:i |		copy addToCopyLast: (collection at: i)].	^ copy.! !!XMLOrderedList methodsFor: 'copying'!copyAfter: anObject	| copy |	copy := self copyEmpty.	(self		indexOf: anObject		ifAbsent: [^ copy]) + 1			to: self size			do: [:i | copy addToCopyLast: (self at: i)].	^ copy.! !!XMLOrderedList methodsFor: 'copying'!copyAfterLast: anObject	| copy |	copy := self copyEmpty.	(self		lastIndexOf: anObject		ifAbsent: [^ copy]) + 1			to: self size			do: [:i | copy addToCopyLast: (self at: i)].	^ copy.! !!XMLOrderedList methodsFor: 'defaults'!copyClass	"the class to use for copies"	^ self class! !!XMLOrderedList methodsFor: 'copying'!copyEmpty	^ self copyClass collection: collection copyEmpty! !!XMLOrderedList methodsFor: 'private'!copyEmptyForCollect	"collect: methods return instances of the generic ordered list species class	because a collect block can return any value, which may not be appropiate to	store in copies of particular subclasses (like XMLNodeList)"	^ self species new: self size! !!XMLOrderedList methodsFor: 'copying'!copyFrom: aStart to: anEnd	| copy |	copy := self copyEmpty.	(aStart max: 1)		to: (anEnd min: self size)		do: [:i | copy addToCopyLast: (self at: i)].	^ copy.! !!XMLOrderedList methodsFor: 'copying'!copyReplaceAll: aSearchCollection with: aReplacementCollection	| copy index size searchCollectionSize |	"this implementation always returns a copy, even if it doesn't replace"	(searchCollectionSize := aSearchCollection size) > 0		ifFalse: [^ self copy].	copy := self copyEmpty.	index := 1.	size := self size.	[index <= size]		whileTrue: [			(self at: index) = (aSearchCollection at: 1)				ifTrue: [| searchCollectionIndex |					searchCollectionIndex := 2.					[searchCollectionIndex <= searchCollectionSize						and: [							(self at: index + searchCollectionIndex - 1) =								(aSearchCollection at: searchCollectionIndex)]]						whileTrue: [searchCollectionIndex := searchCollectionIndex + 1].					searchCollectionIndex > searchCollectionSize						ifTrue: [							"found a match, add the replacement and skip the replaced"							copy addAll: aReplacementCollection.							index := index + searchCollectionSize]						ifFalse: [							copy addLast: (self at: index).							index := index + 1]]				ifFalse: [ 					copy addLast: (self at: index).					index := index + 1]].	^ copy.! !!XMLOrderedList methodsFor: 'copying'!copyReplaceFrom: aStart to: aStop with: aReplacementCollection	| copy start stop |	(self size < 1		or: [self size < aStart])		ifTrue: [			^ self copy				addAll: aReplacementCollection;				yourself].	copy := self copyEmpty.	start := aStart max: 1.	stop := aStop min: self size.	1 to: self size do: [:i |		(i = start)			ifTrue: [				copy addAll: aReplacementCollection.				start > stop					ifTrue: [copy addLast: (self at: i)]]			ifFalse: [				(i > start and: [i <= stop])					ifFalse: [copy addLast: (self at: i)]]].	^ copy.! !!XMLOrderedList methodsFor: 'copying'!copyUpTo: anObject	| copy |	copy := self copyEmpty.	1		to:			(self				indexOf: anObject				ifAbsent: [self size + 1]) - 1		do: [:i | copy addToCopyLast: (self at: i)].	^ copy.! !!XMLOrderedList methodsFor: 'copying'!copyUpToLast: anObject	| copy |	copy := self copyEmpty.	1		to:			(self				lastIndexOf: anObject				ifAbsent: [collection size + 1]) - 1		do: [:i | copy addToCopyLast: (self at: i)].	^ copy.! !!XMLOrderedList methodsFor: 'copying'!copyWith: anObject	^ self copy		addLast: anObject;		yourself! !!XMLOrderedList methodsFor: 'copying'!copyWithFirst: anObject	^ self copyEmpty		addLast: anObject;		addAll: self;		yourself! !!XMLOrderedList methodsFor: 'copying'!copyWithout: anObject	^ self reject: [:each | each = anObject]! !!XMLOrderedList methodsFor: 'copying'!copyWithoutAll: aCollection	| rejected |	rejected :=		aCollection size > 5			ifTrue: [aCollection asSet]			ifFalse: [aCollection].	^ self reject: [:each | rejected includes: each].! !!XMLOrderedList methodsFor: 'defaults'!defaultValue	^ nil! !!XMLOrderedList methodsFor: 'enumerating'!detect: aBlock	^ self detect: aBlock ifNone: [self defaultValue]! !!XMLOrderedList methodsFor: 'enumerating'!detect: aBlock ifNone: anExceptionBlock	^ collection detect: aBlock ifNone: anExceptionBlock! !!XMLOrderedList methodsFor: 'enumerating'!do: aBlock	collection do: aBlock! !!XMLOrderedList methodsFor: 'enumerating'!doWithIndex: aBlock	^ self withIndexDo: aBlock! !!XMLOrderedList methodsFor: 'accessing'!eighth	^ self at: 8! !!XMLOrderedList methodsFor: 'testing'!endsWith: aCollection	^ collection endsWith: aCollection! !!XMLOrderedList methodsFor: 'accessing'!fifth	^ self at: 5! !!XMLOrderedList methodsFor: 'accessing'!first	"optimized implementation"	^ collection size > 0		ifTrue: [collection at: 1]		ifFalse: [self defaultValue]! !!XMLOrderedList methodsFor: 'accessing'!first: anInteger	^ self copyFrom: 1 to: anInteger! !!XMLOrderedList methodsFor: 'accessing'!fourth	^ self at: 4! !!XMLOrderedList methodsFor: 'comparing'!hash	| hash |	hash := self species hash.	self size > 10		ifFalse: [			self do: [:each |				hash := hash bitXor: each hash]].	^ hash bitXor: self size hash.! !!XMLOrderedList methodsFor: 'accessing'!identityIndexOf: anObject	^ self identityIndexOf: anObject ifAbsent: [0]! !!XMLOrderedList methodsFor: 'accessing'!identityIndexOf: anObject ifAbsent: aBlock	^ collection identityIndexOf: anObject ifAbsent: aBlock! !!XMLOrderedList methodsFor: 'accessing'!indexOf: anObject	^ self indexOf: anObject ifAbsent: [0]! !!XMLOrderedList methodsFor: 'accessing'!indexOf: anObject ifAbsent: aBlock	^ collection		indexOf: anObject		ifAbsent: aBlock! !!XMLOrderedList methodsFor: 'accessing'!indexOf: anObject startingAt: anIndex 	^ self		indexOf: anObject		startingAt: anIndex		ifAbsent: [0]! !!XMLOrderedList methodsFor: 'accessing'!indexOf: anObject startingAt: anIndex ifAbsent: aBlock	^ collection		indexOf: anObject		startingAt: (anIndex max: 1)		ifAbsent: aBlock! !!XMLOrderedList methodsFor: 'accessing'!indexOfSubCollection: aSubCollection startingAt: anIndex	^ self		indexOfSubCollection: aSubCollection		startingAt: anIndex		ifAbsent: [0]! !!XMLOrderedList methodsFor: 'accessing'!indexOfSubCollection: aSubCollection startingAt: anIndex ifAbsent: aBlock	^ collection		indexOfSubCollection: aSubCollection		startingAt: anIndex		ifAbsent: aBlock! !!XMLOrderedList methodsFor: 'inspecting'!inspectorClass	"for Squeak"	^ collection inspectorClass! !!XMLOrderedList methodsFor: 'testing'!isEmpty	"Squeak's Collection>>#isEmpty is inefficient"	^ self size = 0! !!XMLOrderedList methodsFor: 'testing'!isSequenceable	^ true! !!XMLOrderedList methodsFor: 'accessing'!last	| lastIndex |	"optimized implementation"	^ (lastIndex := collection size) > 0		ifTrue: [collection at: lastIndex]		ifFalse: [self defaultValue]! !!XMLOrderedList methodsFor: 'accessing'!last: anInteger	^ self copyFrom: self size - anInteger + 1 to: self size! !!XMLOrderedList methodsFor: 'accessing'!lastIndexOf: anObject	^ self lastIndexOf: anObject ifAbsent: [0]! !!XMLOrderedList methodsFor: 'accessing'!lastIndexOf: anObject ifAbsent: aBlock	^ collection lastIndexOf: anObject ifAbsent: aBlock! !!XMLOrderedList methodsFor: 'accessing'!ninth	^ self at: 9! !!XMLOrderedList methodsFor: 'enumerating'!pairsDo: aBlock	collection pairsDo: aBlock! !!XMLOrderedList methodsFor: 'converting'!readStream	"use #readStream to get a 0-based position stream on GS"	^ collection readStream! !!XMLOrderedList methodsFor: 'enumerating'!reject: aBlock	| selected |	selected := self copyEmpty.	"use #to:do: for speed"	1 to: collection size do: [:i | | item |		item := collection at: i.		(aBlock value: item)			ifFalse: [selected addToCopyLast: item]].	^ selected.! !!XMLOrderedList methodsFor: 'enumerating'!reject: aRejectBlock thenCollect: aCollectBlock	| collected |	collected := self copyEmptyForCollect.	"use #to:do: for speed"	1 to: collection size do: [:i | | item |		item := collection at: i.		(aRejectBlock value: item)			ifFalse: [collected addLast: (aCollectBlock value: item)]].	^ collected.! !!XMLOrderedList methodsFor: 'removing'!remove: anObject ifAbsent: aBlock	^ collection remove: anObject ifAbsent: aBlock! !!XMLOrderedList methodsFor: 'removing'!removeAll	"Redefined because Collection>>#removeAll assumes the collection can	be safely modified while iterating it with #do:"	self size timesRepeat: [self removeLast]! !!XMLOrderedList methodsFor: 'removing'!removeAt: anIndex	^ collection removeAt: anIndex! !!XMLOrderedList methodsFor: 'removing'!removeFirst	^ self removeAt: 1! !!XMLOrderedList methodsFor: 'removing'!removeFirst: aNumber	| removed |	removed := self copyFrom: 1 to: aNumber.	aNumber timesRepeat: [self removeFirst].	^ removed.! !!XMLOrderedList methodsFor: 'removing'!removeLast	^ self removeAt: self size! !!XMLOrderedList methodsFor: 'removing'!removeLast: aNumber	| removed |	removed := self copyFrom: self size - (aNumber - 1) to: self size.	aNumber timesRepeat: [self removeLast].	^ removed.! !!XMLOrderedList methodsFor: 'accessing'!replaceFrom: aStart to: aStop with: aReplacementCollection	^ self		replaceFrom: aStart		to: aStop		with: aReplacementCollection		startingAt: 1! !!XMLOrderedList methodsFor: 'accessing'!replaceFrom: aStart to: aStop with: aReplacementCollection startingAt: aReplacementStart	| offset |	offset := 0.	[aStart + offset <= aStop]		whileTrue: [			self				at: aStart + offset				put: (aReplacementCollection at: aReplacementStart + offset).			offset := offset + 1].! !!XMLOrderedList methodsFor: 'removing'!reset	collection reset! !!XMLOrderedList methodsFor: 'converting'!reverse	"returns a copy like #reversed instead of doing in-place reversal to	be compatible with SequenceableCollection>>#reverse"	^ self reversed! !!XMLOrderedList methodsFor: 'enumerating'!reverseDo: aBlock	collection reverseDo: aBlock! !!XMLOrderedList methodsFor: 'converting'!reversed	| reversed |	reversed := self copyEmpty.	self reverseDo: [:each | reversed addToCopyLast: each].	^ reversed.! !!XMLOrderedList methodsFor: 'accessing'!second	^ self at: 2! !!XMLOrderedList methodsFor: 'enumerating'!select: aBlock	| selected |	selected := self copyEmpty.	"use #to:do: for speed"	1 to: collection size do: [:i | | item |		item := collection at: i.		(aBlock value: item)			ifTrue: [selected addToCopyLast: item]].	^ selected.! !!XMLOrderedList methodsFor: 'enumerating'!select: aSelectBlock thenCollect: aCollectBlock	| collected |	collected := self copyEmptyForCollect.	"use #to:do: for speed"	1 to: collection size do: [:i | | item |		item := collection at: i.		(aSelectBlock value: item)			ifTrue: [collected addLast: (aCollectBlock value: item)]].	^ collected.! !!XMLOrderedList methodsFor: 'private'!setCollection: aCollection	collection := aCollection! !!XMLOrderedList methodsFor: 'accessing'!seventh	^ self at: 7! !!XMLOrderedList methodsFor: 'accessing'!sixth	^ self at: 6! !!XMLOrderedList methodsFor: 'accessing'!size	^ collection size! !!XMLOrderedList methodsFor: 'sorting'!sort	self sort: [:a :b | a <= b]! !!XMLOrderedList methodsFor: 'sorting'!sort: aSortBlock	collection sort: aSortBlock! !!XMLOrderedList methodsFor: 'sorting'!sorted	^ self copy sort! !!XMLOrderedList methodsFor: 'sorting'!sorted: aSortBlock	^ self copy sort: aSortBlock! !!XMLOrderedList methodsFor: 'private'!species	"this makes instances of this class and all subclasses with the same	items in the same order be equal"	^ XMLOrderedList! !!XMLOrderedList methodsFor: 'accessing'!swap: aFirstIndex with: aSecondIndex	"swap positions of the objects at aFirstIndex and aSecondIndex,	raising an error if either index is out of bounds"	| temp |	temp := collection at: aFirstIndex.	collection		at: aFirstIndex		put: (collection at: aSecondIndex).	collection		at: aSecondIndex		put: temp.! !!XMLOrderedList methodsFor: 'accessing'!third	^ self at: 3! !!XMLOrderedList methodsFor: 'enumerating'!with: aCollection collect: aBlock	| collected |	collected := self copyEmptyForCollect.	1 to: (collection size min: aCollection size) do: [:i |		collected addLast:			(aBlock				value: (collection at: i)				value: (aCollection at: i))].	^ collected.! !!XMLOrderedList methodsFor: 'enumerating'!with: aCollection do: aBlock	1 to: (collection size min: aCollection size) do: [:i |		aBlock			value: (collection at: i)			value: (aCollection at: i)]! !!XMLOrderedList methodsFor: 'enumerating'!withIndexCollect: aTwoArgumentBlock	| collected |	collected := self copyEmptyForCollect.	1 to: collection size do: [:i |		collected addLast:			(aTwoArgumentBlock				value: (collection at: i)				value: i)].	^ collected.! !!XMLOrderedList methodsFor: 'enumerating'!withIndexDo: aBlock	collection withIndexDo: aBlock! !!XMLOrderedList methodsFor: 'converting'!writeStream	"This is not supported because the collection already supports WriteStream	behavior with #addLast: and the Pharo/Squeak WriteStream works by expanding	its collection with #grownBy:, which should fill the new space with nils,	but some subclasses cannot contain nil"	self shouldNotImplement! !!XMLOrderedList methodsFor: 'accessing'!xmlLastOrNil	^ self last! !!SequenceableCollection methodsFor: '*XML-Parser'!includesXMLName: aName	"optimized with #to:do:"	1 to: self size do: [:i |		(aName isXMLQualifiedOrLocalName: (self at: i))			ifTrue: [^ true]].	^ false.! !!SequenceableCollection methodsFor: '*XML-Parser'!xmlLastOrNil	"for speed to avoid at:ifAbsent: closure"	| lastOrNilOffset |	(lastOrNilOffset := self size) > 0		ifTrue: [^ self at: lastOrNilOffset]		ifFalse: [^ nil]! !"XML-Parser"!!SAXHTMLParserDriver commentStamp: '' prior: 0!This is a parser driver for messy HTML. It uses XMLHTMLElementNester to make bad HTML nest correctly.!!XMLHTMLTagInformation commentStamp: '' prior: 0!This class is used by the element nester to store information about tags for faster lookup.!!SAX2HTMLParser commentStamp: '' prior: 0!This class is a SAX2Parser for messy HTML. The DOM-basesd XMLHTMLParser should probably be preferred.!!XMLHTMLParserTokenizer commentStamp: '' prior: 0!This is the implementation of the tokenizer for the HTML driver.!!SAX2HTMLElementParser commentStamp: '' prior: 0!This class is a SAX2ElementParser for messy HTML. The DOM-basesd XMLHTMLParser should probably be preferred.!!XMLHTMLParser commentStamp: '' prior: 0!This class is a DOM parser that turns invalid and malformed HTML into a DOM tree. All tag and attribute names are converted to lowercase and markup is unrecognized in <script>, <style>, <title>, and <textarea> sections.(If printing the DOM tree, use printWithoutSelfClosingTagsOn: or printedWithoutSelfClosingTags to avoid empty elements being printed as self-closing tags, because some (like <script/>) are not handled correctly by browsers.)!!XMLHTMLElementNester commentStamp: '' prior: 0!This class can handle the nesting of HTML elements missing closing tags or with opening and closing tags in the wrong order.!!SAXHTMLHandler commentStamp: '' prior: 0!This class is a SAXHandler for messy HTML. The DOM-basesd XMLHTMLParser should probably be preferred.!!XMLHTMLNonHTMLSectionState commentStamp: '' prior: 0!A state for elements containing non-markup content.!!XMLHTMLNonHTMLCodeSectionState commentStamp: '' prior: 0!A state for elements containing non-markup code with comments or string literals.!!XMLHTMLNestedStreamReader commentStamp: '' prior: 0!A subclass for HTML that supports case-insensitive hex integer prefixes and a wider set of HTML separator characters.!!Stream methodsFor: '*XML-ParserHTML-Core'!parseHTML	^ XMLHTMLParser parse: self! !!SAXHTMLParserDriver methodsFor: 'private'!deferEventSelector: aSelector	^ self		deferEventSelector: aSelector		arguments: Array new! !!SAXHTMLParserDriver methodsFor: 'private'!deferEventSelector: aSelector argument: anArgument	^ self		deferEventSelector: aSelector		arguments: (Array with: anArgument)! !!SAXHTMLParserDriver methodsFor: 'private'!deferEventSelector: aSelector arguments: anArgumentArray	^ deferredEvents addLast:		(MessageSend			receiver: self saxHandler			selector: aSelector			arguments: anArgumentArray)! !!SAXHTMLParserDriver methodsFor: 'defaults'!elementNesterClass	^ XMLHTMLElementNester! !!SAXHTMLParserDriver methodsFor: 'handling'!handleCData: aString	self handlePCData: aString! !!SAXHTMLParserDriver methodsFor: 'handling'!handleComment: aString	self isDeferringEvents		ifTrue: [			self				deferEventSelector: #comment:				argument: aString]		ifFalse: [self saxHandler comment: aString]! !!SAXHTMLParserDriver methodsFor: 'handling - dtd'!handleEndDTD	self saxHandler endDTD! !!SAXHTMLParserDriver methodsFor: 'handling'!handleEndDocument	self hasDeferredEvents		ifTrue: [self processDeferredEvents].	self saxHandler endDocument.! !!SAXHTMLParserDriver methodsFor: 'handling'!handleEndTag: anElement	| prefix localName |	prefix := anElement xmlPrefixBeforeLocalName.	localName := anElement xmlLocalNameAfterPrefix: prefix.		(self isDeferringEvents		or: [anElement = 'body'])		ifTrue: [			isDeferringEvents := true.			self				deferEventSelector: #endElement:prefix:uri:localName:				arguments:					(Array						with: anElement						with: prefix						with: ''						with: localName)]		ifFalse: [			self saxHandler				endElement: anElement				prefix: prefix				uri: ''				localName: localName].! !!SAXHTMLParserDriver methodsFor: 'handling'!handlePCData: aString	self isDeferringEvents		ifTrue: [self processNonTerminatingDeferredEvents].	self saxHandler characters: aString.! !!SAXHTMLParserDriver methodsFor: 'handling'!handlePI: aTargetString data: aDataString	self isDeferringEvents		ifTrue: [			self				deferEventSelector: #processingInstruction:data:				arguments:					(Array						with: aTargetString						with: aDataString)]		ifFalse: [			self saxHandler 				processingInstruction: aTargetString				data: aDataString]! !!SAXHTMLParserDriver methodsFor: 'handling'!handleParseError: anError! !!SAXHTMLParserDriver methodsFor: 'handling - dtd'!handleStartDTD: aRoot publicID: aPublicID systemID: aSystemID	self saxHandler		startDTD: aRoot		publicID: aPublicID		systemID: aSystemID.! !!SAXHTMLParserDriver methodsFor: 'handling'!handleStartTag: anElement attributes: anAttributeDictionary	| prefix localName |	prefix := anElement xmlPrefixBeforeLocalName.	localName := anElement xmlLocalNameAfterPrefix: prefix.	self isDeferringEvents		ifTrue: [self processNonTerminatingDeferredEvents].	self saxHandler 		startElement: anElement		prefix: prefix		uri: ''		localName: localName		attributes: anAttributeDictionary.! !!SAXHTMLParserDriver methodsFor: 'handling'!handleWhitespace: aString	self isDeferringEvents		ifTrue: [			self				deferEventSelector: #characters:				argument: aString]		ifFalse: [self saxHandler characters: aString]! !!SAXHTMLParserDriver methodsFor: 'handling'!handleXMLVersion: aVersion encoding: anEncoding standalone: aYesOrNo	self saxHandler		xmlVersion:			([Float readFrom: aVersion readStream]				on: Error				do: [:error | 1.0])		encoding: anEncoding		standalone: aYesOrNo = 'yes'! !!SAXHTMLParserDriver methodsFor: 'testing'!hasDeferredEvents	^ self isDeferringEvents		and: [deferredEvents notEmpty]! !!SAXHTMLParserDriver methodsFor: 'testing'!isDeferringEvents	^ isDeferringEvents! !!SAXHTMLParserDriver methodsFor: 'private'!processDeferredEvents	[deferredEvents isEmpty]		whileFalse: [deferredEvents removeFirst value]! !!SAXHTMLParserDriver methodsFor: 'private'!processNonTerminatingDeferredEvents	[deferredEvents isEmpty]		whileFalse: [| deferredMessage |			deferredMessage := deferredEvents removeFirst. 			(deferredMessage selector == #endElement:prefix:uri:localName:				and: [#('body' 'html') includes: deferredMessage arguments first])				ifFalse: [deferredMessage value]]! !!SAXHTMLParserDriver methodsFor: 'initialization'!setSAXHandler: aSAXHandler	super setSAXHandler: aSAXHandler.	isDeferringEvents := false.	deferredEvents := OrderedCollection new: 5.! !!SAXHTMLParserDriver methodsFor: 'defaults'!tokenizerClass	^ XMLHTMLParserTokenizer! !!XMLHTMLTagInformation class methodsFor: 'instance creation'!name: aName	^ self named: aName! !!XMLHTMLTagInformation class methodsFor: 'instance creation'!named: aName	^ self new name: aName! !!XMLHTMLTagInformation methodsFor: 'initialization'!initialize	super initialize.	isHTMLTag := false.	isHeadTag := false.	isBodyTag := false.	isBodySectionTag := false.	isHeadSectionTag := false.	isNonNestable := false.	nestableTagGroup := #().! !!XMLHTMLTagInformation methodsFor: 'testing'!isBodySectionOnlyTag	^ self isBodySectionTag and: [self isHeadSectionTag not]! !!XMLHTMLTagInformation methodsFor: 'testing'!isBodySectionTag	^ isBodySectionTag! !!XMLHTMLTagInformation methodsFor: 'accessing'!isBodySectionTag: aBoolean	isBodySectionTag := aBoolean! !!XMLHTMLTagInformation methodsFor: 'testing'!isBodyTag	^ isBodyTag! !!XMLHTMLTagInformation methodsFor: 'testing'!isHTMLTag	^ isHTMLTag! !!XMLHTMLTagInformation methodsFor: 'testing'!isHeadSectionOnlyTag	^ self isHeadSectionTag and: [self isBodySectionTag not]! !!XMLHTMLTagInformation methodsFor: 'testing'!isHeadSectionTag	^ isHeadSectionTag! !!XMLHTMLTagInformation methodsFor: 'accessing'!isHeadSectionTag: aBoolean	isHeadSectionTag := aBoolean! !!XMLHTMLTagInformation methodsFor: 'testing'!isHeadTag	^ isHeadTag! !!XMLHTMLTagInformation methodsFor: 'testing'!isNonNestable	^ isNonNestable! !!XMLHTMLTagInformation methodsFor: 'accessing'!isNonNestable: aBoolean	isNonNestable := aBoolean! !!XMLHTMLTagInformation methodsFor: 'accessing'!mutuallyExcludingTag	^ mutuallyExcludingTag! !!XMLHTMLTagInformation methodsFor: 'accessing'!mutuallyExcludingTag: aName	mutuallyExcludingTag := aName! !!XMLHTMLTagInformation methodsFor: 'accessing'!name	^ name! !!XMLHTMLTagInformation methodsFor: 'accessing'!name: aName	name := aName.	isHTMLTag := name = 'html'.	isHeadTag := name = 'head'.	isBodyTag := name = 'body'.! !!XMLHTMLTagInformation methodsFor: 'accessing'!nestableTagGroup	^ nestableTagGroup! !!XMLHTMLTagInformation methodsFor: 'accessing'!nestableTagGroup: aNameCollection	nestableTagGroup := aNameCollection! !!XMLHTMLTagInformation methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: '(<';		nextPutAll: self name;		nextPutAll: '>)'.! !!SAX2HTMLParser methodsFor: 'defaults'!driverClass	^ SAXHTMLParserDriver! !!XMLHTMLParserTokenizer class methodsFor: 'private'!compilePredefinedHTMLEntityPageWithEntities: anAssociationCollection	"There are too many entities to represent literally in a single method,	so they're put in a big string and parsed at initialization."	| source |	source :=		String streamContents: [:stream |			stream				nextPutAll: 'predefinedHTMLEntityPage';				cr;				nextPutAll: '	^ '''.			anAssociationCollection do: [:each |				stream					cr;					nextPutAll: '	[';					nextPutAll: each key;					nextPut: $=;					nextPutAll: each value asString;					nextPut: $]].			stream nextPut: $'].	self class		compile: source contents		classified: #private.! !!XMLHTMLParserTokenizer class methodsFor: 'private'!generatePredefinedHTMLEntityPage	"	self generatePredefinedHTMLEntityPage	"	| entityAssociations json |	entityAssociations := OrderedCollection new.	json :=		(XMLClassFinder classNamed: #NeoJSONReader) fromString:			'http://www.w3.org/TR/html5/entities.json' asXMLURI get.	json keysAndValuesDo: [:key :value |		entityAssociations addLast:			key allButFirst allButLast ->				(value at: 'codepoints') first].	entityAssociations sort: [:a :b | a key <= b key].	self compilePredefinedHTMLEntityPageWithEntities: entityAssociations.! !!XMLHTMLParserTokenizer class methodsFor: 'class initialization'!initialize	"self initialize"	self		initializePredefinedHTMLEntities;		initializeHTMLNameDelimiters;		initializeNonHTMLSectionTags;		initializeNonHTMLCodeSectionTags! !!XMLHTMLParserTokenizer class methodsFor: 'class initialization'!initializeHTMLNameDelimiters	"assign after with #yourself to avoid possible race	conditions when reinitializing the class"	HTMLNameDelimiters :=		BitmapCharacterSet new			"#xmlWhitespace is used instead of #xmlSeparators,			which is a narrower range of chars specific to XML"			addAll: Character xmlWhitespace;			add: $>;			add: $/;			add: $<;			add: $=;			add: $";			add: $';			add: $;;			yourself! !!XMLHTMLParserTokenizer class methodsFor: 'class initialization'!initializeNonHTMLCodeSectionTags	NonHTMLCodeSectionTags := #('script' 'style')! !!XMLHTMLParserTokenizer class methodsFor: 'class initialization'!initializeNonHTMLSectionTags	NonHTMLSectionTags := #('script' 'style' 'title' 'textarea' 'template') asSet! !!XMLHTMLParserTokenizer class methodsFor: 'class initialization'!initializePredefinedHTMLEntities	| temp entityPage entityName codePoint |	"use a temp to fully initialize it before assignment to avoid	possible race conditions during class reinitialization"	temp := Dictionary new.	entityPage := self predefinedHTMLEntityPage readStream.	[entityPage atEnd]		whileFalse: [			entityName :=				entityPage					skipTo: $[;					upTo: $=.			codePoint := XMLSmallIntegerReader readFrom: entityPage.			(entityName notEmpty				and: [codePoint notNil])				ifTrue: [					temp						at: entityName						put: codePoint asCharacter]].	PredefinedHTMLEntities := temp.! !!XMLHTMLParserTokenizer class methodsFor: 'accessing'!predefinedHTMLEntities	^ PredefinedHTMLEntities! !!XMLHTMLParserTokenizer class methodsFor: 'private'!predefinedHTMLEntityPage	^ '	[AEli=198]	[AElig=198]	[AM=38]	[AMP=38]	[Aacut=193]	[Aacute=193]	[Abreve=258]	[Acir=194]	[Acirc=194]	[Acy=1040]	[Afr=120068]	[Agrav=192]	[Agrave=192]	[Alpha=913]	[Amacr=256]	[And=10835]	[Aogon=260]	[Aopf=120120]	[ApplyFunction=8289]	[Arin=197]	[Aring=197]	[Ascr=119964]	[Assign=8788]	[Atild=195]	[Atilde=195]	[Aum=196]	[Auml=196]	[Backslash=8726]	[Barv=10983]	[Barwed=8966]	[Bcy=1041]	[Because=8757]	[Bernoullis=8492]	[Beta=914]	[Bfr=120069]	[Bopf=120121]	[Breve=728]	[Bscr=8492]	[Bumpeq=8782]	[CHcy=1063]	[COP=169]	[COPY=169]	[Cacute=262]	[Cap=8914]	[CapitalDifferentialD=8517]	[Cayleys=8493]	[Ccaron=268]	[Ccedi=199]	[Ccedil=199]	[Ccirc=264]	[Cconint=8752]	[Cdot=266]	[Cedilla=184]	[CenterDot=183]	[Cfr=8493]	[Chi=935]	[CircleDot=8857]	[CircleMinus=8854]	[CirclePlus=8853]	[CircleTimes=8855]	[ClockwiseContourIntegral=8754]	[CloseCurlyDoubleQuote=8221]	[CloseCurlyQuote=8217]	[Colon=8759]	[Colone=10868]	[Congruent=8801]	[Conint=8751]	[ContourIntegral=8750]	[Copf=8450]	[Coproduct=8720]	[CounterClockwiseContourIntegral=8755]	[Cross=10799]	[Cscr=119966]	[Cup=8915]	[CupCap=8781]	[DD=8517]	[DDotrahd=10513]	[DJcy=1026]	[DScy=1029]	[DZcy=1039]	[Dagger=8225]	[Darr=8609]	[Dashv=10980]	[Dcaron=270]	[Dcy=1044]	[Del=8711]	[Delta=916]	[Dfr=120071]	[DiacriticalAcute=180]	[DiacriticalDot=729]	[DiacriticalDoubleAcute=733]	[DiacriticalGrave=96]	[DiacriticalTilde=732]	[Diamond=8900]	[DifferentialD=8518]	[Dopf=120123]	[Dot=168]	[DotDot=8412]	[DotEqual=8784]	[DoubleContourIntegral=8751]	[DoubleDot=168]	[DoubleDownArrow=8659]	[DoubleLeftArrow=8656]	[DoubleLeftRightArrow=8660]	[DoubleLeftTee=10980]	[DoubleLongLeftArrow=10232]	[DoubleLongLeftRightArrow=10234]	[DoubleLongRightArrow=10233]	[DoubleRightArrow=8658]	[DoubleRightTee=8872]	[DoubleUpArrow=8657]	[DoubleUpDownArrow=8661]	[DoubleVerticalBar=8741]	[DownArrow=8595]	[DownArrowBar=10515]	[DownArrowUpArrow=8693]	[DownBreve=785]	[DownLeftRightVector=10576]	[DownLeftTeeVector=10590]	[DownLeftVector=8637]	[DownLeftVectorBar=10582]	[DownRightTeeVector=10591]	[DownRightVector=8641]	[DownRightVectorBar=10583]	[DownTee=8868]	[DownTeeArrow=8615]	[Downarrow=8659]	[Dscr=119967]	[Dstrok=272]	[ENG=330]	[ET=208]	[ETH=208]	[Eacut=201]	[Eacute=201]	[Ecaron=282]	[Ecir=202]	[Ecirc=202]	[Ecy=1069]	[Edot=278]	[Efr=120072]	[Egrav=200]	[Egrave=200]	[Element=8712]	[Emacr=274]	[EmptySmallSquare=9723]	[EmptyVerySmallSquare=9643]	[Eogon=280]	[Eopf=120124]	[Epsilon=917]	[Equal=10869]	[EqualTilde=8770]	[Equilibrium=8652]	[Escr=8496]	[Esim=10867]	[Eta=919]	[Eum=203]	[Euml=203]	[Exists=8707]	[ExponentialE=8519]	[Fcy=1060]	[Ffr=120073]	[FilledSmallSquare=9724]	[FilledVerySmallSquare=9642]	[Fopf=120125]	[ForAll=8704]	[Fouriertrf=8497]	[Fscr=8497]	[G=62]	[GJcy=1027]	[GT=62]	[Gamma=915]	[Gammad=988]	[Gbreve=286]	[Gcedil=290]	[Gcirc=284]	[Gcy=1043]	[Gdot=288]	[Gfr=120074]	[Gg=8921]	[Gopf=120126]	[GreaterEqual=8805]	[GreaterEqualLess=8923]	[GreaterFullEqual=8807]	[GreaterGreater=10914]	[GreaterLess=8823]	[GreaterSlantEqual=10878]	[GreaterTilde=8819]	[Gscr=119970]	[Gt=8811]	[HARDcy=1066]	[Hacek=711]	[Hat=94]	[Hcirc=292]	[Hfr=8460]	[HilbertSpace=8459]	[Hopf=8461]	[HorizontalLine=9472]	[Hscr=8459]	[Hstrok=294]	[HumpDownHump=8782]	[HumpEqual=8783]	[IEcy=1045]	[IJlig=306]	[IOcy=1025]	[Iacut=205]	[Iacute=205]	[Icir=206]	[Icirc=206]	[Icy=1048]	[Idot=304]	[Ifr=8465]	[Igrav=204]	[Igrave=204]	[Im=8465]	[Imacr=298]	[ImaginaryI=8520]	[Implies=8658]	[Int=8748]	[Integral=8747]	[Intersection=8898]	[InvisibleComma=8291]	[InvisibleTimes=8290]	[Iogon=302]	[Iopf=120128]	[Iota=921]	[Iscr=8464]	[Itilde=296]	[Iukcy=1030]	[Ium=207]	[Iuml=207]	[Jcirc=308]	[Jcy=1049]	[Jfr=120077]	[Jopf=120129]	[Jscr=119973]	[Jsercy=1032]	[Jukcy=1028]	[KHcy=1061]	[KJcy=1036]	[Kappa=922]	[Kcedil=310]	[Kcy=1050]	[Kfr=120078]	[Kopf=120130]	[Kscr=119974]	[L=60]	[LJcy=1033]	[LT=60]	[Lacute=313]	[Lambda=923]	[Lang=10218]	[Laplacetrf=8466]	[Larr=8606]	[Lcaron=317]	[Lcedil=315]	[Lcy=1051]	[LeftAngleBracket=10216]	[LeftArrow=8592]	[LeftArrowBar=8676]	[LeftArrowRightArrow=8646]	[LeftCeiling=8968]	[LeftDoubleBracket=10214]	[LeftDownTeeVector=10593]	[LeftDownVector=8643]	[LeftDownVectorBar=10585]	[LeftFloor=8970]	[LeftRightArrow=8596]	[LeftRightVector=10574]	[LeftTee=8867]	[LeftTeeArrow=8612]	[LeftTeeVector=10586]	[LeftTriangle=8882]	[LeftTriangleBar=10703]	[LeftTriangleEqual=8884]	[LeftUpDownVector=10577]	[LeftUpTeeVector=10592]	[LeftUpVector=8639]	[LeftUpVectorBar=10584]	[LeftVector=8636]	[LeftVectorBar=10578]	[Leftarrow=8656]	[Leftrightarrow=8660]	[LessEqualGreater=8922]	[LessFullEqual=8806]	[LessGreater=8822]	[LessLess=10913]	[LessSlantEqual=10877]	[LessTilde=8818]	[Lfr=120079]	[Ll=8920]	[Lleftarrow=8666]	[Lmidot=319]	[LongLeftArrow=10229]	[LongLeftRightArrow=10231]	[LongRightArrow=10230]	[Longleftarrow=10232]	[Longleftrightarrow=10234]	[Longrightarrow=10233]	[Lopf=120131]	[LowerLeftArrow=8601]	[LowerRightArrow=8600]	[Lscr=8466]	[Lsh=8624]	[Lstrok=321]	[Lt=8810]	[Map=10501]	[Mcy=1052]	[MediumSpace=8287]	[Mellintrf=8499]	[Mfr=120080]	[MinusPlus=8723]	[Mopf=120132]	[Mscr=8499]	[Mu=924]	[NJcy=1034]	[Nacute=323]	[Ncaron=327]	[Ncedil=325]	[Ncy=1053]	[NegativeMediumSpace=8203]	[NegativeThickSpace=8203]	[NegativeThinSpace=8203]	[NegativeVeryThinSpace=8203]	[NestedGreaterGreater=8811]	[NestedLessLess=8810]	[NewLine=10]	[Nfr=120081]	[NoBreak=8288]	[NonBreakingSpace=160]	[Nopf=8469]	[Not=10988]	[NotCongruent=8802]	[NotCupCap=8813]	[NotDoubleVerticalBar=8742]	[NotElement=8713]	[NotEqual=8800]	[NotEqualTilde=8770]	[NotExists=8708]	[NotGreater=8815]	[NotGreaterEqual=8817]	[NotGreaterFullEqual=8807]	[NotGreaterGreater=8811]	[NotGreaterLess=8825]	[NotGreaterSlantEqual=10878]	[NotGreaterTilde=8821]	[NotHumpDownHump=8782]	[NotHumpEqual=8783]	[NotLeftTriangle=8938]	[NotLeftTriangleBar=10703]	[NotLeftTriangleEqual=8940]	[NotLess=8814]	[NotLessEqual=8816]	[NotLessGreater=8824]	[NotLessLess=8810]	[NotLessSlantEqual=10877]	[NotLessTilde=8820]	[NotNestedGreaterGreater=10914]	[NotNestedLessLess=10913]	[NotPrecedes=8832]	[NotPrecedesEqual=10927]	[NotPrecedesSlantEqual=8928]	[NotReverseElement=8716]	[NotRightTriangle=8939]	[NotRightTriangleBar=10704]	[NotRightTriangleEqual=8941]	[NotSquareSubset=8847]	[NotSquareSubsetEqual=8930]	[NotSquareSuperset=8848]	[NotSquareSupersetEqual=8931]	[NotSubset=8834]	[NotSubsetEqual=8840]	[NotSucceeds=8833]	[NotSucceedsEqual=10928]	[NotSucceedsSlantEqual=8929]	[NotSucceedsTilde=8831]	[NotSuperset=8835]	[NotSupersetEqual=8841]	[NotTilde=8769]	[NotTildeEqual=8772]	[NotTildeFullEqual=8775]	[NotTildeTilde=8777]	[NotVerticalBar=8740]	[Nscr=119977]	[Ntild=209]	[Ntilde=209]	[Nu=925]	[OElig=338]	[Oacut=211]	[Oacute=211]	[Ocir=212]	[Ocirc=212]	[Ocy=1054]	[Odblac=336]	[Ofr=120082]	[Ograv=210]	[Ograve=210]	[Omacr=332]	[Omega=937]	[Omicron=927]	[Oopf=120134]	[OpenCurlyDoubleQuote=8220]	[OpenCurlyQuote=8216]	[Or=10836]	[Oscr=119978]	[Oslas=216]	[Oslash=216]	[Otild=213]	[Otilde=213]	[Otimes=10807]	[Oum=214]	[Ouml=214]	[OverBar=8254]	[OverBrace=9182]	[OverBracket=9140]	[OverParenthesis=9180]	[PartialD=8706]	[Pcy=1055]	[Pfr=120083]	[Phi=934]	[Pi=928]	[PlusMinus=177]	[Poincareplane=8460]	[Popf=8473]	[Pr=10939]	[Precedes=8826]	[PrecedesEqual=10927]	[PrecedesSlantEqual=8828]	[PrecedesTilde=8830]	[Prime=8243]	[Product=8719]	[Proportion=8759]	[Proportional=8733]	[Pscr=119979]	[Psi=936]	[QUO=34]	[QUOT=34]	[Qfr=120084]	[Qopf=8474]	[Qscr=119980]	[RBarr=10512]	[RE=174]	[REG=174]	[Racute=340]	[Rang=10219]	[Rarr=8608]	[Rarrtl=10518]	[Rcaron=344]	[Rcedil=342]	[Rcy=1056]	[Re=8476]	[ReverseElement=8715]	[ReverseEquilibrium=8651]	[ReverseUpEquilibrium=10607]	[Rfr=8476]	[Rho=929]	[RightAngleBracket=10217]	[RightArrow=8594]	[RightArrowBar=8677]	[RightArrowLeftArrow=8644]	[RightCeiling=8969]	[RightDoubleBracket=10215]	[RightDownTeeVector=10589]	[RightDownVector=8642]	[RightDownVectorBar=10581]	[RightFloor=8971]	[RightTee=8866]	[RightTeeArrow=8614]	[RightTeeVector=10587]	[RightTriangle=8883]	[RightTriangleBar=10704]	[RightTriangleEqual=8885]	[RightUpDownVector=10575]	[RightUpTeeVector=10588]	[RightUpVector=8638]	[RightUpVectorBar=10580]	[RightVector=8640]	[RightVectorBar=10579]	[Rightarrow=8658]	[Ropf=8477]	[RoundImplies=10608]	[Rrightarrow=8667]	[Rscr=8475]	[Rsh=8625]	[RuleDelayed=10740]	[SHCHcy=1065]	[SHcy=1064]	[SOFTcy=1068]	[Sacute=346]	[Sc=10940]	[Scaron=352]	[Scedil=350]	[Scirc=348]	[Scy=1057]	[Sfr=120086]	[ShortDownArrow=8595]	[ShortLeftArrow=8592]	[ShortRightArrow=8594]	[ShortUpArrow=8593]	[Sigma=931]	[SmallCircle=8728]	[Sopf=120138]	[Sqrt=8730]	[Square=9633]	[SquareIntersection=8851]	[SquareSubset=8847]	[SquareSubsetEqual=8849]	[SquareSuperset=8848]	[SquareSupersetEqual=8850]	[SquareUnion=8852]	[Sscr=119982]	[Star=8902]	[Sub=8912]	[Subset=8912]	[SubsetEqual=8838]	[Succeeds=8827]	[SucceedsEqual=10928]	[SucceedsSlantEqual=8829]	[SucceedsTilde=8831]	[SuchThat=8715]	[Sum=8721]	[Sup=8913]	[Superset=8835]	[SupersetEqual=8839]	[Supset=8913]	[THOR=222]	[THORN=222]	[TRADE=8482]	[TSHcy=1035]	[TScy=1062]	[Tab=9]	[Tau=932]	[Tcaron=356]	[Tcedil=354]	[Tcy=1058]	[Tfr=120087]	[Therefore=8756]	[Theta=920]	[ThickSpace=8287]	[ThinSpace=8201]	[Tilde=8764]	[TildeEqual=8771]	[TildeFullEqual=8773]	[TildeTilde=8776]	[Topf=120139]	[TripleDot=8411]	[Tscr=119983]	[Tstrok=358]	[Uacut=218]	[Uacute=218]	[Uarr=8607]	[Uarrocir=10569]	[Ubrcy=1038]	[Ubreve=364]	[Ucir=219]	[Ucirc=219]	[Ucy=1059]	[Udblac=368]	[Ufr=120088]	[Ugrav=217]	[Ugrave=217]	[Umacr=362]	[UnderBar=95]	[UnderBrace=9183]	[UnderBracket=9141]	[UnderParenthesis=9181]	[Union=8899]	[UnionPlus=8846]	[Uogon=370]	[Uopf=120140]	[UpArrow=8593]	[UpArrowBar=10514]	[UpArrowDownArrow=8645]	[UpDownArrow=8597]	[UpEquilibrium=10606]	[UpTee=8869]	[UpTeeArrow=8613]	[Uparrow=8657]	[Updownarrow=8661]	[UpperLeftArrow=8598]	[UpperRightArrow=8599]	[Upsi=978]	[Upsilon=933]	[Uring=366]	[Uscr=119984]	[Utilde=360]	[Uum=220]	[Uuml=220]	[VDash=8875]	[Vbar=10987]	[Vcy=1042]	[Vdash=8873]	[Vdashl=10982]	[Vee=8897]	[Verbar=8214]	[Vert=8214]	[VerticalBar=8739]	[VerticalLine=124]	[VerticalSeparator=10072]	[VerticalTilde=8768]	[VeryThinSpace=8202]	[Vfr=120089]	[Vopf=120141]	[Vscr=119985]	[Vvdash=8874]	[Wcirc=372]	[Wedge=8896]	[Wfr=120090]	[Wopf=120142]	[Wscr=119986]	[Xfr=120091]	[Xi=926]	[Xopf=120143]	[Xscr=119987]	[YAcy=1071]	[YIcy=1031]	[YUcy=1070]	[Yacut=221]	[Yacute=221]	[Ycirc=374]	[Ycy=1067]	[Yfr=120092]	[Yopf=120144]	[Yscr=119988]	[Yuml=376]	[ZHcy=1046]	[Zacute=377]	[Zcaron=381]	[Zcy=1047]	[Zdot=379]	[ZeroWidthSpace=8203]	[Zeta=918]	[Zfr=8488]	[Zopf=8484]	[Zscr=119989]	[aacut=225]	[aacute=225]	[abreve=259]	[ac=8766]	[acE=8766]	[acd=8767]	[acir=226]	[acirc=226]	[acut=180]	[acute=180]	[acy=1072]	[aeli=230]	[aelig=230]	[af=8289]	[afr=120094]	[agrav=224]	[agrave=224]	[alefsym=8501]	[aleph=8501]	[alpha=945]	[am=38]	[amacr=257]	[amalg=10815]	[amp=38]	[and=8743]	[andand=10837]	[andd=10844]	[andslope=10840]	[andv=10842]	[ang=8736]	[ange=10660]	[angle=8736]	[angmsd=8737]	[angmsdaa=10664]	[angmsdab=10665]	[angmsdac=10666]	[angmsdad=10667]	[angmsdae=10668]	[angmsdaf=10669]	[angmsdag=10670]	[angmsdah=10671]	[angrt=8735]	[angrtvb=8894]	[angrtvbd=10653]	[angsph=8738]	[angst=197]	[angzarr=9084]	[aogon=261]	[aopf=120146]	[ap=8776]	[apE=10864]	[apacir=10863]	[ape=8778]	[apid=8779]	[apos=39]	[approx=8776]	[approxeq=8778]	[arin=229]	[aring=229]	[ascr=119990]	[ast=42]	[asymp=8776]	[asympeq=8781]	[atild=227]	[atilde=227]	[aum=228]	[auml=228]	[awconint=8755]	[awint=10769]	[bNot=10989]	[backcong=8780]	[backepsilon=1014]	[backprime=8245]	[backsim=8765]	[backsimeq=8909]	[barvee=8893]	[barwed=8965]	[barwedge=8965]	[bbrk=9141]	[bbrktbrk=9142]	[bcong=8780]	[bcy=1073]	[bdquo=8222]	[becaus=8757]	[because=8757]	[bemptyv=10672]	[bepsi=1014]	[bernou=8492]	[beta=946]	[beth=8502]	[between=8812]	[bfr=120095]	[bigcap=8898]	[bigcirc=9711]	[bigcup=8899]	[bigodot=10752]	[bigoplus=10753]	[bigotimes=10754]	[bigsqcup=10758]	[bigstar=9733]	[bigtriangledown=9661]	[bigtriangleup=9651]	[biguplus=10756]	[bigvee=8897]	[bigwedge=8896]	[bkarow=10509]	[blacklozenge=10731]	[blacksquare=9642]	[blacktriangle=9652]	[blacktriangledown=9662]	[blacktriangleleft=9666]	[blacktriangleright=9656]	[blank=9251]	[blk12=9618]	[blk14=9617]	[blk34=9619]	[block=9608]	[bne=61]	[bnequiv=8801]	[bnot=8976]	[bopf=120147]	[bot=8869]	[bottom=8869]	[bowtie=8904]	[boxDL=9559]	[boxDR=9556]	[boxDl=9558]	[boxDr=9555]	[boxH=9552]	[boxHD=9574]	[boxHU=9577]	[boxHd=9572]	[boxHu=9575]	[boxUL=9565]	[boxUR=9562]	[boxUl=9564]	[boxUr=9561]	[boxV=9553]	[boxVH=9580]	[boxVL=9571]	[boxVR=9568]	[boxVh=9579]	[boxVl=9570]	[boxVr=9567]	[boxbox=10697]	[boxdL=9557]	[boxdR=9554]	[boxdl=9488]	[boxdr=9484]	[boxh=9472]	[boxhD=9573]	[boxhU=9576]	[boxhd=9516]	[boxhu=9524]	[boxminus=8863]	[boxplus=8862]	[boxtimes=8864]	[boxuL=9563]	[boxuR=9560]	[boxul=9496]	[boxur=9492]	[boxv=9474]	[boxvH=9578]	[boxvL=9569]	[boxvR=9566]	[boxvh=9532]	[boxvl=9508]	[boxvr=9500]	[bprime=8245]	[breve=728]	[brvba=166]	[brvbar=166]	[bscr=119991]	[bsemi=8271]	[bsim=8765]	[bsime=8909]	[bsol=92]	[bsolb=10693]	[bsolhsub=10184]	[bull=8226]	[bullet=8226]	[bump=8782]	[bumpE=10926]	[bumpe=8783]	[bumpeq=8783]	[cacute=263]	[cap=8745]	[capand=10820]	[capbrcup=10825]	[capcap=10827]	[capcup=10823]	[capdot=10816]	[caps=8745]	[caret=8257]	[caron=711]	[ccaps=10829]	[ccaron=269]	[ccedi=231]	[ccedil=231]	[ccirc=265]	[ccups=10828]	[ccupssm=10832]	[cdot=267]	[cedi=184]	[cedil=184]	[cemptyv=10674]	[cen=162]	[cent=162]	[centerdot=183]	[cfr=120096]	[chcy=1095]	[check=10003]	[checkmark=10003]	[chi=967]	[cir=9675]	[cirE=10691]	[circ=710]	[circeq=8791]	[circlearrowleft=8634]	[circlearrowright=8635]	[circledR=174]	[circledS=9416]	[circledast=8859]	[circledcirc=8858]	[circleddash=8861]	[cire=8791]	[cirfnint=10768]	[cirmid=10991]	[cirscir=10690]	[clubs=9827]	[clubsuit=9827]	[colon=58]	[colone=8788]	[coloneq=8788]	[comma=44]	[commat=64]	[comp=8705]	[compfn=8728]	[complement=8705]	[complexes=8450]	[cong=8773]	[congdot=10861]	[conint=8750]	[cop=169]	[copf=120148]	[coprod=8720]	[copy=169]	[copysr=8471]	[crarr=8629]	[cross=10007]	[cscr=119992]	[csub=10959]	[csube=10961]	[csup=10960]	[csupe=10962]	[ctdot=8943]	[cudarrl=10552]	[cudarrr=10549]	[cuepr=8926]	[cuesc=8927]	[cularr=8630]	[cularrp=10557]	[cup=8746]	[cupbrcap=10824]	[cupcap=10822]	[cupcup=10826]	[cupdot=8845]	[cupor=10821]	[cups=8746]	[curarr=8631]	[curarrm=10556]	[curlyeqprec=8926]	[curlyeqsucc=8927]	[curlyvee=8910]	[curlywedge=8911]	[curre=164]	[curren=164]	[curvearrowleft=8630]	[curvearrowright=8631]	[cuvee=8910]	[cuwed=8911]	[cwconint=8754]	[cwint=8753]	[cylcty=9005]	[dArr=8659]	[dHar=10597]	[dagger=8224]	[daleth=8504]	[darr=8595]	[dash=8208]	[dashv=8867]	[dbkarow=10511]	[dblac=733]	[dcaron=271]	[dcy=1076]	[dd=8518]	[ddagger=8225]	[ddarr=8650]	[ddotseq=10871]	[de=176]	[deg=176]	[delta=948]	[demptyv=10673]	[dfisht=10623]	[dfr=120097]	[dharl=8643]	[dharr=8642]	[diam=8900]	[diamond=8900]	[diamondsuit=9830]	[diams=9830]	[die=168]	[digamma=989]	[disin=8946]	[div=247]	[divid=247]	[divide=247]	[divideontimes=8903]	[divonx=8903]	[djcy=1106]	[dlcorn=8990]	[dlcrop=8973]	[dollar=36]	[dopf=120149]	[dot=729]	[doteq=8784]	[doteqdot=8785]	[dotminus=8760]	[dotplus=8724]	[dotsquare=8865]	[doublebarwedge=8966]	[downarrow=8595]	[downdownarrows=8650]	[downharpoonleft=8643]	[downharpoonright=8642]	[drbkarow=10512]	[drcorn=8991]	[drcrop=8972]	[dscr=119993]	[dscy=1109]	[dsol=10742]	[dstrok=273]	[dtdot=8945]	[dtri=9663]	[dtrif=9662]	[duarr=8693]	[duhar=10607]	[dwangle=10662]	[dzcy=1119]	[dzigrarr=10239]	[eDDot=10871]	[eDot=8785]	[eacut=233]	[eacute=233]	[easter=10862]	[ecaron=283]	[ecir=234]	[ecir=8790]	[ecirc=234]	[ecolon=8789]	[ecy=1101]	[edot=279]	[ee=8519]	[efDot=8786]	[efr=120098]	[eg=10906]	[egrav=232]	[egrave=232]	[egs=10902]	[egsdot=10904]	[el=10905]	[elinters=9191]	[ell=8467]	[els=10901]	[elsdot=10903]	[emacr=275]	[empty=8709]	[emptyset=8709]	[emptyv=8709]	[emsp=8195]	[emsp13=8196]	[emsp14=8197]	[eng=331]	[ensp=8194]	[eogon=281]	[eopf=120150]	[epar=8917]	[eparsl=10723]	[eplus=10865]	[epsi=949]	[epsilon=949]	[epsiv=1013]	[eqcirc=8790]	[eqcolon=8789]	[eqsim=8770]	[eqslantgtr=10902]	[eqslantless=10901]	[equals=61]	[equest=8799]	[equiv=8801]	[equivDD=10872]	[eqvparsl=10725]	[erDot=8787]	[erarr=10609]	[escr=8495]	[esdot=8784]	[esim=8770]	[et=240]	[eta=951]	[eth=240]	[eum=235]	[euml=235]	[euro=8364]	[excl=33]	[exist=8707]	[expectation=8496]	[exponentiale=8519]	[fallingdotseq=8786]	[fcy=1092]	[female=9792]	[ffilig=64259]	[fflig=64256]	[ffllig=64260]	[ffr=120099]	[filig=64257]	[fjlig=102]	[flat=9837]	[fllig=64258]	[fltns=9649]	[fnof=402]	[fopf=120151]	[forall=8704]	[fork=8916]	[forkv=10969]	[fpartint=10765]	[frac1=189]	[frac1=188]	[frac12=189]	[frac13=8531]	[frac14=188]	[frac15=8533]	[frac16=8537]	[frac18=8539]	[frac23=8532]	[frac25=8534]	[frac3=190]	[frac34=190]	[frac35=8535]	[frac38=8540]	[frac45=8536]	[frac56=8538]	[frac58=8541]	[frac78=8542]	[frasl=8260]	[frown=8994]	[fscr=119995]	[g=62]	[gE=8807]	[gEl=10892]	[gacute=501]	[gamma=947]	[gammad=989]	[gap=10886]	[gbreve=287]	[gcirc=285]	[gcy=1075]	[gdot=289]	[ge=8805]	[gel=8923]	[geq=8805]	[geqq=8807]	[geqslant=10878]	[ges=10878]	[gescc=10921]	[gesdot=10880]	[gesdoto=10882]	[gesdotol=10884]	[gesl=8923]	[gesles=10900]	[gfr=120100]	[gg=8811]	[ggg=8921]	[gimel=8503]	[gjcy=1107]	[gl=8823]	[glE=10898]	[gla=10917]	[glj=10916]	[gnE=8809]	[gnap=10890]	[gnapprox=10890]	[gne=10888]	[gneq=10888]	[gneqq=8809]	[gnsim=8935]	[gopf=120152]	[grave=96]	[gscr=8458]	[gsim=8819]	[gsime=10894]	[gsiml=10896]	[gt=62]	[gtcc=10919]	[gtcir=10874]	[gtdot=8919]	[gtlPar=10645]	[gtquest=10876]	[gtrapprox=10886]	[gtrarr=10616]	[gtrdot=8919]	[gtreqless=8923]	[gtreqqless=10892]	[gtrless=8823]	[gtrsim=8819]	[gvertneqq=8809]	[gvnE=8809]	[hArr=8660]	[hairsp=8202]	[half=189]	[hamilt=8459]	[hardcy=1098]	[harr=8596]	[harrcir=10568]	[harrw=8621]	[hbar=8463]	[hcirc=293]	[hearts=9829]	[heartsuit=9829]	[hellip=8230]	[hercon=8889]	[hfr=120101]	[hksearow=10533]	[hkswarow=10534]	[hoarr=8703]	[homtht=8763]	[hookleftarrow=8617]	[hookrightarrow=8618]	[hopf=120153]	[horbar=8213]	[hscr=119997]	[hslash=8463]	[hstrok=295]	[hybull=8259]	[hyphen=8208]	[iacut=237]	[iacute=237]	[ic=8291]	[icir=238]	[icirc=238]	[icy=1080]	[iecy=1077]	[iexc=161]	[iexcl=161]	[iff=8660]	[ifr=120102]	[igrav=236]	[igrave=236]	[ii=8520]	[iiiint=10764]	[iiint=8749]	[iinfin=10716]	[iiota=8489]	[ijlig=307]	[imacr=299]	[image=8465]	[imagline=8464]	[imagpart=8465]	[imath=305]	[imof=8887]	[imped=437]	[in=8712]	[incare=8453]	[infin=8734]	[infintie=10717]	[inodot=305]	[int=8747]	[intcal=8890]	[integers=8484]	[intercal=8890]	[intlarhk=10775]	[intprod=10812]	[iocy=1105]	[iogon=303]	[iopf=120154]	[iota=953]	[iprod=10812]	[iques=191]	[iquest=191]	[iscr=119998]	[isin=8712]	[isinE=8953]	[isindot=8949]	[isins=8948]	[isinsv=8947]	[isinv=8712]	[it=8290]	[itilde=297]	[iukcy=1110]	[ium=239]	[iuml=239]	[jcirc=309]	[jcy=1081]	[jfr=120103]	[jmath=567]	[jopf=120155]	[jscr=119999]	[jsercy=1112]	[jukcy=1108]	[kappa=954]	[kappav=1008]	[kcedil=311]	[kcy=1082]	[kfr=120104]	[kgreen=312]	[khcy=1093]	[kjcy=1116]	[kopf=120156]	[kscr=120000]	[l=60]	[lAarr=8666]	[lArr=8656]	[lAtail=10523]	[lBarr=10510]	[lE=8806]	[lEg=10891]	[lHar=10594]	[lacute=314]	[laemptyv=10676]	[lagran=8466]	[lambda=955]	[lang=10216]	[langd=10641]	[langle=10216]	[lap=10885]	[laqu=171]	[laquo=171]	[larr=8592]	[larrb=8676]	[larrbfs=10527]	[larrfs=10525]	[larrhk=8617]	[larrlp=8619]	[larrpl=10553]	[larrsim=10611]	[larrtl=8610]	[lat=10923]	[latail=10521]	[late=10925]	[lates=10925]	[lbarr=10508]	[lbbrk=10098]	[lbrace=123]	[lbrack=91]	[lbrke=10635]	[lbrksld=10639]	[lbrkslu=10637]	[lcaron=318]	[lcedil=316]	[lceil=8968]	[lcub=123]	[lcy=1083]	[ldca=10550]	[ldquo=8220]	[ldquor=8222]	[ldrdhar=10599]	[ldrushar=10571]	[ldsh=8626]	[le=8804]	[leftarrow=8592]	[leftarrowtail=8610]	[leftharpoondown=8637]	[leftharpoonup=8636]	[leftleftarrows=8647]	[leftrightarrow=8596]	[leftrightarrows=8646]	[leftrightharpoons=8651]	[leftrightsquigarrow=8621]	[leftthreetimes=8907]	[leg=8922]	[leq=8804]	[leqq=8806]	[leqslant=10877]	[les=10877]	[lescc=10920]	[lesdot=10879]	[lesdoto=10881]	[lesdotor=10883]	[lesg=8922]	[lesges=10899]	[lessapprox=10885]	[lessdot=8918]	[lesseqgtr=8922]	[lesseqqgtr=10891]	[lessgtr=8822]	[lesssim=8818]	[lfisht=10620]	[lfloor=8970]	[lfr=120105]	[lg=8822]	[lgE=10897]	[lhard=8637]	[lharu=8636]	[lharul=10602]	[lhblk=9604]	[ljcy=1113]	[ll=8810]	[llarr=8647]	[llcorner=8990]	[llhard=10603]	[lltri=9722]	[lmidot=320]	[lmoust=9136]	[lmoustache=9136]	[lnE=8808]	[lnap=10889]	[lnapprox=10889]	[lne=10887]	[lneq=10887]	[lneqq=8808]	[lnsim=8934]	[loang=10220]	[loarr=8701]	[lobrk=10214]	[longleftarrow=10229]	[longleftrightarrow=10231]	[longmapsto=10236]	[longrightarrow=10230]	[looparrowleft=8619]	[looparrowright=8620]	[lopar=10629]	[lopf=120157]	[loplus=10797]	[lotimes=10804]	[lowast=8727]	[lowbar=95]	[loz=9674]	[lozenge=9674]	[lozf=10731]	[lpar=40]	[lparlt=10643]	[lrarr=8646]	[lrcorner=8991]	[lrhar=8651]	[lrhard=10605]	[lrm=8206]	[lrtri=8895]	[lsaquo=8249]	[lscr=120001]	[lsh=8624]	[lsim=8818]	[lsime=10893]	[lsimg=10895]	[lsqb=91]	[lsquo=8216]	[lsquor=8218]	[lstrok=322]	[lt=60]	[ltcc=10918]	[ltcir=10873]	[ltdot=8918]	[lthree=8907]	[ltimes=8905]	[ltlarr=10614]	[ltquest=10875]	[ltrPar=10646]	[ltri=9667]	[ltrie=8884]	[ltrif=9666]	[lurdshar=10570]	[luruhar=10598]	[lvertneqq=8808]	[lvnE=8808]	[mDDot=8762]	[mac=175]	[macr=175]	[male=9794]	[malt=10016]	[maltese=10016]	[map=8614]	[mapsto=8614]	[mapstodown=8615]	[mapstoleft=8612]	[mapstoup=8613]	[marker=9646]	[mcomma=10793]	[mcy=1084]	[mdash=8212]	[measuredangle=8737]	[mfr=120106]	[mho=8487]	[micr=181]	[micro=181]	[mid=8739]	[midast=42]	[midcir=10992]	[middo=183]	[middot=183]	[minus=8722]	[minusb=8863]	[minusd=8760]	[minusdu=10794]	[mlcp=10971]	[mldr=8230]	[mnplus=8723]	[models=8871]	[mopf=120158]	[mp=8723]	[mscr=120002]	[mstpos=8766]	[mu=956]	[multimap=8888]	[mumap=8888]	[nGg=8921]	[nGt=8811]	[nGtv=8811]	[nLeftarrow=8653]	[nLeftrightarrow=8654]	[nLl=8920]	[nLt=8810]	[nLtv=8810]	[nRightarrow=8655]	[nVDash=8879]	[nVdash=8878]	[nabla=8711]	[nacute=324]	[nang=8736]	[nap=8777]	[napE=10864]	[napid=8779]	[napos=329]	[napprox=8777]	[natur=9838]	[natural=9838]	[naturals=8469]	[nbs=160]	[nbsp=160]	[nbump=8782]	[nbumpe=8783]	[ncap=10819]	[ncaron=328]	[ncedil=326]	[ncong=8775]	[ncongdot=10861]	[ncup=10818]	[ncy=1085]	[ndash=8211]	[ne=8800]	[neArr=8663]	[nearhk=10532]	[nearr=8599]	[nearrow=8599]	[nedot=8784]	[nequiv=8802]	[nesear=10536]	[nesim=8770]	[nexist=8708]	[nexists=8708]	[nfr=120107]	[ngE=8807]	[nge=8817]	[ngeq=8817]	[ngeqq=8807]	[ngeqslant=10878]	[nges=10878]	[ngsim=8821]	[ngt=8815]	[ngtr=8815]	[nhArr=8654]	[nharr=8622]	[nhpar=10994]	[ni=8715]	[nis=8956]	[nisd=8954]	[niv=8715]	[njcy=1114]	[nlArr=8653]	[nlE=8806]	[nlarr=8602]	[nldr=8229]	[nle=8816]	[nleftarrow=8602]	[nleftrightarrow=8622]	[nleq=8816]	[nleqq=8806]	[nleqslant=10877]	[nles=10877]	[nless=8814]	[nlsim=8820]	[nlt=8814]	[nltri=8938]	[nltrie=8940]	[nmid=8740]	[no=172]	[nopf=120159]	[not=172]	[notin=8713]	[notinE=8953]	[notindot=8949]	[notinva=8713]	[notinvb=8951]	[notinvc=8950]	[notni=8716]	[notniva=8716]	[notnivb=8958]	[notnivc=8957]	[npar=8742]	[nparallel=8742]	[nparsl=11005]	[npart=8706]	[npolint=10772]	[npr=8832]	[nprcue=8928]	[npre=10927]	[nprec=8832]	[npreceq=10927]	[nrArr=8655]	[nrarr=8603]	[nrarrc=10547]	[nrarrw=8605]	[nrightarrow=8603]	[nrtri=8939]	[nrtrie=8941]	[nsc=8833]	[nsccue=8929]	[nsce=10928]	[nscr=120003]	[nshortmid=8740]	[nshortparallel=8742]	[nsim=8769]	[nsime=8772]	[nsimeq=8772]	[nsmid=8740]	[nspar=8742]	[nsqsube=8930]	[nsqsupe=8931]	[nsub=8836]	[nsubE=10949]	[nsube=8840]	[nsubset=8834]	[nsubseteq=8840]	[nsubseteqq=10949]	[nsucc=8833]	[nsucceq=10928]	[nsup=8837]	[nsupE=10950]	[nsupe=8841]	[nsupset=8835]	[nsupseteq=8841]	[nsupseteqq=10950]	[ntgl=8825]	[ntild=241]	[ntilde=241]	[ntlg=8824]	[ntriangleleft=8938]	[ntrianglelefteq=8940]	[ntriangleright=8939]	[ntrianglerighteq=8941]	[nu=957]	[num=35]	[numero=8470]	[numsp=8199]	[nvDash=8877]	[nvHarr=10500]	[nvap=8781]	[nvdash=8876]	[nvge=8805]	[nvgt=62]	[nvinfin=10718]	[nvlArr=10498]	[nvle=8804]	[nvlt=60]	[nvltrie=8884]	[nvrArr=10499]	[nvrtrie=8885]	[nvsim=8764]	[nwArr=8662]	[nwarhk=10531]	[nwarr=8598]	[nwarrow=8598]	[nwnear=10535]	[oS=9416]	[oacut=243]	[oacute=243]	[oast=8859]	[ocir=244]	[ocir=8858]	[ocirc=244]	[ocy=1086]	[odash=8861]	[odblac=337]	[odiv=10808]	[odot=8857]	[odsold=10684]	[oelig=339]	[ofcir=10687]	[ofr=120108]	[ogon=731]	[ograv=242]	[ograve=242]	[ogt=10689]	[ohbar=10677]	[ohm=937]	[oint=8750]	[olarr=8634]	[olcir=10686]	[olcross=10683]	[oline=8254]	[olt=10688]	[omacr=333]	[omega=969]	[omicron=959]	[omid=10678]	[ominus=8854]	[oopf=120160]	[opar=10679]	[operp=10681]	[oplus=8853]	[or=8744]	[orarr=8635]	[ord=10845]	[ord=186]	[ord=170]	[order=8500]	[orderof=8500]	[ordf=170]	[ordm=186]	[origof=8886]	[oror=10838]	[orslope=10839]	[orv=10843]	[oscr=8500]	[oslas=248]	[oslash=248]	[osol=8856]	[otild=245]	[otilde=245]	[otimes=8855]	[otimesas=10806]	[oum=246]	[ouml=246]	[ovbar=9021]	[par=182]	[par=8741]	[para=182]	[parallel=8741]	[parsim=10995]	[parsl=11005]	[part=8706]	[pcy=1087]	[percnt=37]	[period=46]	[permil=8240]	[perp=8869]	[pertenk=8241]	[pfr=120109]	[phi=966]	[phiv=981]	[phmmat=8499]	[phone=9742]	[pi=960]	[pitchfork=8916]	[piv=982]	[planck=8463]	[planckh=8462]	[plankv=8463]	[plus=43]	[plusacir=10787]	[plusb=8862]	[pluscir=10786]	[plusdo=8724]	[plusdu=10789]	[pluse=10866]	[plusm=177]	[plusmn=177]	[plussim=10790]	[plustwo=10791]	[pm=177]	[pointint=10773]	[popf=120161]	[poun=163]	[pound=163]	[pr=8826]	[prE=10931]	[prap=10935]	[prcue=8828]	[pre=10927]	[prec=8826]	[precapprox=10935]	[preccurlyeq=8828]	[preceq=10927]	[precnapprox=10937]	[precneqq=10933]	[precnsim=8936]	[precsim=8830]	[prime=8242]	[primes=8473]	[prnE=10933]	[prnap=10937]	[prnsim=8936]	[prod=8719]	[profalar=9006]	[profline=8978]	[profsurf=8979]	[prop=8733]	[propto=8733]	[prsim=8830]	[prurel=8880]	[pscr=120005]	[psi=968]	[puncsp=8200]	[qfr=120110]	[qint=10764]	[qopf=120162]	[qprime=8279]	[qscr=120006]	[quaternions=8461]	[quatint=10774]	[quest=63]	[questeq=8799]	[quo=34]	[quot=34]	[rAarr=8667]	[rArr=8658]	[rAtail=10524]	[rBarr=10511]	[rHar=10596]	[race=8765]	[racute=341]	[radic=8730]	[raemptyv=10675]	[rang=10217]	[rangd=10642]	[range=10661]	[rangle=10217]	[raqu=187]	[raquo=187]	[rarr=8594]	[rarrap=10613]	[rarrb=8677]	[rarrbfs=10528]	[rarrc=10547]	[rarrfs=10526]	[rarrhk=8618]	[rarrlp=8620]	[rarrpl=10565]	[rarrsim=10612]	[rarrtl=8611]	[rarrw=8605]	[ratail=10522]	[ratio=8758]	[rationals=8474]	[rbarr=10509]	[rbbrk=10099]	[rbrace=125]	[rbrack=93]	[rbrke=10636]	[rbrksld=10638]	[rbrkslu=10640]	[rcaron=345]	[rcedil=343]	[rceil=8969]	[rcub=125]	[rcy=1088]	[rdca=10551]	[rdldhar=10601]	[rdquo=8221]	[rdquor=8221]	[rdsh=8627]	[re=174]	[real=8476]	[realine=8475]	[realpart=8476]	[reals=8477]	[rect=9645]	[reg=174]	[rfisht=10621]	[rfloor=8971]	[rfr=120111]	[rhard=8641]	[rharu=8640]	[rharul=10604]	[rho=961]	[rhov=1009]	[rightarrow=8594]	[rightarrowtail=8611]	[rightharpoondown=8641]	[rightharpoonup=8640]	[rightleftarrows=8644]	[rightleftharpoons=8652]	[rightrightarrows=8649]	[rightsquigarrow=8605]	[rightthreetimes=8908]	[ring=730]	[risingdotseq=8787]	[rlarr=8644]	[rlhar=8652]	[rlm=8207]	[rmoust=9137]	[rmoustache=9137]	[rnmid=10990]	[roang=10221]	[roarr=8702]	[robrk=10215]	[ropar=10630]	[ropf=120163]	[roplus=10798]	[rotimes=10805]	[rpar=41]	[rpargt=10644]	[rppolint=10770]	[rrarr=8649]	[rsaquo=8250]	[rscr=120007]	[rsh=8625]	[rsqb=93]	[rsquo=8217]	[rsquor=8217]	[rthree=8908]	[rtimes=8906]	[rtri=9657]	[rtrie=8885]	[rtrif=9656]	[rtriltri=10702]	[ruluhar=10600]	[rx=8478]	[sacute=347]	[sbquo=8218]	[sc=8827]	[scE=10932]	[scap=10936]	[scaron=353]	[sccue=8829]	[sce=10928]	[scedil=351]	[scirc=349]	[scnE=10934]	[scnap=10938]	[scnsim=8937]	[scpolint=10771]	[scsim=8831]	[scy=1089]	[sdot=8901]	[sdotb=8865]	[sdote=10854]	[seArr=8664]	[searhk=10533]	[searr=8600]	[searrow=8600]	[sec=167]	[sect=167]	[semi=59]	[seswar=10537]	[setminus=8726]	[setmn=8726]	[sext=10038]	[sfr=120112]	[sfrown=8994]	[sh=173]	[sharp=9839]	[shchcy=1097]	[shcy=1096]	[shortmid=8739]	[shortparallel=8741]	[shy=173]	[sigma=963]	[sigmaf=962]	[sigmav=962]	[sim=8764]	[simdot=10858]	[sime=8771]	[simeq=8771]	[simg=10910]	[simgE=10912]	[siml=10909]	[simlE=10911]	[simne=8774]	[simplus=10788]	[simrarr=10610]	[slarr=8592]	[smallsetminus=8726]	[smashp=10803]	[smeparsl=10724]	[smid=8739]	[smile=8995]	[smt=10922]	[smte=10924]	[smtes=10924]	[softcy=1100]	[sol=47]	[solb=10692]	[solbar=9023]	[sopf=120164]	[spades=9824]	[spadesuit=9824]	[spar=8741]	[sqcap=8851]	[sqcaps=8851]	[sqcup=8852]	[sqcups=8852]	[sqsub=8847]	[sqsube=8849]	[sqsubset=8847]	[sqsubseteq=8849]	[sqsup=8848]	[sqsupe=8850]	[sqsupset=8848]	[sqsupseteq=8850]	[squ=9633]	[square=9633]	[squarf=9642]	[squf=9642]	[srarr=8594]	[sscr=120008]	[ssetmn=8726]	[ssmile=8995]	[sstarf=8902]	[star=9734]	[starf=9733]	[straightepsilon=1013]	[straightphi=981]	[strns=175]	[sub=8834]	[subE=10949]	[subdot=10941]	[sube=8838]	[subedot=10947]	[submult=10945]	[subnE=10955]	[subne=8842]	[subplus=10943]	[subrarr=10617]	[subset=8834]	[subseteq=8838]	[subseteqq=10949]	[subsetneq=8842]	[subsetneqq=10955]	[subsim=10951]	[subsub=10965]	[subsup=10963]	[succ=8827]	[succapprox=10936]	[succcurlyeq=8829]	[succeq=10928]	[succnapprox=10938]	[succneqq=10934]	[succnsim=8937]	[succsim=8831]	[sum=8721]	[sung=9834]	[sup=179]	[sup=8835]	[sup=178]	[sup=185]	[sup1=185]	[sup2=178]	[sup3=179]	[supE=10950]	[supdot=10942]	[supdsub=10968]	[supe=8839]	[supedot=10948]	[suphsol=10185]	[suphsub=10967]	[suplarr=10619]	[supmult=10946]	[supnE=10956]	[supne=8843]	[supplus=10944]	[supset=8835]	[supseteq=8839]	[supseteqq=10950]	[supsetneq=8843]	[supsetneqq=10956]	[supsim=10952]	[supsub=10964]	[supsup=10966]	[swArr=8665]	[swarhk=10534]	[swarr=8601]	[swarrow=8601]	[swnwar=10538]	[szli=223]	[szlig=223]	[target=8982]	[tau=964]	[tbrk=9140]	[tcaron=357]	[tcedil=355]	[tcy=1090]	[tdot=8411]	[telrec=8981]	[tfr=120113]	[there4=8756]	[therefore=8756]	[theta=952]	[thetasym=977]	[thetav=977]	[thickapprox=8776]	[thicksim=8764]	[thinsp=8201]	[thkap=8776]	[thksim=8764]	[thor=254]	[thorn=254]	[tilde=732]	[time=215]	[times=215]	[timesb=8864]	[timesbar=10801]	[timesd=10800]	[tint=8749]	[toea=10536]	[top=8868]	[topbot=9014]	[topcir=10993]	[topf=120165]	[topfork=10970]	[tosa=10537]	[tprime=8244]	[trade=8482]	[triangle=9653]	[triangledown=9663]	[triangleleft=9667]	[trianglelefteq=8884]	[triangleq=8796]	[triangleright=9657]	[trianglerighteq=8885]	[tridot=9708]	[trie=8796]	[triminus=10810]	[triplus=10809]	[trisb=10701]	[tritime=10811]	[trpezium=9186]	[tscr=120009]	[tscy=1094]	[tshcy=1115]	[tstrok=359]	[twixt=8812]	[twoheadleftarrow=8606]	[twoheadrightarrow=8608]	[uArr=8657]	[uHar=10595]	[uacut=250]	[uacute=250]	[uarr=8593]	[ubrcy=1118]	[ubreve=365]	[ucir=251]	[ucirc=251]	[ucy=1091]	[udarr=8645]	[udblac=369]	[udhar=10606]	[ufisht=10622]	[ufr=120114]	[ugrav=249]	[ugrave=249]	[uharl=8639]	[uharr=8638]	[uhblk=9600]	[ulcorn=8988]	[ulcorner=8988]	[ulcrop=8975]	[ultri=9720]	[um=168]	[umacr=363]	[uml=168]	[uogon=371]	[uopf=120166]	[uparrow=8593]	[updownarrow=8597]	[upharpoonleft=8639]	[upharpoonright=8638]	[uplus=8846]	[upsi=965]	[upsih=978]	[upsilon=965]	[upuparrows=8648]	[urcorn=8989]	[urcorner=8989]	[urcrop=8974]	[uring=367]	[urtri=9721]	[uscr=120010]	[utdot=8944]	[utilde=361]	[utri=9653]	[utrif=9652]	[uuarr=8648]	[uum=252]	[uuml=252]	[uwangle=10663]	[vArr=8661]	[vBar=10984]	[vBarv=10985]	[vDash=8872]	[vangrt=10652]	[varepsilon=1013]	[varkappa=1008]	[varnothing=8709]	[varphi=981]	[varpi=982]	[varpropto=8733]	[varr=8597]	[varrho=1009]	[varsigma=962]	[varsubsetneq=8842]	[varsubsetneqq=10955]	[varsupsetneq=8843]	[varsupsetneqq=10956]	[vartheta=977]	[vartriangleleft=8882]	[vartriangleright=8883]	[vcy=1074]	[vdash=8866]	[vee=8744]	[veebar=8891]	[veeeq=8794]	[vellip=8942]	[verbar=124]	[vert=124]	[vfr=120115]	[vltri=8882]	[vnsub=8834]	[vnsup=8835]	[vopf=120167]	[vprop=8733]	[vrtri=8883]	[vscr=120011]	[vsubnE=10955]	[vsubne=8842]	[vsupnE=10956]	[vsupne=8843]	[vzigzag=10650]	[wcirc=373]	[wedbar=10847]	[wedge=8743]	[wedgeq=8793]	[weierp=8472]	[wfr=120116]	[wopf=120168]	[wp=8472]	[wr=8768]	[wreath=8768]	[wscr=120012]	[xcap=8898]	[xcirc=9711]	[xcup=8899]	[xdtri=9661]	[xfr=120117]	[xhArr=10234]	[xharr=10231]	[xi=958]	[xlArr=10232]	[xlarr=10229]	[xmap=10236]	[xnis=8955]	[xodot=10752]	[xopf=120169]	[xoplus=10753]	[xotime=10754]	[xrArr=10233]	[xrarr=10230]	[xscr=120013]	[xsqcup=10758]	[xuplus=10756]	[xutri=9651]	[xvee=8897]	[xwedge=8896]	[yacut=253]	[yacute=253]	[yacy=1103]	[ycirc=375]	[ycy=1099]	[ye=165]	[yen=165]	[yfr=120118]	[yicy=1111]	[yopf=120170]	[yscr=120014]	[yucy=1102]	[yum=255]	[yuml=255]	[zacute=378]	[zcaron=382]	[zcy=1079]	[zdot=380]	[zeetrf=8488]	[zeta=950]	[zfr=120119]	[zhcy=1078]	[zigrarr=8669]	[zopf=120171]	[zscr=120015]	[zwj=8205]	[zwnj=8204]'! !!XMLHTMLParserTokenizer methodsFor: 'testing'!atEndTag: aTagName	| matched |	streamReader peek == $<		ifFalse: [^ false].	streamReader next.	streamReader peek == $/		ifFalse: [			streamReader pushBackCharacter: $<.			^ false].	streamReader next.	1 to: aTagName size do: [:i | | nextChar |		((nextChar := streamReader peek) notNil			and: [				"use #= here because the tag name and nextChar can be wide chars				and wide chars aren't #== pre-Spur"				nextChar asLowercase = (aTagName at: i)])			ifFalse: [				streamReader pushBack: '</', (aTagName copyFrom: 1 to: i - 1).				^ false].		streamReader next].	matched :=		(streamReader atEnd not			and: [HTMLNameDelimiters includes: streamReader peek]).	streamReader pushBack: '</', aTagName.	^ matched.! !!XMLHTMLParserTokenizer methodsFor: 'decoding'!convertFromEncoding: anEncodingName	| encodingNameWithoutWhitespace |	encodingNameWithoutWhitespace := anEncodingName xmlCopyWithoutWhitespace.	encodingNameWithoutWhitespace isEmpty		ifFalse: [super convertFromEncoding: encodingNameWithoutWhitespace]! !!XMLHTMLParserTokenizer methodsFor: 'private'!endElement: anElement	elementNester endElement: anElement.	driver handleEndTag: anElement.! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing - expecting'!expectNext: aCharacter	"use #= for pre-SpurVM compatibility where wide chars aren't #=="	streamReader peek = aCharacter		ifTrue: [streamReader next].	^ aCharacter.! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing - expecting'!expectNextAll: aString	aString do: [:each |		"use #= for pre-SpurVM compatibility where wide chars aren't #=="		streamReader peek = each			ifTrue: [streamReader next]			ifFalse: [				self nextElementName.				^ aString]].	^ aString.! !!XMLHTMLParserTokenizer methodsFor: 'defaults'!hexCharacterValueLiteralPrefixes	^ 'xX'! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing'!nextAttributeValue	| quote nextChar |	streamReader atQuote		ifFalse: [^ self nextElementName].	quote := streamReader next.	characterStream reset.	[(nextChar := streamReader next) == quote		or: [nextChar == nil]]		whileFalse: [			nextChar == $&				ifTrue: [					self nextGeneralEntityOrCharacterReferenceOnCharacterStream]				ifFalse: [characterStream nextPut: nextChar]].	^ characterStream contents.! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing'!nextCDataSection	| closingBracketsRead nextChar |	self expectNextAll: '[CDATA['.	characterStream reset.	closingBracketsRead := 0.	[(nextChar := streamReader next) == nil		or: [closingBracketsRead = 2			and: [nextChar == $>]]]		whileFalse: [			nextChar == $]				ifTrue: [					closingBracketsRead = 2						ifTrue: [characterStream nextPut: $]]						ifFalse: [closingBracketsRead := closingBracketsRead + 1]]				ifFalse: [					closingBracketsRead > 0						ifTrue: [							1 to: closingBracketsRead do: [:i |								characterStream nextPut: $]].							closingBracketsRead := 0].					characterStream nextPut: nextChar]].	driver handleCData: characterStream contents.! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing'!nextCharacterReferenceOnCharacterStream	"returns the character written to 'characterStream' or $& if	it wasn't replaced"	| character |	"skip $#"	streamReader next.	nameStream reset.	character :=		self characterFromCodePoint:			(self nextCharacterValueLiteralPrintedOn: nameStream).	(character notNil		and: [driver replacesContentEntityReferences])		ifTrue: [			streamReader peek == $; "; is optional"				ifTrue: [streamReader next].			characterStream nextPut: character.			^ character]		ifFalse: [			characterStream				nextPutAll: '&#';				nextPutAll: nameStream contents.			^ $&].! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing'!nextComment	| hyphensRead nextChar |	"Skip first -"	streamReader next.	self expectNext: $-.	hyphensRead := 0.	characterStream reset.	[(nextChar := streamReader next) == nil		or: [nextChar == $>			and: [hyphensRead = 2]]]		whileFalse: [			nextChar == $-				ifTrue: [					hyphensRead = 2						ifTrue: [characterStream nextPut: $-]						ifFalse: [hyphensRead := hyphensRead + 1]]				ifFalse: [					hyphensRead > 0						ifTrue: [							1 to: hyphensRead do: [:i |								characterStream nextPut: $-].							hyphensRead := 0].					characterStream nextPut: nextChar]].	driver handleComment: characterStream contents.! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing'!nextContentMarkupToken	"use #isXMLWhitespace instead of the narrower, XML-specific	#isXMLSeparator, and since nil understands #isXMLWhitespace	no nil test is needed"	streamReader peek isXMLWhitespace		ifTrue: [			streamReader pushBack: '&lt;'.			^ self nextPCDataToken].	streamReader peek == $?		ifTrue: [^ self nextPI].	streamReader peek == $!!		ifTrue: [			streamReader next.			streamReader peek == $-				ifTrue: [^ self nextComment].			streamReader peek == $[				ifTrue: [^ self nextCDataSection].			^ self skipDeclaration].	self nextTag.! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing'!nextDoctypeDeclarationOrCommentOrCDataSection	| nextChar |	"skip !!"	streamReader next.	(nextChar := streamReader peek) == $-		ifTrue: [^ self nextComment].	nextChar == $[		ifTrue: [			^ self				nextStartContent;				nextCDataSection].	state isPostDoctypeDeclarationState		ifTrue: [^ self skipDeclaration].	self nextDoctypeDeclaration.! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing'!nextElementName	| nextChar |	nameStream reset.	 [(nextChar := streamReader peek) == nil		or: [(HTMLNameDelimiters includes: nextChar)			or: [				(state isDoctypeDeclarationState					and: [nextChar == $[])					or: [state isInternalSubsetState						and: [nextChar == $]]]]]]		whileFalse: [nameStream nextPut: streamReader next].	^ nameStream contents.! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing'!nextEndDocument	(state isContentState		and: [elementNester hasOpenElements])		ifTrue: [			elementNester openElementsReverseDo: [:each |				driver handleEndTag: each]].	super nextEndDocument.! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing'!nextEndTag	| tagName |	"Skip /"	streamReader next.	tagName := self nextElementName asLowercase.	streamReader skipSeparators.	self nextMarkupTerminator.	(elementNester isRedundantEndTag: tagName)		ifTrue: [^ self].	(elementNester hasOpenElement: tagName)		ifFalse: [self startElement: tagName].	elementNester		beforeEnding: tagName		elementsToEndDo: [:each | self endElement: each].	self endElement: tagName.! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing'!nextGeneralEntityOrCharacterReferenceOnCharacterStream	"returns the character written to 'characterStream' if any, nil otherwise"	streamReader peek == $#		ifTrue: [^ self nextCharacterReferenceOnCharacterStream]		ifFalse: [			"use #isXMLWhitespace instead of the narrower, XML-specific			#isXMLSeparator, and since nil understands #isXMLWhitespace			no nil test is needed"			streamReader peek isXMLWhitespace				ifTrue: [					characterStream nextPut: $&.					^ $&].			^ self nextGeneralEntityReferenceOnCharacterStream]! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing'!nextGeneralEntityReferenceOnCharacterStream	"returns the (first) character written to 'characterStream' if any,	nil otherwise"	| name |	name := self nextElementName.	driver replacesContentEntityReferences		ifTrue: [			PredefinedHTMLEntities				at: name				ifPresent: [:character |					streamReader peek == $; "; is optional"						ifTrue: [streamReader next].					characterStream nextPut: character.					^ character]].	characterStream		nextPut: $&;		nextPutAll: name.	^ $&.! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing'!nextMarkupTerminator	streamReader skipTo: $>! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing'!nextNonElementWhitespace	self nextPCDataToken! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing'!nextNonHTMLCodeSectionToken	| isInComment nextChar commentStartChar |	characterStream reset.	isInComment := false.	[streamReader atEnd		or: [self atEndTag: nonHTMLElement]]		whileFalse: [			isInComment				ifTrue: [					nextChar := streamReader next.					((commentStartChar == $/						and: [nextChar == streamReader normalizedLineEndingChar])							or: [commentStartChar == $*								and: [nextChar == $*									and: [streamReader peek == $/]]])						ifTrue: [							commentStartChar == $*								ifTrue: [									characterStream nextPut: $*.									nextChar := streamReader next].							isInComment := false].					characterStream nextPut: nextChar]				ifFalse: [					streamReader atQuote						ifTrue: [self nextQuotedStringOnCharacterStream]						ifFalse: [							(((nextChar := streamReader next) == $/)								and: [streamReader peek == $*									or: [streamReader peek == $/]])								ifTrue: [									isInComment := true.									characterStream										nextPut: $/;										nextPut: (commentStartChar := streamReader next)]								ifFalse: [characterStream nextPut: nextChar]]]].	state := state contentState.	driver handlePCData: characterStream contents.! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing'!nextNonHTMLSectionToken	characterStream reset.	[streamReader atEnd		or: [self atEndTag: nonHTMLElement]]		whileFalse: [| nextChar |			(nextChar := streamReader next) == $&				ifTrue: [self nextGeneralEntityOrCharacterReferenceOnCharacterStream]				ifFalse: [characterStream nextPut: nextChar]].	state := state contentState.	driver handlePCData: characterStream contents.! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing'!nextNonPIPrologOrContentMarkupToken	streamReader peek == $!!		ifTrue: [^ self nextDoctypeDeclarationOrCommentOrCDataSection].	self nextStartContent.	"use #isXMLWhitespace instead of the narrower, XML-specific	#isXMLSeparator, and since nil understands #isXMLWhitespace	no nil test is needed"	streamReader peek isXMLWhitespace		ifFalse: [^ self nextTag].	"an unescaped < in pcdata content"	streamReader pushBackCharacter: $<.	^ self nextContentToken.! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing'!nextPCDataToken	| isWhitespace nextChar |	isWhitespace := true.	characterStream reset.	[(nextChar := streamReader peek) == $<		or: [nextChar == nil]]		whileFalse: [			streamReader next == $&				ifTrue: [					self nextGeneralEntityOrCharacterReferenceOnCharacterStream						ifNotNil: [:writtenChar |							isWhitespace								ifTrue: [									"use #isXMLWhitespace instead of the									narrower, XML-specific #isXMLSeparator"									isWhitespace := writtenChar isXMLWhitespace]]]				ifFalse: [					isWhitespace						ifTrue: [isWhitespace := nextChar isXMLWhitespace].					characterStream nextPut: nextChar]].	isWhitespace		ifTrue: [			(elementNester isInElement				and: [characterStream position > 0])				ifTrue: [driver handleWhitespace: characterStream contents]]		ifFalse: [			elementNester				beforePCDataElementsToEndDo: [:each | self endElement: each]				elementsToStartDo: [:each | self startElement: each].			driver handlePCData: characterStream contents].! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing'!nextPIData	| nextChar |	characterStream reset.	[(nextChar := streamReader next) == nil		or: [nextChar == $?			and: [streamReader peek == $>]]]		whileFalse: [characterStream nextPut: nextChar].	self nextMarkupTerminator.	^ characterStream contents.! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing'!nextPITarget	| target |	((target := self nextElementName) = 'xml'		and: [state isXMLDeclarationState])		ifTrue: [^ nil]		ifFalse: [^ target]! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing - dtd'!nextParameterEntityReference	self		nextElementName;		expectNext: $;! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing'!nextPrologToken	streamReader skipSeparators.	streamReader atEnd		ifTrue: [^ self].	streamReader peek == $<		ifTrue: [			streamReader next.			streamReader peek == $?				ifTrue: [^ self nextPI].			^ self nextNonPIPrologOrContentMarkupToken].	self		nextStartContent;		nextContentToken.! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing - dtd'!nextPublicIDLiteral	^ self nextQuotedStringValue! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing'!nextQuotedStringOnCharacterStream	| isEscaped quote nextChar |	isEscaped := false.	quote := streamReader next.	characterStream nextPut: quote.	[streamReader atEnd		or: [(nextChar := streamReader peek) == quote			and: [isEscaped not]]]		whileFalse: [			isEscaped :=				nextChar == $\					and: [isEscaped not].			characterStream nextPut: streamReader next].	streamReader next.	characterStream nextPut: quote.! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing'!nextQuotedStringValue	| quote nextChar |	streamReader atQuote		ifFalse: [^ self nextElementName].	quote := streamReader next.	characterStream reset.	[(nextChar := streamReader next) == quote		or: [nextChar == nil]]		whileFalse: [characterStream nextPut: nextChar].	^ characterStream contents.! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing'!nextSeparators	streamReader skipSeparators! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing'!nextStartNonHTMLElement: anElement	state := 		(NonHTMLCodeSectionTags includes: anElement)			ifTrue: [XMLHTMLNonHTMLCodeSectionState new]			ifFalse: [XMLHTMLNonHTMLSectionState new].	nonHTMLElement := anElement.! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing - dtd'!nextSubsetMarkupToken	streamReader peek == $<		ifTrue: [streamReader next]		ifFalse: [^ self skipNonDeclarationOrEntity].	self expectNext: $!!.	streamReader peek == $-		ifTrue: [^ self nextComment].	self skipDeclaration.! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing - dtd'!nextSystemIDLiteral	^ self nextQuotedStringValue! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing'!nextTag	| tagName attributes attributeName nextChar |	streamReader peek == $/		ifTrue: [^ self nextEndTag].	tagName := self nextElementName asLowercase.	[streamReader skipSeparators.	((nextChar := streamReader peek) == $>		or: [nextChar == $/			or: [nextChar == nil				or: [(attributeName := self nextElementName asLowercase) size = 0]]])]		whileFalse: [			streamReader skipSeparators.			(streamReader peek == $=)				ifTrue: [streamReader next].			streamReader skipSeparators.			(attributes				ifNil: [attributes := driver newAttributeDictionary])				at: attributeName				put: self nextAttributeValue].	(elementNester isRedundantStartTag: tagName)		ifTrue: [			nextChar == $/				ifTrue: [streamReader next].			^ self nextMarkupTerminator].	attributes		ifNil: [attributes := driver newEmptyAttributeDictionary]		ifNotNil: [			tagName = 'meta'				ifTrue: [self processMetaAttributes: attributes]].	elementNester		beforeStarting: tagName		elementsToEndDo: [:each | self endElement: each]		elementsToStartDo: [:each | self startElement: each].	self		startElement: tagName		attributes: attributes.	nextChar == $/		ifTrue: [			streamReader next.			self endElement: tagName]		ifFalse: [			(elementNester isVoidElement: tagName)				ifTrue: [self endElement: tagName]				ifFalse: [					(NonHTMLSectionTags includes: tagName)						ifTrue: [self nextStartNonHTMLElement: tagName]]].	self nextMarkupTerminator.! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing'!nextXMLAttributeValue	| quote nextChar |	streamReader atQuote		ifFalse: [^ self nextElementName].	quote := streamReader next.	xmlDeclarationStream reset.	[(nextChar := streamReader next) == quote		or: [nextChar == nil]]		whileFalse: [xmlDeclarationStream nextPut: nextChar].	^ xmlDeclarationStream contents.! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing'!nextXMLEncodingAttributeValue	^ self nextXMLAttributeValue! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing'!nextXMLStandaloneAttributeValue	^ self nextXMLAttributeValue! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing'!nextXMLVersionAttributeValue	^ self nextXMLAttributeValue! !!XMLHTMLParserTokenizer methodsFor: 'decoding'!processMetaAttributes: anAttributeDictionary	"check for a basic meta charset first, like <meta charset='UTF-8'>"	self convertFromEncoding:		(anAttributeDictionary			at: 'charset'			ifAbsent: [| mimeType |				"otherwise look for an http-equiv content type, like:					<meta						http-equiv='Content-Type'						content='text/html; charset=UTF-8'>"				(anAttributeDictionary at: 'http-equiv') asLowercase = 'content-type'					ifFalse: [^ self].				mimeType :=					XMLHTTPMIMEType fromString:						(anAttributeDictionary							at: 'content'							ifAbsent: [^ self]).				mimeType charset])! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing - dtd'!skipDeclaration	[streamReader atEnd		or: [streamReader peek == $>]]		whileFalse: [			streamReader atQuote				ifTrue: [streamReader skipTo: streamReader next]				ifFalse: [streamReader next]].	streamReader atEnd		ifFalse: [streamReader next].! !!XMLHTMLParserTokenizer methodsFor: 'tokenizing - dtd'!skipNonDeclarationOrEntity	[streamReader atEnd		or: [streamReader peek == $<			or: [streamReader peek == $%				or: [state isInternalSubsetState					and: [streamReader peek == $]]]]]]		whileFalse: [streamReader next]	! !!XMLHTMLParserTokenizer methodsFor: 'private'!startElement: anElement	self		startElement: anElement		attributes: driver newEmptyAttributeDictionary! !!XMLHTMLParserTokenizer methodsFor: 'private'!startElement: anElement attributes: anAttributeDictionary	elementNester startElement: anElement.	driver		handleStartTag: anElement		attributes: anAttributeDictionary.! !!XMLHTMLParserTokenizer methodsFor: 'defaults'!streamReaderClass	^ XMLHTMLNestedStreamReader! !!String methodsFor: '*XML-ParserHTML-Core'!parseHTML	^ XMLHTMLParser parse: self! !!SAX2HTMLElementParser methodsFor: 'defaults'!driverClass	^ SAXHTMLParserDriver! !!XMLHTMLParser methodsFor: 'defaults'!driverClass	^ SAXHTMLParserDriver! !!XMLHTMLParser methodsFor: 'handling - content'!endElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName	self topNode		ifNotNil: [:node |			(node isElement				and: [node name = aQualifiedName])				ifTrue: [self popNode]].! !!XMLHTMLParser methodsFor: 'private'!innerXMLRootNode: aRootNode	aRootNode ancestorNodes reverseDo: [:each |		self pushNode: each].	super innerXMLRootNode: aRootNode.! !!XMLHTMLParser methodsFor: 'private'!startInnerXMLElement: anElement forParser: aParser	| elementNester |	elementNester := aParser driver elementNester.	elementNester		beforeStarting: anElement name		elementsToEndDo: [:each | ]		elementsToStartDo: [:each | elementNester startElement: each].	elementNester startElement: anElement name.! !!XMLHTMLElementNester class methodsFor: 'private'!bodySectionElements	^ #('a' 'abbr' 'acronym' 'address' 'applet'		'area' 'article' 'aside' 'audio' 'b'		'basefont' 'bdi' 'bdo' 'big' 'blockquote'		'br' 'button' 'canvas' 'caption' 'center'		'cite' 'code' 'col' 'colgroup' 'command'		'data' 'datagrid' 'datalist' 'dd' 'del'		'details' 'dfn' 'dir' 'div' 'dl'		'dt' 'em' 'embed' 'eventsource' 'fieldset'		'figcaption' 'figure' 'font' 'footer' 'form'		'frame' 'frameset' 'h1' 'h2' 'h3'		'h4' 'h5' 'h6' 'header' 'hgroup'		'hr' 'i' 'iframe' 'img' 'input'		'ins' 'kbd' 'keygen' 'label' 'legend'		'li' 'map' 'mark' 'menu' 'meter' 'nav'		'noframes' 'noscript' 'object' 'ol' 'optgroup'		'option' 'output' 'p' 'param' 'pre'		'progress' 'q' 'rp' 'rt' 'ruby'		's' 'samp' 'script' 'section' 'select'		'small' 'source' 'span' 'strike' 'strong'		'style' 'sub' 'summary' 'sup' 'table'		'tbody' 'td' 'textarea' 'tfoot' 'th'		'thead' 'time' 'tr' 'track' 'tt'		'u' 'ul' 'var' 'video' 'wbr')! !!XMLHTMLElementNester class methodsFor: 'private'!headSectionElements	^ #('base' 'isindex' 'link' 'meta' 'noscript'		'object' 'script' 'style' 'template' 'title')! !!XMLHTMLElementNester class methodsFor: 'private'!htmlTagInformationIn: aDictionary named: aName	^ aDictionary		at: aName		ifAbsentPut: [XMLHTMLTagInformation named: aName]! !!XMLHTMLElementNester class methodsFor: 'class initialization'!initialize	"self initialize"	self		initializeHTMLTagInformation;		initializeVoidElements;		initializeRedundantEndTags! !!XMLHTMLElementNester class methodsFor: 'class initialization'!initializeHTMLTagInformation	| temp |	"use a temp to fully initialize it before assignment to avoid	possible race conditions during class reinitialization"	temp := Dictionary new.	#('html' 'head' 'body') do: [:each |		self			htmlTagInformationIn: temp			named: each].	self bodySectionElements do: [:each |		(self			htmlTagInformationIn: temp			named: each) isBodySectionTag: true].	self headSectionElements do: [:each |		(self			htmlTagInformationIn: temp			named: each) isHeadSectionTag: true].	self mutuallyExcludingTags keysAndValuesDo: [:key :value |		(self			htmlTagInformationIn: temp			named: key) mutuallyExcludingTag: value].	self nestableTagGroups keysAndValuesDo: [:key :value |		(self			htmlTagInformationIn: temp			named: key) nestableTagGroup: value].	self nonNestableElements do: [:each |		(self			htmlTagInformationIn: temp			named: each) isNonNestable: true].	HTMLTagInformation := temp.! !!XMLHTMLElementNester class methodsFor: 'class initialization'!initializeRedundantEndTags	"assign after with #yourself to avoid possible race	conditions when reinitializing the class"	RedundantEndTags := self voidElements asSet! !!XMLHTMLElementNester class methodsFor: 'class initialization'!initializeVoidElements	VoidElements := self voidElements asSet! !!XMLHTMLElementNester class methodsFor: 'private'!mutuallyExcludingTags	| mutuallyExcludingTags |	mutuallyExcludingTags := Dictionary new.	#(#('dd' 'dt') #('thead' 'tbody') #('th' 'td') #('rp' 'rt'))		do: [:tagList |			tagList do: [:tag |				tagList do: [:each |					(each = tag)						ifFalse: [							mutuallyExcludingTags								at: each								put: tag]]]].	^ mutuallyExcludingTags.! !!XMLHTMLElementNester class methodsFor: 'private'!nestableTagGroups	| nestableTagGroups |	nestableTagGroups := Dictionary new.	#('dd' 'dt') do: [:each |		nestableTagGroups			at: each			put: #('dl')].	#('tr' 'th' 'td' 'thead' 'tfoot') do: [:each |		nestableTagGroups			at: each			put: #('table')].	#('rp' 'rt') do: [:each |		nestableTagGroups			at: each			put: #('ruby')].	nestableTagGroups		at: 'li'		put: #('ul' 'ol' 'menu' 'dir') asSet.	^ nestableTagGroups.! !!XMLHTMLElementNester class methodsFor: 'private'!nonNestableElements	^ #('a' 'applet' 'audio' 'button' 'footer'		'form' 'header' 'label' 'map' 'meter'		'optgroup' 'option' 'ruby' 'select' 'video'),		self nestableTagGroups keys asArray! !!XMLHTMLElementNester class methodsFor: 'private'!voidElements	^ #('area' 'base' 'br' 'col' 'command'		'embed' 'frame' 'hr' 'img' 'input'		'keygen' 'link' 'menuitem' 'meta' 'param'		'source' 'track' 'wbr')! !!XMLHTMLElementNester methodsFor: 'nesting'!beforeEnding: anElement elementsToEndDo: anElementEndingBlock	self openElementsReverseDo: [:each |		each = anElement			ifTrue: [^ self].		anElementEndingBlock value: each].! !!XMLHTMLElementNester methodsFor: 'nesting'!beforePCDataElementsToEndDo: anElementEndingBlock elementsToStartDo: anElementStartingBlock	(self startedHeadSection		and: [self startedBodySection not])		ifTrue: [			self				beforeEnding: 'html'				elementsToEndDo: anElementEndingBlock].	self startedHTMLSection		ifFalse: [anElementStartingBlock value: 'html'].	self startedBodySection		ifFalse: [anElementStartingBlock value: 'body'].! !!XMLHTMLElementNester methodsFor: 'nesting'!beforeStarting: anElement elementsToEndDo: anElementEndingBlock elementsToStartDo: anElementStartingBlock	| htmlTagInfo |	htmlTagInfo :=		HTMLTagInformation			at: anElement			ifAbsent: [XMLHTMLTagInformation named: anElement].				self hasOpenElements		ifTrue: [			self				elementsToEndBeforeStartTag: htmlTagInfo				do: anElementEndingBlock].	self		elementsToStartBeforeStartTag: htmlTagInfo		do: anElementStartingBlock.! !!XMLHTMLElementNester methodsFor: 'private'!cannotSelfNestTag: anHTMLTagInfo	anHTMLTagInfo isNonNestable		ifTrue: [	| tagGroup |			"tags like <td> can nest in each other if there is a <table> between			them like <td><table><tr><td>...."			((tagGroup := anHTMLTagInfo nestableTagGroup)				anySatisfy: [:each | self hasOpenElement: each])				ifFalse: [^ true].			self openElementsReverseDo: [:each |				each = anHTMLTagInfo name					ifTrue: [^ true].				(tagGroup includes: each)					ifTrue: [^ false]]].	^ false.! !!XMLHTMLElementNester methodsFor: 'private'!elementsToEndBeforeStartTag: anHTMLTagInfo do: anElementEndingBlock	| excludingTag |	(self mustEndHeadSectionForTag: anHTMLTagInfo)		ifTrue: [			^ self				beforeEnding: 'html'				elementsToEndDo: anElementEndingBlock].	(((self hasOpenElement: anHTMLTagInfo name)		and: [self cannotSelfNestTag: anHTMLTagInfo])		or: [(excludingTag := anHTMLTagInfo mutuallyExcludingTag) notNil			and: [self hasOpenElement: excludingTag]])		ifTrue: [			self openElementsReverseDo: [:each |				anElementEndingBlock value: each.				((each = anHTMLTagInfo name)					or: [each = excludingTag])					ifTrue: [^ self]]].! !!XMLHTMLElementNester methodsFor: 'private'!elementsToStartBeforeStartTag: anHTMLTagInfo do: anElementStartingBlock	anHTMLTagInfo isHTMLTag		ifTrue: [^ self].	self startedHTMLSection		ifFalse: [anElementStartingBlock value: 'html'].	(anHTMLTagInfo isHeadTag		or: [anHTMLTagInfo isBodyTag])		ifTrue: [^ self]. 	(self mustStartHeadSectionForTag: anHTMLTagInfo)		ifTrue: [anElementStartingBlock value: 'head']		ifFalse: [			(self mustStartBodySectionForTag: anHTMLTagInfo)				ifTrue: [anElementStartingBlock value: 'body']].! !!XMLHTMLElementNester methodsFor: 'nesting'!endElement: anElement	| association |	association :=		self openElementsByName			associationAt: anElement			ifAbsent: [self openElementsByName add: (anElement -> 1)].	association value: (association value - 1 max: 0).	self endCurrentElement.! !!XMLHTMLElementNester methodsFor: 'testing'!hasOpenElement: anElement	^ (self openElementsByName		at: anElement		ifAbsent: [0]) > 0! !!XMLHTMLElementNester methodsFor: 'initialization'!initialize	super initialize.	openElementsByName := Dictionary new.	startedHTMLSection := false.	startedHeadSection := false.	startedBodySection := false.! !!XMLHTMLElementNester methodsFor: 'testing'!isRedundantEndTag: anElement	^ RedundantEndTags includes: anElement! !!XMLHTMLElementNester methodsFor: 'testing'!isRedundantStartTag: anElement	anElement = 'html'		ifTrue: [^ self startedHTMLSection].	anElement = 'head'		ifTrue: [^ self startedHeadSection].	anElement = 'body'		ifTrue: [^ self startedBodySection].	^ false.! !!XMLHTMLElementNester methodsFor: 'testing'!isVoidElement: anElement	^ VoidElements includes: anElement! !!XMLHTMLElementNester methodsFor: 'private'!mustEndHeadSectionForTag: anHTMLTagInfo	^ self startedBodySection not		and: [self startedHeadSection			and: [anHTMLTagInfo isBodyTag				or: [anHTMLTagInfo isBodySectionOnlyTag]]]! !!XMLHTMLElementNester methodsFor: 'private'!mustStartBodySectionForTag: anHTMLTagInfo	^ self startedBodySection not		and: [anHTMLTagInfo isBodySectionOnlyTag			or: [self startedHeadSection not				and: [anHTMLTagInfo isHeadSectionOnlyTag not]]]! !!XMLHTMLElementNester methodsFor: 'private'!mustStartHeadSectionForTag: anHTMLTagInfo	^ self startedBodySection not		and: [self startedHeadSection not			and: [anHTMLTagInfo isHeadSectionOnlyTag]]! !!XMLHTMLElementNester methodsFor: 'private'!openElementsByName	^ openElementsByName! !!XMLHTMLElementNester methodsFor: 'nesting'!startElement: anElement	| association |	association :=		self openElementsByName			associationAt: anElement			ifAbsent: [self openElementsByName add: (anElement -> 0)].	association value: association value + 1.	self startedHTMLSection		ifTrue: [			self startedBodySection				ifFalse: [					(self startedHeadSection not						and: [anElement = 'head']) 						ifTrue: [startedHeadSection := true]						ifFalse: [startedBodySection := anElement = 'body']]]		ifFalse: [startedHTMLSection := anElement = 'html'].	super startElement: anElement.! !!XMLHTMLElementNester methodsFor: 'testing'!startedBodySection	^ startedBodySection! !!XMLHTMLElementNester methodsFor: 'testing'!startedHTMLSection	^ startedHTMLSection! !!XMLHTMLElementNester methodsFor: 'testing'!startedHeadSection	^ startedHeadSection! !!SAXHTMLHandler methodsFor: 'defaults'!driverClass	^ SAXHTMLParserDriver! !!XMLHTMLNonHTMLCodeSectionState methodsFor: 'tokenizing'!nextTokenFrom: aTokenizer	^ aTokenizer nextNonHTMLCodeSectionToken! !!XMLHTMLNonHTMLSectionState methodsFor: 'tokenizing'!nextTokenFrom: aTokenizer	^ aTokenizer nextNonHTMLSectionToken! !!XMLHTMLNestedStreamReader methodsFor: 'positioning'!skipSeparators	"Should be identical to the superclass #skipSeparators, except	it uses #isXMLWhitespace instead of the narrower, XML-specific	#isXMLSeparator.	This code is heavily optimized."	| isExternalNormalizedLineEnding |	[peekChar		ifNil: [			stream atEnd				ifTrue: [					self hasNextAfterPoppingStreamsAtEnd						ifFalse: [^ self]].			peekChar := stream next.			isExternal				ifTrue: [					peekChar == LFCharacter						ifTrue: [isExternalNormalizedLineEnding := true]						ifFalse: [							peekChar == CRCharacter								ifTrue: [									stream atEnd										ifFalse: [											stream peek == LFCharacter												ifTrue: [stream next]].									isExternalNormalizedLineEnding := true]								ifFalse: [									isExternalNormalizedLineEnding := false.									"nil understands #isXMLWhitespace, so it									isn't tested for first"									peekChar isXMLWhitespace]]]				ifFalse: [					"nil understands #isXMLWhitespace, so it isn't tested for first"					peekChar isXMLWhitespace]]			ifNotNil: [				isExternal					ifTrue: [						isExternalNormalizedLineEnding :=							peekChar == normalizedLineEndingChar].				peekChar isXMLWhitespace]]		whileTrue: [			"inlined from #next"			peekChar := nil.			isExternal				ifTrue: [					currentPosition := currentPosition + 1.					isExternalNormalizedLineEnding						ifTrue: [							currentLineNumber := currentLineNumber + 1.							currentLineStartPosition := currentPosition].			readLimit				ifNotNil: [					(readLimit := readLimit - 1) >= 0						ifFalse: [self errorReadLimitExceeded]]]]! !"XML-ParserHTML-Core"!!Class methodsFor: '*Microdown' prior: 19498404!buildMicroDownUsing: aBuilder withComment: aString		aBuilder 		header: [ aBuilder text: 'Class: '.					aBuilder text: self name ] withLevel: 1;		horizontalLine;		text: aString! !!MicInlineBlockWithUrl methodsFor: 'accessing' prior: 50855969!initialize	super initialize.	arguments := OrderedDictionary new! !!MicHTTPResourceReference class methodsFor: 'testing' prior: 50845228!initialize	"self initialize"		<script>	self resetResourcesCache ! !!MicZincPathResolver methodsFor: 'private' prior: 51156960!resolveReferenceIn: aNode	"currently links, figures and input nodes need to be resolved"	| resolvedUri resolvedReference |	aNode reference isRelative ifFalse: [ ^ self ].	resolvedUri := absoluteReference uri withRelativeReference: aNode reference relativePath.	resolvedReference := MicResourceReference fromUri: resolvedUri printString.	resolvedReference isFileReference ifTrue: [ resolvedReference filesystem: absoluteReference filesystem ].	aNode reference: resolvedReference! !!MicAbsoluteResourceReference methodsFor: 'testing'!isFileReference	^ false! !!MicFileResourceReference methodsFor: 'testing'!isFileReference	^ true! !!MicRootBlock methodsFor: 'pillar integration'!includeFor: aFile	| inclusionVisitor |	inclusionVisitor := MicFileIncluder new.	inclusionVisitor topFile: aFile file.	inclusionVisitor visit: self.	^ self! !RGPackage removeSelector: #buildMicroDownUsing:withComment:!MicFileResourceReference removeSelector: #isMicrodownResourceFileReference!MicAbsoluteResourceReference removeSelector: #isMicrodownResourceFileReference!MicPharoEvaluatorBlock removeSelector: #title!MicPharoEvaluatorBlock removeSelector: #label!MicPharoEvaluatorBlock removeSelector: #accept:!MicPharoEvaluatorBlock class removeSelector: #tag!Smalltalk globals removeClassNamed: #AnObsoleteMicPharoEvaluatorBlock!Class removeSelector: #documentExamplesProtocol!Class removeSelector: #documentExampleCodeSelector!Class removeSelector: #documentExampleCode!Class removeSelector: #addDocumentSectionTo:label:methods:!Class removeSelector: #addDocumentSectionExampleCodeTo:!MicrodownVisitor removeSelector: #visitPharoEvaluator:!RGBehavior removeSelector: #buildMicroDownUsing:withComment:!"Microdown"!!MicFileResourceReferenceTest methodsFor: 'tests' prior: 50808539!testFileReferenceExtensionMethod	| fileRef micRef |	fileRef := '/path/to/nowhere.md' asFileReference.	micRef := fileRef asMicResourceReference.	self assert: micRef class equals: MicFileResourceReference.	self assert: micRef fullName equals: '/path/to/nowhere.md'.	self assert: micRef fullName equals: fileRef fullName! !!MicResourceReferenceTest methodsFor: 'tests - file reference conversion' prior: 51047444!testPurePathInterpretedAsFile	| mf |	mf := self resourceClass fromUri: '/chapter1/figures/m.md'.	self assert: mf isFileReference.	self assert: mf fullName equals: '/chapter1/figures/m.md'.	! !!MicElementTest methodsFor: 'initialization' prior: 50778527!setUp	super setUp.	parser := self parser. ! !MicPharoEvaluatortBlockTest removeSelector: #testScriptBloc!MicPharoEvaluatortBlockTest removeSelector: #subjectClass!Smalltalk globals removeClassNamed: #AnObsoleteMicPharoEvaluatortBlockTest!"Microdown-Tests"!!MicElement methodsFor: '*Microdown-Pharo-Tools'!inspectionMicTree	"	(MicroDownParser parse: '# hello Yes microdown is cool') inspect	"	<inspectorPresentationOrder: 930 title: 'MicTree'>	^ SpTreePresenter new		  roots: { self };		  children: [ :aNode | aNode children ];		  display: [ :each | 			  String streamContents: [ :stream | each displayStringOn: stream ] ];		  yourself! !!MicSemanticAction class methodsFor: 'instance creation' prior: 51115274!from: aString 	| contents |	contents := ((RBScanner on: (ReadStream on: aString) errorBlock: [#()]) contents).	^ self fromTokens: (contents collect: [:e | e value])! !!MicDynamicTextStyler methodsFor: 'initialization' prior: 50771267!initialize	self computeHeaderFonts. "super rely on lazy initilization"	errors := OrderedCollection new.	bodyFont := nil.	bullets := '•-'.	counters := '1aA'.	interBlockSpacing := (String cr) asText.	monospaceBackgroundColor := Smalltalk ui theme settings windowColor.	newLineIfNotAlready := String cr asText.	bodyFont := TextStyle defaultFont.	crAfterHeader := #(1 1 1 1 1 1).	keepCRFromInput := true.! !!MicRichTextComposer methodsFor: 'visiting' prior: 51076755!visitCode: aCodeBlock	canvas newLineIfNotAlready.	canvas indentIn: [ 		canvas			<< ((self codeStylerClass stylerFor: aCodeBlock language)					style: aCodeBlock body );			newLine.		aCodeBlock hasCaption ifTrue: [ 			canvas 				includeAttribute: TextEmphasis bold 				in: [ 					canvas						<< aCodeBlock caption asText;					newLine ]]].	canvas << textStyler interBlockSpacing		! !!MicSmalltalkTextStyler class methodsFor: 'attributes' prior: 51118250!initialTextAttributesForPixelHeight: aNumber	"Render undefined same way as defined"	"Perhaps this is not the right spot to hook into stuff, but it seems to work"	| dict |	dict := super initialTextAttributesForPixelHeight: aNumber.	dict at: #undefinedIdentifier put: (dict at: #instVar).	dict at: #undefinedKeyword put: (dict at: #keyword).	dict at: #undefinedBinary put: (dict at: #binary).	dict at: #undefinedUnary put: (dict at: #unary).	^ dict! !MicDocumentHierarchyBuilder removeSelector: #topClass:!MicDocumentHierarchyBuilder removeSelector: #topClass!MicDocumentHierarchyBuilder removeSelector: #isPassingThrough:topLevel:!MicDocumentHierarchyBuilder removeSelector: #fromClass:!MicDocumentHierarchyBuilder removeSelector: #fromClass!MicDocumentHierarchyBuilder removeSelector: #filter:!MicDocumentHierarchyBuilder removeSelector: #fillTreeWithSuperclassesOf:!MicDocumentHierarchyBuilder removeSelector: #fillTreeWithSubclassesOf:!MicDocumentHierarchyBuilder removeSelector: #fillTreeOf:!MicDocumentHierarchyBuilder removeSelector: #builder:!MicDocumentHierarchyBuilder removeSelector: #buildStringFor:!MicDocumentHierarchyBuilder removeSelector: #buildFor:!MicDocumentHierarchyBuilder removeSelector: #applyFilterTo:!MicDocumentHierarchyBuilder removeSelector: #addLevel:from:to:!MicDocumentHierarchyBuilder removeSelector: #addLevel:from:!Smalltalk globals removeClassNamed: #AnObsoleteMicDocumentHierarchyBuilder!MicRichTextComposer removeSelector: #visitPharoEvaluator:!MicRichTextComposer removeSelector: #doVisitCode:code:!MicRichTextComposer removeSelector: #doVisitCode:!MicRichTextDoIt removeSelector: #emphasizeScanner:!Smalltalk globals removeClassNamed: #AnObsoleteMicRichTextDoIt!OrderedCollection removeSelector: #truncateTo:!"Microdown-RichTextComposer"!!MicCenterAlignmentBlockTest commentStamp: '' prior: 0!A MicCenterAllignmentBlockTest is a test class for testing the behavior of MicCenterAllignmentBlock!!MicDynamicTextStylerTest commentStamp: '' prior: 0!A MicDynamicTextStylerTest is a test class for testing the behavior of MicDynamicTextStyler!!MicParsesAndRendersAllCommentsTest commentStamp: '' prior: 0!I test that rendering no class comments make microdown parser or renderer fail!!MicRichTextCodeBlockStylerTest commentStamp: '' prior: 0!A MicRichTextCodeBlockStylerTest is a test class for testing the behavior of MicRichTextCodeBlockStyler!!MicRichTextFormatConfigurationTest commentStamp: '' prior: 0!A MicRichTextFormatConfigurationTest is a test class for testing the behavior of MicRichTextFormatConfiguration!!MicRichTextLinkPresenterTest commentStamp: '' prior: 0!A MicRichTextLinkPresenterTest is a test class for testing the behavior of MicRichTextLinkPresenter!!MicRightAlignmentBlockTest commentStamp: '' prior: 0!A MicRightAllignmentBlockTest is a test class for testing the behavior of MicRightAllignmentBlock!!ManifestMicrodownRichTextComposerTests commentStamp: '' prior: 0!Some specific microdown rich text integration tests.!!MicCenterAlignmentBlockTest methodsFor: 'tests'!testCenter	| src doc center |	src := '<!!centerThis is centered!!>'.	doc := Microdown parse: src.	center := doc children first.	self assert: center class equals: MicCenterAlignmentBlock.	self assert: center children first text equals: 'This is centered'! !!MicCodeSemanticActionTest methodsFor: 'test - bogus entry'!semanticActionClass	^ MicSemanticAction! !!MicCodeSemanticActionTest methodsFor: 'test - bogus entry'!testArrayShouldNotBreak	self deny: (self semanticActionClass fromTokens: #( 1 #+ 2 #* 3 )) hasEntity.	self deny: (self semanticActionClass fromTokens: #( 1 #+ 2 #* )) hasEntity! !!MicCodeSemanticActionTest methodsFor: 'test - bogus entry'!testChevronWithBrokenArguments	self assert: (self semanticActionClass fromTokens: #( Point #>> 2 )) entity isNil.	self assert: (self semanticActionClass fromTokens: #( Point class #>> 2 )) entity isNil.	self assert: (self semanticActionClass fromTokens: #( Point #>> true )) entity isNil.	self assert: (self semanticActionClass fromTokens: #( Point #>> Point )) entity isNil! !!MicCodeSemanticActionTest methodsFor: 'test - bogus entry'!testChevronWithBrokenReceiver	self assert: (self semanticActionClass fromTokens: #( 1 #>> 2 )) entity isNil.	self assert: (self semanticActionClass fromTokens: #( true #>> 2 )) entity isNil.	self assert: (self semanticActionClass fromTokens: #( $t #>> 2 )) entity isNil.	self assert: (self semanticActionClass fromTokens:  #( ClassThatDoesNotExist #>> 2 )) entity isNil.	self assert: (self semanticActionClass fromTokens: #( true class #>> 2 )) entity isNil.	self assert: (self semanticActionClass fromTokens: #( $t class #>> 2 )) entity isNil.	self assert: (self semanticActionClass fromTokens: #( ClassThatDoesNotExist class #>> 2 )) entity isNil! !!MicCodeSemanticActionTest methodsFor: 'test - bogus entry'!testDoubleDollars	self deny: (self semanticActionClass from: '$$') hasEntity! !!MicCodeSemanticActionTest methodsFor: 'test - bogus entry'!testEmptyString	self deny: (self semanticActionClass from: '') hasEntity! !!MicCodeSemanticActionTest methodsFor: 'test - bogus entry'!testGlobalAccess	self assert: (self semanticActionClass fromTokens: #( Transcript )) hasEntity	"the semantics action is working even if it is refers to a global because the class of global is 	used by the browse invocation when clicking on it. "! !!MicCodeSemanticActionTest methodsFor: 'test - bogus entry'!testMoreSpaces	self deny: (self semanticActionClass from: '    ') hasEntity! !!MicCodeSemanticActionTest methodsFor: 'test - bogus entry'!testOneSpace	self deny: (self semanticActionClass from: ' ') hasEntity! !!MicCodeSemanticActionTest methodsFor: 'tests - metaclass'!testReferenceToABrokenMetaClass	self assert: (self semanticActionClass from: 'Point2 class') entity isNil! !!MicCodeSemanticActionTest methodsFor: 'tests - metaclass'!testReferenceToABrokenMetaClass2	self assert: (self semanticActionClass from: 'Point grgrgr') entity isNil! !!MicCodeSemanticActionTest methodsFor: 'tests - class'!testReferenceToAClass	self		assert: (self semanticActionClass from:  'Point') entity		equals: Point! !!MicCodeSemanticActionTest methodsFor: 'tests - metaclass'!testReferenceToAMetaClass	self		assert: (self semanticActionClass from: 'Point class') entity		equals: Point class! !!MicCodeSemanticActionTest methodsFor: 'tests - methods'!testReferenceToAMethod	self		assert: (self semanticActionClass from: 'Point >> #setX:setY:') entity name		equals: 'Point>>#setX:setY:'! !!MicCodeSemanticActionTest methodsFor: 'tests - methods'!testReferenceToANonExistingMethod	self assert: (self semanticActionClass from: 'Point >> 12+3 ') entity isNil! !!MicCodeSemanticActionTest methodsFor: 'tests - methods'!testReferenceToANonExistingMethodBecauseOfBogusClass	self assert: (self semanticActionClass from: 'Point222 >> #setX:setY:') entity isNil! !!MicCodeSemanticActionTest methodsFor: 'tests - methods'!testReferenceToANonExistingMethodBecauseOfNoSymbol	self assert: (self semanticActionClass from: 'Point >> setX:setY2:') entity isNil! !!MicCodeSemanticActionTest methodsFor: 'tests - package'!testReferenceToANonExistingPackage	self assert: (self semanticActionClass from: #Pillar) entity isNil! !!MicCodeSemanticActionTest methodsFor: 'tests - package'!testReferenceToAPackage	self		assert: (self semanticActionClass from: #'''Microdown''') entity name		equals: 'Microdown'! !!MicCodeSemanticActionTest methodsFor: 'tests - class'!testReferenceToNonExistingClass	self deny: (self semanticActionClass from: 'Point22') hasEntity! !!MicCodeSemanticActionTest methodsFor: 'test - bogus entry'!testScannerShouldNotFail	self deny: (self semanticActionClass from: 'half"baked') hasEntity.	self deny: (self semanticActionClass from: '') hasEntity.	self deny: (self semanticActionClass from: 'half"baked') hasEntity.	self deny: (self semanticActionClass from: 16rFFFD asCharacter asString) hasEntity.! !!MicCodeSemanticActionTest methodsFor: 'test - bogus entry'!testTwoBogusElements	self assert:		(self semanticActionClass fromTokens: #( 1 #+ )) entity isNil.	self assert:		(self semanticActionClass fromTokens: #( true #foo )) entity isNil.	self assert:		(self semanticActionClass fromTokens: #( Point #foo )) entity isNil! !!MicCodeSemanticActionTest methodsFor: 'test - bogus entry'!testTwoSpaces	self deny: (self semanticActionClass from: '  ') hasEntity! !!MicDynamicTextStylerTest methodsFor: 'tests'!testBodyFont	| styler |	styler := MicDynamicTextStyler new.	self assert: styler bodyFont equals: TextStyle defaultFont.	styler bodyFont: 'Source Sans Pro;72'.	self assert: styler bodyFont familyName equals: 'Source Sans Pro'.	self assert: styler bodyFont pointSize equals: 72.! !!MicDynamicTextStylerTest methodsFor: 'tests'!testBulletForLevel	| styler |	styler := MicDynamicTextStyler new.	styler bullets: 'abc'.	self assert: (styler bulletForLevel: 1) equals: 'a' asText.	self assert: (styler bulletForLevel: 2) equals: 'b' asText.	self assert: (styler bulletForLevel: 4) equals: 'a' asText.! !!MicDynamicTextStylerTest methodsFor: 'tests'!testBullets	"I am not needed as I am tested by testCounterForAtLevel, but being here marks counters: as tested"! !!MicDynamicTextStylerTest methodsFor: 'tests'!testCodeBackgroundColor	! !!MicDynamicTextStylerTest methodsFor: 'tests'!testCounterForAtLevel	| styler |	styler := MicDynamicTextStyler new.	styler counters: 'Aa1'.	self assert: (styler counterFor: 1 atLevel: 1) equals: 'A)' asText.	self assert: (styler counterFor: 2 atLevel: 2) equals: 'b)' asText.	self assert: (styler counterFor: 3 atLevel: 3) equals: '3.' asText.	self assert: (styler counterFor: 5 atLevel: 5) equals: 'e)' asText.! !!MicDynamicTextStylerTest methodsFor: 'tests'!testCounters	"I am not needed as I am tested by testCounterForAtLevel, but being here marks counters: as tested"! !!MicDynamicTextStylerTest methodsFor: 'tests'!testCrAfterHeader	| styler |	styler := MicDynamicTextStyler new.	self assert: styler crAfterHeaders equals: #(1 1 1 1 1 1).	styler crAfterHeader: '2;2'.	self assert: styler crAfterHeaders equals: #(2 2 1 1 1 1).		! !!MicDynamicTextStylerTest methodsFor: 'tests'!testHeaderFontForLevel	| styler |	styler := MicDynamicTextStyler new.	styler headerFont: 'Source Sans Pro;72' forLevel: 1.	self assert: (styler headerLevelFont: 1) font familyName equals: 'Source Sans Pro'.	self assert: (styler headerLevelFont: 1) font pointSize equals: 72.! !!MicDynamicTextStylerTest methodsFor: 'tests'!testHeaderFontForLevel_wrongFormat	| styler |	styler := MicDynamicTextStyler new.	styler headerFont: 'Source Sans Pro' forLevel: 1.	self assert: styler errors isNotEmpty 	! !!MicDynamicTextStylerTest methodsFor: 'tests'!testHeaderFontForLevel_wrongLevel	| styler |	styler := MicDynamicTextStyler new.	styler headerFont: 'Source Sans Pro;72' forLevel: 9.	self assert: styler errors isNotEmpty ! !!MicDynamicTextStylerTest methodsFor: 'tests'!testInterblockSpacing	| styler |	styler := MicDynamicTextStyler new.	self assert: styler interBlockSpacing equals: String cr asText.	styler interBlockSpacing: '0'.	self assert: styler interBlockSpacing equals: '' asText.	styler interBlockSpacing: '2'.	self assert: styler interBlockSpacing equals: (String cr, String cr) asText! !!MicDynamicTextStylerTest methodsFor: 'tests'!testKeepCRFromInput	| styler textSample|	styler := MicDynamicTextStyler new.	textSample := 'aaa\bbb' withCRs asText.	self assert: (styler postTextTreatment: textSample copy) equals: textSample.	styler keepCRFromInput: 'false'.	self assert: (styler postTextTreatment: textSample copy) equals: 'aaa bbb' asText.	! !!MicDynamicTextStylerTest methodsFor: 'tests'!testMonospaceBackgroundColor	| styler |	styler := MicDynamicTextStyler new.	self assert: styler monospaceBackgroundColor equals: Smalltalk ui theme settings windowColor.	styler monospaceBackgroundColor: 'red'.	self assert: styler monospaceBackgroundColor equals: Color red.	styler monospaceBackgroundColor: '#FF0000'.	self assert: styler monospaceBackgroundColor equals: Color red	! !!MicDynamicTextStylerTest methodsFor: 'tests'!testNewLineIfNotAlready	| styler |	styler := MicDynamicTextStyler new.	self assert: styler newLineIfNotAlready equals: String cr asText.	styler newLineIfNotAlready: 'tab'.	self assert: styler newLineIfNotAlready equals: String tab asText.	styler newLineIfNotAlready: 'cr;tab;space'.	self assert: styler newLineIfNotAlready equals: (String cr, String tab, String space) asText	! !!MicParsesAndRendersAllCommentsTest methodsFor: 'tests'!testCommentFromChunkReadStream	"Test that we do not break on empty annotated blocks"	Microdown asRichText: ChunkReadStream comment.	Microdown asRichText: '!!!!'! !!MicParsesAndRendersAllCommentsTest methodsFor: 'tests'!testCommentFromConfigurationCommandLineHandler	Microdown asRichText: ConfigurationCommandLineHandler comment.	"Command line handler for dealing with Metacello configurations from the command lineUsage: config [--help] <repository url> [<configuration>] [--install[=<version>]] [--group=<group>] [--username=<username>] [--password=<password>][--no-quit][--no-save]	--help              show this help message	--no-quit        keep the image running after configuration install	--no-save       Don't save the image after configuration install	<repository url>    A Monticello repository name 	<configuration>     A valid Metacello Configuration name	<version>           A valid version for the given configuration	<group>             A valid Metacello group name	<username>          An optional username to access the configuration's repository	<password>          An optional password to access the configuration's repository	Examples:	# display this help message	pharo Pharo.image config		# list all configurations of a repository	pharo Pharo.image config $MC_REPOS_URL		# list all the available versions of a confgurtation	pharo Pharo.image config $MC_REPOS_URL ConfigurationOfFoo		# install the stable version	pharo Pharo.image config $MC_REPOS_URL ConfigurationOfFoo --install		#install a specific version '1.5'	pharo Pharo.image config $MC_REPOS_URL ConfigurationOfFoo --install=1.5		#install a specific version '1.5' and only a specific group 'Tests'	pharo Pharo.image config $MC_REPOS_URL ConfigurationOfFoo --install=1.5 --group=Tests"! !!MicParsesAndRendersAllCommentsTest methodsFor: 'tests'!testCommentFromFluidBuilder	"Test that we do not break on empty code blocks"	Microdown asRichText: '``````'! !!MicParsesAndRendersAllCommentsTest methodsFor: 'tests'!testSmokeSignalAndChoke	| difficultClasses |	"this test disables error handling and tries to render all class comments in the system"	"Really, it is a test of the robustness of Microdown parsing and rendering"	self skip. "I take too long for normal circumstances"	difficultClasses := OrderedCollection new.	Smalltalk globals allClasses do: [ :cl |			[ Microdown asRichText: cl comment ]				on: Exception 				do: [ difficultClasses add: cl ]		 ].	self assert: difficultClasses isEmpty! !!MicRichTextCodeBlockStylerTest methodsFor: 'accessing'!stylerFor: aLanguage	^ MicRichTextCodeBlockStyler stylerFor: aLanguage! !!MicRichTextCodeBlockStylerTest methodsFor: 'tests'!testDefaultStylerIsFound	| defaultStyler |	defaultStyler := self stylerFor: 'blblbl'.	self assert: defaultStyler class equals: MicRichTextCodeBlockStylerDefault! !!MicRichTextCodeBlockStylerTest methodsFor: 'tests'!testStylerForMethod		| code richText blueLocation textColor |	code := 'codeStylerFor: aString<codeblockStylerFor: #smalltalk>^bobby new isForWorkspace: blue; styledTextFor: aString asFest'.		richText := (self stylerFor: 'method') style: code.		self assert: richText asString trim equals: code trim.	self assert: ((richText attributesAt: 2) includes: TextEmphasis bold).	"Check that the unknown variable 'blue' is not colored red"	blueLocation := richText asString findString: 'blue'.	textColor := (richText attributesAt: blueLocation) detect: [ :attr | attr class = TextColor  ].	self assert: textColor color red equals: 0.! !!MicRichTextCodeBlockStylerTest methodsFor: 'tests'!testStylerForSmalltalk		| code richText blueLocation textColor |	code := 'green isColored: yellow^ blue & red'.	richText := (self stylerFor: 'Smalltalk') style: code.		self assert: richText asString trim equals: code trim.	"style smalltalk is assumes the code to be a code fragment, not a full method def"	self assert: ((richText attributesAt: 2) includes: TextEmphasis bold) not.	"Check that the unknown variable 'blue' is not colored red"	blueLocation := richText asString findString: 'blue'.	textColor := (richText attributesAt: blueLocation) detect: [ :attr | attr class = TextColor  ].	self assert: textColor color red equals: 0.! !!MicRichTextCodeBlockStylerTest methodsFor: 'tests'!testStylersForText	| defaultStyler |	defaultStyler := self stylerFor: 'text'.	self assert: defaultStyler class equals: MicRichTextCodeBlockStylerUnstyledText! !!MicRichTextComposerTest methodsFor: 'helpers'!assertWriting: aPRDocument include: expectedAttribute	self assert: ((self runsOf: aPRDocument) includes: {expectedAttribute})! !!MicRichTextComposerTest methodsFor: 'tests - format'!boldFormat	^ TextEmphasis bold! !!MicRichTextComposerTest methodsFor: 'helpers'!composer		composer ifNotNil: [ ^ composer ].	^ composer := self composerClass new! !!MicRichTextComposerTest methodsFor: 'helpers'!composerClass	^ MicRichTextComposer! !!MicRichTextComposerTest methodsFor: 'skipped tests'!externalLink: aLink	^ TextAction new actOnClickBlock: [WebBrowser openOn: aLink]! !!MicRichTextComposerTest methodsFor: 'skipped tests'!figure: aFigureLink	| url |	url := aFigureLink.	^ TextAnchor new anchoredMorph: (ZnEasy getPng: url)! !!MicRichTextComposerTest methodsFor: 'tests - header'!headerLevel1	^ self composer textStyler headerLevelFont: 1! !!MicRichTextComposerTest methodsFor: 'tests - header'!headerLevel2	^ self composer textStyler headerLevelFont: 2! !!MicRichTextComposerTest methodsFor: 'tests - header'!headerLevel3	^ self composer textStyler headerLevelFont: 3! !!MicRichTextComposerTest methodsFor: 'tests - header'!headerLevel4	^ self composer textStyler headerLevelFont: 4! !!MicRichTextComposerTest methodsFor: 'tests - header'!headerLevel5	^ self composer textStyler headerLevelFont: 5! !!MicRichTextComposerTest methodsFor: 'tests - header'!headerLevel6	^ self composer textStyler headerLevelFont: 6! !!MicRichTextComposerTest methodsFor: 'tests - format'!italicFormat	^ TextEmphasis italic! !!MicRichTextComposerTest methodsFor: 'tests - header'!microElementsFrom: aString	^ sample documentFrom: aString.	! !!MicRichTextComposerTest methodsFor: 'tests - format'!monospaceFormat	^ TextBackgroundColor color: Smalltalk ui theme settings windowColor! !!MicRichTextComposerTest methodsFor: 'tests - format'!normalFormat	^ TextEmphasis normal! !!MicRichTextComposerTest methodsFor: 'helpers'!richTextFor: aDocument	^ self composer visit: aDocument! !!MicRichTextComposerTest methodsFor: 'helpers'!richTextForString: aString	^ self composer asRichText: aString! !!MicRichTextComposerTest methodsFor: 'helpers'!runsOf: aDocument		^ (self richTextFor: aDocument) runs! !!MicRichTextComposerTest methodsFor: 'running'!setUp	super setUp.	sample := MicMicrodownSnippetFactory new.	parser := Microdown new.	offlineStatus := Microdown offline.	Microdown offline: false.	MicRichTextComposer initialize.! !!MicRichTextComposerTest methodsFor: 'skipped tests'!strikethroughtFormat	^ TextEmphasis struckOut! !!MicRichTextComposerTest methodsFor: 'helpers'!stringOf: aPRDocument		^ (self richTextFor: aPRDocument) string! !!MicRichTextComposerTest methodsFor: 'skipped tests'!subscriptFormat	^ TextColor red! !!MicRichTextComposerTest methodsFor: 'tests - format'!superscriptFormat	^ TextColor blue! !!MicRichTextComposerTest methodsFor: 'running'!tearDown	Microdown offline: offlineStatus.	super tearDown.! !!MicRichTextComposerTest methodsFor: 'tests'!testBackslashLast	| source richText |	source := 'I am a text which ends in \'.	richText := self richTextForString: source.	self assert: richText asString trim equals: source! !!MicRichTextComposerTest methodsFor: 'tests'!testBackslashNoBreak	"This test is related to issue: https://github.com/pillar-markup/Microdown/issues/107"	| source richText |	source := 'I''m a simple lexer. I''m used bt the DLitlleLParser.I recogniseI- names: list of characters letter and number and ''- separators: one character separator.- escape char \Whitespaces and separators can be customised using setters.Subclasses may change the definition of names by redefining isCurrentALetter.'.	richText := self richTextForString: source.	self assert: true "I did not fail"! !!MicRichTextComposerTest methodsFor: 'tests - format'!testBoldFormat	self assertWriting: (self microElementsFrom: sample boldFormatSample) include: self boldFormat! !!MicRichTextComposerTest methodsFor: 'tests - format'!testCenter	| src doc|	src := '<!!centerThis is centered!!>'.	doc := Microdown parse: src.	self assertWriting: doc include: TextAlignment centered ! !!MicRichTextComposerTest methodsFor: 'tests - codeBlock'!testCodeBlock	| source runs richText |	source := '```argumentsline 1line 2```'.	richText := self richTextForString: source.	runs := (richText runs collect: [:run | run collect: [:a| a class]]) asArray .			 	self assert: (runs second includes: TextIndent).	self assert: richText asString trim equals: 'line 1line 2'! !!MicRichTextComposerTest methodsFor: 'tests - codeBlock'!testCodeBlockStylerExplicitLanguage	| source richText expected |	source := '```language=dummyForTestline 1line 2```'.	expected := '§dummy§'.	richText := self richTextForString: source.	self assert: richText asString trim equals: expected! !!MicRichTextComposerTest methodsFor: 'tests - codeBlock'!testCodeBlockStylerShortHand	| source richText expected |	source := '```dummyForTestline 1line 2```'.	expected := '§dummy§'.	richText := self richTextForString: source.	self assert: richText asString trim equals: expected! !!MicRichTextComposerTest methodsFor: 'tests - codeBlock'!testCodeBlockWithCaption	| source runs richText |	source := '```caption=Roger Rabbitline 1line 2```'.	richText := self richTextForString: source.	runs := richText runs asArray.			self assert: runs first notEmpty. 	self assert: (runs second anySatisfy: [ :r | r class = TextIndent]).	self assert: ((runs at: 15) includes: self boldFormat ).	self assert: richText asString trim equals: 'line 1line 2Roger Rabbit'! !!MicRichTextComposerTest methodsFor: 'tests - codeBlock'!testCodeBlockWithTabbedCode	| source richText |	source := '```7	8```'.	richText := self richTextForString: source.	self assert: richText asString trim equals: '7	8'! !!MicRichTextComposerTest methodsFor: 'tests'!testEnvironment_unknownShouldNotFail	| src |	src := '<!!card stuff!!>'.	Microdown asRichText: src! !!MicRichTextComposerTest methodsFor: 'skipped tests'!testExternaLink	| source richText obj1 |	source := 'See [my anchor](https://pharo.org)'.	richText := self composerClass asRichText: source.	obj1 := (richText runs at: 10) first. "element 10 is the 'n' in anchor"	self assert: obj1 class name equals: #TextAction! !!MicRichTextComposerTest methodsFor: 'skipped tests'!testFigureCaptionMissingRemote	| source richText|	source := 'See !![SomeText](https://pharo.org/web/files/pharooooooo.png)'.	richText := self composerClass asRichText: source.	self assert: (richText asString trim includesSubstring: 'SomeText').	self assert: richText asTextMorph height < 100 "No image embedded"! !!MicRichTextComposerTest methodsFor: 'skipped tests'!testFigureCaptionRemote	| source richText |	source := 'See !![SomeText](https://pharo.org/web/files/pharo.png)'.	richText := self composerClass asRichText: source.	self deny: (richText asString trim includesSubstring: 'SomeText').	self assert: richText asTextMorph height > 100 "It is high because of the embedded image"! !!MicRichTextComposerTest methodsFor: 'skipped tests'!testFigureNoCaptionRemote	| source richText |	source := 'See !![](https://pharo.org/web/files/pharo.png)'.	richText := self composerClass asRichText: source.	self assert: (richText asString trim first: 6) equals: 'See  ', (String value: 1).	self assert: richText asTextMorph height > 100 "It is high because of the embedded image"! !!MicRichTextComposerTest methodsFor: 'tests - header'!testHeaderLevel1	self 		assertWriting: (self microElementsFrom: sample headerLevel1Sample) 		include: self headerLevel1! !!MicRichTextComposerTest methodsFor: 'tests - header'!testHeaderLevel2	self 		assertWriting: (self microElementsFrom: sample headerLevel2Sample) 		include: self headerLevel2! !!MicRichTextComposerTest methodsFor: 'tests - header'!testHeaderLevel3	self 		assertWriting: (self microElementsFrom: sample headerLevel3Sample) 		include: self headerLevel3! !!MicRichTextComposerTest methodsFor: 'tests - header'!testHeaderLevel4	self 		assertWriting: (self microElementsFrom: sample headerLevel4Sample) 		include: self headerLevel4! !!MicRichTextComposerTest methodsFor: 'tests - header'!testHeaderLevel5	self 		assertWriting: (self microElementsFrom: sample headerLevel5Sample) 		include: self headerLevel5! !!MicRichTextComposerTest methodsFor: 'tests - header'!testHeaderLevel6	self 		assertWriting: (self microElementsFrom: sample headerLevel6Sample) 		include: self headerLevel6! !!MicRichTextComposerTest methodsFor: 'tests'!testInputfile	| source result |	source := '<!!inputFile|path=comment://class/MicRichTextComposerTest!!>'.	result := (self richTextForString: source) asString trim.	self assert: (result beginsWith: 'MicRichTextComposerTest').	self assert: (result includesSubstring: 'This class contains tests')! !!MicRichTextComposerTest methodsFor: 'skipped tests'!testItalicFormat	| source runs richText |	source := 'This have been _emphasized_'.	richText := self richTextForString: source.	runs := richText runs asArray.		self assert: runs first isEmpty. 	self assert: ((runs at: 19 "the p in emphasized") includes: self italicFormat ).	self deny: ((runs at: 6 "the h in have") includes: self italicFormat  ).! !!MicRichTextComposerTest methodsFor: 'tests - list'!testLatexMathStyleEmpty	| source richText |	source :=  'foo$$bar'.	richText := self richTextForString: source.	self assert: richText asString trim equals: 'foobar' .! !!MicRichTextComposerTest methodsFor: 'tests - list'!testListAreCorrectlyNumbered	| source richText |	source :='1. item 11. other item 12. item 23. item 34. item 4'.	richText := self richTextForString: source. 	self assert: (richText asString copyFrom: 11 to: 25) equals: '2.	other item 1'.	self assert: (richText asString copyFrom: 47 to: 55) equals: '5.	item 4'.	! !!MicRichTextComposerTest methodsFor: 'tests'!testMathEnvironmentError	| source richText |	source :=  'foo$$\include{nowhere.com}$$'.	richText := self richTextForString: source.	self assert: richText asString equals: 'foo$$ - LATEX ERROR - $$'! !!MicRichTextComposerTest methodsFor: 'tests'!testNestedList	"I just need to be here and succeed to override an existing test which is obsolete"	| silly |	silly := 'absolutely'.	self assert: silly equals: silly! !!MicRichTextComposerTest methodsFor: 'skipped tests'!testNestedMixedList	| source richText runs |	source := '- item 1  1. sub item 1.1- item 2  2. sub item 2.1  2. sub item 2.2- item 3'.	richText := self richTextForString: source.	runs := richText runs.		"check that 'sub item 2.1' is numbered 'A)' and is rightly indented"	self assert: (richText asString copyFrom: 35 to: 36) equals: 'A)'.	self assert: (runs at: 36) first amount equals: 3	! !!MicRichTextComposerTest methodsFor: 'skipped tests'!testNestedMixedListNoEmptyLinesEfterSubLists	| source output |	source := '- item 1  1. sub item 1.1- item 2  2. sub item 2.1  2. sub item 2.2- item 3'.	output := (self richTextForString: source) asString trim.	self assert: output lines size equals: 6		! !!MicRichTextComposerTest methodsFor: 'skipped tests'!testNestedUnorderdList	| source richText |	source := '- item 1  - sub item 1.1- item 2  - sub item 2.1  - sub item 2.2- item 3'.	richText := self richTextForString: source.	"check that 'sub item 1.1' is bulleted and is rightly indented"	self assert: (richText asString includesSubstring: '•	item 2').	self assert: (richText asString includesSubstring: '-	sub item 2.1')	! !!MicRichTextComposerTest methodsFor: 'tests - list'!testNewDictionaryAPI		| dict |	dict := Dictionary newFrom: { #a -> 1  . #b -> 2 }.	self assert: (dict at: #a) equals: 1! !!MicRichTextComposerTest methodsFor: 'tests - list'!testNoNSuperfluousNewLines	| source richText expected |	source :=  'This is **bold**And this is just an other paragraph'.	expected := 'This is boldAnd this is just an other paragraph'.	richText := self richTextForString: source.	self assert: richText asString equals: expected! !!MicRichTextComposerTest methodsFor: 'tests - list'!testNosuperfluousNewLines	| source richText expected |	source :=  'This is **bold**'.	expected := 'This is bold'.	richText := self richTextForString: source.	self assert: richText asString equals: expected! !!MicRichTextComposerTest methodsFor: 'tests - list'!testOrderedList	| source richText runs  |	source := '1. First item2. Second item   on two lines3. Third item'.	richText := self richTextForString: source.	runs := richText runs .		self assert: runs first first class equals: TextIndent.	self assert: runs first first amount equals: 1.	self assert: (runs at: 30) "the first o in 'on two lines'" first class equals: TextIndent.	self assert: (runs at: 30) first amount equals: 2.	! !!MicRichTextComposerTest methodsFor: 'tests'!testOrderedNestedList	| source richText   |	source := '1. First item   2. Second item      3. Third item'.	richText := self richTextForString: source.	self assert: (richText asString includesSubstring: '1.	First item').	self assert: (richText asString includesSubstring: 'A)	Second item').	self assert: (richText asString includesSubstring: 'a)	Third item')	! !!MicRichTextComposerTest methodsFor: 'tests - paragraph'!testParagraphNotFormat	| runs richText |	richText := self richTextFor: (self microElementsFrom: 'foobarwith a space').	runs := richText runs.	self assert: (runs allSatisfy: [ :format | format = #() ] )! !!MicRichTextComposerTest methodsFor: 'tests'!testQuoteBlock	| src richText |	"Quote blocks have not been implemented"	src := '> foo'.	richText := Microdown asRichText: src.	"should at least include foo somehow"	self deny: (richText asString findString: 'foo') equals: 0! !!MicRichTextComposerTest methodsFor: 'tests'!testRaw	| text |	text := Microdown asRichText: '{{**not bold**}}'.	self assert: text asString trim equals: '**not bold**'.! !!MicRichTextComposerTest methodsFor: 'tests'!testRawNewLinesPreserved	| text |	text := Microdown asRichText: '{{**not bold**}}'.	self assert: text asString trim equals: '**notbold**'.! !!MicRichTextComposerTest methodsFor: 'tests - format'!testRightAlignment 	| src doc|	src := '<!!rightThis is righted!!>'.	doc := Microdown parse: src.	self assertWriting: doc include: TextAlignment rightFlush  ! !!MicRichTextComposerTest methodsFor: 'skipped tests'!testStrikethroughFormat 	| source runs richText |	source := 'This have been ~deleted~'.	richText := self richTextForString: source.	runs := richText runs asArray.		self assert: runs first isEmpty. 	self assert: ((runs at: 19 "the l in deleted") includes: self strikethroughtFormat ).	self deny: ((runs at: 6 "the h in have") includes: self strikethroughtFormat ).! !!MicRichTextComposerTest methodsFor: 'tests'!testStylerForMethod		| code source richText blueLocation textColor |	self composerClass initialize.	code := 'codeStylerFor: aString<codeblockStylerFor: #smalltalk>^bobby new isForWorkspace: blue; styledTextFor: aString asFest'.	source := '```language=method' , code ,'```'.	richText := self richTextForString: source.		self assert: richText asString trim equals: code trim.	self assert: ((richText attributesAt: 2) includes: TextEmphasis bold).	"Check that the unknown variable 'blue' is not colored red"	blueLocation := richText asString findString: 'blue'.	textColor := (richText attributesAt: blueLocation) detect: [ :attr | attr class = TextColor  ].	self assert: textColor color red equals: 0.! !!MicRichTextComposerTest methodsFor: 'tests - list'!testUnorderedList	| source richText runs  |	source :=  '- First item- Second item   on two lines- Third item'.	richText := self richTextForString: source.	runs := richText runs.	self assert: runs first first class equals: TextIndent.	self assert: runs first first amount equals: 1.	self assert: (runs at: 29) "the first o in 'on two lines'" first class equals: TextIndent.	self assert: (runs at: 29) first amount equals: 2.! !!MicRichTextComposerTest methodsFor: 'tests - format'!underlineFormat	^ TextEmphasis underlined! !!MicRichTextFormatConfigurationTest methodsFor: 'as yet unclassified'!fontString	^ TextStyle defaultFont familyName,';72'! !!MicRichTextFormatConfigurationTest methodsFor: 'tests'!testBodyFont	| richText |	richText := Microdown asRichText: 'foo bar'.	self assert: (richText asMorph height < 50).	richText := Microdown asRichText: ('{!!richtext|bodyFont=$font$!!}foo bar' copyReplaceAll: '$font$' with: self fontString).	self assert: (richText asMorph height > 100).! !!MicRichTextFormatConfigurationTest methodsFor: 'tests'!testBullets	| src richText |	src := '{!!richtext|bullets=◊»!!}- aaa  - bbb'.	richText := Microdown asRichText: src.	self assert: (richText asString includesSubstring: '◊	aaa').	self assert: (richText asString includesSubstring: '»	bbb')! !!MicRichTextFormatConfigurationTest methodsFor: 'tests'!testChangingSameStyler	| src richText |	"Test that the same styler is changed"	src := '{!!richtext|crAfterHeader=3!!}# Header 1{!!richtext|crAfterHeader=1!!}# Header 2last line'.	richText := Microdown asRichText: src.	self assert: (richText asString) equals: 'Header 1Header 2last line'! !!MicRichTextFormatConfigurationTest methodsFor: 'tests'!testCounters	| src richText |	src := '{!!richtext|counters=A1!!}1. aaa   9. bbb'.	richText := Microdown asRichText: src.	self assert: (richText asString includesSubstring: 'A)	aaa').	self assert: (richText asString includesSubstring: '1.	bbb')! !!MicRichTextFormatConfigurationTest methodsFor: 'tests'!testHeader1	| src richText |	src := '{!!richtext|headerFont1=$font$!!}# Huge header'.	src := src copyReplaceAll: '$font$' with: self fontString. 	richText := Microdown asRichText: src.	self assert: (richText asMorph height > 100).! !!MicRichTextFormatConfigurationTest methodsFor: 'tests'!testHeader2	| src richText |	src := '{!!richtext|headerFont2=$font$!!}## Huge header'.	src := src copyReplaceAll: '$font$' with: self fontString. 	richText := Microdown asRichText: src.	self assert: (richText asMorph height > 100).! !!MicRichTextFormatConfigurationTest methodsFor: 'tests'!testHeader3	| src richText |	src := '{!!richtext|headerFont3=$font$!!}### Huge header'.	src := src copyReplaceAll: '$font$' with: self fontString. 	richText := Microdown asRichText: src.	self assert: (richText asMorph height > 100).! !!MicRichTextFormatConfigurationTest methodsFor: 'tests'!testHeader4	| src richText |	src := '{!!richtext|headerFont4=$font$!!}#### Huge header'.	src := src copyReplaceAll: '$font$' with: self fontString. 	richText := Microdown asRichText: src.	self assert: (richText asMorph height > 100).! !!MicRichTextFormatConfigurationTest methodsFor: 'tests'!testHeader5	| src richText |	src := '{!!richtext|headerFont5=$font$!!}##### Huge header'.	src := src copyReplaceAll: '$font$' with: self fontString. 	richText := Microdown asRichText: src.	self assert: (richText asMorph height > 100).! !!MicRichTextFormatConfigurationTest methodsFor: 'tests'!testHeader6	| src richText |	src := '{!!richtext|headerFont6=$font$!!}###### Huge header'.	src := src copyReplaceAll: '$font$' with: self fontString. 	richText := Microdown asRichText: src.	self assert: (richText asMorph height > 100).! !!MicRichTextFormatConfigurationTest methodsFor: 'tests'!testIllegalArgument	| src richText |	src := '{!!richtext|foo=bar!!}'.	richText := Microdown asRichText: src.	self assert: richText asString  equals: 'richtext annotation - unknown argument: foo'! !!MicRichTextFormatConfigurationTest methodsFor: 'tests'!testInterBlockSpacing 	| src richText |	src := '{!!richtext|interBlockSpacing=0!!}fooobarboo'.	richText := Microdown asRichText: src.	self assert: (richText asString lines size) equals: 3! !!MicRichTextFormatConfigurationTest methodsFor: 'tests'!testInterBlockSpacing_three	| src richText |	src := '{!!richtext|interBlockSpacing=3!!}fooobarboo'.	richText := Microdown asRichText: src.	self assert: (richText asString lines size) equals: 7! !!MicRichTextFormatConfigurationTest methodsFor: 'tests'!testNewLineIfNotAlready	| src richText |	"newLineIfNotAlready mostely makes sense if interBlockSpacing is 0"	src := '{!!richtext|newLineIfNotAlready=cr;tab&interBlockSpacing=0!!}foobar'.	richText := Microdown asRichText: src.	self assert: (richText asString) equals: 'foo	bar'! !!MicRichTextFormatConfigurationTest methodsFor: 'tests'!testSpaceAfterHeader	| src richText |	src := '{!!richtext|crAfterHeader=2;2;1;1!!}# Header 1## Header 2### Header 3#### Header 4##### Header 5###### Header 6'.	richText := Microdown asRichText: src.	self assert: (richText asString) equals: 'Header 1Header 2Header 3Header 4Header 5Header 6'! !!MicRichTextLinkPresenterTest methodsFor: 'running'!setUp	super setUp.	linkPresenter := MicRichTextLinkPresenter new.! !!MicRichTextLinkPresenterTest methodsFor: 'tests'!testGuessKindOf	"Testing default"	| ref file |	file := FileSystem memory / 'mydoc'.	ref := file asMicResourceReference.	ref contents: 'I am just a text file'.	self assert: (linkPresenter guessKindOf: ref) equals: 'md'! !!MicRichTextLinkPresenterTest methodsFor: 'tests'!testGuessKindOf_html	"Testing default"	| ref file |	file := FileSystem memory / 'mydoc'.	ref := file asMicResourceReference.	ref contents: '<!!doctype html>'.	self assert: (linkPresenter guessKindOf: ref) equals: 'html'! !!MicRichTextLinkPresenterTest methodsFor: 'tests'!testGuessKindOf_html_with_comment	"Testing default"	| ref file |	file := FileSystem memory / 'mydoc'.	ref := file asMicResourceReference.	ref contents: '<!!-- Silly stuff here --><!!doctype html>'.	self assert: (linkPresenter guessKindOf: ref) equals: 'html'! !!MicRichTextLinkPresenterTest methodsFor: 'tests'!testGuessKindOf_withExtension	"Testing default"	| ref file |	file := FileSystem memory / 'mydoc.foo'.	ref := file asMicResourceReference.	self assert: (linkPresenter guessKindOf: ref) equals: 'foo'! !!MicRichTextLinkPresenterTest methodsFor: 'tests'!testPragmaForKind	"Testing default"		self assert: (linkPresenter pragmaForKind: '$$$' ) isEmpty! !!MicRightAlignmentBlockTest methodsFor: 'tests'!testRightAlignment	| src doc center |	src := '<!!rightThis is righted!!>'.	doc := Microdown parse: src.	center := doc children first.	self assert: center class equals: MicRightAlignmentBlock .	self assert: center children first text equals: 'This is righted'! !!MicTemplatingTest methodsFor: 'tests'!testBaselineWithoutBaselineMethodShouldNotBreak			MicMockBaselineOf buildMicroDownUsing: Microdown builder withComment: 'balbabl'! !!MicRichTextCodeBlockStylerDummyForTest class methodsFor: 'accessing'!styleTags 	^ #(dummyForTest)! !!MicRichTextCodeBlockStylerDummyForTest methodsFor: 'accessing'!style: sString	^ '§dummy§' asText! !"Microdown-RichTextComposer-Tests"!!MicRichTextComposerTest methodsFor: '*Microdown-MathFlaky-Tests'!testClassExamplesNotBroken	"I merely test that the examples do not break"	| examples |	examples := (Pragma allNamed: #sampleInstance in: MicRichTextComposer class)		collect: [ :pragma | pragma method selector ].	examples do: [ :selector | MicRichTextComposer perform: selector ]! !!MicRichTextComposerTest methodsFor: '*Microdown-MathFlaky-Tests'!testLatexMathStyle	| source1 source2 richText1 richText2 |	"this checks if latex is working by making two formulas, of which the second should be taller"	source1 :=  'foo$a+b$bar'.	source2 :=  'foo$\frac{A}{B}$bar'.	richText1 := self richTextForString: source1.	richText2 := self richTextForString: source2.	self assert: richText1 asMorph height < richText2 asMorph height! !!MicRichTextComposerTest methodsFor: '*Microdown-MathFlaky-Tests'!testMathEnvironment	| source1 source2 richText1 richText2 |	"this checks if latex is working by making two formulas, of which the second should be taller"	source1 :=  'foo$$a+b$$bar'.	source2 :=  'foo$$\frac{A}{B}$$bar'.	richText1 := self richTextForString: source1.	richText2 := self richTextForString: source2.	self assert: richText1 asMorph height < richText2 asMorph height! !!MicMorphicTextAdapter commentStamp: '' prior: 50989038!I am an adapter used by `SpRichTextPresenter` to connect to a `SpRichTextMorph`.## ImplementationMy primary method is `buildWidget` which creates an instance of `SpRichTextMorph`. My model (inherited instance variable) is a `SpRichTextPresenter`. Perhaps in the future the methods for menu and shiftMenu should be forwarded to the presenter.!!MicScrolledTextMorph methodsFor: 'event handling' prior: 51103784!textAreaExtentChanged	super textAreaExtentChanged.	"When textArea size change, scalable images might need to be redrawn"	self model model renderWidth: self width.	self resetState! !!MicMorphicTextAdapter methodsFor: 'factory' prior: 50991157!buildWidget	| newWidget |		newWidget := (MicScrolledTextMorph  on: self)		beReadOnly;		beWrapped;		enabled: self enabled;		vResizing: #spaceFill;		hResizing: #spaceFill;		hScrollbarShowWhenNeeded;		getSelectionSelector: #readSelection;		setSelectionSelector: #setSelection:;		getTextSelector: #getText;		setTextSelector: #accept:notifying:;		yourself.		newWidget setText: self presenter text.	self presenter selectionInterval 		ifNotNil: [  :anInterval | self selectionInterval: anInterval].	^ newWidget! !!MicMorphicTextAdapter methodsFor: 'presenter->morph' prior: 50990083!selectionInterval: anInterval	"called by presenter to set selection in morph"	self widgetDo: [ :w | w setTextAreaSelection: anInterval ].	! !!MicMorphicTextAdapter methodsFor: 'presenter->morph' prior: 50992402!setText: aText	"called by presenter to set text in morph"	widget ifNotNil: [ 		widget 			setText: aText;			resetState ]! !!MicTextPresenter methodsFor: 'api'!enabled: aBoolean	"Set if the widget is enabled (clickable or focusable)"	super enabled: aBoolean.	self changed: #enabled: with: { aBoolean }! !!MicTextPresenter methodsFor: 'initialization' prior: 51130917!initialize	super initialize.	text := '' asText.	scalingImageIndexes := Array new.! !!MicTextPresenter methodsFor: 'selection' prior: 51131255!rawSelection: anInterval	self property: #selection rawValue: anInterval! !!MicTextPresenter methodsFor: 'accessing'!renderWidth: renderWidth	"I am called by the morph directly to recompute image sizes"	adapter ifNil: [ ^self ]. "I can be asked to render during setup"	scalingImageIndexes  do: [ :idx | 		(text attributeAt: idx ofKind: MicScalingTextAnchor) targetWidth: renderWidth ].! !!MicTextPresenter methodsFor: 'selection' prior: 51131567!selectAll	self selectionInterval: (1 to: text size)! !!MicTextPresenter methodsFor: 'selection' prior: 51131457!selectNone	self selectionInterval: (1 to: 0)! !!MicTextPresenter methodsFor: 'selection' prior: 51129455!selectedText 	"Answer the text contained in selection interval 	(See `SpAbstractTextPresenter>>#selectionInterval`)"	| selectionInterval |		selectionInterval := self selectionInterval.	selectionInterval ifEmpty: [ ^ '' asText ].		^ self text		copyFrom: selectionInterval first 		to: selectionInterval last! !!MicTextPresenter methodsFor: 'selection' prior: 51130524!selectionInterval	"Answer the text selection interval (an interval from start to end)."		self withAdapterDo: [ :anAdapter | 		self property: #selection rawValue: anAdapter selectionInterval].	^ selection ifNil: [ 1 to: 0 ]! !!MicTextPresenter methodsFor: 'selection' prior: 51131030!selectionInterval: anInterval	"Set the text selection interval.	 `anInterval` is an `Interval` from the first character selected to the end."		selection := anInterval.	adapter selectionInterval: anInterval	! !!MicTextPresenter methodsFor: 'accessing' prior: 51131380!text	^ text! !!MicTextPresenter methodsFor: 'accessing' prior: 51130784!text: aText	text := aText asText "just in case I was given a string".	scalingImageIndexes := (1 to: text size) 		select: [ :idx | 			((text at: idx) = Character home) 			and: [ (text attributeAt: idx ofKind: MicScalingTextAnchor) notNil ] ].	self withAdapterDo: [ adapter setText: aText ]	! !!MicTextPresenter methodsFor: 'enumerating' prior: 51130001!whenSelectionChangedDo: aBlock	"Inform when selection changed. 	 `aBlock` receives two optional arguments 	 - new selection	 - old selection"	self property: #selection whenChangedDo: aBlock! !!MicTextPresenter methodsFor: 'api' prior: 51130257!whenTextChangedDo: aBlock	"Inform when text has been changed (`text:` has been called)	 `aBlock` receives two optional arguments 	 - new text	 - old text"	self property: #text whenChangedDo: aBlock! !!MicrodownPresenter methodsFor: 'composing'!compose	self document ifNil: [ ^ self ].	self text: (MicRichTextComposer new 		textStyler: self textStyler; 		asRichText: self document)! !!MicrodownPresenter methodsFor: 'accessing' prior: 51215438!document	^ document! !!MicrodownPresenter methodsFor: 'accessing' prior: 51215513!document: aNode	document := aNode.	self compose.! !!MicrodownPresenter methodsFor: 'accessing' prior: 51215602!documentFromString: aString	self document: (self parserClass parse: aString)			! !!MicrodownPresenter methodsFor: 'initialization' prior: 51215360!parserClass 	^ Microdown! !!MicrodownPresenter methodsFor: 'accessing' prior: 51215739!textStyler	textStyler ifNil: [ textStyler := MicTextStyler new ].	^ textStyler! !!MicrodownPresenter methodsFor: 'accessing' prior: 51215861!textStyler: styler	textStyler := styler.	self compose! !!MicrodownPresenter methodsFor: 'enumerating' prior: 51215965!whenDocumentChangedDo: aBlock	self property: #document whenChangedDo: aBlock! !!MicrodownPresenter methodsFor: 'enumerating' prior: 51216106!whenTextStylerChangedDo: aBlock	self property: #textStyler whenChangedDo: aBlock! !!SequenceableCollection methodsFor: '*Microdown-RichTextPresenter'!truncateTo: smallSize	"return myself or a copy shortened to smallSize."	^ self size <= smallSize		ifTrue: [ self ]		ifFalse: [ self copyFrom: 1 to: smallSize ]! !MicMorphicTextAdapter removeSelector: #setText:to:!MicMorphicTextAdapter removeSelector: #setEnabled:to:!MicMorphicTextAdapter removeSelector: #scalingImageIndexes!MicMorphicTextAdapter removeSelector: #renderWidth:!MicMorphicTextAdapter removeSelector: #initialize!MicMorphicMicrodownAdapter removeSelector: #composeOn:!MicMorphicMicrodownAdapter removeSelector: #compose!MicMorphicMicrodownAdapter removeSelector: #buildWidget!Smalltalk globals removeClassNamed: #AnObsoleteMicMorphicMicrodownAdapter!MicrodownPresenter class removeSelector: #adapterName!"Microdown-RichTextPresenter"!!MicrodownPresenterTest methodsFor: 'tests' prior: 51217478!testDocumentIsRendered	presenter document: (Microdown parse: '# Nice header').	self assert: presenter text asString trim equals: 'Nice header'! !!MicrodownPresenterTest methodsFor: 'tests' prior: 51216846!testDocumentIsRenderedFromString	presenter documentFromString: '# Nice header'.	self assert: presenter text asString trim equals: 'Nice header'! !"Microdown-RichTextPresenter-Tests"!!ManifestMicrodownDocumentBrowser commentStamp: '' prior: 0!I implement a browser and editor for Microdown documents.See comment in `MicDocumentBrowser`.I implement two new kind of Microdown resource references: `MicPharoCommentResourceReference` and `MicGitHubRessourceReference`.And I extend the MicFileResourceReference with icons for use in the documnt browser.The classes in tag 'Model' are unused at the moment, but implement hierarchical structure over microdown documents and are just kept for reference for the time being (the issue is that some documents might be large, and it would be nice to browse a large document by sections in the tree view, but then what to do when trying to edit this large document).!!MicAbstractBlock methodsFor: '*Microdown-DocumentBrowser' prior: 50675268!canSave	"Called by the document browser. Polymorphic with MicResourceReferences"	^ false! !!MicAbstractBlock methodsFor: '*Microdown-DocumentBrowser' prior: 50676228!contents	"polymorphic with MicResourceReference - returns the source code of me - here generated"	^ 'You cannot edit subsections of a document.Select the whole document for editing'! !!MicAbstractBlock methodsFor: '*Microdown-DocumentBrowser' prior: 50675620!isHeader	^ false! !!MicAbstractBlock methodsFor: '*Microdown-DocumentBrowser' prior: 50676728!loadMicrodown	"polymorphic with resource references"	^ self! !!MicIntermediateBlock methodsFor: 'visiting' prior: 50903896!accept: aVisitor	self children do: [ :n | n accept: aVisitor ]! !!MicIntermediateBlock methodsFor: 'public' prior: 50903484!addLineAndReturnNextNode: line	"I am not supposed to be generated during parsing, and this method should not be called on me"	self shouldNotImplement! !!MicIntermediateBlock methodsFor: 'public' prior: 50903694!canConsumeLine: line	"I am not supposed to be generated during parsing, and this method should not be called on me"	self shouldNotImplement! !!MicSectionBlock class methodsFor: 'instance creation' prior: 51107479!fromRoot: document	| newSection |	newSection := self new		from: document children readStream.	"If the document used header level 1 as title (ie it was the only level 1 header), 	do not introduce an intermediate level"	^ (newSection body children isEmpty and: [newSection subsections children size = 1])		ifTrue: [ newSection subsections children first ]		ifFalse: [ newSection ]! !!MicSectionBlock methodsFor: 'visiting' prior: 51107338!accept: aVisitor	self children do: [ :node | node accept: aVisitor  ]! !!MicSectionBlock methodsFor: 'public' prior: 51104974!addLineAndReturnNextNode: line	"I am not supposed to be generated during parsing, and this method should not be called on me"	self shouldNotImplement! !!MicSectionBlock methodsFor: 'accessing' prior: 51106998!body	^ body! !!MicSectionBlock methodsFor: 'accessing' prior: 51104783!body: anObject	body := anObject! !!MicSectionBlock methodsFor: 'public' prior: 51105179!canConsumeLine: line	"I am not supposed to be generated during parsing, and this method should not be called on me"	self shouldNotImplement! !!MicSectionBlock methodsFor: 'accessing' prior: 51107150!children	^ self header 		ifNil: [ { self body. self subsections  } ]		ifNotNil: [ { self header. self body. self subsections  } ]! !!MicSectionBlock methodsFor: 'displaying' prior: 51105686!displayString	header ifNil: [ ^'Root section' ].	^ (Microdown asRichText: self header) asString trim! !!MicSectionBlock methodsFor: 'instance creation' prior: 51105853!from: nodeStream	"collect preamble"	[ nodeStream atEnd not and:[ nodeStream peek isHeader not ]]		whileTrue: [ nodeStream next parent: self body  ].	"collect subsections"	[ nodeStream atEnd not and:[ nodeStream peek isHeader  ]]		whileTrue: [ 			(nodeStream peek level > self level)				ifTrue: [					(self class new 							header: nodeStream next;							from: nodeStream) 						parent: self subsections  ]				ifFalse: [ ^ self ]		].	^self				 ! !!MicSectionBlock methodsFor: 'accessing' prior: 51106638!header	^ header! !!MicSectionBlock methodsFor: 'accessing' prior: 51105564!header: headerBlock	header := headerBlock.	header parent: self! !!MicSectionBlock methodsFor: 'initialization' prior: 51106375!initialize	super initialize.	header := nil.	body := MicIntermediateBlock new parent: self; yourself.	subsections := MicIntermediateBlock new parent: self; yourself.! !!MicSectionBlock methodsFor: 'displaying' prior: 51106712!inspectionSection	<inspectorPresentationOrder: 830 title: 'Sections'>	^ SpTreePresenter new		  roots: { self };		  children: [ :aNode | aNode subsections children];		  display: [ :aNode | aNode displayString ];		  yourself! !!MicSectionBlock methodsFor: 'accessing' prior: 51105377!level	header ifNil: [ ^0 ].	^ header level! !!MicSectionBlock methodsFor: 'accessing' prior: 51107067!subsections	^ subsections! !!MicSectionBlock methodsFor: 'accessing' prior: 51104873!subsections: anObject	subsections := anObject! !!MicSectionBlock methodsFor: 'displaying' prior: 51105479!title	^ self displayString ! !!MicDocumentBrowserLayoutModel methodsFor: 'initialization' prior: 50750656!initialize	showDocumentList := true.	showSource := false.	sourceMode := self sourceBotton.	sourceLayouts := nil.	! !!MicDocumentBrowserLayoutModel methodsFor: 'layouting' prior: 50750819!layoutList: spDocumentList rendering: spRendering source: spSource	"I return a layout based on my state for the three components"	^ showDocumentList		ifTrue: [ 			SpPanedLayout newLeftToRight				  add: spDocumentList;				  add: (self layoutRendering: spRendering source: spSource );				  positionOfSlider: 0.3;				  yourself ]		ifFalse: [ 			self layoutRendering: spRendering source: spSource  ]! !!MicDocumentBrowserLayoutModel methodsFor: 'layouting' prior: 50750130!layoutRendering: spRendering source: spSource		self showSource ifFalse: [ ^ spRendering ].	self sourceMode = self sourceSwap ifTrue: [ ^ spSource ].	^ (self sourceLayouts at: self sourceMode)		value: spRendering		value: spSource ! !!MicDocumentBrowserLayoutModel methodsFor: 'accessing' prior: 50749817!showDocumentList	^ showDocumentList! !!MicDocumentBrowserLayoutModel methodsFor: 'accessing' prior: 50752514!showDocumentList: anObject	showDocumentList := anObject! !!MicDocumentBrowserLayoutModel methodsFor: 'accessing' prior: 50751295!showSource	^ showSource! !!MicDocumentBrowserLayoutModel methodsFor: 'accessing' prior: 50752304!showSource: anObject	showSource := anObject! !!MicDocumentBrowserLayoutModel methodsFor: 'source modes'!sourceBotton	^'Source bottom'! !!MicDocumentBrowserLayoutModel methodsFor: 'source modes' prior: 50751490!sourceLayouts	"return a dictionary of layout blocks."	sourceLayouts ifNotNil: [ ^ sourceLayouts ].	^ sourceLayouts := {	self sourceBotton 	-> [ :r :s | SpPanedLayout newTopToBottom add: r;add: s; yourself].	self sourceTop 		-> [ :r :s | SpPanedLayout newTopToBottom add: s;add: r; yourself].	self sourceRight 	-> [ :r :s | SpPanedLayout newLeftToRight add: r;add: s; yourself].	self sourceLeft		-> [ :r :s | SpPanedLayout newLeftToRight add: s;add: r; yourself].	self sourceSwap 	-> [ :r :s | s ]	} asDictionary 	! !!MicDocumentBrowserLayoutModel methodsFor: 'source modes' prior: 50750439!sourceLeft	^   'Source left'! !!MicDocumentBrowserLayoutModel methodsFor: 'accessing' prior: 50751391!sourceMode	^ sourceMode! !!MicDocumentBrowserLayoutModel methodsFor: 'accessing' prior: 50752084!sourceMode: anObject	sourceMode := anObject! !!MicDocumentBrowserLayoutModel methodsFor: 'source modes' prior: 50750541!sourceModes	^ self sourceLayouts keys! !!MicDocumentBrowserLayoutModel methodsFor: 'source modes' prior: 50752203!sourceRight	^  'Source right'! !!MicDocumentBrowserLayoutModel methodsFor: 'source modes' prior: 50752423!sourceSwap	^ #Swap ! !!MicDocumentBrowserLayoutModel methodsFor: 'source modes' prior: 50750034!sourceTop	^ 'Source top'! !!MicDocumentBrowserModel methodsFor: 'accessing' prior: 50756968!canSave	resourceReference ifNil: [ ^ false ].	^ resourceReference canSave! !!MicDocumentBrowserModel methodsFor: 'accessing' prior: 50757380!document	resourceReference ifNil: [ ^ nil ].	document ifNotNil: [ ^ document ].	[ document := resourceReference loadMicrodown.]		on: MicResourceReferenceError		do: [ :error | 			document := Microdown parse: '# Error: ' , error message].	^ document ! !!MicDocumentBrowserModel methodsFor: 'initialization' prior: 50757705!initialize	isDirty := false.! !!MicDocumentBrowserModel methodsFor: 'accessing' prior: 50757799!isDirty	^ isDirty! !!MicDocumentBrowserModel methodsFor: 'accessing' prior: 50758605!resourceReference	^ resourceReference! !!MicDocumentBrowserModel methodsFor: 'accessing' prior: 50757883!resourceReference: ref	"I set the document and source of the argument"	resourceReference := ref.	isDirty := false.	document := source := nil	! !!MicDocumentBrowserModel methodsFor: 'actions' prior: 50758092!save	"store the source into resourceReference. Do nothing if not dirty or if not canSave"	(isDirty and: [ self canSave ]) ifFalse: [ ^ self ].	resourceReference contents: source.	"self updateDocumentFromSource."	source := document := nil.	isDirty := false.! !!MicDocumentBrowserModel methodsFor: 'accessing' prior: 50757108!source	resourceReference ifNil: [ ^ nil ].	source ifNotNil: [ ^ source ].	[ source := resourceReference contents.]		on: MicResourceReferenceError		do: [ :error | source := '# Resorce error'].	^ source ! !!MicDocumentBrowserModel methodsFor: 'accessing' prior: 50758419!source: markupString	"Assumes we can save"	self canSave ifFalse: [ ^ self ].	source := markupString.	isDirty := true.! !!MicDocumentBrowser class methodsFor: 'services menu' prior: 50746594!fileReaderServicesForFile: fullName suffix: suffix	<fileService>	suffix = 'md' ifFalse:[^ #() ].	^ { self serviceOpenMicrodownDocument  }! !!MicDocumentBrowser class methodsFor: 'services menu' prior: 50746804!itemsForDirectory: aFileDirectory	<directoryService>		^ { self serviceOpenMicrodownDirectory }! !!MicDocumentBrowser class methodsFor: 'instance creation' prior: 50748275!open	"I ensure the browser to be open. If no browser exist, I instantiate one"	<script>	Browser ifNil: [ Browser := self new ].	(Browser owner isNil or: [ Browser owner isClosed ])		ifTrue: [ Browser open ].		! !!MicDocumentBrowser class methodsFor: 'opening' prior: 50746050!openDocument: aMicResourceReferenceOrString	"I open microdown documents. If an existing browser instance is present, add the reference to the browser.	I am called when following links in rich text to microdown documents, but can also be used as api method."		<richtextlinkpresenter: #md>	self open.	Browser addRoot: (aMicResourceReferenceOrString isString		ifTrue: [ aMicResourceReferenceOrString asMicResourceReference  ]		ifFalse: [aMicResourceReferenceOrString ])! !!MicDocumentBrowser class methodsFor: 'class initialization' prior: 50747376!reset	<script>	Browser ifNil: [ ^ self ].	Browser owner ifNil: [ Browser := nil. ^ self ].	Browser owner close.	Browser := nil.! !!MicDocumentBrowser class methodsFor: 'services menu' prior: 50746971!serviceOpenMicrodownDirectory	"Answer the service of opening a file-contents browser"	^ (SimpleServiceEntry		provider: self 		label: 'Open Micodown document'		selector: #openDocument:		description: 'Open a this document in Microdown Document Browser'		buttonLabel: 'Microdown')		argumentGetter: [ :file| file fullName]! !!MicDocumentBrowser class methodsFor: 'services menu' prior: 50747874!serviceOpenMicrodownDocument	"Answer the service of opening a file-contents browser"	^ (SimpleServiceEntry		provider: self 		label: 'Open Micodown document'		selector: #openDocument:		description: 'Open a this document in Microdown Document Browser'		buttonLabel: 'Microdown')		argumentGetter: [ :file| file fullName]! !!MicDocumentBrowser methodsFor: 'navigation' prior: 50742518!addRoot: document	"Add document to the documents list and select it. If already in the list, just select it"	| toSelect |	"Notice, once equals is defined for resource references this code should make use of it"	toSelect := self documentRoots 		detect: [ :root | root uri = document uri ] 		ifNone: [self documentRoots add: document. document].	self disableEventsDuring: [		spDocumentList roots: self documentRoots.		spDocumentList selection selectItem: toSelect].	self documentSelected: document				! !!MicDocumentBrowser methodsFor: 'navigation' prior: 50745342!childrenOf: aNode	"I am a utility method to find children in a node"	(aNode isKindOf: MicElement)		ifTrue: [ ^ aNode subsections children].	aNode loadChildren		ifNotEmpty: [ :children |  ^ children sort: [:a :b | (self displayStringOf: a) < (self displayStringOf: b)] ]		ifEmpty: [ 			[ ^ self childrenOf: (MicSectionBlock fromRoot: aNode loadMicrodown) ] 			on: Error  			do: [ ^ #() ]]	! !!MicDocumentBrowser methodsFor: 'initialization' prior: 50743095!connectPresenters	"Listen to gui input"	spDocumentList 		whenSelectionChangedDo: [ :selection | self guiNewSelection: selection selectedItem ].	spSource 		whenSubmitDo: [:text|  self guiSaveSource ];		whenResetDo: [ :text | self guiCancelSourceChange ];		whenTextChangedDo: [ :newSource | self guiSetSource: newSource ]! !!MicDocumentBrowser methodsFor: 'private' prior: 50740020!defaultDocumentRoots	"By default include the pharo doc and the docs of loaded projects"	^ ({'github://pharo-project/pharo/doc'}, 		self loadedDocsInWorkspace  )			collect: #asMicResourceReference! !!MicDocumentBrowser methodsFor: 'events' prior: 50744596!disableEventsDuring: aBlock	| old | 	"The clue of old is to allow multible nested diableEventsDuring calls	and only the outermost will reset back to the default false value"	old := disableEvents.	disableEvents := true.	aBlock value.	disableEvents := old. ! !!MicDocumentBrowser methodsFor: 'navigation' prior: 50739792!displayIconOf: aNode	"Utility method to put icons on the document list"	(aNode isKindOf: MicElement) ifTrue: [ ^ self iconNamed: #smallLeftFlush ].	^ aNode browserIcon! !!MicDocumentBrowser methodsFor: 'navigation' prior: 50738897!displayStringOf: aNode	"Utility method to generate the titles used in document list"	(aNode isKindOf: MicSectionBlock) ifTrue: [ ^ (Microdown asRichText: aNode header) asString trim ].	^aNode browserTitle! !!MicDocumentBrowser methodsFor: 'private' prior: 50743467!documentRoots	^ documentRoots 		ifNil: [ documentRoots := self defaultDocumentRoots asOrderedCollection  ].! !!MicDocumentBrowser methodsFor: 'navigation' prior: 50739165!documentSelected: document	"document is newly selected, and should be rendered. If source is showing, set it as well"	documentModel save.	documentModel resourceReference: document.	documentModel resourceReference ifNil: [ ^ self ].	spRendering document: documentModel document.	spRendering selectionInterval: (1 to: 0).	self updateSourcePresenter.	self owner title:		(self displayStringOf: documentModel resourceReference)! !!MicDocumentBrowser methodsFor: 'events'!guiCancelSourceChange	"called by whenResetDo: on spSource "	disableEvents ifTrue: [ ^ self ].	documentModel isDirty ifFalse: [ ^ self ].	self disableEventsDuring: [ 		documentModel source: nil.		self showSourceNotDirty.		spSource 			text: documentModel source]! !!MicDocumentBrowser methodsFor: 'events'!guiNewSelection: selection	"I am called when a user selects a new element in spDocumentList"	disableEvents ifTrue: [ ^ self ].	self documentSelected: selection! !!MicDocumentBrowser methodsFor: 'events'!guiSaveSource	"called by save button or accept in spSource"	| path sourceSelection sourceScroll |	disableEvents ifTrue: [ ^ self ].	documentModel isDirty ifFalse: [ ^ self ].	self disableEventsDuring: [ 		documentModel			source: spSource text;			save.		self showSourceNotDirty.		spRendering document: documentModel document.		"Sync the views"		path := spDocumentList selection selectedPath.		sourceSelection := spSource selectionInterval.		sourceScroll := spSource adapter widget scrollPane vScrollbarValue.		spDocumentList roots: self documentRoots.		spDocumentList			expandPath: path;			selectPath: path.		spSource selectionInterval: sourceSelection.		spSource adapter setScrollValue: 0 @ sourceScroll.		spRendering adapter setScrollValue: 0 @ sourceScroll.		spSource takeKeyboardFocus ]! !!MicDocumentBrowser methodsFor: 'events'!guiSetListShowing: aBoolean	"Change layout to include the document list or not"	layoutModel showDocumentList: aBoolean.	self disableEventsDuring: [ self setTopLayout ] ! !!MicDocumentBrowser methodsFor: 'events'!guiSetSource: newSource	"called by changes to spSource"	disableEvents ifTrue: [ ^ self ].	documentModel source: newSource.	self showSourceDirty	! !!MicDocumentBrowser methodsFor: 'events'!guiSetSourceMode: sourceMode	"Change the layout as how spRendering and spSource are placed"	layoutModel sourceMode: sourceMode.	self disableEventsDuring: [ self setTopLayout  ]! !!MicDocumentBrowser methodsFor: 'events'!guiSetSourceShowing: showSource	"change layout to include spSource or not"	layoutModel showSource: showSource.	self disableEventsDuring: [		self setTopLayout.		self updateSourcePresenter]! !!MicDocumentBrowser methodsFor: 'initialization' prior: 50740625!initialize	"Initialize my models first"	documentModel := MicDocumentBrowserModel new.	layoutModel := MicDocumentBrowserLayoutModel new.	disableEvents := false.	self intializeApplication.	super initialize! !!MicDocumentBrowser methodsFor: 'initialization' prior: 50740871!initializeButtons	"initialize the button bar"	spButtonBar := self instantiate: MicDocumentBrowserButtonBar.	spButtonBar		left: (spButtonBar newCheckBox				 label: 'Show List';				 state: layoutModel showDocumentList;				 whenChangedDo: [ :val | self guiSetListShowing: val ]);		right: (spButtonBar newDropList				 help: 'source view';				 items: layoutModel sourceModes;				 whenSelectedItemChangedDo: [ :item | 					 self guiSetSourceMode: item ]);		right: (saveButton := spButtonBar newButton				 label: 'Save';				 state: layoutModel showSource;				  action: [ self guiSaveSource ]);		right: (spButtonBar newCheckBox				 label: 'Show Source';				 state: layoutModel showSource;				 whenChangedDo: [ :val | self guiSetSourceShowing: val ])! !!MicDocumentBrowser methodsFor: 'initialization' prior: 50743641!initializePresenters	super initializePresenters.		Browser := self.	spDocumentList := self newTree.	spDocumentList		roots: self documentRoots;		children: [ :aNode | self childrenOf: aNode ];		display: [ :aNode | self displayStringOf: aNode ];		displayIcon: [ :aNode | self displayIconOf: aNode ].	spRendering := self instantiate: MicrodownPresenter.	spSource := self newText.	self initializeButtons! !!MicDocumentBrowser methodsFor: 'initialization'!initializeStylesheet	browserApp backend name = #Morphic		ifTrue: [ browserApp  addStyleSheetFromString: '.application [    .dirty [ Container { #borderColor: #red, #borderWidth: 1 } ],    .notDirty [ Container { #borderColor: #transparent, #borderWidth: 1 } ]]'].	browserApp backend name = #Gtk		ifTrue: [ browserApp addCSSProviderFromString: '.dirty {     border-color: red;     border-width: 1px; }' ]! !!MicDocumentBrowser methodsFor: 'initialization' prior: 50738313!initializeWindow: aWindowPresenter	"Adds window closing behaviour"	super initializeWindow: aWindowPresenter.	aWindowPresenter 		initialExtent: 1000@600;		title: 'Microdown document browser'.	aWindowPresenter whenClosedDo: [ 		self guiSaveSource.		Browser := nil ].! !!MicDocumentBrowser methodsFor: 'dirty indication'!intializeApplication	browserApp := SpApplication new.	self initializeStylesheet.	self application: browserApp.	! !!MicDocumentBrowser methodsFor: 'layout'!layout	"I use dynamic layout"	layout ifNil: [ self setTopLayout  ].	^ layout ! !!MicDocumentBrowser methodsFor: 'private' prior: 50741969!loadedDocsInWorkspace	"I return all the doc folders which exist in the local iceberg repository"	| iceRepository githubUsers |	iceRepository := FileSystem workingDirectory / 'pharo-local' / 'iceberg'.	githubUsers := iceRepository directories.	^ ((githubUsers collect: [ :userDir | userDir directories ]) flattened		collect: [ :project | project directories ]) flattened		select: [ :dir | #('doc' 'docs') includes: dir basename ]! !!MicDocumentBrowser methodsFor: 'layout' prior: 50744917!setTopLayout	"I set the layout of the browser. The dynamic part of the layout is done by layoutModel"	self layout: (SpBoxLayout newTopToBottom		add: (layoutModel			layoutList: spDocumentList			rendering: spRendering			source: spSource);		add: spButtonBar expand: false;		yourself)! !!MicDocumentBrowser methodsFor: 'dirty indication' prior: 50739663!showSourceDirty	spSource removeStyle: 'notDirty'; addStyle: 'dirty'! !!MicDocumentBrowser methodsFor: 'dirty indication' prior: 50740286!showSourceNotDirty	spSource removeStyle: 'dirty'; addStyle: 'notDirty'! !!MicDocumentBrowser methodsFor: 'updating' prior: 50744180!updateSourcePresenter	""	layoutModel showSource ifTrue: [ 		self disableEventsDuring: [ 			spSource				editable: documentModel canSave;				text: documentModel source.			spSource adapter color: (documentModel canSave					 ifTrue: [ self theme backgroundColor ]					 ifFalse: [ self theme lightBaseColor ]).			self showSourceNotDirty ] ]! !!MicDocumentBrowserButtonBar methodsFor: 'initialization' prior: 50748986!initializePresenters	super initializePresenters.	left := self newButtonBar placeAtStart.	right := self newButtonBar.	self layout: (SpBoxLayout newHorizontal			 add: left;			 add: self newNullPresenter;			 add: right)! !!MicDocumentBrowserButtonBar methodsFor: 'api - adding' prior: 50748776!left: button	left add: button! !!MicDocumentBrowserButtonBar methodsFor: 'api - adding' prior: 50748879!right: button	right add: button! !!ManifestMicrodownDocumentBrowser class methodsFor: 'code-critics'!ruleBadMessageRule2V1FalsePositive	^ #(#(#(#RGPackageDefinition #(#'Microdown-DocumentBrowser')) #'2022-07-13T10:42:18.082534+02:00') )! !!MicGitHubAPIRateError methodsFor: 'accessing' prior: 50829620!response	^ response! !!MicGitHubAPIRateError methodsFor: 'accessing' prior: 50829516!response: anObject	response := anObject! !!MicAbsoluteResourceReference methodsFor: '*Microdown-DocumentBrowser' prior: 50672621!browserIcon	^ self iconNamed: #book! !!MicAbsoluteResourceReference methodsFor: '*Microdown-DocumentBrowser' prior: 50673128!browserTitle	| title slashes |	title := self uriString.	slashes := title allRangesOfSubstring: '/'.	slashes size <= 3 ifTrue: [ ^ title ].	^ '...', (title 		copyFrom: (slashes at: (slashes size - 2)) first		to: title size)! !!MicGitHubRessourceReference class methodsFor: 'instance creation' prior: 50837292!handlesUriScheme: scheme	^ scheme = 'github'! !!MicGitHubRessourceReference methodsFor: 'accessing' prior: 50834174!binaryReadStream	"return the binaryStream I refer to"	^ self error: 'Binary streams to github items not yet supporteds'.! !!MicGitHubRessourceReference methodsFor: 'accessing' prior: 50834447!branch	^ branch! !!MicGitHubRessourceReference methodsFor: 'document browser' prior: 50836508!browserIcon	^ self iconNamed: #github! !!MicGitHubRessourceReference methodsFor: 'document browser' prior: 50837113!browserTitle	^ uri query		ifNotNil:[:query | query at: #fullPath]		ifNil: [ uri printString ]! !!MicGitHubRessourceReference methodsFor: 'accessing' prior: 50836707!contents	"This is inefficient, but can be done"	| response content |	response := self githubPathLookup.	content := response 		at: #content 		ifAbsent: [^ 'I am a directory and has no contents'].	^ content base64Decoded asString! !!MicGitHubRessourceReference methodsFor: 'accessing' prior: 50836615!docFolder	^ docFolder! !!MicGitHubRessourceReference methodsFor: 'private' prior: 50833200!extractFolderReferencesFrom: response	| folders raw docPath |	folders := (response at: #tree) select: [ :elem | (elem at: #type) = #tree].	"github://user/project:sha"	raw := 'github://{1}/{2}' format: { user. project }.	docPath := self branch,'/', (self docFolder joinUsing: '/').	^ folders collect: [ :folder |  		MicResourceReference fromUri: (raw ,':', (folder at: #sha),'?fullPath=', docPath, '/', (folder at: #path))]! !!MicGitHubRessourceReference methodsFor: 'private' prior: 50836083!extractMicrodownDocReferencesFrom: response	| docs path |	docs := (response at: #tree) select: [ :elem | 		(elem at: #type) = #blob and:[ #(md mic) includes: ((elem at: #path) copyAfterLast: $.) ]].	docs ifEmpty: [ ^#() ].	path := self pathStringForRawAccess.	^ docs collect: [ :doc |  MicResourceReference fromUri: path, '/', (doc at: #path)]! !!MicGitHubRessourceReference methodsFor: 'private' prior: 50837008!githubApi	^ MicGitHubAPI new! !!MicGitHubRessourceReference methodsFor: 'private' prior: 50834531!githubPathLookup	"I return the response object from the trees api - see https://docs.github.com/en/rest/reference/git#get-a-tree"	| request response |	request := self githubTreesApiRequest.	self docFolder do: [ :segment |		response := self githubApi get: request.		request := ((response at: #tree) 			detect: [ :elem | (elem at: #path) = segment ]) at: #url.		request := request withoutPrefix: 'https://api.github.com/'.		 ].	response := STONJSON fromString: (ZnEasy get: ('https://api.github.com/',request) )entity contents.	^ response! !!MicGitHubRessourceReference methodsFor: 'private' prior: 50835145!githubTreesApiRequest	"See documentation at: https://docs.github.com/en/rest/reference/git#get-a-tree"	 ^ 'repos/{1}/{2}/git/trees/{3}' 			format: { user. project. branch }! !!MicGitHubRessourceReference methodsFor: 'accessing' prior: 50832759!loadChildren	children 		ifNil:[ | response folders microdownDocs|			response := self githubPathLookup.			folders := self extractFolderReferencesFrom: response.			microdownDocs := self extractMicrodownDocReferencesFrom: response.			children := folders , microdownDocs].	^ children! !!MicGitHubRessourceReference methodsFor: 'private' prior: 50835938!lookupDefaultBranch		^ self githubApi defaultBranch: user project: project	! !!MicGitHubRessourceReference methodsFor: 'private' prior: 50833696!pathStringForRawAccess	"I return the path string to be used for the raw.githubusercontent.com access to blobs"	| path |	path := 'https://raw.githubusercontent.com/{1}/{2}' 		format: { user. project}.	self docFolder 		ifNotEmpty: [ ^ path, '/' , self branch, '/', (self docFolder joinUsing: '/') ].	uri query 		ifNil: [ ^ path, '/', self branch ].	^ path ,'/', (uri query at: #fullPath ifAbsent: [''])! !!MicGitHubRessourceReference methodsFor: 'accessing' prior: 50833114!project	^ project! !!MicGitHubRessourceReference methodsFor: 'accessing' prior: 50835389!uri: docUri	"I assume docUri to be a ZnURI on the form: github://user/project[:branch][/pathToDoc]"	| projectAndBranch |	super uri: docUri.	user := docUri host.	projectAndBranch := docUri segments first splitOn: ':'.	project := projectAndBranch first.	branch := projectAndBranch size > 1 		ifTrue: [ projectAndBranch second ]		ifFalse: [ self lookupDefaultBranch ].	docFolder := docUri segments size > 1 		ifTrue: [ docUri segments allButFirst asArray]		ifFalse: [ #() ]! !!MicGitHubRessourceReference methodsFor: 'accessing' prior: 50834365!user	^ user! !!MicPharoClassCommentResourceReference methodsFor: 'private' prior: 51013249!browserIcon	^ self iconNamed: #class! !!MicPharoClassCommentResourceReference methodsFor: 'accessing' prior: 51012565!canSave	"return true if I implement contents: "	^true! !!MicPharoClassCommentResourceReference methodsFor: 'accessing' prior: 51013478!classReference	^ classReference! !!MicPharoClassCommentResourceReference methodsFor: 'accessing' prior: 51013365!contents	^ classReference comment! !!MicPharoClassCommentResourceReference methodsFor: 'accessing' prior: 51012699!contents: newCommentString	^ classReference comment: newCommentString! !!MicPharoClassCommentResourceReference methodsFor: 'loading' prior: 51013588!loadMicrodown	"I override to provide the comment produced by beautifulComments"	| builder |	builder := Microdown builder.	self classReference 		buildMicroDownUsing: builder 		withComment: self contents.	^ Microdown parse: builder contents! !!MicPharoClassCommentResourceReference methodsFor: 'accessing' prior: 51012848!uri: aUri	"the uri is on the form commet://class/ClassName[/class]"	| className |	super uri: aUri.	className := aUri segments first.	classReference := self class environment at: className asSymbol.	(aUri segments size = 2 and: [ aUri segments second = 'class' ]) 		ifTrue: [ classReference := classReference class ]! !!MicPharoCommentResourceReference class methodsFor: 'instance creation' prior: 51015794!handlesUriScheme: scheme	^ scheme = 'comment'! !!MicPharoCommentResourceReference class methodsFor: 'instance creation' prior: 51015928!newFromUri: aUri	"I assume aUri to be a ZnUrl"	aUri host = 'class'		ifTrue: [ ^ MicPharoClassCommentResourceReference new uri: aUri ].	aUri host = 'package'		ifTrue: [ ^ MicPharoPackageCommentResourceReference  new uri: aUri ].	(MicResourceReferenceError new 		messageText: 'the host in comments must be either class or package - in ', aUri printString	) signal! !!MicPharoCommentResourceReference methodsFor: 'accessing' prior: 51015569!binaryReadStream	"comments are not in binary format"	MicResourceReferenceError signal: 'Pharo comments cannot be read in binary format'! !!MicPharoPackageCommentResourceReference methodsFor: 'private' prior: 51026117!browserIcon	self kind = #prefix ifTrue: [ ^ self iconNamed: #group ].	self kind = #package ifTrue: [ ^ self iconNamed: #package ].	self kind = #tag ifTrue: [ ^ self iconNamed: #blank ].	^ self iconNamed: #error! !!MicPharoPackageCommentResourceReference methodsFor: 'document browser' prior: 51028364!browserTitle	kind = 'prefix'		ifTrue: [ ^categoryName ,'*' ].	^ categoryName ! !!MicPharoPackageCommentResourceReference methodsFor: 'testing' prior: 51023489!canSave	"return true if I implement contents: "	^self isPackage! !!MicPharoPackageCommentResourceReference methodsFor: 'accessing' prior: 51024146!categoryName	^ categoryName! !!MicPharoPackageCommentResourceReference methodsFor: 'private' prior: 51026795!childrenOfAllCategories	"I return the children of 'comment://package/' "	^ (SystemOrganizer default categories 		reject: [ :cat | cat beginsWith: 'BaselineOf' ]		thenCollect: [:cat | self reduceCategoryName: cat]) 		asSet asArray sort			collect: [ :cat | ('comment://package/', cat) asMicResourceReference  ]! !!MicPharoPackageCommentResourceReference methodsFor: 'accessing' prior: 51024256!childrenOfCategoryPrefix	"I am a prefix of a set of categories, 	my children are those categories with one more depth in their name"	| children |	categoryName ifEmpty: [ ^ self childrenOfAllCategories ].	children := SystemOrganizer default categories				select: [ :cat |  (cat beginsWith: categoryName) and: [ self isPackage: cat ] ]				thenCollect: [:cat | ('comment://package/', cat) asMicResourceReference ].	^ children	! !!MicPharoPackageCommentResourceReference methodsFor: 'accessing' prior: 51025800!childrenOfPackageWithTag	"my categoryName is a package tag, children are the classes under that tag"	^ (SystemOrganizer default classesInCategory:  categoryName)			collect: [:cl | ('comment://class/',cl name) asMicResourceReference]	 ! !!MicPharoPackageCommentResourceReference methodsFor: 'initialization' prior: 51027195!childrenOfRPackage	"I assume I am a RPackage, return my tags"	|tags| 	tags := (categoryName asPackage classTags) 			reject: [:tag | #(Manifest Extensions) includes: tag name].	tags := tags asArray sort: [ :a :b | a name < b name ].	^ tags collect: [ :tag |		('comment://package/', ( categoryName, '-', tag name )) asMicResourceReference  ]! !!MicPharoPackageCommentResourceReference methodsFor: 'accessing' prior: 51027622!contents 	[ ^ categoryName asPackage packageComment ]	on: NotFound 	do: [ ^ '' ]! !!MicPharoPackageCommentResourceReference methodsFor: 'accessing' prior: 51024770!contents: aNewComment 	[ ^ categoryName asPackage packageComment: aNewComment]	on: NotFound 	do: [ MicResourceReferenceError signal: 'No package named ', categoryName]! !!MicPharoPackageCommentResourceReference methodsFor: 'testing' prior: 51027784!isPackage	categoryName asPackageIfAbsent: [ ^ false ].	^true! !!MicPharoPackageCommentResourceReference methodsFor: 'private - utilities' prior: 51023005!isPackage: cat	cat asPackageIfAbsent: [ ^ false ].	^true! !!MicPharoPackageCommentResourceReference methodsFor: 'testing' prior: 51026410!isTag	"return true if I am tag inside a package"	| parent |	parent := self parentPackage.	"if no parent package exist, I am not a tag"	parent ifNil: [ ^ false ].	"If I am my own parent, I am not a tag"	parent name = categoryName ifTrue: [ ^ false ].	"I have a parent package, so I am a tag"	^ true! !!MicPharoPackageCommentResourceReference methodsFor: 'accessing' prior: 51025524!kind	^ kind! !!MicPharoPackageCommentResourceReference methodsFor: 'private - utilities' prior: 51023645!level	"return the number of '-' in categoryName"	categoryName ifEmpty: [ ^-1 ].	^ categoryName occurrencesOf: $-! !!MicPharoPackageCommentResourceReference methodsFor: 'accessing' prior: 51023144!loadChildren	kind = #prefix ifTrue: [ ^ self childrenOfCategoryPrefix  ].	kind = #package ifTrue: [ ^ self childrenOfRPackage  ].	kind = #tag ifTrue: [ ^ self childrenOfPackageWithTag  ].	MicResourceReferenceError signal: 'Unknow kind in ', self uri printString.! !!MicPharoPackageCommentResourceReference methodsFor: 'loading' prior: 51027925!loadMicrodown	"I override to provide the comment produced by beautifulComments"	| builder |	self isPackage ifFalse: [ ^ Microdown parse: 'No documentation for tags or package prefixes' ].	builder := Microdown builder.	self categoryName asPackage  		buildMicroDownUsing: builder 		withComment: self contents.	^ Microdown parse: builder contents! !!MicPharoPackageCommentResourceReference methodsFor: 'testing' prior: 51022636!parentPackage	"return my parent package, or nil if none exist"	| parts package |	parts := categoryName splitOn: '-'.	parts size to: 1 by: -1 do: [ :i | 		package := ((parts truncateTo: i) joinUsing: '-') asPackageIfAbsent: [ nil ].		package ifNotNil: [ ^ package ]		 ].	^ nil! !!MicPharoPackageCommentResourceReference methodsFor: 'private - utilities' prior: 51025628!reduceCategoryName: aCategory	^ self reduceCategoryName: aCategory toLevel: self level + 1! !!MicPharoPackageCommentResourceReference methodsFor: 'private - utilities' prior: 51023851!reduceCategoryName: aString toLevel: level 	"a package name aaa-bbb-ccc-ddd reduced to level 0 is aaa, reduced to 2 is aaa-bbb-ccc"	| parts |	parts := aString splitOn: $-.	^ (parts truncateTo: level+1) joinUsing: $-! !!MicPharoPackageCommentResourceReference methodsFor: 'accessing' prior: 51025021!uri: aUri	"the uri is on the form commet://package/packageName - 	packageName can be a prefix of a full package name"	super uri: aUri.	categoryName := aUri segments		ifNil: ['*']		ifNotNil: [ :segments | segments first ].	kind := (categoryName endsWith: '*') 		ifTrue: [ categoryName := categoryName withoutSuffix: '*'. 'prefix' ]		ifFalse: [ 			self isPackage 				ifTrue:['package']				ifFalse: [ 'tag' ]			]! !!MicFileResourceReference methodsFor: '*Microdown-DocumentBrowser' prior: 50807222!browserIcon 	^ self isDirectory 		ifTrue: [ self iconNamed: #packageColored]		ifFalse: [ self iconNamed: #smallLeftFlush ]! !!MicHeaderBlock methodsFor: '*Microdown-DocumentBrowser' prior: 50850162!isHeader	^ true! !!MicGitHubAPI class methodsFor: 'rates' prior: 50828692!apiCallsRemaining	| fullCount |	fullCount := 60.	APICount ifNil: [ ^ fullCount ].	(NextReset < DateAndTime now) ifTrue: [ ^ fullCount ].	^ APICount ! !!MicGitHubAPI class methodsFor: 'cache' prior: 50828901!cache	ResponseCache   ifNil: [ ResponseCache := LRUCache new maximumWeight: 117; yourself ].	^ ResponseCache! !!MicGitHubAPI class methodsFor: 'cache' prior: 50829196!cache: aCache	"Only intended usage is for testing"	ResponseCache := aCache! !!MicGitHubAPI class methodsFor: 'class initialization' prior: 50829082!reset	<script>	ResponseCache := nil.	APICount := nil.	! !!MicGitHubAPI methodsFor: 'requesting' prior: 50827811!defaultBranch: user project: project	"Looks up the name of the default branch. returns nil if user/project does not exist"	| response |	[response := self get: ('repos/{1}/{2}' format: {user. project}).	^ response at: 'default_branch' ifAbsent: [ 'main' ]]	on: IceGitHubError 	do: [ ^ 'main' ]! !!MicGitHubAPI methodsFor: 'private' prior: 50828161!extractRateInfo: response	| unixTime |	APICount := (response headers at: 'X-Ratelimit-Remaining') asNumber.	unixTime := (response headers at: 'X-Ratelimit-Reset') asNumber.	NextReset := DateAndTime fromUnixTime: unixTime.	^ response! !!MicGitHubAPI methodsFor: 'private - requesting' prior: 50828463!get: apiCallString	"I return a json structure as the result from the github api call"	^ self class cache 		at: apiCallString 		ifAbsentPut: [ super get: apiCallString]	! !!MicGitHubAPI methodsFor: 'responses' prior: 50827577!handleUnauthorized: response	"I override this method as it was the least wrong place to access the response"	self extractRateInfo: response.	super handleUnauthorized: response.! !"Microdown-DocumentBrowser"!!ManifestMicrodownDocumentBrowserTests commentStamp: '' prior: 0!No description for this package available. Please add a description for this package here!!MicDocumentBrowserLayoutModelTest methodsFor: 'running' prior: 50754009!setUp	super setUp.		model := MicDocumentBrowserLayoutModel new.	testDocumentList := SpTextPresenter new text: 'list'.	testRender := SpTextPresenter new text: 'render'.	testSource := SpTextPresenter new text: 'source'! !!MicDocumentBrowserLayoutModelTest methodsFor: 'tests' prior: 50756510!testInitilize	self		assert: model showDocumentList;		deny: model showSource;		assert: model sourceMode equals: model sourceBotton ! !!MicDocumentBrowserLayoutModelTest methodsFor: 'tests' prior: 50753731!testNoListAndNoSource	| layout |	model showDocumentList: false.	layout := model 		layoutList: testDocumentList  		rendering: testRender 		source: testSource.	self assert: layout equals: testRender .! !!MicDocumentBrowserLayoutModelTest methodsFor: 'tests' prior: 50753314!testNoListAndSource	| layout |	model showDocumentList: false.	model showSource: true.	layout := model 		layoutList: testDocumentList  		rendering: testRender 		source: testSource.	self 		assert: layout class equals: SpPanedLayout ;		assert: layout children first equals: testRender;		assert: layout children second equals: testSource	! !!MicDocumentBrowserLayoutModelTest methodsFor: 'tests' prior: 50754302!testSourceBottom	| layout |	model showDocumentList: false.	model showSource: true.	model sourceMode: model sourceBotton.	layout := model 		layoutList: testDocumentList  		rendering: testRender 		source: testSource.	self 		assert: layout direction class equals: SpVerticalLayoutDirection;		assert: layout children first equals: testRender;		assert: layout children second equals: testSource	! !!MicDocumentBrowserLayoutModelTest methodsFor: 'tests' prior: 50754776!testSourceLeft	| layout |	model showDocumentList: false.	model showSource: true.	model sourceMode: model sourceLeft.	layout := model 		layoutList: testDocumentList  		rendering: testRender 		source: testSource.	self 		assert: layout direction class equals: SpHorizontalLayoutDirection ;		assert: layout children first equals: testSource;		assert: layout children second equals: testRender	! !!MicDocumentBrowserLayoutModelTest methodsFor: 'tests' prior: 50755249!testSourceRight	| layout |	model showDocumentList: false.	model showSource: true.	model sourceMode: model sourceRight.	layout := model 		layoutList: testDocumentList  		rendering: testRender 		source: testSource.	self 		assert: layout direction class equals: SpHorizontalLayoutDirection ;		assert: layout children first equals: testRender;		assert: layout children second equals: testSource	! !!MicDocumentBrowserLayoutModelTest methodsFor: 'tests' prior: 50755724!testSourceTop	| layout |	model showDocumentList: false.	model showSource: true.	model sourceMode: model sourceTop.	layout := model 		layoutList: testDocumentList  		rendering: testRender 		source: testSource.	self 		assert: layout direction class equals: SpVerticalLayoutDirection;		assert: layout children first equals: testSource;		assert: layout children second equals: testRender	! !!MicDocumentBrowserLayoutModelTest methodsFor: 'tests' prior: 50756192!testStandardLayout	| layout |	layout := model 		layoutList: testDocumentList  		rendering: testRender 		source: testSource.	self assert: layout children first equals: testDocumentList.	self assert: layout children second equals: testRender ! !!MicDocumentBrowserLayoutModelTest methodsFor: 'tests' prior: 50752806!testStandardLayoutWithSource	| layout |	model showSource: true.	layout := model 		layoutList: testDocumentList  		rendering: testRender 		source: testSource.	self assert: layout children first equals: testDocumentList.	self assert: layout children second class equals: SpPanedLayout.	self assert: layout children second children first equals: testRender.	self assert: layout children second children second equals: testSource  ! !!MicDocumentBrowserModelTest class methodsFor: 'as yet unclassified' prior: 50761419!backupComment ^ 'A MicDocumentBrowserModelTest is a test class for testing the behavior of MicDocumentBrowserModel.This comment has `comment://class/MicDocumentBrowserModelTest` as micResourceReference'! !!MicDocumentBrowserModelTest class methodsFor: 'as yet unclassified'!myCommentRefernce	^ 'comment://class/MicDocumentBrowserModelTest' asMicResourceReference! !!MicDocumentBrowserModelTest methodsFor: 'running' prior: 50759264!setUp	super setUp.		model := MicDocumentBrowserModel new.! !!MicDocumentBrowserModelTest methodsFor: 'tests' prior: 50759389!testCanSave	model resourceReference: 'https://nowhere.atall' asMicResourceReference.	self deny: model canSave.! !!MicDocumentBrowserModelTest methodsFor: 'tests' prior: 50761130!testDocument	model resourceReference: self class myCommentRefernce.	self 		assert: model document children first class equals: MicHeaderBlock.	model resourceReference: nil.	self 		assert: model document isNil! !!MicDocumentBrowserModelTest methodsFor: 'tests' prior: 50760879!testInitilize	self 		assert: model resourceReference equals: nil;		assert: model document equals: nil;		assert: model source equals: nil;		deny: model canSave;		deny: model isDirty! !!MicDocumentBrowserModelTest methodsFor: 'tests' prior: 50759566!testIsDirty	model resourceReference: self class myCommentRefernce.	self deny: model isDirty.	model source: 'Dummy source'.	self assert: model isDirty! !!MicDocumentBrowserModelTest methodsFor: 'tests' prior: 50760095!testResourceReference	model resourceReference: self class myCommentRefernce.	self 		assert: model resourceReference uri equals: self class myCommentRefernce uri;		assert: model document children first class equals: MicHeaderBlock ;		assert: (model source first: 57) equals: 'A MicDocumentBrowserModelTest is a test class for testing';		assert: model canSave;		deny: model isDirty! !!MicDocumentBrowserModelTest methodsFor: 'tests' prior: 50760548!testSave	[		model resourceReference: self class myCommentRefernce.		model 			source: 'Dummy source';			save.		self 			deny: model isDirty;			assert: (self class comment) equals: 'Dummy source'	]	ensure: [ self class comment: self class backupComment ]			! !!MicDocumentBrowserModelTest methodsFor: 'tests' prior: 50758944!testSave_not	"Pick a resource which is read-only"	model resourceReference: 'pharo:///MicDocumentBrowserModelTest/backupComment' asMicResourceReference.	model source: 'Should not be written'.	self deny: model source equals: 'Should not be written'		! !!MicDocumentBrowserModelTest methodsFor: 'tests' prior: 50759785!testSource	model resourceReference: self class myCommentRefernce.	self 		assert: (model source first: 57) equals: 'A MicDocumentBrowserModelTest is a test class for testing'.	model resourceReference: nil.	self 		assert: model source isNil! !!MicGitHubAPITest methodsFor: 'api - accessing' prior: 50830375!ensureApi: anInteger for: aFullBlockClosure 	api class apiCallsRemaining >= anInteger 		ifTrue: [ aFullBlockClosure value ]		ifFalse: [ self skip: 'Rate limit exhaused' ]! !!MicGitHubAPITest methodsFor: 'running' prior: 50830032!setUp	super setUp.		api := MicGitHubAPI new.	MicGitHubAPI apiCallsRemaining = 60		ifTrue: [ 			[ api defaultBranch: 'pillar-markup' project: 'Microdown' ]			on: MicGitHubAPIRateError 			do: [ 'Just reading the default branch will set the number of API calls remaining' ]]! !!MicGitHubAPITest methodsFor: 'tests' prior: 50831416!testGet	| url res |	self ensureApi: 1 for: [		url := 'repos/pillar-markup/Microdown'.		res := api get: url.		self assert: (res at: 'full_name') equals: 'pillar-markup/Microdown'.		self assert: (res at: 'default_branch') equals: 'dev']! !!MicGitHubAPITest methodsFor: 'tests' prior: 50830602!testIsCaching	| url res rate|	self ensureApi: 1 for: [		url := 'repos/pillar-markup/Microdown'.		res := api get: url.		self assert: (api class cache includesKey: url).		rate := MicGitHubAPI apiCallsRemaining.		api get: url.		self assert: MicGitHubAPI apiCallsRemaining equals: rate		].! !!MicGitHubAPITest methodsFor: 'tests' prior: 50829808!testdefaultBranchProject	| branch |	self ensureApi: 1 for: [		branch := api defaultBranch: 'pillar-markup' project: 'Microdown'.		self assert: branch equals: 'dev']! !!MicGitHubAPITest methodsFor: 'tests' prior: 50830950!testdefaultBranchProject_Pharo	| branch |	self ensureApi: 1 for: [		branch := api defaultBranch: 'pharo-project' project: 'pharo'.		self assert: (branch beginsWith: 'Pharo')]! !!MicGitHubAPITest methodsFor: 'tests' prior: 50831182!testdefaultBranchProject_defaultBranch		| branch |	self ensureApi: 1 for: [		branch := api defaultBranch: 'JohnDoe' project: 'Calculator'.		self assert: branch equals: 'main']! !!MicGitHubRessourceReferenceTest methodsFor: 'api - accessing' prior: 50839025!ensureApi: anInteger for: aFullBlockClosure 	MicGitHubAPI apiCallsRemaining >= anInteger 		ifTrue: [ aFullBlockClosure value ]		ifFalse: [ self skip: 'Rate limit exhaused' ]! !!MicGitHubRessourceReferenceTest methodsFor: 'test data' prior: 50841354!sampleTreeResponse	^ { 		  ('sha' -> '3d2ff94661d6a0399e3f4ea0ea5dc36a45971bf2').		  ('tree' -> { 			   { 				   ('mode' -> '040000').				   ('path' -> 'images').				   ('sha' -> 'b1dc21dabca4c774fec51c52b8b5f576cf53ff08').				   ('type' -> 'tree'). 				   ('url'				    ->				    'https://api.github.com/repos/pillar-markup/Microdown/git/trees/b1dc21dabca4c774fec51c52b8b5f576cf53ff08') }				   asDictionary.			   { 				   ('mode' -> '100644').				   ('path' -> 'other.md').				   ('sha' -> '1b37a7800cfdfd2692662bfd6e743b5a33faef46').				   ('size' -> 97).				   ('type' -> 'blob').				   ('url'				    ->				    'https://api.github.com/repos/pillar-markup/Microdown/git/blobs/1b37a7800cfdfd2692662bfd6e743b5a33faef46') }				   asDictionary.			   { 				   ('mode' -> '100644').				   ('path' -> 'readme.md').				   ('sha' -> '0d0a4c4fbe085e75d0cc3b69b5f520b9c4b4c288').				   ('size' -> 439).				   ('type' -> 'blob').				   ('url'				    ->				    'https://api.github.com/repos/pillar-markup/Microdown/git/blobs/0d0a4c4fbe085e75d0cc3b69b5f520b9c4b4c288') }				   asDictionary.			   { 				   ('mode' -> '040000').				   ('path' -> 'subfolder').				   ('sha' -> 'b490118847905baf156093fba34ce8381304f252').				   ('type' -> 'tree').				   ('url'				    ->				    'https://api.github.com/repos/pillar-markup/Microdown/git/trees/b490118847905baf156093fba34ce8381304f252') }				   asDictionary.			   { 				   ('mode' -> '100644').				   ('path' -> 'toplevel.png').				   ('sha' -> 'e301bdce18877ad507b6080d4122eda9fc05461a').				   ('size' -> 442).				   ('type' -> 'blob').				   ('url'				    ->				    'https://api.github.com/repos/pillar-markup/Microdown/git/blobs/e301bdce18877ad507b6080d4122eda9fc05461a') }				   asDictionary }).		  ('truncated' -> false).		  ('url'		   ->		   'https://api.github.com/repos/pillar-markup/Microdown/git/trees/3d2ff94661d6a0399e3f4ea0ea5dc36a45971bf2') }		  asDictionary! !!MicGitHubRessourceReferenceTest methodsFor: 'tests' prior: 50843387!testContents	|uri ref contents|	self ensureApi: 4 for: [ "need one for default branch, and one for each level of directory"		uri := 'github://pillar-markup/Microdown/doc/testMicrodown/readme.md'.		ref := MicResourceReference fromUri: uri.		contents := ref contents.		self 			assert: (contents beginsWith: '# Test documents' )]! !!MicGitHubRessourceReferenceTest methodsFor: 'tests' prior: 50839270!testExtractFolderReferencesFrom	| uri ref response folders expectedRaw |		uri := 'github://pillar-markup/Microdown:testBranch/doc/testMicrodown'.	ref := MicResourceReference fromUri: uri.	response := self sampleTreeResponse.	folders := ref extractFolderReferencesFrom: response.	self assert: folders size equals: 2.	expectedRaw := 'https://raw.githubusercontent.com/pillar-markup/Microdown/testBranch/doc/testMicrodown'.	self assert: (folders 		allSatisfy: [:folder |			folder pathStringForRawAccess beginsWith: expectedRaw])	! !!MicGitHubRessourceReferenceTest methodsFor: 'tests' prior: 50840508!testExtractMicrodownDocReferencesFrom	| uri ref response documents expectedRaw |	uri := 'github://pillar-markup/Microdown:testBranch/doc/testMicrodown'.	ref := MicResourceReference fromUri: uri.	response := self sampleTreeResponse.	documents := ref extractMicrodownDocReferencesFrom: response.	self assert: documents size equals: 2.	expectedRaw := 'https://raw.githubusercontent.com/pillar-markup/Microdown/testBranch/doc/testMicrodown'.	self assert: (documents 		allSatisfy: [ :doc |			doc fullName beginsWith: expectedRaw ]) 	! !!MicGitHubRessourceReferenceTest methodsFor: 'tests' prior: 50839878!testGithubTreesApiRequest	|uri ref|	uri := 'github://JohnDoe/Calculator:devBranch/path/to/docs'.	ref := MicResourceReference fromUri: uri.	self 		assert: ref githubTreesApiRequest  		equals: 'repos/johndoe/Calculator/git/trees/devBranch'.! !!MicGitHubRessourceReferenceTest methodsFor: 'tests' prior: 50838601!testLoadChildren	|uri ref children|	self ensureApi: 3 for: [		uri := 'github://pillar-markup/Microdown/doc/testMicrodown'.		ref := MicResourceReference fromUri: uri.		children := ref loadChildren.		self 			assert: children size 			equals: 4.		self assert: (children allSatisfy: [:child | child isKindOf: MicAbsoluteResourceReference ])]! !!MicGitHubRessourceReferenceTest methodsFor: 'tests' prior: 50837867!testUri	|uri ref|	uri := 'github://JohnDoe/Calculator:devBranch/path/to/docs'.	ref := MicResourceReference fromUri: uri.	self assert: ref class equals: MicGitHubRessourceReference.	self assert: ref user equals: 'johndoe'.	self assert: ref project equals: 'Calculator'.	self assert: ref branch equals: 'devBranch'.	self assert: ref docFolder equals: { 'path'. 'to'. 'docs' }! !!MicGitHubRessourceReferenceTest methodsFor: 'tests' prior: 50837564!testUri_defaultBranch	|uri ref|	self ensureApi: 1 for: [ "needs one api callto establish default branch"		uri := 'github://JohnDoe/Calculator'.		ref := MicResourceReference fromUri: uri.			self assert: ref branch equals: 'main']! !!MicGitHubRessourceReferenceTest methodsFor: 'tests' prior: 50840191!testUri_defaultBranch_Pharo	|uri ref|	self ensureApi: 1 for: [ "needs one api callto establish default branch"		uri := 'github://pharo-project/pharo'.		ref := MicResourceReference fromUri: uri.			self assert: (ref branch beginsWith: 'Pharo')]! !!MicGitHubRessourceReferenceTest methodsFor: 'tests' prior: 50838317!testUri_defaultBranch_Pharo_withDoc	|uri ref|	uri := 'github://pharo-project/pharo:dummyBranch/path/to/docs'.	ref := MicResourceReference fromUri: uri.	self assert: ref docFolder equals: { 'path'. 'to'. 'docs' }! !!MicGitHubRessourceReferenceTest methodsFor: 'tests' prior: 50841117!testUri_defaultPath	|uri ref|	uri := 'github://JohnDoe/Calculator:devBranch'.	ref := MicResourceReference fromUri: uri.		self assert: ref docFolder equals: #()! !!MicPharoClassCommentResourceReferenceTest methodsFor: 'running' prior: 51014219!setUp	super setUp.	savedComment := self class comment.! !!MicPharoClassCommentResourceReferenceTest methodsFor: 'running' prior: 51014356!tearDown 	self class comment: savedComment.	super tearDown! !!MicPharoClassCommentResourceReferenceTest methodsFor: 'tests' prior: 51014000!testClassComment	| ref |	ref := 'comment://class/Microdown' asMicResourceReference.	self assert: ref contents equals: Microdown comment! !!MicPharoClassCommentResourceReferenceTest methodsFor: 'tests' prior: 51014495!testClassCommentWrite	| ref myName |	myName := self class name.	ref := ('comment://class/', myName) asMicResourceReference.	ref contents: 'Writing to comment'.	self assert: self class comment equals: 'Writing to comment'! !!MicPharoClassCommentResourceReferenceTest methodsFor: 'tests' prior: 51014799!testSetup	| ref |	ref := 'comment://class/Microdown' asMicResourceReference.	self assert: ref class equals: MicPharoClassCommentResourceReference.	self assert: ref classReference equals: Microdown! !!MicPharoClassCommentResourceReferenceTest methodsFor: 'tests' prior: 51015078!testSetup_metaClass	| ref |	ref := 'comment://class/Microdown/class' asMicResourceReference.	self assert: ref class equals: MicPharoClassCommentResourceReference.	self assert: ref classReference equals: Microdown class! !!MicPharoCommentResourceReferenceTest methodsFor: 'tests' prior: 51017048!testNewFromUri	| ref |	ref := 'comment://class/Microdown' asMicResourceReference.	self assert: ref class equals: MicPharoClassCommentResourceReference.	! !!MicPharoCommentResourceReferenceTest methodsFor: 'tests' prior: 51016620!testNewFromUri_hostError	self 		should: [ 'comment://foo/Microdown' asMicResourceReference  ]		raise:  MicResourceReferenceError  		! !!MicPharoCommentResourceReferenceTest methodsFor: 'tests' prior: 51016371!testNewFromUri_packageComment	| ref |	ref := 'comment://package/Microdown' asMicResourceReference.	self assert: ref class equals: MicPharoPackageCommentResourceReference.	! !!MicPharoCommentResourceReferenceTest methodsFor: 'tests' prior: 51016831!testNoBinaryReading	self 		should: [ 'comment://class/Microdown' asMicResourceReference loadImage ]		raise:  MicResourceReferenceError  		! !!MicPharoPackageCommentResourceReferenceTest methodsFor: 'running' prior: 51030831!setUp	super setUp.	savedComment := self class package packageComment.! !!MicPharoPackageCommentResourceReferenceTest methodsFor: 'running' prior: 51030985!tearDown 	self class package packageComment: savedComment.	super tearDown! !!MicPharoPackageCommentResourceReferenceTest methodsFor: 'tests' prior: 51028951!testCategoryName	| ref |	ref := 'comment://package/Microdown' asMicResourceReference.	self assert: ref categoryName equals: 'Microdown'.	! !!MicPharoPackageCommentResourceReferenceTest methodsFor: 'tests' prior: 51034796!testContents	| ref |	ref := 'comment://package/Microdown' asMicResourceReference.	self assert: ref contents equals: 'Microdown' asPackage packageComment.	self assert: ref contents notEmpty	! !!MicPharoPackageCommentResourceReferenceTest methodsFor: 'tests' prior: 51028525!testIsPackage	self assert: 'comment://package/Microdown' asMicResourceReference isPackage.	self assert: 'comment://package/Microdown-RichTextComposer' asMicResourceReference isPackage.	self deny: 'comment://package/Microdown-Core' asMicResourceReference isPackage.	self deny: 'comment://package/Microup' asMicResourceReference isPackage.		! !!MicPharoPackageCommentResourceReferenceTest methodsFor: 'tests' prior: 51033476!testIsTag	self deny: 'comment://package/Microdown' asMicResourceReference isTag .	self 		assert: 'comment://package/Microdown-Core' asMicResourceReference isTag .	self 		assert: 'comment://package/Microdown-RichTextComposer-Table-Support' asMicResourceReference isTag.	self		deny: 'comment://package/Calypso-SystemPlugins-ClassScripts' asMicResourceReference isTag! !!MicPharoPackageCommentResourceReferenceTest methodsFor: 'tests' prior: 51029173!testKind	self 		assert: 'comment://package/Microdown*' asMicResourceReference kind 		equals: #prefix.	self 		assert: 'comment://package/Microdown' asMicResourceReference kind 		equals: #package.	self 		assert: 'comment://package/Microdown-Core' asMicResourceReference kind 		equals: #tag.	self 		assert: 'comment://package/Microdown-RichTextComposer-Table-Support' asMicResourceReference kind 		equals: #tag.	! !!MicPharoPackageCommentResourceReferenceTest methodsFor: 'tests' prior: 51029676!testLoadDirectory	| ref dir |	ref := 'comment://package/Microdown' asMicResourceReference.	dir := ref loadChildren.	self assert: dir notEmpty.	self assert: (dir allSatisfy: [ :r |r class = MicPharoPackageCommentResourceReference  ] ).	self assert: (dir first uri segments first beginsWith: 'Microdown')! !!MicPharoPackageCommentResourceReferenceTest methodsFor: 'tests' prior: 51032090!testLoadDirectory_emptyPrefix	| dir prefixes |	dir := 'comment://package/' asMicResourceReference loadChildren.	self assert: (dir size between: 100 and: 200).	"check that four known prefises are in the found set."	prefixes := dir collect: [ :ref | ref uri segments first ].	self assert: (#(AST Collections Refactoring Iceberg) \ prefixes) isEmpty.	self assert: (prefixes allSatisfy: [:prefix | (prefix occurrencesOf: $-) = 0])! !!MicPharoPackageCommentResourceReferenceTest methodsFor: 'tests' prior: 51030065!testLoadDirectory_package	| ref dir |	ref := 'comment://package/Microdown?kind=package' asMicResourceReference.	dir := ref loadChildren.	"Expect Extension and Manifest tags removed"	self assert: dir size equals: ('Microdown' asPackage classTags size - 2).	self assert: (dir allSatisfy: [ :r |r class = MicPharoPackageCommentResourceReference  ] ).	self assert: (dir first uri segments first beginsWith: 'Microdown-').	self assert: (dir allSatisfy: [:r | r kind = #tag])		! !!MicPharoPackageCommentResourceReferenceTest methodsFor: 'tests' prior: 51032604!testLoadDirectory_prefix	| ref dir |	ref := 'comment://package/Microdown-DocumentBrowser' asMicResourceReference.	dir := ref loadChildren.	self assert: dir size equals: 3.! !!MicPharoPackageCommentResourceReferenceTest methodsFor: 'tests' prior: 51031141!testLoadDirectory_withTag	| ref dir |	ref := 'comment://package/Microdown-DocumentBrowser-Tests-ResourceModel' asMicResourceReference.	dir := ref loadChildren.	self assert: dir notEmpty.	self assert: (dir allSatisfy: [ :r |r class = MicPharoClassCommentResourceReference  ] ).	self assert: (dir anySatisfy:  [:aRef | aRef uri segments first = self class name])! !!MicPharoPackageCommentResourceReferenceTest methodsFor: 'tests' prior: 51033928!testNewFromUri	| ref |	ref := 'comment://package/Microdown' asMicResourceReference.	self assert: ref class equals: MicPharoPackageCommentResourceReference.	! !!MicPharoPackageCommentResourceReferenceTest methodsFor: 'tests' prior: 51032858!testPackageCommentWrite	| ref myName |	myName := self class package name.	ref := ('comment://package/', myName) asMicResourceReference.	ref contents: 'Writing to comment'.	self assert: self class package packageComment equals: 'Writing to comment'! !!MicPharoPackageCommentResourceReferenceTest methodsFor: 'tests' prior: 51030627!testPackageComment_NotThere	 self assert: 'comment://package/Microdownnnnn' asMicResourceReference contents equals: ''	! !!MicPharoPackageCommentResourceReferenceTest methodsFor: 'tests' prior: 51034169!testParentPackage	self 		assert: 'comment://package/Microdown' asMicResourceReference parentPackage 		equals: 'Microdown' asPackage.	self 		assert: 'comment://package/Microdown-Core' asMicResourceReference parentPackage 		equals: 'Microdown' asPackage.	self 		assert: 'comment://package/Microdown-RichTextComposer-Table-Support' asMicResourceReference parentPackage 		equals: 'Microdown-RichTextComposer' asPackage.	self		assert: 'comment://package/Calypso-SystemPlugins-ClassScripts' asMicResourceReference parentPackage		equals: nil! !!MicPharoPackageCommentResourceReferenceTest methodsFor: 'tests' prior: 51031587!testReduceCategoryNameToLevel	 | dummy |	dummy := MicPharoPackageCommentResourceReference new.	self assert: (dummy reduceCategoryName: '' toLevel: -1) equals: ''.	self assert: (dummy reduceCategoryName: 'aaa-bbb-ccc' toLevel: 0) equals: 'aaa'.	self assert: (dummy reduceCategoryName: 'aaa-bbb-ccc' toLevel: 1) equals: 'aaa-bbb'.	self assert: (dummy reduceCategoryName: 'aaa-bbb-ccc' toLevel: 2) equals: 'aaa-bbb-ccc'! !!MicPharoPackageCommentResourceReferenceTest methodsFor: 'tests' prior: 51033191!testSetup	| ref |	ref := 'comment://package/Microdown' asMicResourceReference.	self assert: ref class equals: MicPharoPackageCommentResourceReference.	self assert: ref categoryName equals: 'Microdown'! !!MicSectionBlockTest methodsFor: 'tests' prior: 51109557!testEmpty	"An empty document should not break sectioning"	| doc sec |	doc := Microdown parse: ''.	sec := MicSectionBlock fromRoot: doc.	self assert: sec class equals: MicSectionBlock.	self assert: sec header isNil.	self assert: sec body children isEmpty.	self assert: sec subsections children isEmpty! !!MicSectionBlockTest methodsFor: 'tests' prior: 51110423!testNoHeader	| doc sec |	doc := Microdown parse: 'This is **just**a few lines'.	sec := MicSectionBlock fromRoot: doc.	self assert: sec header equals: nil.	self assert: sec body children size equals: 2.	self assert: sec subsections children isEmpty! !!MicSectionBlockTest methodsFor: 'tests' prior: 51111217!testOneHeader	"With one header, only one section is created and become the root"	| doc sec |	doc := Microdown parse: '# Header1This is **just**a few lines'.	sec := MicSectionBlock fromRoot: doc.	self assert: sec header children first text equals: 'Header1'.	self assert: sec body children size equals: 2.	self assert: sec subsections children isEmpty! !!MicSectionBlockTest methodsFor: 'tests' prior: 51110735!testOneHeaderWithInitialBody	"With one header, but body, a level 0 section is created and become the root"	| doc sec |	doc := Microdown parse: 'stuff here# Header1This is **just**a few lines'.	sec := MicSectionBlock fromRoot: doc.	self assert: sec level equals: 0.	self assert: sec header isNil.	self assert: sec body children first text equals: 'stuff here'.	self assert: sec subsections children size equals: 1! !!MicSectionBlockTest methodsFor: 'tests' prior: 51109145!testOneHeaderWithSubHeader	"With one top header, only one section is created and become the root, subsections as its subsections"	| doc sec |	doc := Microdown parse: '# Header1## sub1## sub2'.	sec := MicSectionBlock fromRoot: doc.	self assert: sec header children first text equals: 'Header1'.	self assert: sec subsections children size equals: 2! !!MicSectionBlockTest methodsFor: 'tests' prior: 51107922!testSubHeaders	"Check more complex mixture of sections"	| doc sec header1 |	doc := Microdown parse: '# Header1### subOfHeader1## sub2OfHeader1# Header2'.	sec := MicSectionBlock fromRoot: doc.	self assert: sec header isNil.	self assert: sec subsections children size equals: 2.	header1 := sec subsections children first.	self assert: header1 level equals: 1.	self assert: header1 subsections children size equals: 2.	self assert: header1 subsections children first level equals: 3.	self assert: header1 subsections children second level equals: 2.! !!MicSectionBlockTest methodsFor: 'tests' prior: 51111635!testTwoHeaders	"With several headers, the top section has empty header"	| doc sec |	doc := Microdown parse: '# Header1This is **just**a few lines# Header2'.	sec := MicSectionBlock fromRoot: doc.	self assert: sec header equals: nil.	self assert: sec body children isEmpty.	self assert: sec subsections children size equals: 2.	self assert: sec subsections children second header children first text equals: 'Header2'.! !!MicSectionBlockTest methodsFor: 'tests' prior: 51109922!testTwoHeadersAtDeeperLevel	"With several headers, the top section has empty header"	| doc sec |	doc := Microdown parse: '## Header1This is **just**a few lines## Header2'.	sec := MicSectionBlock fromRoot: doc.	self assert: sec header equals: nil.	self assert: sec body children isEmpty.	self assert: sec subsections children size equals: 2.	self assert: sec subsections children second header children first text equals: 'Header2'.! !!MicSectionBlockTest methodsFor: 'tests' prior: 51108541!testTwoHeadersWithInitialBody	"With several headers, the top section has empty header"	| doc sec |	doc := Microdown parse: 'Some stuff goes here# Header1This is **just**a few lines# Header2'.	sec := MicSectionBlock fromRoot: doc.	self assert: sec header equals: nil.	self assert: sec body children size equals: 1.	self assert: sec body children first text equals: 'Some stuff goes here'.	self assert: sec subsections children size equals: 2.	self assert: sec subsections children second header children first text equals: 'Header2'.! !"Microdown-DocumentBrowser-Tests"!!MicNodeTransformer commentStamp: '' prior: 0!I'm a special visitor that replaces a node by another one. I'm used for example to replace a codeblock by the result of the evaluation of the code block body.Another important example is how to input a file in another one.!!MicFileIncluder commentStamp: '' prior: 0!I replace the inputFileBlock by the nodes of the file.In particular I resolve paths to the correct places.For example imagine that we have the file `Books/Book1/index.mic`containing 	`${inputfile&path=SUnit/SUnit.mic$`	and that `SUnit/SUnit.mic` contains a figuresuch as 	`!![](figures/setUpTearDown.png)`	Such `figures/setUpTearDown.png` file should get its path being: `Books/Book1/SUnit/figures/setUpTearDown.png`	Note that if the path does not exist the transformer does nothing.!!MicInputDocument commentStamp: '' prior: 0!I'm a little file wrapper so that we can mix pillar and microdown file within a document.As such I'm responsible to determine how my instances are parsed.!!MicMicrodownInputDocument commentStamp: '' prior: 0!I make sure that microdown file are parsed with a microdown parser. This way I can integrate within the pillar pipeline in a modular way.!!MicNoInputDocument commentStamp: '' prior: 0!I represent unknown file extension.!!MicFileIncluder methodsFor: 'initialization'!beRelaxed	isStrict := false! !!MicFileIncluder methodsFor: 'configuration'!doNotTransform	shouldTransform := false! !!MicFileIncluder methodsFor: 'accessing'!inProcessFiles: aCollection 	inProcessFiles := aCollection! !!MicFileIncluder methodsFor: 'initialization'!initialize	super initialize.	isStrict := true.	inProcessFiles := #()! !!MicFileIncluder methodsFor: 'visiting-document'!input: anInputDocument	input := anInputDocument! !!MicFileIncluder methodsFor: 'testing'!shouldTransform	^ shouldTransform ifNil: [ shouldTransform := true ]! !!MicFileIncluder methodsFor: 'accessing'!topFile: aFileReference	topFile := aFileReference! !!MicFileIncluder methodsFor: 'validation'!validateInclusionOfFile: aFileReference 		aFileReference = topFile ifTrue: [ 		MicCyclicFileInclusionError new			files: { topFile };			signal	].	(inProcessFiles includes: aFileReference)		ifTrue: [ MicCyclicFileInclusionError new			files: (inProcessFiles copyWith: aFileReference);			signal  ]! !!MicFileIncluder methodsFor: 'visiting-document'!visitInputFile: anInputFileAnnotation	"I load the file and if the file exist I replace the node of the annotation by the content of the file."		| inputRef inputDoc |	inputRef := anInputFileAnnotation path.	[ inputDoc := inputRef loadMicrodown inlineInputFiles]	on: MicResourceReferenceError 	do: [ :error | isStrict 			ifFalse: [ ^ self ]			ifTrue: [ error pass  ]].	self replaceCurrentNodeBy: inputDoc children	! !!MicNodeTransformer class methodsFor: 'execution'!executeOn: aMicContext	self new		"configuration: aMicContext configuration;"		start: aMicContext input.	^ aMicContext! !!MicNodeTransformer class methodsFor: 'instance creation'!withContext: aContext	"The API is done this way (without using the parameter) because most of the subclasses do not need to access the context of the process (such as files, configuration). Some subclasses may get access by redefine it."		^ self new 		! !!MicNodeTransformer methodsFor: 'accessing'!configuration	^ configuration! !!MicNodeTransformer methodsFor: 'accessing'!configuration: anObject	configuration := anObject.! !!MicNodeTransformer methodsFor: 'enumerating'!delete	"When we do a transformation I replace the current node by nothing."		self replaceCurrentNodeBy: {  }! !!MicNodeTransformer methodsFor: 'execution'!executeOn: aMicContext		self visit: aMicContext input.	^ aMicContext! !!MicNodeTransformer methodsFor: 'enumerating'!initialize	super initialize.	replacement := Stack new! !!MicNodeTransformer methodsFor: 'execution'!replaceChildrenOf: aGroup	aGroup		children:			(aGroup children				flatCollect: [ :child | 					replacement push: {child}.					self visitAll: child.					replacement pop]). ! !!MicNodeTransformer methodsFor: 'enumerating'!replaceCurrentNodeBy: newNodes	"When we do a transformation I replace the current node by its transformation."	replacement pop.	replacement push: newNodes! !!MicNodeTransformer methodsFor: 'execution'!visit: anObject	super visit: anObject.	^ anObject! !!MicNodeTransformer methodsFor: 'execution'!visitAll: aGroup	self replaceChildrenOf: aGroup.	aGroup accept: self.! !!MicNodeTransformer methodsFor: 'execution'!visitRoot: aGroup	self replaceChildrenOf: aGroup ! !!MicElement methodsFor: '*Microdown-Transformer'!inlineInputFiles	"Assume all input has been resolved."	MicFileIncluder new visit: self! !!MicCyclicFileInclusionError methodsFor: 'accessing'!files: aCollection 	files := aCollection! !!RelativePath methodsFor: '*Microdown-Transformer'!microdownPrintString	self isEmpty ifTrue: [ ^ '' ].	^ String streamContents: [ :str |		str nextPutAll: (self at: 1) asString.		2 to: self size do: [:i |			str				nextPut: self delimiter;				nextPutAll: (self at: i) ] ]								! !!MicInputDocument class methodsFor: 'factory'!forFile: aFile		^ (self inputClassForFile: aFile) new file: aFile ; yourself! !!MicInputDocument class methodsFor: 'factory'!inputClassForFile: aFile		^ self subclasses		detect: [ :each | each doesHandleExtension: aFile extension ]		ifNone: [ MicNoInputDocument  ]! !!MicInputDocument methodsFor: 'accessing'!basename		^ file basename! !!MicInputDocument methodsFor: 'building'!contributeToPipelineBuilding: aPRPipelineBuilder 		self error: 'To be fixed'.	self flag: #maybeToRemove.		aPRPipelineBuilder setInputDocument: file.	aPRPipelineBuilder parser: self parser! !!MicInputDocument methodsFor: 'accessing'!file	^ file! !!MicInputDocument methodsFor: 'accessing'!file: aFileReference 	file := aFileReference! !!MicInputDocument methodsFor: 'accessing'!fullName	^ file fullName! !!MicInputDocument methodsFor: 'accessing'!path		^ file path! !!MicInputDocument methodsFor: 'printing'!printOn: aStream	aStream		nextPutAll: self class name;		nextPutAll: '(';		nextPutAll: file fullName;		nextPutAll: ')'! !!MicInputDocument methodsFor: 'accessing'!project	^ project! !!MicInputDocument methodsFor: 'accessing'!project: aProject 	project := aProject! !!MicMicrodownInputDocument class methodsFor: 'registration'!doesHandleExtension: anExtension	^ #('md' 'mic' 'MD' 'MIC') includes: anExtension! !!MicMicrodownInputDocument methodsFor: 'accessing'!parsedDocument	^ self parserClass new parse: file contents! !!MicMicrodownInputDocument methodsFor: 'accessing'!parserClass		^ MicAbstractBlock new parserClass! !!MicNoInputDocument class methodsFor: 'registration'!doesHandleExtension: anExtension	^ false! !!MicNoInputDocument methodsFor: 'accessing'!parserClass 	"may be the error should not be raised here."		self error: 'Extension file ', file extension, 'not recognized'! !"Microdown-Transformer"!!MicNodeTransformerCodeDeleterMock commentStamp: '' prior: 0!I'm a silly `MicNodeTransformer`: I delete code block and replace paragraph by text. !!MicFileIncluderTest methodsFor: 'running'!generateFilesystemExample	| file |	file := filesystem workingDirectory / 'anExample1.md'.	file writeStreamDo: [ :stream | stream nextPutAll: '# FooPharo is cool```	this is a code```' ].	file := filesystem workingDirectory / 'anExample2.md'.	file writeStreamDo: [ :stream | stream nextPutAll: '## BarPharo is **cool**```	this is a code 2```' ]! !!MicFileIncluderTest methodsFor: 'running'!setUp	super setUp.	filesystem := FileSystem memory.		includer := MicFileIncluder new.	includer topFile: filesystem root.	builder := Microdown builder.	self generateFilesystemExample.! !!MicFileIncluderTest methodsFor: 'tests - simple'!testBeforeIncludingTheInputFile	| root file reference |		file := filesystem workingDirectory / 'test.md'.	file writeStreamDo: [ :stream |		builder		 	setStream: stream;			inputFile: 'anExample1.md' ].		reference := (MicResourceReference fromUri: 'file:///test.md') filesystem: filesystem .	root := reference loadMicrodown.		self assert: root children first class equals: MicInputfileBlock.	! !!MicFileIncluderTest methodsFor: 'tests - simple'!testGenerateFilesystemIsGood		self assert: (filesystem workingDirectory / 'anExample1.md') contents equals: '# FooPharo is cool```	this is a code```'.	self assert: (filesystem workingDirectory / 'anExample2.md') contents equals: '## BarPharo is **cool**```	this is a code 2```' ! !!MicFileIncluderTest methodsFor: 'tests'!testHandleNestedFileResolution	| root file reference |	(filesystem workingDirectory / 'Chapters') createDirectory.	(filesystem workingDirectory / 'Chapters' / 'SUnit') createDirectory.		file := filesystem workingDirectory / 'Chapters' / 'SUnit.md'.	file writeStreamDo: [ :stream | 		builder		 	setStream: stream;			inputfile: 'SUnit/anExample1.md' ].		file := filesystem workingDirectory / 'Chapters' / 'SUnit' / 'anExample1.md'.	file writeStreamDo: [ :stream | 		builder		 	setStream: stream;			header: [builder text: 'Foo'] withLevel: 1;			inputfile: 'anExample2.md' ].			file := filesystem workingDirectory / 'Chapters' / 'SUnit' / 'anExample2.md'.	file writeStreamDo: [ :stream |  		builder		 	setStream: stream;			header: [builder text: 'Example2'] withLevel: 1 ].		reference := (MicResourceReference fromUri: 'file:///Chapters/SUnit.md') filesystem: filesystem.		includer topFile: reference fileReference parent.	includer visit: (root := reference loadMicrodown).		self assert: root children first class equals: MicHeaderBlock.	self assert: root children first header equals: 'Foo'.		self assert: root children second class equals: MicHeaderBlock.	self assert: root children second header equals: 'Example2'.! !!MicFileIncluderTest methodsFor: 'tests'!testHandleNestedFileResolutionOnDifferentLevel	| root file reference |	(filesystem workingDirectory / 'Chapters') createDirectory.	(filesystem workingDirectory / 'Chapters' / 'SUnit') createDirectory.	(filesystem workingDirectory / 'Chapters' / 'SUnit' / 'Sub') createDirectory.		file := filesystem workingDirectory / 'Chapters' / 'SUnit.md'.	file writeStreamDo: [ :stream | 		builder		 	setStream: stream;			inputfile: 'SUnit/anExample1.md' ].		file := filesystem workingDirectory / 'Chapters' / 'SUnit' / 'anExample1.md'.	file writeStreamDo: [ :stream | 		builder		 	setStream: stream;			header: [builder text: 'Foo'] withLevel: 1;			inputfile: 'Sub/anExample2.md' ].			file := filesystem workingDirectory / 'Chapters' / 'SUnit' / 'Sub' / 'anExample2.md'.	file writeStreamDo: [ :stream |  		builder		 	setStream: stream;			header: [builder text: 'Example2'] withLevel: 1 ].		reference := (MicResourceReference fromUri: 'file:///Chapters/SUnit.md') filesystem: filesystem.		includer topFile: reference fileReference parent.	includer visit: (root := reference loadMicrodown).		self assert: root children first class equals: MicHeaderBlock.	self assert: root children first header equals: 'Foo'.		self assert: root children second class equals: MicHeaderBlock.	self assert: root children second header equals: 'Example2'.! !!MicFileIncluderTest methodsFor: 'tests'!testIncluderIncludesInputFileFromTheSameLevel	| root file reference |	(filesystem workingDirectory / 'Chapters') createDirectory.	(filesystem workingDirectory / 'Chapters' / 'SUnit') createDirectory.		file := filesystem workingDirectory / 'Chapters' / 'SUnit' / 'anExample1.md'.	file writeStreamDo: [ :stream | 		builder		 	setStream: stream;			header: [ builder text: 'Foo' ] withLevel: 1;			text: 'Pharo is cool';			codeblock: 'This is a code'].		file := filesystem workingDirectory / 'Chapters' / 'SUnit' / 'SUnit.md'.	file writeStreamDo: [ :stream | 		builder		 	setStream: stream;			inputfile: 'anExample1.md' ].		reference := (MicResourceReference fromUri: 'file:///Chapters/SUnit/SUnit.md') filesystem: filesystem.	root := reference loadMicrodown.						self assert: root children first class equals: MicInputfileBlock.	self assert: (root children first path isKindOf: MicResourceReference).				includer visit: root.	self assert: root children first class equals: MicHeaderBlock.	self assert: root children first header equals: 'Foo'.	self assert: root children second class equals: MicParagraphBlock.	self assert: root children third class equals: MicCodeBlock.! !!MicFileIncluderTest methodsFor: 'tests'!testIncluderIncludesInputFilesWithinTheSameParagraph	"As a general remark I do not like that the input can produce document that are not correct from a parser point of view. For example we should have a paragraph containing an header and this is what the transformation of the includer is doing."	| root file reference |	file := filesystem workingDirectory / 'test.md'.	file writeStreamDo: [ :stream |   		builder		 	setStream: stream;			inputfile: 'anExample1.md';			inputfile: 'anExample2.md' ].	reference := (MicResourceReference fromUri: 'file:///test.md') filesystem: filesystem.	root := reference loadMicrodown.	includer visit: root.	self assert: root children first class equals: MicHeaderBlock.	self assert: root children first header equals: 'Foo'.	self assert: root children first level equals: 1.	self assert: root children second class equals: MicParagraphBlock.	self assert: root children third class equals: MicCodeBlock.		self assert: root children fourth class equals: MicHeaderBlock.	self assert: root children fourth header equals: 'Bar'.	self assert: root children fourth level equals: 2.	self assert: root children fifth class equals: MicParagraphBlock.	self assert: root children sixth class equals: MicCodeBlock! !!MicFileIncluderTest methodsFor: 'tests'!testIncluderJustReturnInputFileBlockWhenIncludedFileDoesNotExist	| root file reference |	file := filesystem workingDirectory / 'test.md'.	file writeStreamDo: [ :stream |  		builder		 	setStream: stream;			inputfile: 'anExample3.md'].		reference := (MicResourceReference fromUri: 'file:///test.md') filesystem: filesystem.	root := reference loadMicrodown.		includer beRelaxed.	includer visit: root.		self assert: root children first class equals: MicInputfileBlock.! !!MicFileIncluderTest methodsFor: 'tests'!testMicFileInclusionTransformMicInputFiles	| root file reference |	file := filesystem workingDirectory / 'test.md'.	file writeStreamDo: [ :stream |  		builder		 	setStream: stream;			inputfile: 'anExample1.md';			paragraph: '';			inputfile: 'anExample2.md' ].	reference := (MicResourceReference fromUri: 'file:///test.md') filesystem: filesystem.	root := reference loadMicrodown.	includer visit: root.	self assert: root children first class equals: MicHeaderBlock.	self assert: root children second class equals: MicParagraphBlock.	self assert: root children third class equals: MicCodeBlock.		self assert: root children fourth class equals: MicHeaderBlock.	self assert: root children fifth class equals: MicParagraphBlock.		self assert: root children fifth children size equals: 2.	self assert: root children sixth class equals: MicCodeBlock! !!MicNodeTransformerTest methodsFor: 'running'!setUp	super setUp.	transformer := MicNodeTransformerCodeDeleterMock new! !!MicNodeTransformerTest methodsFor: 'tests'!testDeleteNode	| root |	root := Microdown parse: '```this is a paragraph```'.	self assert: root children first class equals: MicCodeBlock.	transformer visit: root.	self assert: root children size equals: 0! !!MicNodeTransformerTest methodsFor: 'tests'!testReplaceNodeByAnotherNode	| root |	root := Microdown parse: 'this is a paragraph'.	self assert: root children first class equals: MicParagraphBlock.	transformer visit: root.	self assert: root children first class equals: MicTextBlock.	self assert: root children first substring equals: 'test'! !!MicNodeTransformerCodeDeleterMock methodsFor: 'visiting'!visitCode: aCode	self delete! !!MicNodeTransformerCodeDeleterMock methodsFor: 'visiting'!visitParagraph: aParagraph	self replaceCurrentNodeBy: { MicTextBlock new substring: 'test' }! !"Microdown-Transformer-Tests"!!MicCodeblockEvaluator commentStamp: '' prior: 0!This transformer compiles the code content by a codeblock which have the parameters eval at true.```MicCodeblockEvaluator new 	visit: (Microdown	parse: '```eval=truestream nextPutAll: ''Hello world''\```')```!!MicCodeblockEvaluatorEnv commentStamp: '' prior: 0!I'm stupid helper to support the evaluation of codeBlock.When the MicCodeBlockEvaluator is loaded and the eval parameter is true then the user can use the stream to generate a different body of the codeblock using stream as receiver ofstream messages.!!MicCodeBlock methodsFor: '*Microdown-Evaluator'!eval: aBoolean		"the string conversion is due to the fact that the arguments are not converted so normally the parser returns strings and not boolean. 	This could be changed but it means that the parser (closeMe method), the isEvaluated method and this one should be in sync.	"		arguments at: #eval put: aBoolean asString! !!MicCodeBlock methodsFor: '*Microdown-Evaluator'!evaluate	| content |	content := self evaluationString.	^ [ (self parserClass parse: content) children ]		on: Error		do: [ :e | MicBoldFormatBlock new children: { (MicTextBlock new substring: e messageText) } ]! !!MicCodeBlock methodsFor: '*Microdown-Evaluator'!evaluationString	^ String		streamContents: [ :stream | 			| evaluator |			evaluator := MicCodeblockEvaluatorEnv new				setStream: stream;				yourself.			[ self class compiler				source: self body;				logged: false;				receiver: evaluator;				evaluate ]				on: Error				do: [ :e | 					stream						nextPutAll: e description ] ]! !!MicCodeBlock methodsFor: '*Microdown-Evaluator'!isEvaluated 	arguments at: #eval ifAbsent: [ ^ false ].	^ (arguments at: #eval) = 'true'! !!MicCompilationContext class methodsFor: 'instance creation'!configuration: aConfiguration	^ self new configuration: aConfiguration! !!MicCompilationContext class methodsFor: 'instance creation'!isAbstract	^ false! !!MicCompilationContext class methodsFor: 'instance creation'!withDocument: aDocument	^ self new		input: aDocument;		yourself! !!MicCompilationContext class methodsFor: 'instance creation'!withDocument: aDocument withConfiguration: aConfiguration	^ self new		input: aDocument;		configuration: aConfiguration;		yourself! !!MicCompilationContext methodsFor: 'accessing'!configuration	^ configuration! !!MicCompilationContext methodsFor: 'accessing'!configuration: aConfiguration	configuration := aConfiguration! !!MicCompilationContext methodsFor: 'accessing'!input	^ input! !!MicCompilationContext methodsFor: 'accessing'!input: anObject	input := anObject! !!MicCodeblockEvaluator methodsFor: 'visiting'!visitCode: aCodeBlock		aCodeBlock isEvaluated		ifTrue: [ self replaceCurrentNodeBy: aCodeBlock evaluate ]! !!MicCodeblockEvaluatorEnv methodsFor: 'initialization'!setStream: aStream	stream := aStream! !"Microdown-Evaluator"!!MicCodeblockEvaluatorTest methodsFor: 'private'!actualClass	^ MicCodeblockEvaluator ! !!MicCodeblockEvaluatorTest methodsFor: 'private'!testCodeblockWithEvalExecuteBody	| input |	input := MicRootBlock new		addChild:			(MicParagraphBlock new				addChild:						((MicCodeBlock new body: 'stream nextPutAll: ''- test''')								eval: true; 								yourself);				yourself) yourself.	self actualClass new visit: input.	self assert: input children first class equals: MicParagraphBlock.	self assert: input children first children first class equals: MicUnorderedListBlock.	self assert: input children first children first children first class equals: MicListItemBlock.	self assert: input children first children first children first text equals: 'test'! !!MicCodeblockEvaluatorTest methodsFor: 'tests'!testCodeblockWithProblematicEval	| input |	input := MicRootBlock new		addChild:				((MicCodeBlock new body: 'Object SomethingThatIsNotAMethod')						eval: true;						yourself);		yourself.	self actualClass new visit: input.	self 		assert: input children first text 		equals: 'Instance of Object class did not understand #SomethingThatIsNotAMethod'! !!MicCodeblockEvaluatorTest methodsFor: 'tests'!testCodeblockWithoutEval	| input |	input := MicRootBlock new		addChild:				((MicCodeBlock new body: 'stream nextPut: $h; nextPut: $e; nextPut: $l; nextPutAll: ''lo''')						eval: false;						yourself);		yourself.	self actualClass new visit: input.	self assert: input children first class equals: MicCodeBlock.	self assert: input children first body equals: 'stream nextPut: $h; nextPut: $e; nextPut: $l; nextPutAll: ''lo'''! !!MicCodeblockEvaluatorTest methodsFor: 'tests'!testParsedCodeblockEvaluated	| input |	input := MicCodeblockEvaluator new  visit: (Microdown parse: '```eval=truestream nextPutAll: ''Hello world''```').	self actualClass new visit: input.	self assert: input children first class equals: MicParagraphBlock.	self assert: input children first text equals: 'Hello world'! !!MicCodeblockEvaluatorTest methodsFor: 'tests'!testParsedCodeblockNonEvaluated	| input |	input := MicCodeblockEvaluator new  visit: (Microdown parse: '```eval=grgrgrstream nextPutAll: ''Hello world''```').	self actualClass new visit: input.	self assert: input children first class equals: MicCodeBlock.	self assert: input children first body equals: 'stream nextPutAll: ''Hello world'''! !"Microdown-Evaluator-Tests"!!MicDocumentWriter commentStamp: '' prior: 0!I'm the superclass of writers in various formats.I managed end of line conventions, canvas responsible for the encodings of specific commands to output a given format and I support raw ouputting.!!MicLaTeXWriter commentStamp: '' prior: 0!I'm producing a textual latex version of a microdown document.!!MicSBALaTeXWriter commentStamp: '' prior: 0!I'm version producing LaTeX for the SBA template.In the future (once the templatedWriter is working) I should get removed.!!MicLatexPathUpdateVisitor commentStamp: '' prior: 0!I am a pillar visitor that updates all references to be latex compatible. I am particularly useful in windows platforms that use the \ delimiter, which is not correctly parsed by the latex compiler.Latex Paths have to use the / delimiter, even in windows. The following are examples of correct paths:/usr/lib/blaC:/Program Files/SomethingFor now I'm a copy and paste from Pillar (to avoid to have to patch all the visit API).!!MicExportBrush commentStamp: '' prior: 0!I'm the superclass of all brushes. A brush is something you can add on a canvas. For example, LaTeX command and environment brushes can be added to a LaTeX canvas; HTML tags can be added to an HTML canvas.Copied from Pillar!!MicLaTeXBrush commentStamp: '' prior: 0!Command and environment LaTeX brushes common superclass.!!MicLaTeXCommand commentStamp: '' prior: 0!A LaTeX commandTo emit `\mycommand` potentially with arguments and optionals. ```\mycommand[1]{#1}```!!MicLaTeXEnvironment commentStamp: '' prior: 0!A LaTeX environmentTo emit```\begin{XXX}kjlkjkl\end{XXX}```!!MicExportCanvas commentStamp: '' prior: 0!I am the place where the visitors will write stuff. I output everything to a stream. Eventhough I have some streaming capabilities (`nextPutAll:`, `raw:`, ...), my clients should use brushes as much as possible instead. This is because the brushes will take the responsibility to write correct text for the clients.Copied from Pillar!!MicLaTeXCanvas commentStamp: '' prior: 0!I'm a specialized canvas to emit commands and latex environments.!!MicDocumentWriter methodsFor: 'accessing'!canvasClass 	^ self subclassResponsibility ! !!MicDocumentWriter methodsFor: 'writing'!contents	^ canvas contents! !!MicDocumentWriter methodsFor: 'initialization'!crAsNewLine	canvas crAsNewLine! !!MicDocumentWriter methodsFor: 'initialization'!crlfAsNewLine	canvas crlfAsNewLine! !!MicDocumentWriter methodsFor: 'initialization'!initialize	| stream |	super initialize.	stream := MicOutputStream new setStream: (WriteStream on: (String new: 1000)).	canvas := self canvasClass on: stream.	writingRaw := false.	nbListTab := -1! !!MicDocumentWriter methodsFor: 'initialization'!lfAsNewLine	canvas lfAsNewLine! !!MicDocumentWriter methodsFor: 'initialization'!usedNewLine	"Return the encoded new line. Useful for tests."		^ canvas stream usedNewLine! !!MicDocumentWriter methodsFor: 'writing'!visit: aMicElement	aMicElement accept: self.	^ self contents! !!MicDocumentWriter methodsFor: 'writing'!write: aMicElement	"for now for integration with Pillar."	self visit: aMicElement.	^ self contents! !!MicDocumentWriter methodsFor: 'writing'!writeRawDuring: aBlock	[ 	canvas writingRaw: true.	aBlock value ]		ensure: [ canvas writingRaw: false. ]! !!MicLaTeXWriter class methodsFor: 'accessing'!fileExtension	^ 'tex'! !!MicLaTeXWriter class methodsFor: 'accessing'!folderName	^ #latex! !!MicLaTeXWriter class methodsFor: 'accessing'!toLatexPath: aString	"Replace all (windows style) back slashes in paths by (unix style) forward slashes.	This is required as path in latex only support unix style pathes like		  /home/xxx		or		  C:/home/xxx		See https://tex.stackexchange.com/questions/9363/how-does-one-insert-a-backslash-or-a-tilde-into-latex	"	^ aString copyReplaceAll: '\' with: '/'! !!MicLaTeXWriter class methodsFor: 'accessing'!writerName	^ #miclatex! !!MicLaTeXWriter methodsFor: 'accessing'!canvas	^ canvas! !!MicLaTeXWriter methodsFor: 'accessing'!canvasClass	^ MicLaTeXCanvas! !!MicLaTeXWriter methodsFor: 'templating'!chapterTemplateName		^ 'latexChapterTemplate'! !!MicLaTeXWriter methodsFor: 'helpers'!createLinkToLabelWithAlias: anInternalLink	canvas command		name: 'hyperref';		optParameter: [ canvas nextPutAll: anInternalLink anchor ];		parameter: [ 					anInternalLink counter isValidCounter						ifTrue: [ self writeCounter: anInternalLink counter ].					canvas nextPutAll: anInternalLink alias ]! !!MicLaTeXWriter methodsFor: 'helpers'!createLinkToLabelWithoutAlias: anInternalLink	canvas command		name: 'ref';		parameter: [ canvas raw: anInternalLink substring ]! !!MicLaTeXWriter methodsFor: 'helpers'!getStringForAll: aCollection	"Visit each element of aCollection and exports everything to a new stream. Answer the stream content."		| visitor |		visitor := self class new.		aCollection do: [ :object | visitor visit: object ].		^ visitor contents! !!MicLaTeXWriter methodsFor: 'visiting-document'!includeGraphicsFor: aFigure	canvas command		name: 'includegraphics';		optParameter: [ self writeGraphicsParametersOfExternalLink: aFigure ];		parameter: [ canvas raw: aFigure fullName ]	"we should see when the reference is resolved if we really emit well figures in the case of file://figures/logo.png"	! !!MicLaTeXWriter methodsFor: 'protected'!monospaceMacro	^ 'code'! !!MicLaTeXWriter methodsFor: 'helpers'!protectUrl: aString	^ ((aString copyReplaceAll: '\' with: '\\') copyReplaceAll: '#' with: '\#') copyReplaceAll: '%' with: '\%'! !!MicLaTeXWriter methodsFor: 'helpers'!sectioningCommands	^ #('part' 'chapter' 'section' 'subsection' 'subsubsection' 'paragraph' 'subparagraph')! !!MicLaTeXWriter methodsFor: 'helpers'!tabList	0 to: nbListTab do: [ :nothing | canvas raw: '    ' ]! !!MicLaTeXWriter methodsFor: 'protected'!tabularEnvironment	^ 'tabular'! !!MicLaTeXWriter methodsFor: 'visiting-document'!typeOfSectionFor: aHeader	| sections level section |	sections := self sectioningCommands.	level := aHeader level.	section := sections at: (level min: sections size max: 1).	^ section! !!MicLaTeXWriter methodsFor: 'blocks'!visitAnchor: anAnchor	canvas command		name: 'label';		parameter: anAnchor label! !!MicLaTeXWriter methodsFor: 'blocks - inline'!visitAnchorReference: anAchorReference	self createLinkToLabelWithoutAlias: anAchorReference	! !!MicLaTeXWriter methodsFor: 'blocks - inline'!visitBold: aBold	canvas command name: 'textbf'; parameter: [ super visitBold: aBold ]! !!MicLaTeXWriter methodsFor: 'blocks - inline'!visitCitation: aCitation	canvas command		name: 'cite';		parameter: aCitation ref.! !!MicLaTeXWriter methodsFor: 'blocks - code'!visitCode: aCodeBlock	| env parameters |	parameters := OrderedCollection new.	aCodeBlock hasCaption		ifTrue: [ parameters add: 'caption={' , (self getStringForAll: aCodeBlock captionElements), '}' ].	aCodeBlock hasNonDefaultLanguage 		ifTrue: [parameters add: 'language=' , aCodeBlock language asString].	aCodeBlock hasLabel		ifTrue: [ parameters add: 'label=' , aCodeBlock label ].	env := canvas environment		name: 'listing';		yourself.	parameters ifNotEmpty: [ env optParameter: parameters asCommaString ].	env		with: [ 			canvas nextPutAllLines: aCodeBlock body.			canvas newLine ]! !!MicLaTeXWriter methodsFor: 'blocks - inline'!visitFigure: aFigure	(aFigure hasCaption not and: [ aFigure hasLabel not ]) ifTrue: [ 		self includeGraphicsFor: aFigure.		^ self ].	canvas environment		name: 'figure';		optParameter: [ canvas raw: 'htpb' ];		with: [ 			canvas environment				name: 'center';				with: [ 					self includeGraphicsFor: aFigure.					canvas newLine.					canvas command						name: 'caption';						parameter: [ self writeCaptionOfExternalLink: aFigure ].					self writeLabelOfExternalLink: aFigure.					canvas newLine ] ]! !!MicLaTeXWriter methodsFor: 'blocks - inline'!visitFootnote: aFootnote	canvas command name: 'footnote'; parameter: (aFootnote note)! !!MicLaTeXWriter methodsFor: 'blocks'!visitHeader: aHeader	| section |	canvas newLine.	section := self typeOfSectionFor: aHeader.	canvas command		name: section;		parameter: [ super visitHeader: aHeader ]! !!MicLaTeXWriter methodsFor: 'blocks'!visitHorizontalLine: aHorizontalLine	canvas newLine.	canvas raw: '\rule{\textwidth}{0.1pt}'.	canvas newLine.! !!MicLaTeXWriter methodsFor: 'blocks - inline'!visitItalic: anItalic	canvas command name: 'textit'; parameter: [ super visitItalic: anItalic ]! !!MicLaTeXWriter methodsFor: 'blocks - inline'!visitLink: aLink	| text reference |	reference := aLink fileStringWithoutHostFile.	self flag: #todo.	"I do not get this logic if the string does not have file:// it can still be	something else than a url... all this logic is bogus."	text := aLink text.	(text isEmptyOrNil or: [ reference = text ])		ifTrue: [ canvas command				name: 'url';				parameter: reference ]		ifFalse: [			canvas command				name: 'href';				parameter: reference;				parameter: [ canvas nextPutAll: text ].			canvas command				name: 'footnotesize';				parameter: [ canvas command name: 'url'; parameter: (self protectUrl: reference) ] ]! !!MicLaTeXWriter methodsFor: 'blocks - list'!visitListItem: anItem	self tabList.	canvas command name: 'item'.	canvas space.	canvas raw: [ super visitListItem: anItem ].	canvas newLine! !!MicLaTeXWriter methodsFor: 'blocks - inline'!visitMonospace: aMonospace	canvas command		name: self monospaceMacro;		parameter: [ super visitMonospace: aMonospace ]! !!MicLaTeXWriter methodsFor: 'blocks - list'!visitOrderedList: aList	"tabulation for  \begin{itemize} it can do in the environment of the canvas"	canvas newLine.	self tabList.	canvas raw: '\begin{enumerate}'.	canvas newLine.	nbListTab := nbListTab + 1.	super visitOrderedList: aList.	nbListTab := nbListTab - 1.	self tabList.	canvas raw: '\end{enumerate}'.	nbListTab = -1 ifTrue: [canvas newLine]! !!MicLaTeXWriter methodsFor: 'blocks'!visitParagraph: aParagraph	canvas newLine.	super visitParagraph: aParagraph.	canvas newLine.! !!MicLaTeXWriter methodsFor: 'blocks'!visitQuote: aQuote	canvas environment		name: 'verbatim';		with: [ aQuote children do: [ :child | 						self visit: child.						canvas newLine ] ]! !!MicLaTeXWriter methodsFor: 'blocks - inline'!visitStrike: aStrike	canvas command name: 'sout'; parameter: [ super visitStrike: aStrike ]! !!MicLaTeXWriter methodsFor: 'blocks - table'!visitTable: aTable	| environment |	canvas newLine.	environment := canvas environment name: self tabularEnvironment.	aTable rows size = 0		ifTrue: [ environment with: [  ].			^ self ].	environment parameter: aTable latexSpecification.	environment		with: [ canvas command name: 'toprule'.			canvas newLine.			aTable rows doWithIndex: [ :row :i | self visitTableRow: row with: aTable hasHeader at: i].			canvas command name: 'bottomrule'.			canvas newLine ]! !!MicLaTeXWriter methodsFor: 'blocks - table'!visitTableCell: aCell	aCell isAligned		ifFalse: [ self writeTableCellContent: aCell ]		ifTrue: [ 			canvas command				name: 'multicolumn';				parameter: '1';				parameter: aCell latexAlignment;				parameter: [ self writeTableCellContent: aCell ] ]! !!MicLaTeXWriter methodsFor: 'blocks - table'!visitTableCell: aCell with: aBool	self writeTableCellContent: aCell with: aBool ! !!MicLaTeXWriter methodsFor: 'blocks - table'!visitTableRow: aRow	self visitAll: aRow children separatedBy: [ canvas raw: ' & ' ].	canvas		raw: ' \\';		newLine.	aRow isHeading		ifTrue: [ 			canvas command name: 'midrule'.			canvas newLine ]! !!MicLaTeXWriter methodsFor: 'blocks - table'!visitTableRow: aRow with: aBool at: anIndex	aRow do: [ :cell | self visitTableCell: cell with: (aBool and: [ anIndex = 1 ]) ] separatedBy: [ canvas raw: ' & ' ].	canvas		raw: ' \\';		newLine.	(aBool and: [ anIndex = 1 ])		ifTrue: [ 			canvas command name: 'midrule'.			canvas newLine ]! !!MicLaTeXWriter methodsFor: 'blocks'!visitText: aText	canvas nextPutAllLines: aText substring! !!MicLaTeXWriter methodsFor: 'blocks - list'!visitUnorderedList: aList	"tabulation for  \begin{itemize} it can do in the environment of the canvas"		canvas newLine.	self tabList.	canvas raw: '\begin{itemize}'.	canvas newLine.	nbListTab := nbListTab + 1.	super visitUnorderedList: aList.	nbListTab := nbListTab - 1.	self tabList.	canvas raw: '\end{itemize}'.	nbListTab = -1 ifTrue: [canvas newLine]! !!MicLaTeXWriter methodsFor: 'helpers'!writeCaptionOfExternalLink: anExternalLink	self visitAll: anExternalLink captionElements! !!MicLaTeXWriter methodsFor: 'helpers'!writeGraphicsParametersOfExternalLink: anExternalLink	canvas		nextPutAll: 'width=';		nextPutAll:			((anExternalLink arguments at: 'width' ifAbsent: [ 100 ]) asNumber			 / 100.0) printString;		raw: '\textwidth'! !!MicLaTeXWriter methodsFor: 'helpers'!writeLabelOfExternalLink: anExternalLink	"we decided not to create an arbitrary label when there is none specified.	This decision should be changed but we need to find a way to uniquely identify a figure, math, ..."		| label |	label := anExternalLink arguments		         at: 'label'		         ifAbsent: [ nil ].	label ifNotNil: [ 		canvas command			name: 'label';			parameter: [ canvas raw: label ] ]! !!MicLaTeXWriter methodsFor: 'helpers'!writeTableCellContent: aCell	^ aCell isHeading		ifTrue: [ 			canvas command				name: 'textbf';				parameter: [ super visitTableCell: aCell ] ]		ifFalse: [ super visitTableCell: aCell ]! !!MicLaTeXWriter methodsFor: 'blocks - table'!writeTableCellContent: aCell with: aBool	^ aBool		ifTrue: [ 			canvas command				name: 'textbf';				parameter: [ self visitAll: aCell ] ]		ifFalse: [ self visitAll: aCell ]! !!MicSBALaTeXWriter class methodsFor: 'accessing'!writerName	^ #miclatex:sbabook! !!MicSBALaTeXWriter methodsFor: 'accessing'!folderName	^ #latex! !!MicSBALaTeXWriter methodsFor: 'protected'!monospaceMacro	^ 'textcode'! !!MicSBALaTeXWriter methodsFor: 'protected'!optionalParametersForFloatingScript: aCodeBlock	| parameters |	parameters := OrderedCollection new.	parameters add: 'float'.	aCodeBlock hasLabel ifTrue: [ parameters add: 'label=', aCodeBlock label ].	^ parameters asCommaString! !!MicSBALaTeXWriter methodsFor: 'protected'!tabularEnvironment	^ 'fullwidthtabular'! !!MicSBALaTeXWriter methodsFor: 'accessing'!templateForConfiguration: aConfiguration	^ 'main.mustache'! !!MicSBALaTeXWriter methodsFor: 'protected'!visitCode: aCodeBlock		aCodeBlock hasCaption | aCodeBlock hasLabel		ifTrue: [ self writeFloatingCodeSnippet: aCodeBlock ]		ifFalse: [ self writeInFlowCodeSnippet: aCodeBlock ]! !!MicSBALaTeXWriter methodsFor: 'protected'!writeFloatingCodeSnippet: aCodeBlock 	canvas environment		name: 'listing';		optParameter: (self optionalParametersForFloatingScript: aCodeBlock);		"parameter: (self languageForScript: aScript) sbaString;"		flag: #todo;"should come back here"		parameter: 'smalltalk';		parameter: [ aCodeBlock captionElements collect: [ :each | each accept: self ] ];		with: [			self writeRawDuring: [ canvas nextPutAllLines: aCodeBlock body ].			canvas newLine ]! !!MicSBALaTeXWriter methodsFor: 'protected'!writeInFlowCodeSnippet: aCodeBlock	canvas environment		name: 'displaycode';		"parameter: (self languageForScript: aScript) sbaString;"		flag: #todo;"should come back here"		parameter: 'smalltalk';		with: [			self writeRawDuring: [ "there is no need of the writeRaw if I do not call high level " 				canvas nextPutAllLines: aCodeBlock body ].			canvas newLine ]! !!MicLatexPathUpdateVisitor class methodsFor: 'visiting'!isAbstract	^ false! !!MicLatexPathUpdateVisitor class methodsFor: 'visiting'!key	^ #latexPathUpdate! !!MicLatexPathUpdateVisitor class methodsFor: 'visiting'!start: aDocument	^ self new start: aDocument! !!MicLatexPathUpdateVisitor methodsFor: 'instance creation'!newReferenceFor: aReference		^ aReference reference copyReplaceAll: '\' with: '/'! !!MicLatexPathUpdateVisitor methodsFor: 'visiting'!visitFigure: aFigure	aFigure reference: (self newReferenceFor: aFigure).	super visitFigure: aFigure! !!MicLatexPathUpdateVisitor methodsFor: 'unused'!visitInternalLink: anInternalLink	anInternalLink hasReference  		ifTrue: [ anInternalLink reference: (self newReferenceFor: anInternalLink) ].	super visitInternalLink: anInternalLink! !!MicTableBlock methodsFor: '*Microdown-LaTeXExporter'!latexSpecification	^ String new: rows first size withAll: $l! !!MicExportBrush methodsFor: 'initialization'!setStream: aStream	stream := aStream! !!MicLaTeXBrush methodsFor: 'accessing'!optParameter: aStringOrBlock	stream		<< $[		<< aStringOrBlock		<< $]! !!MicLaTeXBrush methodsFor: 'accessing'!parameter: aStringOrBlock	stream		<< ${		<< aStringOrBlock		<< $}! !!MicLaTeXCommand methodsFor: 'accessing'!name: aString 	stream		<< $\		<< aString! !!MicLaTeXEnvironment methodsFor: 'accessing'!name: aString	name := aString.	stream << '\begin{' << aString << '}'! !!MicLaTeXEnvironment methodsFor: 'accessing'!with: aBlock	stream newLine.	aBlock value.	(stream << '\end{' << name)		<< '}';		newLine! !!MicExportCanvas class methodsFor: 'instance creation'!on: aStream 	^ self new		setStream: aStream;		yourself! !!MicExportCanvas methodsFor: 'private'!brush: aBrush	self flush.	currentBrush := aBrush.	aBrush setStream: stream.	^ aBrush! !!MicExportCanvas methodsFor: 'accessing'!contents 	^ stream contents! !!MicExportCanvas methodsFor: 'accessing'!crAsNewLine	stream crAsNewLine! !!MicExportCanvas methodsFor: 'accessing'!crlfAsNewLine	stream crlfAsNewLine! !!MicExportCanvas methodsFor: 'accessing'!flush	stream flush! !!MicExportCanvas methodsFor: 'writing text'!initialize	super initialize.	writingRaw := false! !!MicExportCanvas methodsFor: 'accessing'!lfAsNewLine	stream lfAsNewLine! !!MicExportCanvas methodsFor: 'writing text'!line: aString	self		nextPutAll: aString;		newLine! !!MicExportCanvas methodsFor: 'writing text'!lines: aString	"Output aString and take care of line ending within aString."	| str |	str := aString readStream.	[ str atEnd ] whileFalse: [ | line |		line := str nextLine.		str atEnd			ifTrue: [ self nextPutAll: line ]			ifFalse: [ self line: line ]	 ]! !!MicExportCanvas methodsFor: 'writing text'!newLine	stream newLine! !!MicExportCanvas methodsFor: 'writing text'!nextPut: aCharacter	stream nextPut: aCharacter! !!MicExportCanvas methodsFor: 'writing text'!nextPutAll: aString	aString do: [ :char | self nextPut: char ]! !!MicExportCanvas methodsFor: 'writing text'!nextPutAllLines: aString	self withLinesIn: aString do: [ :line | self nextPutAll: line ] separatedBy: [ self newLine ]! !!MicExportCanvas methodsFor: 'writing text'!raw: aString	stream << aString! !!MicExportCanvas methodsFor: 'writing text'!rawLines: aString	"Output aString and take care of line ending within aString."	self withLinesIn: aString do: [ :line | self raw: line ] separatedBy: [ self newLine ]! !!MicExportCanvas methodsFor: 'initialization'!setStream: aStream 	stream := aStream! !!MicExportCanvas methodsFor: 'writing text'!space	stream space! !!MicExportCanvas methodsFor: 'accessing'!stream	"Pay attention to what you do with this stream. You may break the canvas logic"		^ stream! !!MicExportCanvas methodsFor: 'private'!withLinesIn: aString do: aBlock separatedBy: anotherBlock	"this method shows that the body of code block is weak because it should encapsulate the way it internally represents lines. Now this is exposed in clients."	| str |	str := aString readStream.	[ str atEnd ]		whileFalse: [ 			| line |			line := str nextLine.			aBlock value: line.			str atEnd				ifFalse: anotherBlock ]! !!MicExportCanvas methodsFor: 'writing text'!writingRaw: aBoolean	writingRaw := aBoolean! !!MicLaTeXCanvas class methodsFor: 'class initialization'!initialize	" self initialize "	LatexCharacters := Dictionary new.	LatexCharacters		at: $# put: '\#';		at: $& put: '\&';		at: $% put: '\%';		at: $$ put: '\$';		at: ${ put: '\{';		at: $} put: '\}';		at: $_ put: '\_';		at: $" put: '\symbol{34}';		" -- "		at: $[ put: '{[}';		at: $] put: '{]}';		at: $| put: '\textbar{}';		at: $< put: '\textless{}';		at: $> put: '\textgreater{}';		"at: $/ put: '\slash{}';"		at: $\ put: '\textbackslash{}';		at: $^ put: '\string^';		" -- "		at: $ä put: '\"{a}';		at: $Ä put: '\"{A}';		at: $ë put: '\"{e}';		at: $Ë put: '\"{E}';		at: $ï put: '\"{i}';		at: $Ï put: '\"{I}';		at: $ö put: '\"{o}';		at: $Ö put: '\"{O}';		at: $ü put: '\"{u}';		at: $Ü put: '\"{U}';		at: $ÿ put: '\"{y}';		at: (Character value: 159) put: '\"{Y}';		" -- "		at: $â put: '\^{a}';		at: $Â put: '\^{A}';		at: $ê put: '\^{e}';		at: $Ê put: '\^{E}';		at: $î put: '\^{i}';		at: $Î put: '\^{I}';		at: $ô put: '\^{o}';		at: $Ô put: '\^{O}';		at: $û put: '\^{u}';		at: $Û put: '\^{U}';		" -- "		at: $à put: '\`{a}';		at: $À put: '\`{A}';		at: $è put: '\`{e}';		at: $È put: '\`{E}';		at: $ì put: '\`{i}';		at: $Ì put: '\`{I}';		at: $ò put: '\`{o}';		at: $Ò put: '\`{O}';		at: $ù put: '\`{u}';		at: $Ù put: '\`{U}';		" -- "		at: $á put: '\''{a}';		at: $Á put: '\''{A}';		at: $é put: '\''{e}';		at: $í put: '\''{i}';		at: $Í put: '\''{I}';		at: $ó put: '\''{o}';		at: $Ó put: '\''{O}';		at: $ú put: '\''{u}';		at: $Ú put: '\''{U}';		" -- "		at: $ç put: '\c{c}';		at: $Ç put: '\c{C}';		" -- "		at: $~ put: '\textasciitilde{}';		at: $ñ put: '\~{n}';		at: $Ñ put: '\~{N}'! !!MicLaTeXCanvas methodsFor: 'tags'!command	^ self brush: MicLaTeXCommand new! !!MicLaTeXCanvas methodsFor: 'tags'!environment	^ self brush: MicLaTeXEnvironment new! !!MicLaTeXCanvas methodsFor: 'writing text'!interpretedNextPut: aCharacter	(LatexCharacters at: aCharacter ifAbsent: nil)		ifNil: [ self raw: aCharacter ]		ifNotNil: [ :string | self raw: string ]! !!MicLaTeXCanvas methodsFor: 'writing text'!nextPut: aCharacter	writingRaw 		ifFalse: [ self interpretedNextPut: aCharacter ]		ifTrue: [ self raw: aCharacter ]! !"Microdown-LaTeXExporter"!!MicCSSDownloader commentStamp: '' prior: 0!Helper class to download CSS resources.!!MicCSSEntity commentStamp: '' prior: 0!Provides common support for CSS artifacts, such as frameworks (a.k.a. libraries) or themes.A CSS entity provides:  - A "base path" location.  - The CSS file, which is an instance of `MicCSSFile`  - The CSS URL.  - Its source code String.The basePath defaults to the value in #defaultBasePath (commonly "css/"), however, the location of css files could be changed using the setter #basePath: and a folder `String` as parameter.!!MicCSSFramework commentStamp: '' prior: 0!A Cascading Style Sheets (CSS) **framework** is a library of prepared and ready-to-use standards-compliant CSS rules which implements cross-browser functionality. A Microdown CSS framework represents a library intended to be used as part of setting up a `MicHTMLDoc`. It contains CSS artifacts such as helper classes, typography, structures, equalizers (to create equivalent height content) and reset (browser normalization) resources.It also could have:  - A minified version (usually named as .min.css) where extra comments and white space were removed.  - A normalized URL to apply browser default styling.  - A Collection of fonts URL's. _These should be downloaded manually for now_  - A Collection of themes URL's, which could be minified or normal (human-readable).# UsageTo include a Microdown CSS Framework, send the message #addCSSNamed: with a String representing the name of the framework.```language=PharoMicHTMLDoc new	addCSSNamed: 'AwsmCSS';	fromMicrodown: 'Your Microdown document';	writeToFile.```To query the name of the available frameworks, open the Microdown HTML Styler application, or evaluate:```language=pharoMicCSSProvider new frameworks.```# Internal Representation and Key Implementation Points.Instance Variables	cssFile: 			<MicCSSFile>	cssUrl:			<String>	fonts:				<Collection>	mainUrl:			<String>	minCssUrl:		<String>	name:				<String>	normalizeUrl:	<String>	resetUrl:			<String>	themes:			<Collection>!!MicCSSTheme commentStamp: '' prior: 0!A theme is a variation in style of a CSS framework. Commonly this variation is minimal and mostly used for color schemes such as dark or light. Each theme knows which framework it belongs to.See superclass comments for details.!!MicCSSFile commentStamp: '' prior: 0!It includes behavior to facilitate the handling of CSS files, such as relative paths, copying to other folders, etc.!!MicCSSNullFile commentStamp: '' prior: 0!A special type of Microdown CSS file with contents empty.!!MicCSSProvider commentStamp: '' prior: 0!As there are many CSS frameworks available each with its own set of features, this class implements a helper for clients to obtain, configure, and query `MicCSSFramework`s. Frameworks differ each other in multiple aspects:  - Each one contains an opinionated style.  - They are lower or higher-level, intended to be customized or not.  - Theme provisioning (for example, light & dark modes).  - It may contain fully responsive layout, which optimizes content to different types of screens.  - Is provided through a CDN (Content Delivery Network), which are a set of web servers that can deliver commonly-requested content very quickly all over the world, enabling browser caching and dynamic patching.This class implements behavior to access each framework, and configure its location on the file system. Additionally:  - It contains a list of specifications for each CSS framework in #frameworkSpecs.  - It uses a `MicCSSDownloader` as helper to download resources.   - Try to download both minified and normal versions of the CSS, if possible. In any case, at leat one should be available# Usage## Obtain CSS frameworksTo download a set of pre-defined CSS frameworks, evaluate:```language=PharoMicCSSProvider new installFrameworks.```Currently most downloaded frameworks are class-less CSS.The destination folder where CSS frameworks are downloaded can be configured with #destinationPath:```language=PharoMicCSSProvider new	destinationPath: 'css_libs';	installFrameworks```If not specified, a default destination folder is set automatically.## Querying CSS librariesTo inspect the currently available libraries:```language=PharoMicCSSProvider new frameworks.```To filter CSS Frameworks with themes:```language=PharoMicCSSProvider new frameworks select: #hasThemes.```## Adding a CSS FrameworkTo add a new framework, see the class method #frameworks. At least one of the two following keys must exist: #minCss or #css.### Mandatory Attributes- #minCss : associate to the minified version of the CSS file.- #css : associate to the non-obfuscated, non-minified CSS file.- #repository : associates with a URL string to access the CSS library main repository.### Optional Attributes- #fluidCss : associate to the Fluid CSS resource (a CSS for responsive UIs).- #normalizeCss : associate to the Normalize.CSS library**Important: After adding a CSS framework, do not forget to download it executing #installFrameworks**!!MicHTMLConfiguration commentStamp: '' prior: 0!Handle and provides writing methods of additional information (metadata) of a Microdown HTML document:- A default character set (**charSet**) as UTF-8 by default (**setCharSetUTF8**).- A language (**languageId**) `String` of element's contents (matches the lang attribute in HTML specification).- A title `String` acting as document short explanation.- A `Collection` of Keywords (**keywords**).- A `Collection` of authors (**authors**), each one being a `String`.- A `Boolean` parameter which specifies if the CSS will be embeeded or linked.It also parses Pillar-like headers converting a `Dictionary` of metadata attributes to their equivalent tag in the HTML header.!!MicHTMLDocument commentStamp: '' prior: 0!Represents a Text/HTML file to be displayed in a web browser. It can be created with a CSS style **newWithStyle:**, and passing a `Microdown` content String through **fromMicrodown:** as parameter.## ExampleThe following generates a HTML String from Microdown contents:```language=Pharo(MicHTMLDocument newWithStyle: 'NewCSS') 	fromMicrodown: MicDocFactory exampleMic;	contents.```Select and inspect the following:```language=PharoMicCSSProvider libraryNames.```to see a list of available CSS libraries.## DescriptionA document has multiple primary properties which can be configured:- A **fileName** `String`.- A `Collection` of CSS files to define the look of the document, through **addCSSFile:**.- A destination directory (**destinationDir**) representing the output path of the document.Additional properties, for example those specified in a Microdown header, are translated into HTML meta tags and they are handled in its `MicHTMLConfiguration` object.A Microdown HTML document can receive as input a raw HTML String, without any surrounding header tags, and it builds a header and body tags around it.## InternalsA HTML document uses a canvas which acts as a brush to render content.Internally, it uses a Configuration object (instance of `MicHTMLConfiguration`) to set important HTML properties, prividing widely used defaults:- The viewport, specified in **defaultViewport**, to control layout in mobile browsers.- The language identifier is set by default to 'en' (English).- A subdirectory where the linked CSS files are stored, specified in `MicHTMLDoc >> cssBasePath`.!!MicHTMLStylerApp commentStamp: '' prior: 0!The Spec hook for the Microdown CSS Styler, a tool to configure document export options from Microdown to HTML.See class side to open the UI.!!MicHTMLVisitor commentStamp: '' prior: 0!A first version of an HTML writer. We should rewrite it once the templatedWriter is working.!!MicHTMLStyler commentStamp: '' prior: 0!A Spec user-interface to browse and apply a CSS style to a Microdown document.Evaluate the following expression to open it in a browsing mode (only to view available CSS frameworks):```language=PharoMicHTMLStyler open.```To open on a Microdown document, evaluate:```language=PharoMicHTMLStyler openOn: MicDocFactory exampleMic.```!!MicHTMLStylerAbstractPresenter commentStamp: '' prior: 0!Groups common behavior and provides helpers to access MicHTMLDoc object to subclasses.The **styler** is an instance of `MicHTMLStyler` passed as model before initialization.!!MicHTMLStylerCSSInfoPresenter commentStamp: '' prior: 0!Presents details about the selected CSS library.!!MicHTMLStylerCSSSourcePresenter commentStamp: '' prior: 0!Holds a text presenter to display CSS source, and a status bar indicating the size of the CSS.!!MicHTMLStylerExportOptionsPresenter commentStamp: '' prior: 0!Provide a presenter with destination options for export such as:- Output file name.- Destination path.- Overwrite existing files.!!MicHTMLStylerHTMLOptionsPresenter commentStamp: '' prior: 0!Provides a presenter to configure common export HTML options, for example:- The document type a.k.a DOCTYPE- Include CSS in header.- Set links to open to a new web page.!!MicHTMLStylerHTMLSourcePresenter commentStamp: '' prior: 0!Holds a text presenter to display HTML source, and a status bar indicating the size of the HTML.!!MicHTMLStylerDetailViewsPresenter commentStamp: '' prior: 0!Provides a presenter to display the currently selected CSS library details, such as:- The main project web page.- Themes list.- Minified, Normalize and Reset versions.!!MicHTMLBrush commentStamp: '' prior: 0!I'm an abstract brush dedicated to HTML documents. As of today, the only subclass is the tag brush but we can imagine others (e.g., to write HTML comments).!!MicHTMLTag commentStamp: '' prior: 0!HTML tags are used to delimit the start and end of elements in the markup. An HTML tag is composed of the name of the element, surrounded by angle brackets:```<p class="para">Content</p>```A tag could be:- A start tag: Can have HTML attributes.- An end tag: Has a slash after the opening angle bracket, to distinguish it from the start tag.Note that not all elements require an **end** tag, for example the `<br>` tag.This class contains utility methods to append HTML tags to a stream, and to manage parameters:- #addArguments:- #parameterAt:put:!!MicHTMLCanvas commentStamp: '' prior: 0!A specialized canvas to emit HTML tags.!!MicHTMLStylerCommand commentStamp: '' prior: 0!Abstract command concerning Microdown HTML Styler.!!MicHTMLStylerExportCommand commentStamp: '' prior: 0!A command to write the Microdown input file as HTML.!!MicHTMLStylerHelpCommand commentStamp: '' prior: 0!A command to open a Help window explaining Microdown HTML styler topics.!!MicHTMLStylerOpenCommand commentStamp: '' prior: 0!A simple command to request for open .mic files.!!MicHTMLStylerPreviewCommand commentStamp: '' prior: 0!Command to export the Microdown document to HTML and open a web browser to preview the results.!!MicHTMLStylerQuitCommand commentStamp: '' prior: 0!Command to close the application!!MicHTMLStylerUpdateCommand commentStamp: '' prior: 0!Command to update the application source code and styles!!MicCSSDownloader methodsFor: 'accessing'!cssProvider	"Answer the receiver's <MicCSSProvider>"		^ cssProvider! !!MicCSSDownloader methodsFor: 'accessing'!cssProvider: anObject	cssProvider := anObject! !!MicCSSDownloader methodsFor: 'accessing - downloading'!destinationPath	"Answer a <String> with the location to download the CSS resources"	^ self cssProvider destinationPath! !!MicCSSDownloader methodsFor: 'accessing - downloading'!downloadCSSFramework: cssFramework	"Download a CSS library using information provided in cssFramework method"	self downloadCSSFrameworkFrom: cssFramework minCssUrl.	self downloadCSSFrameworkFrom: cssFramework cssUrl.	cssFramework themes do: [ : cssFrwThemeUrl |		self downloadCSSFrameworkFrom: cssFrwThemeUrl cssUrl.		self downloadCSSFrameworkFrom: cssFrwThemeUrl minCssUrl ].! !!MicCSSDownloader methodsFor: 'accessing - downloading'!downloadCSSFrameworkFrom: anURLString 	| client url dest |	anURLString ifEmpty: [ ^ self ].	url := anURLString asZnUrl.	dest := self destinationPath asFileReference.	dest ensureCreateDirectory.	ZnFileSystemUtils deleteIfExists: dest / url pathSegments last.	(client := self httpClient) 		url: url ;		downloadTo: (dest / url pathSegments last)! !!MicCSSDownloader methodsFor: 'accessing - downloading'!downloadCSSFrameworks	"Download CSS frameworks specified in the receiver's CSS provider"	self frameworks		do: [ : cssFramework | self downloadCSSFramework: cssFramework ]		displayingProgress: 'Downloading CSS frameworks...'.! !!MicCSSDownloader methodsFor: 'accessing'!frameworks	^ self cssProvider frameworks! !!MicCSSDownloader methodsFor: 'accessing - downloading'!httpClient	"Answer a new <ZnClient> configured HTTP client for internal use"	^ ZnClient new		systemPolicy;		signalProgress: true;		ifFail: [ :exception | self error: 'Could not load : ', exception printString ];		yourself! !!MicCSSEntity methodsFor: 'defaults'!basePath	"Answer a <String> with the location where the receiver will be installed"		^ basePath		ifNil: [ basePath := self defaultBasePath ]! !!MicCSSEntity methodsFor: 'accessing'!cssFile	"Answer the receiver's <MicCSSFile>"	^ cssFile contents		ifEmpty: [ minCssFile ]		ifNotEmpty: [ cssFile ]! !!MicCSSEntity methodsFor: 'accessing'!cssFile: anObject	cssFile := anObject! !!MicCSSEntity methodsFor: 'accessing'!cssPath	"Answer a <String> describing the location path for the receiver, including its file name"		^ String streamContents: [ : stream |		stream 			<< self basePath;			<< self cssFile basename ]! !!MicCSSEntity methodsFor: 'accessing'!cssUrl	"Answer a <String> representing the receiver's human-readable CSS URL"	^ cssUrl! !!MicCSSEntity methodsFor: 'accessing'!cssUrl: anObject	cssUrl := anObject! !!MicCSSEntity methodsFor: 'defaults'!defaultBasePath	"Answer a non-empty <String> representing the location where the receiver's files will be written"	^ 'css/'! !!MicCSSEntity methodsFor: 'defaults'!defaultDestinationPath	"Answer a default <String> describing the location where receiver's CSS files are stored"		^ 'support/'! !!MicCSSEntity methodsFor: 'accessing'!destinationPath	"Answer a <String> representing the location used to store the receiver. This location is used as a repository of CSS entities opposed to the #basePath which is the user-location of a specific installation"	^ destinationPath		ifNil: [ destinationPath := self defaultDestinationPath ]! !!MicCSSEntity methodsFor: 'accessing'!destinationPath: anObject	destinationPath := anObject! !!MicCSSEntity methodsFor: 'testing'!hasMinifiedVersion	"Anwswer <true> if the receiver contains a minified version"		^ self minCssUrl notEmpty! !!MicCSSEntity methodsFor: 'testing'!hasNormalVersion	"Anwswer <true> if the receiver contains a normal (human-legible) version"		^ self cssUrl notEmpty! !!MicCSSEntity methodsFor: 'accessing'!minCssFile	"Answer the recceiver's <MicCSSFile>, or nil if absent"	^ minCssFile! !!MicCSSEntity methodsFor: 'accessing'!minCssFile: anObject	minCssFile := anObject! !!MicCSSEntity methodsFor: 'accessing'!minCssUrl	"Answer a <String> with the URL endpoint of the minified source code, or empty if it is not present"	^ minCssUrl		ifNil: [ minCssUrl := String empty ]! !!MicCSSEntity methodsFor: 'accessing'!minCssUrl: anObject	minCssUrl := anObject! !!MicCSSEntity methodsFor: 'accessing - source code'!minifiedSourceCode	"Answer a <String> representing the receiver's minified CSS source version"	^ self minCssFile contents! !!MicCSSEntity methodsFor: 'accessing'!name	"Answer a <String> representing the receiver's name"	^ name! !!MicCSSEntity methodsFor: 'accessing'!name: anObject	name := anObject! !!MicCSSEntity methodsFor: 'instance creation'!newCssFile: frwSpec version: versionSymbol	"Private - Answer a new <MicCSSFile> configured with the CSS URL specified in versionSymbol. If there is no resolvable versionSymbol in frwSpec, answer a new <MicCSSNullFile>"	^ frwSpec 		at: versionSymbol		ifPresent: [ : frwSpecCssUrl | self newCssFileFor: frwSpecCssUrl ]		ifAbsent: [ MicCSSNullFile new  ].! !!MicCSSEntity methodsFor: 'accessing'!newCssFileFor: aCssUrl	^ MicCSSFile new		fileReference: (self destinationPath asFileReference / aCssUrl asZnUrl filename);		yourself! !!MicCSSEntity methodsFor: 'instance creation'!newCssFiles: frwSpec	"Private - Configure receiver's CSS files using specifications in fwrSpec"	self cssFile: (self newCssFile: frwSpec version: #css).	self minCssFile: (self newCssFile: frwSpec version: #minCss)! !!MicCSSEntity methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream 		<< ': ';		<< self name.! !!MicCSSEntity methodsFor: 'accessing - source code'!sourceCode	"Answer a <String> representing the receiver's CSS source"		^ self cssFile contents! !!MicCSSEntity methodsFor: 'accessing'!writeTo: destDirFileRef	"Private - Write receiver's CSS resource into destDirFileRef"	| fullOutputDir |	fullOutputDir := (destDirFileRef ensureCreateDirectory / self basePath) ensureCreateDirectory.	self cssFile copyTo: fullOutputDir / self cssFile basename.! !!MicCSSFramework methodsFor: 'adding'!addTheme: aMicCSSTheme	"Add aMicCSSTheme to the receiver themes. Answer the receiver"		self themes add: aMicCSSTheme! !!MicCSSFramework methodsFor: 'accessing'!fonts	"Answer a <Collection> of receiver's typographies"	^ fonts		ifNil: [ fonts := OrderedCollection new ]! !!MicCSSFramework methodsFor: 'accessing'!fonts: anObject	fonts := anObject! !!MicCSSFramework methodsFor: 'testing'!hasMinifiedThemes	"Answer <true> if the receiver has any minified themes"		^ self themes anySatisfy: #hasMinifiedVersion! !!MicCSSFramework methodsFor: 'testing'!hasNormalThemes	"Answer <true> if the receiver has any human-readable themes"		^ self themes anySatisfy: #hasNormalVersion! !!MicCSSFramework methodsFor: 'testing'!hasThemes	"Answer <true> if the receiver has themes"	^ self themes notEmpty! !!MicCSSFramework methodsFor: 'private'!newCssTheme: themeInfoDict 	"Answer a new <MicCSSTheme> configured with values in aMicCSSTheme"	^ MicCSSTheme new			name: (themeInfoDict at: #name);			newCssFiles: themeInfoDict;			framework: self;			cssUrl: (themeInfoDict at: #css ifAbsent: [ String empty ]);			minCssUrl: (themeInfoDict at: #minCss ifAbsent: [ String empty ]);			yourself! !!MicCSSFramework methodsFor: 'accessing'!normalizeUrl	"Answer a <String> with the URL endpoint of the Normalize library source code, or empty if it is not present"		^ normalizeUrl		ifNil: [ normalizeUrl := String empty ]! !!MicCSSFramework methodsFor: 'accessing'!normalizeUrl: anObject	normalizeUrl := anObject! !!MicCSSFramework methodsFor: 'accessing'!projectUrl	"Answer a <String> representing the receiver's minified CSS URL"		^ projectUrl		ifNil: [ projectUrl := String empty ]! !!MicCSSFramework methodsFor: 'accessing'!projectUrl: anObject	projectUrl := anObject! !!MicCSSFramework methodsFor: 'accessing'!resetUrl	"Answer a <String> with the URL endpoint of a Reset library source code, or empty if it is not present"	^ resetUrl		ifNil: [ resetUrl := String empty ]! !!MicCSSFramework methodsFor: 'accessing'!resetUrl: anObject	resetUrl := anObject! !!MicCSSFramework methodsFor: 'accessing'!themes	"Answer a <Collection> of <MicCSSTheme>"	^ themes		ifNil: [ themes := OrderedCollection new ]! !!MicCSSFramework methodsFor: 'accessing'!themes: aDictionary	"Set the receiver's normal themes according to aDictionary"	themes := OrderedCollection new.	aDictionary associationsDo: [ : themeInfoDict |		themes add: (self newCssTheme: themeInfoDict) ]! !!MicCSSTheme methodsFor: 'accessing'!framework	"Answer the receiver's <MicCSSFramework>"	^ framework! !!MicCSSTheme methodsFor: 'accessing'!framework: aMicCSSFramework	"Set the receiver's <MicCSSFramework>"	framework := aMicCSSFramework! !!MicCSSFile methodsFor: 'accessing'!basename	"Answer a <String> representing the receiver's file name without its path"	^ self fileReference basename! !!MicCSSFile methodsFor: 'accessing'!contents	"Answer a <String> with the receiver's source code"		^ self fileReference contents! !!MicCSSFile methodsFor: 'copying'!copyTo: aFileReference	"Copy the receiver into aFileReference, if the file already exists, notify, delete it and retry"	[ self fileReference copyTo: aFileReference ]	on: FileExists 	do: [ : ex | 		ex printString traceCr.		(aFileReference / self basename) ensureDelete.		ex retry. ]! !!MicCSSFile methodsFor: 'accessing'!fileReference	"Answer the receiver's <FileReference> CSS"	^ fileReference! !!MicCSSFile methodsFor: 'accessing'!fileReference: anObject	fileReference := anObject! !!MicCSSFile methodsFor: 'accessing'!fullName	"Answer a <String> with the full path of the receiver"	^ self fileReference fullName! !!MicCSSFile methodsFor: 'accessing'!relativePath	"Answer a <String> representing the relative path to the receiver"	^ self fileReference path fullName! !!MicCSSNullFile methodsFor: 'accessing'!contents	"Answer a <String> with the receiver's source code"		^ String empty! !!MicCSSProvider class methodsFor: 'accessing'!defaultFramework	"Answer a <String> with the name of the CSS library used as default"	^ 'AwsmCSS'! !!MicCSSProvider class methodsFor: 'instance creation'!forCSSNamed: aString	"Answer the receiver's <MicCSSFramework> matching aString"	| provider |	provider := self new.	^ provider findCssNamed: aString		! !!MicCSSProvider class methodsFor: 'instance creation'!installFrameworks 	<script>	^ self new installFrameworks inspect.! !!MicCSSProvider methodsFor: 'accessing'!cssDownloader	"Answer a <MicCSSDownloader>, a helper to download CSS resources"	^ cssDownloader		ifNil: [ cssDownloader := self newCssDownloader ]! !!MicCSSProvider methodsFor: 'accessing'!cssDownloader: anObject	cssDownloader := anObject! !!MicCSSProvider methodsFor: 'frameworks'!defaultFrameworks	"Answer a <Collection> of available <MicCSSFramework> taken from the receiver's specifications"	^ self frameworksSpecs collect: [ : frwSpec |		self newCssFrameworkFrom: frwSpec ]! !!MicCSSProvider methodsFor: 'accessing'!destinationPath	"Answer a <String> used as location to store the receiver's CSS frameworks"	^ destinationPath		ifNil: [ destinationPath := 'support' ]! !!MicCSSProvider methodsFor: 'accessing'!destinationPath: aPathname	destinationPath := aPathname! !!MicCSSProvider methodsFor: 'initialization'!findCssNamed: aString	"Answer a <MicCSSFramework> matching aString"		^ self frameworks 		detect: [ : framework | framework name = aString ]! !!MicCSSProvider methodsFor: 'frameworks'!frameworks	"Answer a <Collection> of available <MicCSSFramework> taken from the receiver's specifications"	^ frameworks		ifNil: [ frameworks := self defaultFrameworks ]! !!MicCSSProvider methodsFor: 'frameworks'!frameworksSpecs	"Answer a <Collection> of <Array> representing specifications for building CSS framework objects.	Re-execute #installFrameworks after modifying this method."	^ { 		{ 		#name -> 'AttriCSS' .		#minCss -> 'https://raw.githubusercontent.com/raj457036/attriCSS/master/themes/brightlight-green.css' .		#repository -> 'https://github.com/raj457036/attriCSS' .		#themes -> ({ 			{ 			#name -> 	'Brightlight Green' .			#minCss -> 'https://raw.githubusercontent.com/raj457036/attriCSS/master/themes/brightlight-green.css' 			} .			{ 			#name -> 'Dark Fairy Pink' .			#minCss -> 'https://raw.githubusercontent.com/raj457036/attriCSS/master/themes/darkfairy-pink.css' 			} .			{ 			#name -> 'Dark Forest Green' .			#minCss -> 'https://raw.githubusercontent.com/raj457036/attriCSS/master/themes/darkforest-green.css'			} .			{ 			#name -> 'Light Fairy Pink' .			#minCss ->  'https://raw.githubusercontent.com/raj457036/attriCSS/master/themes/lightfairy-pink.css' 			} .			{ 			#name -> 'Midnight Green' .			#minCss -> 'https://raw.githubusercontent.com/raj457036/attriCSS/master/themes/midnight-green.css' 			} } collect: #asDictionary)		} .				{ 		#name -> 'AwsmCSS' .		#css -> 'https://igoradamenko.github.io/awsm.css/css/awsm.css' .		#minCss -> 'https://igoradamenko.github.io/awsm.css/css/awsm.min.css' .		#repository -> 'https://github.com/igoradamenko/awsm.css' .		#themes -> ({			{ 			#name -> 'White' .			#css -> 'https://igoradamenko.github.io/awsm.css/css/awsm_theme_white.css' .			#minCss -> 'https://igoradamenko.github.io/awsm.css/css/awsm_theme_white.min.css'			} .			{ 			#name -> 	'Gondola' .			#css -> 'https://igoradamenko.github.io/awsm.css/css/awsm_theme_gondola.css' .			#minCss -> 'https://igoradamenko.github.io/awsm.css/css/awsm_theme_gondola.min.css' 			} .			{ 			#name -> 'Mischnka' .			#css -> 'https://igoradamenko.github.io/awsm.css/css/awsm_theme_mischka.css' .			#minCss -> 'https://igoradamenko.github.io/awsm.css/css/awsm_theme_mischka.min.css' 			} .			{ 			#name -> 'Big Stone' .			#css -> 'https://igoradamenko.github.io/awsm.css/css/awsm_theme_big-stone.css' .			#minCss -> 'https://igoradamenko.github.io/awsm.css/css/awsm_theme_big-stone.min.css'			} .			{ 			#name -> 'Black' .			#css -> 'https://igoradamenko.github.io/awsm.css/css/awsm_theme_black.css' .			#minCss -> 'https://igoradamenko.github.io/awsm.css/css/awsm_theme_black.min.css'			} .			{ 			#name -> 'Tasman' .			#css -> 'https://igoradamenko.github.io/awsm.css/css/awsm_theme_tasman.css' .			#minCss -> 'https://igoradamenko.github.io/awsm.css/css/awsm_theme_tasman.min.css'			} .			{ 			#name -> 'Pastel Pink' .			#css -> 'https://igoradamenko.github.io/awsm.css/css/awsm_theme_pastel-pink.css' .			#minCss -> 'https://igoradamenko.github.io/awsm.css/css/awsm_theme_pastel-pink.min.css' 			} .			{ 			#name -> 'Pearl Lusta' .			#css -> 'https://igoradamenko.github.io/awsm.css/css/awsm_theme_pearl-lusta.css' .			#minCss -> 'https://igoradamenko.github.io/awsm.css/css/awsm_theme_pearl-lusta.min.css'			 } } collect: #asDictionary)		} .		{ 		#name -> 'Axist' .		#minCss -> 'https://unpkg.com/axist@latest/dist/axist.min.css' .		#repository -> 'https://github.com/ruanmartinelli/axist'		} .				{ 		#name -> 'Chota' .			#minCss -> 'https://unpkg.com/chota@0.8.0/dist/chota.min.css' .		#repository -> 'https://github.com/jenil/chota'		} .				{ 		#name -> 'ClasslessCSS' .			#css -> 'https://classless.de/classless.css' .		#minCss -> 'https://classless.de/classless-tiny.css' .		#repository -> 'https://github.com/emareg/classlesscss' .		#themes -> ({ 			{ 			#name -> 'Theme' . 			#css -> 'https://classless.de/addons/themes.css'			} } collect: #asDictionary)		} .				{ 		#name -> 'ConcreteCSS' .			#css -> 'https://unpkg.com/concrete.css' .		#normalizeCss -> 'https://unpkg.com/normalize.css' .		#repository -> 'https://github.com/louismerlin/concrete.css'		} .				{ 		#name -> 'MercuryCSS' .		#minCss -> 'https://raw.githubusercontent.com/wmeredith/MercuryCSS/master/css/min/mercury.min.css' .		#normalizeCss -> 'https://raw.githubusercontent.com/wmeredith/MercuryCSS/master/css/min/normalize.min.css' .		#repository -> 'https://github.com/wmeredith/MercuryCSS'		} .				{ 		#name -> 'MVP' .			#css -> 'https://raw.githubusercontent.com/andybrewer/mvp/master/mvp.css' .		#repository -> 'https://github.com/andybrewer/mvp'		} .				{ 		#name -> 'NewCSS' .			#minCss -> 'https://cdn.jsdelivr.net/npm/@exampledev/new.css@1/new.min.css' .		#repository -> 'https://github.com/xz/new.css' .		#themes -> ({ 			{ 			#name -> 'Night' .			#css -> 'https://newcss.net/theme/night.css'			} .			{ 			#name -> 'Terminal' .			#css ->  'https://newcss.net/theme/terminal.css'			}			} collect: #asDictionary)		} .				{ 		#name -> 'PicnicCSS' .			#css -> 'https://cdn.jsdelivr.net/npm/picnic@7.1.0/picnic.css' .		#repository -> 'https://github.com/franciscop/picnic'		} .				{ 		#name -> 'Sakura' .			#css -> 'https://raw.githubusercontent.com/oxalorg/sakura/master/css/sakura.css' .		#repository -> 'https://github.com/oxalorg/sakura'		} .				{ 		#name -> 'SimpleCSS' .			#minCss -> 'https://cdn.simplecss.org/simple.min.css' .		#css -> 'https://cdn.simplecss.org/simple.css' .		#repository -> 'https://github.com/kevquirk/simple.css'		} .				{ 		#name -> 'SpCSS' .			#minCss -> 'https://raw.githubusercontent.com/susam/spcss/main/sp.min.css' .		#css -> 'https://cdn.jsdelivr.net/npm/spcss' .		#repository -> 'https://github.com/susam/spcss'		} .				{ 		#name -> 'Splendor' .			#minCss -> 'https://raw.githubusercontent.com/markdowncss/splendor/master/css/splendor.min.css' .		#repository -> 'https://github.com/markdowncss/splendor'		} .				{ 		#name -> 'StylizeCSS' .			#minCss -> 'https://raw.githubusercontent.com/vasanthv/stylize.css/master/stylize.min.css' .		#css -> 'https://raw.githubusercontent.com/vasanthv/stylize.css/master/stylize.css' .		#repository -> 'https://github.com/vasanthv/stylize.css'		} .				{ 		#name -> 'Tufte' .			#minCss -> 'https://raw.githubusercontent.com/edwardtufte/tufte-css/gh-pages/tufte.min.css' .		#repository -> 'https://github.com/edwardtufte/tufte-css' .		#fontsDir -> 'https://github.com/edwardtufte/tufte-css/tree/gh-pages/et-book'		} .				{ 		#name -> 'W3C' .			#css -> 'https://www.w3.org/StyleSheets/Core/Modernist.css' .		#repository -> 'https://www.w3.org/StyleSheets/Core/Overview'		} .				{ 		#name -> 'WaterCSS' .			#minCss -> 'https://cdn.jsdelivr.net/npm/water.css@2/out/water.min.css' .		#repository -> 'https://github.com/kognise/water.css' .		#themes -> ({			{ 			#name -> 'Dark' . 			#minCss -> 'https://cdn.jsdelivr.net/npm/water.css@2/out/dark.min.css' 			} .			{ 			#name -> 'Light' .			#minCss -> 'https://cdn.jsdelivr.net/npm/water.css@2/out/light.min.css' 			} } collect: #asDictionary)		} .				{ 		#name -> 'Wing' .			#minCss -> 'https://unpkg.com/wingcss@1.0.0-beta/dist/wing.min.css' .		#repository -> 'https://github.com/kbrsh/wing'		} .				{ 		#name -> 'Yorha' .			#minCss -> 'https://raw.githubusercontent.com/metakirby5/yorha/master/dist/yorha.min.css' .		#css -> 'https://raw.githubusercontent.com/metakirby5/yorha/master/dist/yorha.css' .		#repository -> 'https://github.com/metakirby5/yorha'		} .				{ 		#name -> 'LaTeX' .		#css -> 'https://latex.vercel.app/style.css' .		#minCss -> 'https://unpkg.com/latex.css/style.min.css' .		#repository -> 'https://github.com/vincentdoerig/latex-css' 		}			} collect: #asDictionary! !!MicCSSProvider methodsFor: 'testing'!hasFrameworksInstalled	"Answer <true> if frameworks has been installed in the receiver's destination path"		| destFileRef |		destFileRef := self destinationPath asFileReference.	^ destFileRef exists and: [ destFileRef entries anySatisfy: [ : entry | entry reference extension = 'css' ] ]! !!MicCSSProvider methodsFor: 'accessing'!installFrameworks	"Download CSS libraries to local system"	self destinationPath asFileReference exists		ifTrue: [ self destinationPath asFileReference ensureDeleteAll ].	self cssDownloader downloadCSSFrameworks! !!MicCSSProvider methodsFor: 'accessing'!newCssDownloader	"Answer a new <MicCSSDownloader> configured to download resources in the receiver's destination directory"	^ MicCSSDownloader new		cssProvider: self;		yourself! !!MicCSSProvider methodsFor: 'private'!newCssFrameworkFrom: frwSpec	^ MicCSSFramework new		name: (frwSpec at: #name);		newCssFiles: frwSpec;		destinationPath: self destinationPath;				projectUrl: (frwSpec at: #repository);		cssUrl: (frwSpec at: #css ifAbsent: [ String empty ]);		minCssUrl: (frwSpec at: #minCss ifAbsent: [ String empty ]);		normalizeUrl: (frwSpec at: #normalizeCss ifAbsent: [ String empty ]);		resetUrl: (frwSpec at: #resetUrl ifAbsent: [ String empty ]);		themes: (frwSpec at: #themes ifAbsent: [ OrderedCollection empty ]);		fonts: (frwSpec at: #fontsDir ifAbsent: [ OrderedCollection empty ]);		yourself! !!MicHTMLConfiguration methodsFor: 'accessing'!author	"Answer a <String> representing the author of the receiver"		^ author		ifNil: [ author := String empty ]! !!MicHTMLConfiguration methodsFor: 'accessing'!author: anObject	author := anObject! !!MicHTMLConfiguration methodsFor: 'writing - css'!beCssEmbedded	"Answer the receiver. Set CSS to be inserted into its the receiver's document"	embeedCss := true! !!MicHTMLConfiguration methodsFor: 'writing - css'!beCssLinked	"Answer the receiver. Link CSS in the receiver's document"	embeedCss := false! !!MicHTMLConfiguration methodsFor: 'accessing - robots'!beRobotFollow	"Instruct search engines to follow all the links in the receiver's document"		self robots add: 'follow'! !!MicHTMLConfiguration methodsFor: 'accessing - robots'!beRobotIndex	"Instruct search engines to index the whole receiver's document"		self robots add: 'index'! !!MicHTMLConfiguration methodsFor: 'accessing - robots'!beRobotNoArchive	"Instruct search engines to NOT show a cached copy of the receiver's document"		self robots add: 'noarchive'! !!MicHTMLConfiguration methodsFor: 'accessing - robots'!beRobotNoCache	"Same as noarchive but only used by MSN/Live"		self robots add: 'nocache'! !!MicHTMLConfiguration methodsFor: 'accessing - robots'!beRobotNoFollow	"Instruct search engines to NOT follow all the links in the receiver's document"		self robots add: 'nofollow'! !!MicHTMLConfiguration methodsFor: 'accessing - robots'!beRobotNoImageIndex	"Instruct search engines to NOT index the images in the receiver's document"		self robots add: 'noimageindex'! !!MicHTMLConfiguration methodsFor: 'accessing - robots'!beRobotNoIndex	"Instruct search engines to NOT index the whole receiver's document"		self robots add: 'noindex'! !!MicHTMLConfiguration methodsFor: 'accessing - robots'!beRobotNoSnippet	"Prevents the search engines from showing a text or video snippet of this page in the search results, and prevents them from showing a cached copy of this page in their search results listings"		self robots add: 'nosnippet'! !!MicHTMLConfiguration methodsFor: 'accessing - robots'!beRobotNoTranslate	"Prevents search engines from showing translations of the page in their search results"		self robots add: 'notranslate'! !!MicHTMLConfiguration methodsFor: 'accessing - links'!beTargetAttributeBlank	"Opens the linked document in a new window or tab (Microdown default)"		self targetAttribute: '_blank'! !!MicHTMLConfiguration methodsFor: 'accessing - links'!beTargetAttributeParent	"Opens the linked document in the parent frame"		self targetAttribute: '_parent'! !!MicHTMLConfiguration methodsFor: 'accessing - links'!beTargetAttributeSelf	"Opens the linked document in the same frame as it was clicked (W3C default)"		self targetAttribute: '_self'! !!MicHTMLConfiguration methodsFor: 'accessing - links'!beTargetAttributeTop	"Opens the linked document in the full body of the window"		self targetAttribute: '_top'! !!MicHTMLConfiguration methodsFor: 'accessing'!canvas	"Answer the receiver's document <MicHTMLCanvas>"	^ self document canvas! !!MicHTMLConfiguration methodsFor: 'accessing'!charSet	"Answer a <String> with specifies the character encoding for the HTML document"	^ charSet! !!MicHTMLConfiguration methodsFor: 'accessing'!charSet: anObject	charSet := anObject! !!MicHTMLConfiguration methodsFor: 'writing - css'!cssFrameworks	"Answer the receiver's <Collection> of <MicCSSEntity>"		^ self document cssFrameworks! !!MicHTMLConfiguration methodsFor: 'accessing'!date	"Answer a <String> describing the receiver's date"	^ date! !!MicHTMLConfiguration methodsFor: 'accessing'!date: anObject	date := anObject! !!MicHTMLConfiguration methodsFor: 'defaults'!defaultCharset	"Answer a <String> representing the default character set used in a HTML document"		^ 'utf-8'! !!MicHTMLConfiguration methodsFor: 'initialization'!defaultDocumentType	"Answer a <String> specifying the mandatory document specification tag"	^ '<!!DOCTYPE html>'! !!MicHTMLConfiguration methodsFor: 'defaults'!defaultLanguageId	^ 'en'! !!MicHTMLConfiguration methodsFor: 'defaults'!defaultScriptLanguage	"Answer a <PRAbstractScriptLanguage>"	^ PRRealScriptLanguage for: 'pharo'! !!MicHTMLConfiguration methodsFor: 'defaults'!defaultTargetAttribute	"By default, opens the linked document in a new window or tab"	^ '_blank'! !!MicHTMLConfiguration methodsFor: 'defaults'!defaultTitle	^ 'Untitled document'! !!MicHTMLConfiguration methodsFor: 'defaults'!defaultViewport	"Answer a <String> to give the browser instructions on how to control the page's dimensions and scaling"	^ 'width=device-width,initial-scale=1.0,user-scalable=yes'! !!MicHTMLConfiguration methodsFor: 'accessing'!description	"Answer a <String> which define a description for the receiver"		^ description		ifNil: [ description := String empty ]! !!MicHTMLConfiguration methodsFor: 'accessing'!description: anObject	description := anObject! !!MicHTMLConfiguration methodsFor: 'accessing'!document	"Answer a <MicHTMLDocument> if configured, or nil otherwise"	^ document! !!MicHTMLConfiguration methodsFor: 'accessing'!document: anObject	document := anObject! !!MicHTMLConfiguration methodsFor: 'private'!documentType	"Answer a <String> specifying the mandatory document specification tag"		^ documentType		ifNil: [ documentType := self defaultDocumentType ]! !!MicHTMLConfiguration methodsFor: 'accessing'!documentType: anObject	documentType := anObject! !!MicHTMLConfiguration methodsFor: 'initialization'!initialize		super initialize.	self beCssLinked! !!MicHTMLConfiguration methodsFor: 'testing'!isCssEmbedded	^ embeedCss! !!MicHTMLConfiguration methodsFor: 'accessing'!keywords	"Answer a <Collection> of <String> which define keywords for search engines"		^ keywords		ifNil: [ keywords := OrderedCollection new ]! !!MicHTMLConfiguration methodsFor: 'accessing'!keywords: anObject	keywords := anObject! !!MicHTMLConfiguration methodsFor: 'accessing'!languageId	"Answer a <String> representing the target language of the receiver"		^ languageId		ifNil: [ languageId := self defaultLanguageId ]! !!MicHTMLConfiguration methodsFor: 'accessing'!languageId: anObject	languageId := anObject! !!MicHTMLConfiguration methodsFor: 'private'!metadataSelectorMap	"Answer a <Dictionary> mapping Pillar metadata keys to receiver's selectors. Corresponding methods will use the meta HTML tag and write its parameter as value"	^ { 		'description' -> #description: .		'title' -> #title: .		'author' -> #author: .		'attribution' -> #author: .		'date' -> #date:	} asDictionary! !!MicHTMLConfiguration methodsFor: 'accessing - robots'!robots	"Answer a <Collection> of <String> with information to control how the receiver's document should be indexed and served"	^ robots		ifNil: [ robots := OrderedCollection new ]! !!MicHTMLConfiguration methodsFor: 'accessing'!scriptLanguage	^ scriptLanguage! !!MicHTMLConfiguration methodsFor: 'accessing'!scriptLanguage: anObject	scriptLanguage := anObject! !!MicHTMLConfiguration methodsFor: 'accessing - links'!targetAttribute	"Answer a <String>. The target attribute specifies where to open the linked document."	^ targetAttribute		ifNil: [ targetAttribute := self defaultTargetAttribute ]! !!MicHTMLConfiguration methodsFor: 'accessing - links'!targetAttribute: aString	"Set the receiver's target to be aString"		targetAttribute := aString! !!MicHTMLConfiguration methodsFor: 'accessing'!title	"Answer a <String> representing the required title element"		^ title		ifNil: [ title := self defaultTitle ]! !!MicHTMLConfiguration methodsFor: 'accessing'!title: anObject	title := anObject! !!MicHTMLConfiguration methodsFor: 'accessing'!viewport	^ viewport 		ifNil: [ viewport := self defaultViewport ]! !!MicHTMLConfiguration methodsFor: 'accessing'!viewport: anObject	viewport := anObject! !!MicHTMLConfiguration methodsFor: 'writing - css'!writeCssEmbeed	self canvas tag		name: 'style';		parameterAt: 'type' put: 'text/css';		with: ((self cssFrameworks collect: #sourceCode) joinUsing: Character cr).! !!MicHTMLConfiguration methodsFor: 'writing - css'!writeCssLinked	"Add linked CSS resources to the receiver. This does not guarantee the CSS file exists, it only appends the tag to the document header"		self cssFrameworks do: [ : cssFramework | 		self canvas tag			name: 'link';			parameterAt: 'rel' put: 'stylesheet';			parameterAt: 'href' put: cssFramework cssPath;			close ]! !!MicHTMLConfiguration methodsFor: 'writing - metadata'!writeDocumentAuthor	"Set the receiver's authors, who write the content of the document"		self canvas tag		name: 'meta';		parameterAt: 'name' put: 'author';		parameterAt: 'content' put: self author;		close! !!MicHTMLConfiguration methodsFor: 'writing - css'!writeDocumentCSS	"Add linked CSS resources to the receiver"	self isCssEmbedded		ifFalse: [ self writeCssLinked ]		ifTrue: [ self writeCssEmbeed ]! !!MicHTMLConfiguration methodsFor: 'writing - metadata'!writeDocumentCharSet	"Write the character encoding for the receiver"	self canvas tag		name: 'meta';		parameterAt: 'http-equiv' put: 'Content-Type';		parameterAt: 'content' put: 'text/html; charset=' , self document charSet;		close.! !!MicHTMLConfiguration methodsFor: 'writing - metadata'!writeDocumentDate	"Set the receiver's authors, who write the content of the document"		self canvas tag		name: 'meta';		parameterAt: 'name' put: 'date';		parameterAt: 'content' put: self date;		close! !!MicHTMLConfiguration methodsFor: 'writing - metadata'!writeDocumentDescription	"Write a description for the receiver"	self canvas tag		name: 'description';		parameterAt: 'content' put: self description;		close.! !!MicHTMLConfiguration methodsFor: 'writing - metadata'!writeDocumentGenerator	"Write the automation tool used to generate the page content"	self canvas tag		name: 'meta';		parameterAt: 'name' put: 'generator';		parameterAt: 'content' put: 'Microdown';		close.! !!MicHTMLConfiguration methodsFor: 'writing'!writeDocumentHead	self canvas tag		name: 'head';		with: [ 			self 				writeDocumentMetadata;				writeDocumentTitle;				writeDocumentCSS ]! !!MicHTMLConfiguration methodsFor: 'writing - metadata'!writeDocumentKeywords	"Set the receiver's page-related keywords, which help for better ranking on search engines"	self canvas tag		name: 'meta';		parameterAt: 'name' put: 'keywords';		parameterAt: 'content' put: self keywords;		close! !!MicHTMLConfiguration methodsFor: 'writing - metadata'!writeDocumentMetadata	self 		writeDocumentCharSet;		writeDocumentGenerator;		writeDocumentViewport! !!MicHTMLConfiguration methodsFor: 'writing - metadata'!writeDocumentRobots	"Set the receiver's robot’s values, which gives instructions to search engines how the web page should be indexed or not"		self canvas tag		name: 'meta';		parameterAt: 'name' put: 'robots';		parameterAt: 'content' put: (self robots joinUsing: ', ');		close! !!MicHTMLConfiguration methodsFor: 'writing'!writeDocumentTitle	"Write the mandatory title tag which defines the title of the receiver"	self canvas tag		name: 'title';		with: self title! !!MicHTMLConfiguration methodsFor: 'writing'!writeDocumentType	"Write the mandatory DOCTYPE HTML declaration in the receiver"	self canvas raw: self documentType! !!MicHTMLConfiguration methodsFor: 'writing - metadata'!writeDocumentViewport	"Set the receiver's visible area to look good on all devices"		self canvas tag		name: 'meta';		parameterAt: 'name' put: 'viewport';		parameterAt: 'content' put: self viewport;		close! !!MicHTMLConfiguration methodsFor: 'writing'!writeFromMetadataAssociation: anAssociation 	anAssociation key = 'metadata'		ifTrue: [ self writeHeaderFromMetadata: anAssociation value ]		ifFalse: [ self writeHeaderFromMetadataAssociation: anAssociation ]! !!MicHTMLConfiguration methodsFor: 'private'!writeHeaderFromMetadata: aDictionary 	aDictionary associationsDo: [ : assoc |		self writeHeaderFromMetadataAssociation: assoc ]! !!MicHTMLConfiguration methodsFor: 'private'!writeHeaderFromMetadataAssociation: anAssociation 	self metadataSelectorMap associationsDo: [ : metaSelectorPair | 			metaSelectorPair key = anAssociation key asLowercase				ifTrue: [ self perform: metaSelectorPair value with: anAssociation value ] ]! !!MicHTMLDocument class methodsFor: 'initialization'!newWithStyle: aStyleName	"Answer a new HTML document styled with aStyleName <String>"	^ self new		addCSSNamed: aStyleName;		yourself! !!MicHTMLDocument methodsFor: 'accessing - css'!addCSS: aMicCSSEntity	"Add a <aMicCSSEntity> to the receiver's linked CSS resources. Answer a <MicCSSFramework>"		^ self cssFrameworks add: aMicCSSEntity! !!MicHTMLDocument methodsFor: 'accessing - css'!addCSSNamed: aString	"Add a <MicCSSProvider> named aString to the receiver's linked CSS resources. Answer a <MicCSSFramework>"		^ self cssFrameworks add: (MicCSSProvider forCSSNamed: aString)! !!MicHTMLDocument methodsFor: 'accessing'!author	"Refer to comment in MicHTMLConfiguration>>author"		^ self configuration author! !!MicHTMLDocument methodsFor: 'accessing'!author: aString	"Refer to comment in MicHTMLConfiguration>>author:"		^ self configuration author: aString! !!MicHTMLDocument methodsFor: 'accessing - css'!beCssEmbedded	"Set the receiver to embeed its CSS"	self configuration beCssEmbedded! !!MicHTMLDocument methodsFor: 'accessing - css'!beCssLinked	"Set the receiver to embeed its CSS"	self configuration beCssLinked! !!MicHTMLDocument methodsFor: 'accessing'!canvas	^ canvas! !!MicHTMLDocument methodsFor: 'accessing'!canvas: anObject	canvas := anObject! !!MicHTMLDocument methodsFor: 'private'!canvasClass	^ MicHTMLCanvas! !!MicHTMLDocument methodsFor: 'accessing'!charSet	"Answer a <String> with specifies the character encoding for the HTML document"	^ self configuration charSet! !!MicHTMLDocument methodsFor: 'accessing'!charSet: anObject	self configuration charSet: anObject! !!MicHTMLDocument methodsFor: 'accessing'!configuration	"Answer the receiver's <MicHTMLConfiguration>"	^ configuration! !!MicHTMLDocument methodsFor: 'accessing'!configuration: anObject	configuration := anObject! !!MicHTMLDocument methodsFor: 'accessing'!contents	"Update the document with the canvas contents and answer the HTML"	^ canvas contents! !!MicHTMLDocument methodsFor: 'accessing - css'!cssFrameworks	"Answer a <Collection> of <String> each one representing a path to a CSS file"		^ cssFrameworks		ifNil: [ cssFrameworks := OrderedCollection new ]! !!MicHTMLDocument methodsFor: 'accessing'!description	"Refer to comment in MicHTMLConfiguration>>description"		^ self configuration description! !!MicHTMLDocument methodsFor: 'accessing'!description: aString	"Refer to comment in MicHTMLConfiguration>>description:"		^ self configuration description: aString! !!MicHTMLDocument methodsFor: 'accessing'!destinationPath	"Answer a <String> specifying the destination directory where receiver's output is written"	^ destinationDir		ifNil: [ destinationDir := 'output' ]! !!MicHTMLDocument methodsFor: 'accessing'!destinationPath: anObject	destinationDir := anObject! !!MicHTMLDocument methodsFor: 'accessing'!documentType	"Refer to comment in MicHTMLConfiguration>>documentType"		^ self configuration documentType! !!MicHTMLDocument methodsFor: 'accessing'!documentType: aString	"Refer to comment in MicHTMLConfiguration>>documentType:"		^ self configuration documentType: aString! !!MicHTMLDocument methodsFor: 'testing'!exists	"Answer <true> if receiver exists as a file"		^ self fullName asFileReference exists! !!MicHTMLDocument methodsFor: 'accessing'!fileName	"Answer a <String> representing the basename for the receiver when written to disk"		^ fileName 		ifNil: [ fileName := 'index.html' ]! !!MicHTMLDocument methodsFor: 'accessing'!fileName: anObject	fileName := anObject! !!MicHTMLDocument methodsFor: 'accessing'!flush	"Write the receiver's contents to a file. If there is no file name, then assign a temporary file name and write contents"		self fileName ifNil: [ self fileName: self tempFileName ].	(self destinationPath asFileReference / self fileName)		ensureCreateFile;		writeStreamDo: [ : fileStream | 			fileStream 				nextPutAll: self contents; 				flush ]! !!MicHTMLDocument methodsFor: 'accessing'!fromMicrodown: aMicrodownString	"Convert to HTML and wrap aMicrodownString in the receiver's HTML stream"	self initializeCanvas.	self writeDocument: (Microdown 		asHTMLString: aMicrodownString 		configuration: self configuration)! !!MicHTMLDocument methodsFor: 'accessing'!fullName	"Return the full path name of the receiver."		^ (self destinationPath asFileReference / self fileName) fullName ! !!MicHTMLDocument methodsFor: 'initialization'!initialize		super initialize.	self configuration: (MicHTMLConfiguration new 		document: self;		yourself).		self setCharSetUTF8.	self initializeCanvas.! !!MicHTMLDocument methodsFor: 'initialization'!initializeCanvas	canvas := self canvasClass new.! !!MicHTMLDocument methodsFor: 'accessing'!keywords	"Refer to comment in MicHTMLConfiguration>>keywords"		^ self configuration keywords! !!MicHTMLDocument methodsFor: 'accessing'!keywords: aCollection	"Refer to comment in MicHTMLConfiguration>>keywords:"		^ self configuration keywords: aCollection! !!MicHTMLDocument methodsFor: 'accessing'!languageId	"Refer to comment in MicHTMLConfiguration>>languageId"		^ self configuration languageId! !!MicHTMLDocument methodsFor: 'accessing'!languageId: aString	"Refer to comment in MicHTMLConfiguration>>languageId:"		^ self configuration languageId: aString! !!MicHTMLDocument methodsFor: 'accessing'!newMicStreamOn: aString	"Answer a new wrapper over aString to help not hardcoding line ending everywhere."	^ MicOutputStream new 		setStream: (WriteStream on: String empty);		nextPutAll: aString;		yourself! !!MicHTMLDocument methodsFor: 'accessing - css'!removeCSSNamed: aString	"Remove <MicCSSFramework> named aString from the receiver's linked CSS resources"		self cssFrameworks remove: aString! !!MicHTMLDocument methodsFor: 'writing'!serializeHtml: aFilename in: destDirFileRef	"Private - Serialize the receiver's into aFilename in destDirFileRef <FileReference>"	self fileName: aFilename.	(destDirFileRef resolveString: aFilename) 		ensureDelete;		ensureCreateFile.	self flush.! !!MicHTMLDocument methodsFor: 'writing - metadata'!setCharSetUTF8	self charSet: 'utf-8'! !!MicHTMLDocument methodsFor: 'accessing'!tempFileName	"Answer a <String> representing a random file in a temporary location in the receiver's file system"	^ String streamContents: [ : str | 		str 			<< FileLocator temp fullName;			<< DiskStore delimiter asString;			<< UUIDGenerator new next asString36;			<< '.html' ]! !!MicHTMLDocument methodsFor: 'accessing'!title	"Refer to comment in MicHTMLConfiguration>>title"		^ self configuration title! !!MicHTMLDocument methodsFor: 'writing'!writeDocument: aHTMLString	"Write markup from anHTMLString to the receiver's body part"	self configuration writeDocumentType.	canvas tag		name: 'html';		parameterAt: 'lang' put: self languageId;		with: [ 			self configuration writeDocumentHead.			self writeDocumentBody: aHTMLString ].	self flush.! !!MicHTMLDocument methodsFor: 'writing'!writeDocumentBody: aHTMLString	"Write aHTMLString representing a valid HTML body for the receiver"	canvas tag		name: 'body';		with: [ 			canvas tag 				name: 'main';				parameterAt: 'role' put: 'main';				with: aHTMLString ]! !!MicHTMLDocument methodsFor: 'writing'!writeToFile	"Write the receiver's contents to the default file name"	self writeToFileNamed: self fileName! !!MicHTMLDocument methodsFor: 'writing'!writeToFileNamed: aFilename	"Ensure a new file named aFilename and write the receiver's contents into it"	| destDirFileRef |		destDirFileRef := self destinationPath asFileReference.	self serializeHtml: aFilename in: destDirFileRef.	self cssFrameworks do: [ : cssEntity | cssEntity writeTo: destDirFileRef ].! !!MicHTMLStylerApp class methodsFor: 'instance creation'!menuCommandOn: aBuilder	<worldMenu>	(aBuilder item: #'Microdown HTML Styler')		parent: #Tools;		action: [ self new run ];		icon: (self iconNamed: self taskbarIconName)! !!MicHTMLStylerApp class methodsFor: 'instance creation'!open	<script>	self new run! !!MicHTMLStylerApp methodsFor: 'accessing'!start	" Private - See superimplementor's comment "	(MicHTMLStyler newApplication: self) open.! !!MicHTMLVisitor class methodsFor: 'converting'!asHTMLDocument: aMicrodownString	"Answer a <String> formatted as HTML with UTF-8 encoding from aMicrodownString as input"	^ self new convertMicStringToDoc: aMicrodownString! !!MicHTMLVisitor class methodsFor: 'converting'!asHTMLString: aMicrodownString	"Answer a <String> formatted as HTML from aMicrodownString as input"	^ self new convertMicString: aMicrodownString! !!MicHTMLVisitor class methodsFor: 'converting'!asHTMLString: aMicrodownString configuration: aMicHTMLConfiguration	"Answer a <String> formatted as HTML from aMicrodownString as input"	^ self new 		configuration: aMicHTMLConfiguration;		convertMicString: aMicrodownString! !!MicHTMLVisitor class methodsFor: 'examples'!exampleHTMLDocument	<example>		^ (Microdown asHTMLDocument: MicMicrodownSnippetFactory buildDocument) inspect.! !!MicHTMLVisitor class methodsFor: 'examples'!exampleHTMLDocumentWithFigure	<example>		^ (Microdown asHTMLDocument: '!![AltText](my_directory/image.png label=42&width=90)') inspect.! !!MicHTMLVisitor class methodsFor: 'examples'!exampleHTMLDocumentWithLink	<example>		^ (Microdown asHTMLDocument: '[Pharo Website](http://pharo.org target=blank&rel=bookmark)') inspect.! !!MicHTMLVisitor class methodsFor: 'examples'!exampleHTMLString	<example>		^ (Microdown asHTMLString: MicMicrodownSnippetFactory buildDocument) inspect.! !!MicHTMLVisitor class methodsFor: 'examples'!exampleHTMLStringWithLink	<example>		^ (Microdown asHTMLString: '[Pharo Website](http://pharo.org target=_blank&rel=bookmark)') inspect.! !!MicHTMLVisitor class methodsFor: 'converting'!serializeToHTMLDoc: aMicrodownString	"Serialize aMicrodownString <String> to a HTML file with default for output name, directory and CSS"	self		serializeToHTMLDoc: aMicrodownString		withStyle: MicCSSProvider defaultFramework! !!MicHTMLVisitor class methodsFor: 'converting'!serializeToHTMLDoc: aMicrodownString withStyle: aStyleName	"Serialize aMicrodownString <String> to a HTML file with CSS style named aStyleName and default for output directory and file name"	MicHTMLDocument new		addCSSNamed: aStyleName;		fromMicrodown: aMicrodownString;		writeToFile! !!MicHTMLVisitor methodsFor: 'initialization'!canvasClass	^ MicHTMLCanvas! !!MicHTMLVisitor methodsFor: 'accessing'!configuration	^ configuration		ifNil: [ configuration := MicHTMLConfiguration new ]! !!MicHTMLVisitor methodsFor: 'accessing'!configuration: anObject	configuration := anObject! !!MicHTMLVisitor methodsFor: 'accessing'!contents 	"Answer a <String> of HTML formatted receiver's canvas"	^ canvas contents! !!MicHTMLVisitor methodsFor: 'converting'!convertMicFile: aFilename	| fileRef |	fileRef := aFilename asFileReference.	self visit: (Microdown parse: fileRef contents).	(fileRef parent / (fileRef basenameWithoutExtension: 'md') , 'html') asFileReference 		writeStreamDo: [ : writeStream | writeStream nextPutAll: self contents ]! !!MicHTMLVisitor methodsFor: 'converting'!convertMicString: aMicString	"Answer a <String> representing the HTML equivalent of Microdown formatted aMicString "	self visit: (Microdown parse: aMicString).	^ self contents! !!MicHTMLVisitor methodsFor: 'converting'!convertMicStringToDoc: aMicString	"Answer a <String> representing the HTML equivalent of Microdown formatted aMicString "	self visit: (Microdown parse: aMicString).	^ MicHTMLDocument new		configuration: self configuration;		writeDocument: self contents;		contents! !!MicHTMLVisitor methodsFor: 'initialization'!crAsNewLine 	canvas crAsNewLine! !!MicHTMLVisitor methodsFor: 'initialization'!crlfAsNewLine 	canvas crlfAsNewLine! !!MicHTMLVisitor methodsFor: 'initialization'!initialize 	| stream |	super initialize.	stream := MicOutputStream new setStream: (WriteStream on: String empty).	canvas := self canvasClass on: stream.	! !!MicHTMLVisitor methodsFor: 'initialization'!lfAsNewLine 	canvas lfAsNewLine! !!MicHTMLVisitor methodsFor: 'visiting - list'!metaDataFromAssociations: aDictionary	"Write the receiver's metadata from aDictionary"	aDictionary associationsDo: [ : metadataAssociation |		self configuration writeFromMetadataAssociation: metadataAssociation ].! !!MicHTMLVisitor methodsFor: 'defaults'!minQuoteThreshold	"Answer a <Number> which is the number of characters used as the limit between short and long quotations"		^ 50! !!MicHTMLVisitor methodsFor: 'initialization'!usedNewLine	"Return the encoded new line. Useful for tests."		^ canvas stream usedNewLine! !!MicHTMLVisitor methodsFor: 'visiting'!visitAnchor: anAnchor	"Target could be any tag, h1, h2, a, etc., it is only a placeholder for a hyperlink"	canvas tag		name: 'a';		parameterAt: 'id' put: anAnchor label;		with: String empty! !!MicHTMLVisitor methodsFor: 'visiting'!visitAnchorReference: anAnchor	"Linking to an element on the same page"	canvas tag		name: 'a';		parameterAt: 'href' put: '#' , anAnchor substring;		with: anAnchor substring! !!MicHTMLVisitor methodsFor: 'visiting'!visitAnnotated: anAnnotatedParagraph	canvas newLine.	canvas tag		name: 'section';		parameterAt: 'id' put: anAnnotatedParagraph label;		with: [ 			canvas tag				name: 'label';				parameterAt: 'for' put: anAnnotatedParagraph label;				with: [ super visitAnnotated: anAnnotatedParagraph ] ].! !!MicHTMLVisitor methodsFor: 'visiting - inline elements'!visitBold: aBoldText	canvas tag		name: 'strong';		with: [ super visitBold: aBoldText ]! !!MicHTMLVisitor methodsFor: 'visiting - extensions'!visitCitation: aCitation	canvas tag		name: 'cite';		with: aCitation ref.! !!MicHTMLVisitor methodsFor: 'visiting'!visitCode: aCodeBlock	canvas newLine.	canvas tag		name: 'pre';		with: [ 			| code |			code := canvas tag				        name: 'code';				        yourself.			"language := self languageForScript: aCodeBlock.			language isSyntaxHighlightingPossible ifTrue: [ 			code parameterAt: 'class' put: language printString ]."			code with: [ canvas lines: aCodeBlock body ] ].			"canvas tag				name: 'figcaption';				with: [ 					aCodeBlock hasLabel ifTrue: [ 							self createAnchorWith: aCodeBlock label.							self writeCounterForScript: aCodeBlock ].					aCodeBlock hasCaption ifTrue: [ 							self visitAll: aCodeBlock caption children ] ]" .	canvas newLine! !!MicHTMLVisitor methodsFor: 'visiting'!visitCodeblock: aCodeBlock	canvas tag		name: 'figure';		with: [ 			canvas tag				name: 'pre';				with: [ 					| code language |					code := canvas tag						        name: 'code';						        yourself.					"(language := self languageForScript: aCodeBlock) isSyntaxHighlightingPossible 						ifTrue: [ code parameterAt: 'class' put: language printString ]."					code with: [ canvas lines: aCodeBlock text ] ].			canvas tag				name: 'figcaption';				with: [ 					aCodeBlock hasLabel ifTrue: [ 							self visitAnchor: aCodeBlock.							self writeCounterForScript: aCodeBlock ].					aCodeBlock hasCaption ifTrue: [ 							self visitAll: aCodeBlock caption children ] ] ].	canvas newLine! !!MicHTMLVisitor methodsFor: 'visiting'!visitColumn: aMicColumnsBlock 	"??"! !!MicHTMLVisitor methodsFor: 'visiting'!visitColumns: aMicColumnsBlock 	"??"! !!MicHTMLVisitor methodsFor: 'visiting'!visitFigCaption: aFigCaptionBlock	canvas tag		name: 'figcaption';		with: [ 			aFigCaptionBlock hasCaption ifTrue: [ 				aFigCaptionBlock captionElements do: [:each | each accept: self ] ] ]! !!MicHTMLVisitor methodsFor: 'visiting - inline elements'!visitFigure: aFigure	"Write mark up elements related with photo in the receiver's canvas"	canvas tag		name: 'figure';		with: [ self visitImg: aFigure ]! !!MicHTMLVisitor methodsFor: 'visiting'!visitHeader: aHeader	canvas newLine.		canvas tag 		name: 'h',  aHeader level asString;		with: aHeader header	! !!MicHTMLVisitor methodsFor: 'visiting'!visitHorizontalLine: aHorizontalLine	canvas tag		name: 'hr';		with: ''! !!MicHTMLVisitor methodsFor: 'visiting'!visitImg: aMicFigureBlock	"Write mark up elements related with image tag in the receiver's canvas.	Mandatory attributes:		src - Specifies the path to the image		alt - Specifies an alternate text for the image, if the image for some reason cannot be displayed"		canvas tag		name: 'img';		parameterAt: 'src' put: aMicFigureBlock reference path;		parameterAt: 'alt' put: (aMicFigureBlock hasChildren ifTrue: [ aMicFigureBlock text ] ifFalse: [ '' ]);		addArguments: aMicFigureBlock;		with: [ self visitFigCaption: aMicFigureBlock ]! !!MicHTMLVisitor methodsFor: 'visiting - inline elements'!visitItalic: aItalicText	canvas tag		name: 'i';		with: [ super visitItalic: aItalicText ]! !!MicHTMLVisitor methodsFor: 'visiting - inline elements'!visitLink: aLink	"Write markup hyperlink, which is used to link from one page to another"	canvas tag		name: 'a';		parameterAt: 'target' put: self configuration targetAttribute;		parameterAt: 'href' put: aLink referencePath;		addArguments: aLink;		with: aLink caption! !!MicHTMLVisitor methodsFor: 'visiting - list'!visitListItem: anItem	canvas raw: [ super visitListItem: anItem ].! !!MicHTMLVisitor methodsFor: 'visiting'!visitMath: anObject	"<script src=""https://polyfill.io/v3/polyfill.min.js?features=es6""></script><script id=""MathJax-script"" async src=""https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js""></script>"! !!MicHTMLVisitor methodsFor: 'visiting'!visitMetaData: aMetaData	self metaDataFromAssociations: aMetaData body.	super visitMetaData: aMetaData.! !!MicHTMLVisitor methodsFor: 'visiting - inline elements'!visitMonospace: aMonospace	canvas tag		name: 'code';		with: [ super visitMonospace: aMonospace ]! !!MicHTMLVisitor methodsFor: 'visiting - list'!visitOrderedList: anOrderedList	canvas newLine.	canvas tag		name: 'ol';		with: [ 			canvas newLine. 			super visitOrderedList: anOrderedList  ]! !!MicHTMLVisitor methodsFor: 'visiting - list'!visitOrderedListItem: anOrderedListItem	"will not work with we have text decorators such as bold, italic, monospace"	canvas tag		name: 'li';		with: [ super visitOrderedListItem: anOrderedListItem ].	canvas newLine.! !!MicHTMLVisitor methodsFor: 'visiting'!visitParagraph: aParagraph	canvas newLine.	canvas tag		name: 'p';		with: [ super visitParagraph: aParagraph ]! !!MicHTMLVisitor methodsFor: 'visiting'!visitQuote: aQuote	"If the quote text size exceeds a minimum threshold, use blockquote which is appropriate for long quotations"		| tagName |	tagName := aQuote text size > self minQuoteThreshold		ifTrue: [ 'blockquote' ]		ifFalse: [ 'q' ].	canvas tag		name: tagName;		with: [ super visitQuote: aQuote ]! !!MicHTMLVisitor methodsFor: 'visiting - inline elements'!visitStrike: aStrike	canvas tag		name: 'strike';		with: [ super visitStrike: aStrike ]! !!MicHTMLVisitor methodsFor: 'visiting'!visitTable: aTable	canvas newLine.	canvas tag		name: 'table';		with: [ 			canvas newLine.			self visitTableRows: aTable ]! !!MicHTMLVisitor methodsFor: 'writing'!visitTableHeaders: header	self visitTableRow: header withTag: 'th'.		! !!MicHTMLVisitor methodsFor: 'writing'!visitTableRow: row	self visitTableRow: row withTag: 'td'! !!MicHTMLVisitor methodsFor: 'writing'!visitTableRow: row withTag: aString	"Private - Generalized visiting row to handle both table header and table row (td)"	canvas tag		name: 'tr';		with: [ 			row do: [ : cell |				canvas tag 					name: aString; 					with: [ self visitAll: cell ] ] ].	canvas newLine			! !!MicHTMLVisitor methodsFor: 'writing'!visitTableRows: aTable	| remainingRows |	aTable hasHeader		ifTrue: [ 			self visitTableHeaders: aTable rows first. 			remainingRows := aTable rows allButFirst  ] 		ifFalse: [ remainingRows := aTable rows ].	remainingRows do: [ : row | self visitTableRow: row ]! !!MicHTMLVisitor methodsFor: 'visiting - inline elements'!visitText: aText	canvas nextPutAll: (		(aText text copyReplaceAll: String cr with: '<br>') 			copyReplaceAll: String lf with: '<br />'). ! !!MicHTMLVisitor methodsFor: 'visiting - list'!visitUnorderedList: anUnorderedList	canvas newLine.	canvas tag		name: 'ul';		with: [ 			canvas newLine. 			super visitUnorderedList: anUnorderedList  ]! !!MicHTMLVisitor methodsFor: 'visiting - list'!visitUnorderedListItem: anUnorderedListItem	"will not work with we have text decorators such as bold, italic, monospace"	canvas tag		name: 'li';		with: [ super visitUnorderedListItem: anUnorderedListItem ].	canvas newLine.! !!MicHTMLVisitor methodsFor: 'visiting'!writeCounter: aCounter	"Write on the canvas the string representation of ==aCounter=="	^ aCounter elements		  do: [ :each | self writeCounterElement: each ]		  separatedBy: [ self writeCounterElementSeparator ]! !!MicHTMLVisitor methodsFor: 'visiting'!writeCounterDefinitionSeparator	canvas nextPutAll: '. '! !!MicHTMLVisitor methodsFor: 'visiting'!writeCounterElement: aCounterElement	canvas nextPutAll: aCounterElement asString! !!MicHTMLVisitor methodsFor: 'visiting'!writeCounterElementSeparator	self shouldBeImplemented! !!MicHTMLVisitor methodsFor: 'visiting'!writeCounterForScript: aScript	aScript counter isValidCounter ifFalse: [ ^ self ].	self writeCounter: aScript counter.	self writeCounterDefinitionSeparator! !!MicHTMLStyler class methodsFor: 'instance creation'!open	<script>	^ self new open.! !!MicHTMLStyler class methodsFor: 'instance creation'!openOn: aMicrodownString	self new		micDocumentString: aMicrodownString;		openWithSpec.! !!MicHTMLStyler methodsFor: 'accessing - toolbar'!addToolbarCommandsTo: aGroup	self toolbarCommands do: [ :each | 		aGroup register: (each forSpecContext: self) ]! !!MicHTMLStyler methodsFor: 'accessing - toolbar'!baseToolbarCommands	^ { 		MicHTMLStylerPreviewCommand .		MicHTMLStylerHelpCommand .		MicHTMLStylerExportCommand .		MicHTMLStylerUpdateCommand .		MicHTMLStylerQuitCommand		}! !!MicHTMLStyler methodsFor: 'accessing'!cssDetailsPresenter	" Answer the Notebook container of this MicCSSStyler "	^ stylerNotebookPresenter! !!MicHTMLStyler methodsFor: 'initialization'!cssFramework 	"Answer a <MicCSSFramework>"		^ self cssListPresenter ifNotNil: [ : cssList |		cssList selectedItem ]! !!MicHTMLStyler methodsFor: 'accessing'!cssFramework: aMicCSSFramework 	self shouldBeImplemented.! !!MicHTMLStyler methodsFor: 'accessing'!cssListPresenter	^ cssListPresenter! !!MicHTMLStyler methodsFor: 'initialization'!cssProvider	"Answer a <MicCSSProvider> which handles provisioning of CSS frameworks to the receiver"	^ cssProvider		ifNil: [ cssProvider := MicCSSProvider new ]! !!MicHTMLStyler methodsFor: 'accessing'!cssTheme	"Answer the currently selected MicCSSTheme"		^ self cssDetailsPresenter cssTheme! !!MicHTMLStyler methodsFor: 'layout'!defaultLayout	^ SpBoxLayout newTopToBottom 		add: toolbarPresenter height: self class toolbarHeight + 15;			add:  (SpPanedLayout newLeftToRight			positionOfSlider: 20 percent;			add: cssListPresenter;			add: stylerNotebookPresenter;			yourself);		yourself! !!MicHTMLStyler methodsFor: 'initialization'!frameworks	"Answer a <Collection> with CSS libraries"		^ self cssProvider frameworks! !!MicHTMLStyler methodsFor: 'testing'!hasCssSelection	^ self cssListPresenter notNil and: [ self cssListPresenter selection isEmpty not ]! !!MicHTMLStyler methodsFor: 'testing'!hasMicDocument	"Answer <true> if the receiver has a Microdown HTML document opened"	^ micHtmlDocument notNil! !!MicHTMLStyler methodsFor: 'testing'!hasMicDocumentFileRef	"Answer <true> if the receiver has a Microdown documennt supplied by the user"	^ micDocumentFileRef notNil! !!MicHTMLStyler methodsFor: 'testing'!hasMicDocumentString	"Answer <true> if the receiver has a Microdown documennt supplied by the user"	^ micDocumentString notNil! !!MicHTMLStyler methodsFor: 'testing'!hasMicHtmlDocument	"Answer <true> if there is content in the HTML preview presenter"	^ self cssDetailsPresenter hasMicHtmlDocument ! !!MicHTMLStyler methodsFor: 'testing'!hasThemeSelection	^ self cssDetailsPresenter hasThemeSelection! !!MicHTMLStyler methodsFor: 'accessing'!iconForWindow	"Answer a Form to be used during initialization when opening in a SpWindowPresenter."	^ self iconNamed: #smallWindow! !!MicHTMLStyler methodsFor: 'initialization'!initialize	"Private - Initialize the receiver's frameworks before UI display"	self cssProvider hasFrameworksInstalled		ifFalse: [ self cssProvider installFrameworks ].	super initialize.! !!MicHTMLStyler methodsFor: 'initialization'!initializeDetailPresenter	stylerNotebookPresenter := self instantiate: MicHTMLStylerDetailViewsPresenter on: self.! !!MicHTMLStyler methodsFor: 'initialization'!initializeFocus	" Private - See superimplementor's comment "	self focusOrder		add: self cssListPresenter;		add: self toolbarPresenter;		add: self cssDetailsPresenter.! !!MicHTMLStyler methodsFor: 'initialization'!initializeListPresenter	cssListPresenter := self newList		enableSearch;		beSingleSelection;		display: #name;		whenSelectionChangedDo: [ : selectionMode | 			selectionMode selectedItem				ifNotNil: [ : micCSSFrw | self updatePresenter ] ];		items: self frameworks;		sortingBlock: [ : a : b | a name < b name ];		headerTitle: 'Styles';		yourself.	cssListPresenter items 		ifNotEmpty: [ cssListPresenter selectIndex: 0 ]		ifEmpty: [ self cssDetailsPresenter updatePresenter ]! !!MicHTMLStyler methodsFor: 'initialization'!initializePresenters	" Private - See superimplementor's comment "	self initializeToolbar.	self initializeListPresenter.		self initializeDetailPresenter.! !!MicHTMLStyler methodsFor: 'accessing - toolbar'!initializeToolbar	toolbarPresenter := self newToolbar		fillWith: self toolbarActions;		yourself.! !!MicHTMLStyler methodsFor: 'initialization'!initializeWindow: aWindowPresenter	aWindowPresenter		title: self title;		initialExtent: 950 @ 650;		windowIcon: self iconForWindow;		whenClosedDo: [ self ].! !!MicHTMLStyler methodsFor: 'testing'!isOverwrite	"Answer <true> if receiver is set to overwrite on exporting"		^ self cssDetailsPresenter isOverwrite! !!MicHTMLStyler methodsFor: 'accessing'!micDocumentContents	"Answer a <String> representing Microdown contents taken from the receiver. 	We could have a micDocumentFileRef pointing to an existing .mic file or 	we could have a micDocumentString being a unsaved new Microdown document"		^ self hasMicDocumentFileRef 		ifTrue: [ 			micDocumentFileRef exists				ifFalse: [ self error: 'File moved or deleted' ].			micDocumentFileRef contents ]		ifFalse: [ micDocumentString  ]! !!MicHTMLStyler methodsFor: 'accessing'!micDocumentFileRef	^ micDocumentFileRef! !!MicHTMLStyler methodsFor: 'accessing'!micDocumentFileRef: aFileReference	"A document has been opened, update the receiver's views"	micDocumentFileRef := aFileReference.	micDocumentString := aFileReference contents.	self updatePresenter.! !!MicHTMLStyler methodsFor: 'accessing'!micDocumentString	^ micDocumentString! !!MicHTMLStyler methodsFor: 'accessing'!micDocumentString: anObject	micDocumentString := anObject! !!MicHTMLStyler methodsFor: 'accessing'!micHtmlDocument	^ micHtmlDocument! !!MicHTMLStyler methodsFor: 'accessing'!micHtmlDocument: anObject	micHtmlDocument := anObject! !!MicHTMLStyler methodsFor: 'accessing - toolbar'!optionalToolbarCommands	"Show opening button if this tool was opened externally, i.e. without a user document"	self hasMicDocumentString		ifFalse: [ ^ { MicHTMLStylerOpenCommand } ].	^ Array empty ! !!MicHTMLStyler methodsFor: 'accessing'!selectedCssFramework	^ self cssListPresenter		ifNotNil: [ : cssFrameworkList | cssFrameworkList selectedItem ]! !!MicHTMLStyler methodsFor: 'initialization'!title	" Private - See superimplementor's comment "	^ 'Microdown HTML Styler'! !!MicHTMLStyler methodsFor: 'accessing'!titleForWindow 	^ self hasMicDocumentFileRef		ifTrue: [ self title , ' on: ' , self micDocumentFileRef basename ]		ifFalse: [ self title ]! !!MicHTMLStyler methodsFor: 'accessing - toolbar'!toolbarActions	^ CmCommandGroup forSpec		in: [ :this | self addToolbarCommandsTo: this ];		yourself! !!MicHTMLStyler methodsFor: 'accessing - toolbar'!toolbarCommands	^ self baseToolbarCommands , self optionalToolbarCommands sorted: #order ascending! !!MicHTMLStyler methodsFor: 'accessing - toolbar'!toolbarPresenter	" Answer the toolbarPresenter of this MicCSSStyler "	^ toolbarPresenter! !!MicHTMLStyler methodsFor: 'accessing - toolbar'!toolbarPresenter: anObject	" Sets the toolbarPresenter of this MicCSSStyler "	toolbarPresenter := anObject! !!MicHTMLStyler methodsFor: 'updating'!updateCssSelection	| selectedCss |		self hasCssSelection 		ifFalse: [ ^ self ].   selectedCss := self hasThemeSelection      ifTrue: [ self cssTheme ]      ifFalse: [ self cssFramework ].    self micHtmlDocument addCSS: selectedCss.! !!MicHTMLStyler methodsFor: 'updating'!updateHtmlOptionsPresenter	self cssDetailsPresenter updateHtmlOptionsPresenter! !!MicHTMLStyler methodsFor: 'updating'!updateHtmlSourcePresenter	"Update the HTML source presenter only if we have a FileReference to it, i.e. a Microdown file was opened. We still allow MicHTMLDoc to be present because the user could set options before opening a Microdown file"	self hasMicDocumentFileRef		ifTrue: [ self cssDetailsPresenter updateHtmlSourcePresenter ]! !!MicHTMLStyler methodsFor: 'updating'!updateMicHtmlDocument	"Answer a new Microdown HTML document configured with the receiver's settings"		self micHtmlDocument: MicHTMLDocument new.	self updateCssSelection.	self hasMicDocumentFileRef 		ifTrue: [ self micHtmlDocument fileName: self micDocumentFileRef withoutExtension basename , '.html' ].	self micHtmlDocument 		destinationPath: self cssDetailsPresenter destinationPath;		fromMicrodown: self micDocumentContents! !!MicHTMLStyler methodsFor: 'initialization'!updatePresenter	super updatePresenter.	self cssDetailsPresenter updatePresenter	.	self updateTitle.	self 		updateMicHtmlDocument;		updateHtmlSourcePresenter;		updateHtmlOptionsPresenter.! !!MicHTMLStyler methodsFor: 'updating'!updateTitle		self withWindowDo: [ :aWindow | aWindow title: self titleForWindow ]! !!MicHTMLStylerAbstractPresenter methodsFor: 'updating'!micHtmlDocument 	^ self styler micHtmlDocument ! !!MicHTMLStylerAbstractPresenter methodsFor: 'initialization'!setModelBeforeInitialization: aDomainObject	styler := aDomainObject! !!MicHTMLStylerAbstractPresenter methodsFor: 'accessing'!statusBarHeight	^ 25! !!MicHTMLStylerAbstractPresenter methodsFor: 'accessing'!styler	^ styler! !!MicHTMLStylerAbstractPresenter methodsFor: 'accessing'!stylerDetailsPresenter	^ self styler cssDetailsPresenter! !!MicHTMLStylerCSSInfoPresenter methodsFor: 'private'!cssFramework	^ self styler cssFramework! !!MicHTMLStylerCSSInfoPresenter methodsFor: 'accessing'!cssLinkPresenter	^ cssLinkPresenter! !!MicHTMLStylerCSSInfoPresenter methodsFor: 'accessing'!cssTheme	"Answer the currently selected <MicCSSTheme>"	^ themesListPresenter selectedItem ! !!MicHTMLStylerCSSInfoPresenter methodsFor: 'layout'!defaultLayout	^ SpBoxLayout newLeftToRight 		add: themesListPresenter expand: false fill: true padding: 10;			add: (SpGridLayout build: [ : builder |			builder				beColumnNotHomogeneous;						add: 'Repository';				add: projectUrlPresenter;				nextRow;				add: 'CSS';				add: cssLinkPresenter;				nextRow;				add: 'Minified CSS';				add: minCssLinkPresenter;				nextRow;				add: 'Normalize CSS';				add: normalizeCssLinkPresenter;				nextRow;				add: 'Reset CSS';				add: resetCssLinkPresenter;				nextRow;				add: 'Versions';				add: (SpBoxLayout newTopToBottom					add: useNormalButton;					add: useMinifiedButton;					yourself) ]);		yourself! !!MicHTMLStylerCSSInfoPresenter methodsFor: 'testing'!hasThemeSelection	^ self themesListPresenter selection isEmpty not! !!MicHTMLStylerCSSInfoPresenter methodsFor: 'initialization'!initializePresenters 	projectUrlPresenter := self newLink label: String empty; yourself.	cssLinkPresenter := self newLink label: String empty; yourself.	minCssLinkPresenter := self newLink label: String empty; yourself.	normalizeCssLinkPresenter := self newLink label: String empty; yourself.	resetCssLinkPresenter := self newLink label: String empty; yourself.	self initializeThemesPresenter.	self initializeVersionOptions.! !!MicHTMLStylerCSSInfoPresenter methodsFor: 'initialization'!initializeThemesPresenter	themesListPresenter := self newList		beSingleSelection;		display: #name;		headerTitle: 'Themes';		items: OrderedCollection new;		sortingBlock: [ : a : b | a name < b name ];		whenSelectionChangedDo: [ : selectionMode | 			selectionMode selectedItem				ifNotNil: [ : micCSSTheme | 							self updatePresenterRadioOptions.						self stylerDetailsPresenter 							updatePresentersAfterThemeSelection;							updateSourceCodePresenter ] ];		yourself.! !!MicHTMLStylerCSSInfoPresenter methodsFor: 'initialization'!initializeVersionOptions	useNormalButton := self newRadioButton 		label: 'Use normal';		whenActivatedDo: [ 			useMinifiedButton state: false. 			self updatePresenter ];		yourself.	useMinifiedButton := self newRadioButton 		label: 'Use minified';		whenActivatedDo: [ 			useNormalButton state: false.			self updatePresenter ];		yourself.	useNormalButton associatedRadioButtons: { useMinifiedButton  }.	versionButtons := Dictionary newFrom: { 		#normal -> useNormalButton .		#minified -> useMinifiedButton }.! !!MicHTMLStylerCSSInfoPresenter methodsFor: 'testing'!isMinifiedSelection	"Answer <true> if the minified version option is selected"	^ self useMinifiedButton state! !!MicHTMLStylerCSSInfoPresenter methodsFor: 'accessing'!minCssLinkPresenter	^ minCssLinkPresenter! !!MicHTMLStylerCSSInfoPresenter methodsFor: 'accessing'!normalizeCssLinkPresenter	^ normalizeCssLinkPresenter! !!MicHTMLStylerCSSInfoPresenter methodsFor: 'accessing'!projectUrlPresenter	^ projectUrlPresenter! !!MicHTMLStylerCSSInfoPresenter methodsFor: 'accessing'!resetCssLinkPresenter	^ resetCssLinkPresenter! !!MicHTMLStylerCSSInfoPresenter methodsFor: 'private'!setLink: aLinkPresenter url: anEmptyStringOrUrl help: helpString	anEmptyStringOrUrl isEmpty		ifTrue: [ 			aLinkPresenter				color: Color black;				label: 'Not Available' ]		ifFalse: [ 			aLinkPresenter 				url: anEmptyStringOrUrl;				label: anEmptyStringOrUrl;				help: helpString ]! !!MicHTMLStylerCSSInfoPresenter methodsFor: 'initialization'!themeSelection	^ themesListPresenter selectedItem! !!MicHTMLStylerCSSInfoPresenter methodsFor: 'accessing'!themesListPresenter	^ themesListPresenter! !!MicHTMLStylerCSSInfoPresenter methodsFor: 'initialization'!updatePresenter	super updatePresenter.	self cssFramework ifNil: [ ^ self ].	projectUrlPresenter		url: self cssFramework projectUrl;		label: 'Visit project web';		help: 'Open a web browser to visit the main project site'.	self updatePresenterLinks.	self updatePresenterRadioOptions.	self stylerDetailsPresenter updateSourceCodePresenter.! !!MicHTMLStylerCSSInfoPresenter methodsFor: 'updating'!updatePresenterLinks	{ 		{ self cssLinkPresenter . self cssFramework cssUrl . 'Open a web browser to visit the CSS file' } .		{ self minCssLinkPresenter . self cssFramework minCssUrl . 'Open a web browser to visit the minified CSS file' } .		{ self normalizeCssLinkPresenter . self cssFramework normalizeUrl . 'Open a web browser to visit the Normalize CSS file' } .		{ self resetCssLinkPresenter . self cssFramework resetUrl . 'Open a web browser to visit the Reset CSS file' } 	} do: [ : linkArray |		self 			setLink: linkArray first 			url: linkArray second 			help: linkArray third ]! !!MicHTMLStylerCSSInfoPresenter methodsFor: 'updating'!updatePresenterRadioOptions	self useNormalButton enable.	self useMinifiedButton enable.	self cssFramework hasThemes		ifTrue: [ 			themesListPresenter items: self cssFramework themes.			self cssFramework hasNormalThemes				ifFalse: [ 					self useNormalButton disable.					self useMinifiedButton state: true ].			self cssFramework hasMinifiedThemes 				ifFalse: [ 					self useMinifiedButton disable.					self useNormalButton state: true ] ]		ifFalse: [			themesListPresenter items: OrderedCollection new.			self cssFramework hasNormalVersion				ifFalse: [ 					self useNormalButton disable.					self useMinifiedButton state: true ].			self cssFramework hasMinifiedVersion 				ifFalse: [ 					self useMinifiedButton disable.					self useNormalButton state: true ] ]! !!MicHTMLStylerCSSInfoPresenter methodsFor: 'accessing'!useMinifiedButton	^ useMinifiedButton! !!MicHTMLStylerCSSInfoPresenter methodsFor: 'accessing'!useMinifiedButton: anObject	useMinifiedButton := anObject! !!MicHTMLStylerCSSInfoPresenter methodsFor: 'accessing'!useNormalButton	^ useNormalButton! !!MicHTMLStylerCSSInfoPresenter methodsFor: 'accessing'!useNormalButton: anObject	useNormalButton := anObject! !!MicHTMLStylerCSSSourcePresenter methodsFor: 'accessing'!cssSourceCodePresenter	^ cssSourceCodePresenter! !!MicHTMLStylerCSSSourcePresenter methodsFor: 'accessing'!cssSourceCodePresenter: anObject	cssSourceCodePresenter := anObject! !!MicHTMLStylerCSSSourcePresenter methodsFor: 'accessing'!cssStatusbarPresenter	^ cssStatusbarPresenter! !!MicHTMLStylerCSSSourcePresenter methodsFor: 'accessing'!cssStatusbarPresenter: anObject	cssStatusbarPresenter := anObject! !!MicHTMLStylerCSSSourcePresenter methodsFor: 'layout'!defaultLayout 	^ self layout: (SpBoxLayout newTopToBottom 		add: 'CSS' height: self class labelHeight;		add: cssSourceCodePresenter;		add: cssStatusbarPresenter height: self statusBarHeight;		yourself)! !!MicHTMLStylerCSSSourcePresenter methodsFor: 'initialization'!initializePresenters	cssSourceCodePresenter := self newText		beWrapWord;		beNotEditable;		text: self selectedCssFrameworkSourceCode;		whenTextChangedDo: [ : text | self updateSizeMessage: text size ]		yourself.	cssStatusbarPresenter := self newStatusBar! !!MicHTMLStylerCSSSourcePresenter methodsFor: 'private'!selectedCssFrameworkSourceCode	^ styler selectedCssFrameworkSourceCode! !!MicHTMLStylerCSSSourcePresenter methodsFor: 'accessing'!text: aString	self cssSourceCodePresenter text: aString! !!MicHTMLStylerCSSSourcePresenter methodsFor: 'initialization'!updateSizeMessage: anInteger	self cssStatusbarPresenter 		pushMessage: 			(String streamContents: [ : stream |				stream					<< 'File size: ';					<< anInteger asFileSizeString ])! !!MicHTMLStylerExportOptionsPresenter methodsFor: 'defaults'!defaultDestinationPath 	^ 'mic_html_output'! !!MicHTMLStylerExportOptionsPresenter methodsFor: 'layout'!defaultLayout 	^ SpGridLayout build: [ : builder |		builder			beColumnNotHomogeneous;			rowSpacing: 15;			add: 'Output file name';			add: outputFilenameTextPresenter;			nextRow;			add: 'Output folder';			add: outputPathTextPresenter;			add: browseOutputButton;			nextRow;			add: 'Overwrite';			add: overwriteCheckboxPresenter ]! !!MicHTMLStylerExportOptionsPresenter methodsFor: 'defaults'!defaultOutputFilename	^ 'index.html'! !!MicHTMLStylerExportOptionsPresenter methodsFor: 'initialization'!destinationPath	"Answer a <String> representing the path where the output files will be exported"	^ outputPathTextPresenter text		ifEmpty: [ self defaultDestinationPath ]! !!MicHTMLStylerExportOptionsPresenter methodsFor: 'initialization'!initializePresenters 	outputFilenameTextPresenter := self newTextInput		help: 'Output file name';		text: self defaultOutputFilename;		yourself.	outputPathTextPresenter := self newTextInput 		help: 'Select the output directory';		text: self defaultDestinationPath;		yourself.	browseOutputButton := self newButton		label: 'Select';		icon: (self iconNamed: #smallOpen);		action: [ self selectOutputDirectory ];		yourself.	overwriteCheckboxPresenter := self newCheckBox		state: true;		yourself.! !!MicHTMLStylerExportOptionsPresenter methodsFor: 'testing'!isOverwrite	"Answer <true> if overwrite existing file is set"		^ overwriteCheckboxPresenter state! !!MicHTMLStylerExportOptionsPresenter methodsFor: 'accessing'!micDocumentFileRef	^ self styler micDocumentFileRef! !!MicHTMLStylerExportOptionsPresenter methodsFor: 'accessing'!outputDestinationPath: aString	outputPathTextPresenter text: aString! !!MicHTMLStylerExportOptionsPresenter methodsFor: 'accessing'!outputFilename: aString	outputFilenameTextPresenter text: aString! !!MicHTMLStylerExportOptionsPresenter methodsFor: 'initialization'!requestDirectoryForOpen	" Open request dialog to select a directory "		^ UIManager default chooseDirectory: 'Choose a directory'! !!MicHTMLStylerExportOptionsPresenter methodsFor: 'initialization'!selectOutputDirectory	"Private - Callback for choose directory button"		self requestDirectoryForOpen		ifNotNil: [ : dirRef | 			self styler hasMicHtmlDocument 				ifTrue: [ self micHtmlDocument destinationPath: dirRef fullName ].			outputPathTextPresenter text: dirRef fullName ].! !!MicHTMLStylerHTMLOptionsPresenter methodsFor: 'layout'!charSet	^ encodingOptionsListPresenter selectedItem.! !!MicHTMLStylerHTMLOptionsPresenter methodsFor: 'initialization'!defaultLanguageSelection	^ (ISOLanguageDefinition iso2LanguageTable associations 		select: [ : assoc | assoc key = 'en' ] 		thenCollect: [ : assoc | assoc key , ' - ' , assoc value language ]) anyOne! !!MicHTMLStylerHTMLOptionsPresenter methodsFor: 'layout'!defaultLayout 	^ SpGridLayout build: [ : builder |		builder			beColumnNotHomogeneous;					add: 'Document Type';			add: doctypeListPresenter;			nextRow;			add: 'Encoding';			add: encodingOptionsListPresenter;			nextRow;			add: 'Language';			add: languageOptionsPresenter;			nextRow;			add: 'Embeed CSS';			add: embeedCheckboxPresenter;			nextRow;			add: 'Links open a new page';			add: linksOpenNewPage ]! !!MicHTMLStylerHTMLOptionsPresenter methodsFor: 'private'!docTypeOptionNames	^ self docTypeOptions keys! !!MicHTMLStylerHTMLOptionsPresenter methodsFor: 'private'!docTypeOptions	^ OrderedDictionary new		at: 'HTML 5' put: '<!!DOCTYPE html>';			at: 'XHTML 1.1' put: '<!!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">';		at: 'XHTML 1.0 Transitional' put: '<!!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'; 		at: 'XHTML 1.0 Frameset' put: '<!!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">';		at: 'XHTML 1.0 Strict' put: '<!!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">';		at: 'HTML 4.01 Transitional' put: '<!!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">';		at: 'HTML 4.01 Frameset' put: '<!!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN""http://www.w3.org/TR/html4/frameset.dtd">';		at: 'HTML 4.01 Strict' put: '<!!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""http://www.w3.org/TR/html4/strict.dtd">';		at: 'HTML 3.2' put: '<!!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">'; 		at: 'Compact HTML 2.0' put: '<!!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0 Strict Level 2//EN">';		yourself! !!MicHTMLStylerHTMLOptionsPresenter methodsFor: 'layout'!documentType	"Answer a <String> describing the selected HTML document type"		^ doctypeListPresenter selectedItem! !!MicHTMLStylerHTMLOptionsPresenter methodsFor: 'accessing'!embeedCheckboxPresenter	^ embeedCheckboxPresenter! !!MicHTMLStylerHTMLOptionsPresenter methodsFor: 'accessing'!enableEmbeedCss	self embeedCheckboxPresenter enabled: true.! !!MicHTMLStylerHTMLOptionsPresenter methodsFor: 'private'!encodingOptions	^ #(		'UTF-8'		'UTF-16'		'UTF-32'		'ASCII'		'ISO 8859-1'		'ISO 8859-2'		'ISO 8859-3'		'ISO 8859-4'		'ISO 8859-5'		'ISO 8859-6'		'ISO 8859-7'		'ISO 8859-8'		'ISO 8859-9'		'ISO 8859-10'		'ISO 8859-11'		'ISO 8859-13'		'ISO 8859-14' 		'ISO 8859-15'		'ISO 8859-16'		'Windows-1250'		'Windows-1251'		'Windows-1252'		'Windows-1253'		'Windows-1254'		'Windows-1255'		'Windows-1256'		'Windows-1257'		'Windows-1258'		)! !!MicHTMLStylerHTMLOptionsPresenter methodsFor: 'initialization'!initializeDocTypeListPresenter	doctypeListPresenter := self newDropList		help: 'Select the document type to be generated';		items: self docTypeOptionNames;		whenSelectedItemChangedDo: [ : selection |			self micHtmlDocument documentType: (self docTypeOptions at: selection).			self styler updateHtmlSourcePresenter ]		yourself.		! !!MicHTMLStylerHTMLOptionsPresenter methodsFor: 'initialization'!initializeEmbeedingCheckPresenter	embeedCheckboxPresenter := self newCheckBox		state: false;		enabled: false;		whenChangedDo: [ 			embeedCheckboxPresenter state				ifTrue: [ self micHtmlDocument beCssEmbedded ]				ifFalse: [ self micHtmlDocument beCssLinked ].			self styler updateHtmlSourcePresenter ];		yourself.! !!MicHTMLStylerHTMLOptionsPresenter methodsFor: 'initialization'!initializeEncodingOptionsListPresenter	encodingOptionsListPresenter := self newDropList 		help: 'Select the document encoding';		items: self encodingOptions;		whenSelectedItemChangedDo: [ : selection | 			self micHtmlDocument charSet: selection.			self styler updateHtmlSourcePresenter ];		yourself.! !!MicHTMLStylerHTMLOptionsPresenter methodsFor: 'initialization'!initializeLanguageOptionsListPresenter	languageOptionsPresenter := self newDropList 		help: 'Select the document language';		items: self languageOptions;		selectItem: self defaultLanguageSelection;		whenSelectedItemChangedDo: [ : selection |			self micHtmlDocument languageId: (selection first: 2).			self styler updateHtmlSourcePresenter ].! !!MicHTMLStylerHTMLOptionsPresenter methodsFor: 'initialization'!initializeLinksOptionCheckPresenter			linksOpenNewPage := self newCheckBox 		state: true;		whenChangedDo: [ : state |			state 				ifFalse: [ self micHtmlDocumentConfiguration beTargetAttributeSelf ]				ifTrue: [ self micHtmlDocumentConfiguration beTargetAttributeBlank ].			self styler updateHtmlSourcePresenter ]		yourself! !!MicHTMLStylerHTMLOptionsPresenter methodsFor: 'initialization'!initializePresenters 	self		initializeDocTypeListPresenter;		initializeEncodingOptionsListPresenter;		initializeLanguageOptionsListPresenter;		initializeEmbeedingCheckPresenter;		initializeLinksOptionCheckPresenter.! !!MicHTMLStylerHTMLOptionsPresenter methodsFor: 'initialization'!languageOptions	^ (ISOLanguageDefinition iso2LanguageTable associations 		select: [ : assoc | assoc key size = 2 ] 		thenCollect: [ : assoc | assoc key , ' - ' , assoc value language ]) asSortedCollection! !!MicHTMLStylerHTMLOptionsPresenter methodsFor: 'accessing'!micHtmlDocumentConfiguration	"Answer a <MicHTMLConfiguration> for the receiver's document"	^ self micHtmlDocument configuration.! !!MicHTMLStylerHTMLSourcePresenter methodsFor: 'layout'!defaultLayout 	^ self layout: (SpBoxLayout newTopToBottom 		add: 'HTML' height: self class labelHeight;		add: htmlSourceCodePresenter;		add: htmlStatusbarPresenter height: self statusBarHeight;		yourself)! !!MicHTMLStylerHTMLSourcePresenter methodsFor: 'accessing'!htmlSourceCodePresenter	^ htmlSourceCodePresenter! !!MicHTMLStylerHTMLSourcePresenter methodsFor: 'accessing'!htmlSourceCodePresenter: anObject	htmlSourceCodePresenter := anObject! !!MicHTMLStylerHTMLSourcePresenter methodsFor: 'accessing'!htmlStatusbarPresenter	^ htmlStatusbarPresenter! !!MicHTMLStylerHTMLSourcePresenter methodsFor: 'accessing'!htmlStatusbarPresenter: anObject	htmlStatusbarPresenter := anObject! !!MicHTMLStylerHTMLSourcePresenter methodsFor: 'initialization'!initializePresenters	htmlSourceCodePresenter := self newText		beWrapWord;		beNotEditable;		whenTextChangedDo: [ : text | self updateSizeMessage: text size ]				yourself.	htmlStatusbarPresenter := self newStatusBar.! !!MicHTMLStylerHTMLSourcePresenter methodsFor: 'accessing'!text	^ self htmlSourceCodePresenter text! !!MicHTMLStylerHTMLSourcePresenter methodsFor: 'accessing'!text: aString	self htmlSourceCodePresenter text: aString! !!MicHTMLStylerHTMLSourcePresenter methodsFor: 'initialization'!updateSizeMessage: anInteger	self htmlStatusbarPresenter 		pushMessage: 			(String streamContents: [ : stream |				stream					<< 'File size: ';					<< anInteger asFileSizeString ])! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'accessing'!charSet	^ htmlOptionsPresenter charSet.! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'accessing - pages'!cssDetailsPage	^ (SpNotebookPage 		title: 'CSS Details' 		icon: (self iconNamed: #book) 		provider: [ cssMetaInfoPresenter ])		yourself! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'accessing'!cssFramework	^ self styler cssFramework! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'accessing'!cssFramework: anObject	self styler cssFramework: anObject.	self updatePresenter! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'accessing'!cssListPresenter	^ self styler cssListPresenter! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'accessing'!cssMetaInfoPresenter	^ cssMetaInfoPresenter! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'updating'!cssSourceCodeForSelection	"Answer a <String> which is the source code matching the user selected options"	^ self cssMetaInfoPresenter hasThemeSelection		ifFalse: [			self cssMetaInfoPresenter isMinifiedSelection				ifFalse: [ self cssFramework sourceCode ]				ifTrue: [ self cssFramework minifiedSourceCode ] ]		ifTrue: [ 			| currentTheme |			currentTheme := self cssMetaInfoPresenter themeSelection.			self cssMetaInfoPresenter isMinifiedSelection				ifTrue: [ currentTheme  minifiedSourceCode ]				ifFalse: [ currentTheme sourceCode ] ]! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'accessing'!cssSourcePresenter	^ cssSourceCodePresenter! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'accessing'!cssTheme	^ self cssMetaInfoPresenter cssTheme! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'layout'!defaultLayout 	^ self layout: (SpPanedLayout newTopToBottom 		positionOfSlider: 45 percent;		add: notebookPresenter;		add: (SpPanedLayout newLeftToRight			add: cssSourceCodePresenter;			add: htmlSourcePresenter;			yourself);		yourself)! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'accessing'!destinationPath		^ exportOptionsPresenter destinationPath! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'accessing'!documentType	"Answer a <String> describing the selected HTML document type"	^ htmlOptionsPresenter documentType.! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'accessing - pages'!exportOptionsPage	^ (SpNotebookPage 		title: 'Export Options' 		icon: (self iconNamed: #smallExport) 		provider: [ exportOptionsPresenter ])		yourself! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'testing'!hasMicHtmlDocument	"Answer <true> if there is content in the HTML preview presenter"		^ self htmlSourcePresenter text notEmpty! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'testing'!hasThemeSelection		^ self cssMetaInfoPresenter hasThemeSelection! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'accessing - pages'!htmlOptionsPage	^ SpNotebookPage 		title: 'HTML Options'		icon: (self iconNamed: #configuration)		provider: [ htmlOptionsPresenter ].! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'accessing'!htmlOptionsPresenter	^ htmlOptionsPresenter! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'accessing'!htmlOptionsPresenter: anObject	htmlOptionsPresenter := anObject! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'accessing'!htmlSourcePresenter	^ htmlSourcePresenter! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'initialization'!initializeNotebookPresenter	cssMetaInfoPresenter := self instantiate: MicHTMLStylerCSSInfoPresenter on: self styler.	htmlOptionsPresenter := self instantiate: MicHTMLStylerHTMLOptionsPresenter on: self styler.	exportOptionsPresenter := self instantiate: MicHTMLStylerExportOptionsPresenter on: self styler.	notebookPresenter := self newNotebook		addPage: self htmlOptionsPage;		addPage: self cssDetailsPage;		addPage: self exportOptionsPage;		yourself! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'initialization'!initializePresenters 	htmlSourcePresenter := MicHTMLStylerHTMLSourcePresenter on: self.	cssSourceCodePresenter := MicHTMLStylerCSSSourcePresenter on: self.	self initializeNotebookPresenter.! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'testing'!isOverwrite	^ exportOptionsPresenter isOverwrite! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'updating'!micDocumentString	^ self styler micDocumentString! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'updating'!micHtmlDocument	^ self styler micHtmlDocument! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'accessing'!selectedCssFramework	^ self styler selectedCssFramework! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'accessing'!selectedCssFrameworkSourceCode	"Answer a <String> with the receiver's selected CSS Framework source code"	^ self cssListPresenter selectedItem		ifNotNil: [ : cssFrw | cssFrw sourceCode ]		ifNil: [ String empty ]! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'accessing - model'!setModelBeforeInitialization: aDomainObject	styler := aDomainObject.! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'initialization'!styler	^ styler! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'updating'!updateHtmlOptionsPresenter	exportOptionsPresenter outputFilename: self micHtmlDocument fileName.! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'updating'!updateHtmlSourcePresenter	"Update the receiver's HTML view"	| updatedMicHtml |		updatedMicHtml := self micHtmlDocument fromMicrodown: self micDocumentString.	self htmlSourcePresenter text: updatedMicHtml contents! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'initialization'!updatePresenter	"Callback after CSS framework selection"	super updatePresenter.	self styler hasCssSelection ifFalse: [ ^ self ].	self cssMetaInfoPresenter updatePresenter.	self updateSourceCodePresenter.	self htmlOptionsPresenter enableEmbeedCss.! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'updating'!updatePresentersAfterThemeSelection	self styler hasMicDocumentFileRef ifFalse: [ ^ self ].	self styler updateMicHtmlDocument.	self updateHtmlSourcePresenter.! !!MicHTMLStylerDetailViewsPresenter methodsFor: 'updating'!updateSourceCodePresenter	self cssSourcePresenter text: self cssSourceCodeForSelection.! !!MicListBlock methodsFor: '*Microdown-HTMLExporter'!listItemText	"I just need the first children which contains the text, currently #text concatenates all children's text"		^ self children first text! !!MicHTMLBrush methodsFor: 'accessing'!name	"Answer a <String> with the receiver's name"		^ name! !!MicHTMLBrush methodsFor: 'accessing'!name: aString	name := aString.	stream nextPut: $<; << aString! !!MicHTMLTag methodsFor: 'accessing'!addArguments: aMicInlineBlockWithUrl	aMicInlineBlockWithUrl hasArguments ifFalse: [ ^ self ].	self htmlArgumentsMapDo: [ :argAssoc | 		aMicInlineBlockWithUrl			argumentAt: argAssoc key			ifPresent: [ :labelString | self parameterAt: argAssoc value put: labelString ] ]! !!MicHTMLTag methodsFor: 'accessing'!close	"Close the receiver's tag. Note that this method does not check if the tag is opened"	stream << $>! !!MicHTMLTag methodsFor: 'accessing'!contents	"Answer a <String> with receiver's output without modifying the stream position"		^ stream contents! !!MicHTMLTag methodsFor: 'accessing'!htmlArgumentsMap	"Answer a <Dictionary> of receiver's associations between Microdown attributes and HTML attributes"		^ htmlArgumentsMap		ifNil: [ htmlArgumentsMap := self initializeArgumentsMap ]! !!MicHTMLTag methodsFor: 'accessing'!htmlArgumentsMapDo: aFullBlockClosure 	"Iterate over the receiver's mapping of Microdown to HTML attributes"	self htmlArgumentsMap associationsDo: aFullBlockClosure! !!MicHTMLTag methodsFor: 'initialization'!initializeArgumentsMap	^ Dictionary new		at: 'label' put: 'class';		at: 'width' put: 'width';		at: 'rel' put: 'rel';		at: 'target' put: 'target';		yourself! !!MicHTMLTag methodsFor: 'accessing'!parameterAt: keyString put: valueString	"Write a parameter named keyString with valueString as value. Note that this method does not close the tag"	stream 		space;		<< keyString;		<< '="';		<< valueString;		<< '"'! !!MicHTMLTag methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream << ' name: ['.	name		ifNotNil: [ aStream << name ].	aStream << '] contents: ('.	stream		ifNotNil: [ aStream << stream contents ].	aStream		<< ')'! !!MicHTMLTag methodsFor: 'accessing'!with: aString	stream 		nextPut: $>; 		<< aString;		<< '</'; 		<< name;		nextPut: $>! !!ZnClient methodsFor: '*Microdown-HTMLExporter'!requestSegments	"Answer a <Collection> with the receiver's parts (those separated by /)"	^ self requestUri segments! !!ZnClient methodsFor: '*Microdown-HTMLExporter'!requestUri	^ self request uri! !!ZnClient methodsFor: '*Microdown-HTMLExporter'!requestedResource	"Answer a <String> with the name of resource (file or directory) requested"		^ self requestSegments last! !!MicLinkBlock methodsFor: '*Microdown-HTMLExporter'!referencePath	^ self reference fullName! !!MicRelativeResourceReference methodsFor: '*Microdown-HTMLExporter'!uri	"Answer the receiver's reference in a uri (ZnUrl)."	^ self path asZnUrl! !!MicHTMLCanvas methodsFor: 'writing text'!initialize	"Private - Initialize the receiver's stream"	super initialize.	self initializeWith: String empty.! !!MicHTMLCanvas methodsFor: 'initialization'!initializeWith: aString	"Private - Set the receiver's stream to store the HTML contents"	self setStream: (self newMicStreamOn: aString)! !!MicHTMLCanvas methodsFor: 'initialization'!newMicStreamOn: aString	"Answer a new wrapper over aString to help not hardcoding line ending everywhere."	^ MicOutputStream new 		setStream: (WriteStream on: aString);		"nextPutAll: aString;"		yourself! !!MicHTMLCanvas methodsFor: 'accessing'!tag	^ self brush: MicHTMLTag new! !!Integer methodsFor: '*Microdown-HTMLExporter'!asFileSizeString	" From Magritte-Model.MetaGUI-SeanDeNigris.459.mcz "	#( 'B' 'KB' 'MB' 'GB' 'TB' 'PB' 'EB' 'ZB' 'YB' )		inject: self		into: [ :value :each |			value < 1024				ifFalse: [ value // 1024 ]				ifTrue: [ 					^ String streamContents: [ : stream |							stream 								nextPutAll: value asString;								space;								nextPutAll: each ] ] ]! !!Microdown class methodsFor: '*Microdown-HTMLExporter'!asHTMLDocument: aStringOrDoc	"Facade method to serialize a Microdown document or string to HTML"		^ MicHTMLVisitor serializeToHTMLDoc: aStringOrDoc.			! !!Microdown class methodsFor: '*Microdown-HTMLExporter'!asHTMLString: aStringOrDoc	"Facade method to render a microdown document or string to HTML"		^ MicHTMLVisitor asHTMLString: aStringOrDoc.			! !!Microdown class methodsFor: '*Microdown-HTMLExporter'!asHTMLString: aStringOrDoc configuration: aMicHTMLConfiguration	"Facade method to render a microdown document or string to HTML"		^ MicHTMLVisitor asHTMLString: aStringOrDoc configuration: aMicHTMLConfiguration			! !!MicHTMLStylerCommand class methodsFor: 'initialization'!defaultIconName	^self subclassResponsibility ! !!MicHTMLStylerCommand class methodsFor: 'instance creation'!forSpecContext: anObject	self flag: 'This helper is needed so icons can be displayed through #defaultIconName in class side subclasses (oposed to sending #iconNamed: to the command manually)'.	^ (self forSpecWithIconNamed: self defaultIconName)		context: anObject;		yourself! !!MicHTMLStylerCommand class methodsFor: 'accessing'!order	^ self subclassResponsibility! !!MicHTMLStylerCommand methodsFor: 'accessing'!cssFramework	"Answer the currently selected <MicCSSFramework>"	^ self context cssFramework! !!MicHTMLStylerCommand methodsFor: 'executing'!exportToHtml: aMicHTMLDoc 	"Write passed Microdown HTML document to a file"	aMicHTMLDoc exists		ifTrue: [			self context isOverwrite				ifFalse: [ ^ self inform: 'Already exists' ]				ifTrue: [ self removeExport: aMicHTMLDoc fullName asFileReference ] ].	aMicHTMLDoc writeToFileNamed: aMicHTMLDoc fileName.	self inform: 'Export finished'! !!MicHTMLStylerCommand methodsFor: 'updating'!micHtmlDocument	^ self context micHtmlDocument! !!MicHTMLStylerCommand methodsFor: 'private'!removeExport: aFileReference 	aFileReference parent ensureDeleteAll.! !!MicHTMLStylerExportCommand class methodsFor: 'default'!defaultDescription	^ 'Export Microdown to HTML'! !!MicHTMLStylerExportCommand class methodsFor: 'initialization'!defaultIconName	^ #smallExport! !!MicHTMLStylerExportCommand class methodsFor: 'default'!defaultName	^ 'Export'! !!MicHTMLStylerExportCommand class methodsFor: 'default'!defaultShortcutKey	^ $g command mac | $g ctrl win | $g ctrl unix! !!MicHTMLStylerExportCommand class methodsFor: 'accessing'!order	^ 6! !!MicHTMLStylerExportCommand methodsFor: 'testing'!canBeExecuted	^ super canBeExecuted and: [ self context hasMicHtmlDocument ]! !!MicHTMLStylerExportCommand methodsFor: 'executing'!execute	self canBeExecuted 		ifFalse: [ ^ self inform: 'Please open a Microdown document first' ].	self exportToHtml: self micHtmlDocument.! !!MicHTMLStylerHelpCommand class methodsFor: 'default'!defaultDescription 	^ 'Help'! !!MicHTMLStylerHelpCommand class methodsFor: 'initialization'!defaultIconName	^ #smallHelp! !!MicHTMLStylerHelpCommand class methodsFor: 'default'!defaultName	^ 'Help'! !!MicHTMLStylerHelpCommand class methodsFor: 'default'!defaultShortcutKey	^ $p command mac | $p ctrl win | $p ctrl unix! !!MicHTMLStylerHelpCommand class methodsFor: 'accessing'!order	^ 9! !!MicHTMLStylerHelpCommand methodsFor: 'executing'!execute	"Open a Help"	MicHTMLStylerHelp open.! !!MicHTMLStylerOpenCommand class methodsFor: 'default'!defaultDescription 	^ 'Open a Microdown document'! !!MicHTMLStylerOpenCommand class methodsFor: 'initialization'!defaultIconName 	^ #smallOpen! !!MicHTMLStylerOpenCommand class methodsFor: 'default'!defaultName	^ 'Open'! !!MicHTMLStylerOpenCommand class methodsFor: 'accessing - defaults'!defaultShortcutKey 	^ $o command mac | $o ctrl win | $o ctrl unix! !!MicHTMLStylerOpenCommand class methodsFor: 'accessing'!order	^ 2! !!MicHTMLStylerOpenCommand methodsFor: 'executing'!execute	(self requestFileNameForOpen: '*.md')		ifNotNil: [ : answer | 			(self isValidMic: answer)				ifTrue: [ self context micDocumentFileRef: answer asFileReference ]				ifFalse: [ self inform: 'File not recognized as Microdown format' ] ]! !!MicHTMLStylerOpenCommand methodsFor: 'testing'!isValidMic: aString 	"Answer <true> if aString is a valid Microdown file (determined by its extension)"		| fileRef |		fileRef := aString asFileReference.	^ fileRef exists and: [ fileRef extension asLowercase = 'md'  ]! !!MicHTMLStylerOpenCommand methodsFor: 'execution'!requestFileNameForOpen: extensionString	" Open request dialog to select a file "		^ UIManager default 		chooseFullFileNameMatching: (Array with: extensionString)		label: 'Choose ' , extensionString , ' file'! !!MicHTMLStylerPreviewCommand class methodsFor: 'default'!defaultDescription	^ 'Preview the selected style'! !!MicHTMLStylerPreviewCommand class methodsFor: 'initialization'!defaultIconName	^ #forward! !!MicHTMLStylerPreviewCommand class methodsFor: 'default'!defaultName	^ 'Preview'! !!MicHTMLStylerPreviewCommand class methodsFor: 'default'!defaultShortcutKey	^ $v command mac | $v ctrl win | $v ctrl unix! !!MicHTMLStylerPreviewCommand class methodsFor: 'accessing'!order	^ 3! !!MicHTMLStylerPreviewCommand methodsFor: 'testing'!canBeExecuted	^ super canBeExecuted and: [ self context hasMicHtmlDocument ]! !!MicHTMLStylerPreviewCommand methodsFor: 'executing'!execute	self canBeExecuted 		ifFalse: [ ^ self inform: 'Please open a Microdown document first' ].	self exportToHtml: self micHtmlDocument.	WebBrowser openOn: self micHtmlDocument fullName.! !!MicHTMLStylerQuitCommand class methodsFor: 'default'!defaultDescription 	^ 'Close the Styler'! !!MicHTMLStylerQuitCommand class methodsFor: 'initialization'!defaultIconName 	^ #smallQuit! !!MicHTMLStylerQuitCommand class methodsFor: 'default'!defaultName	^ 'Quit'! !!MicHTMLStylerQuitCommand class methodsFor: 'accessing'!order	^ 100! !!MicHTMLStylerQuitCommand methodsFor: 'executing'!execute	^ self context delete! !!MicHTMLStylerUpdateCommand class methodsFor: 'default'!defaultDescription 	^ 'Check for CSS frameworks updates'! !!MicHTMLStylerUpdateCommand class methodsFor: 'accessing - defaults'!defaultIconName 	^ #smallUpdate! !!MicHTMLStylerUpdateCommand class methodsFor: 'default'!defaultName 	^ 'Update'! !!MicHTMLStylerUpdateCommand class methodsFor: 'accessing'!order	^ 12! !!MicListItemBlock methodsFor: '*Microdown-HTMLExporter'!hasChildren	"Answer <true> if the receiver has any children"		^ self children size > 1! !!MicListItemBlock methodsFor: '*Microdown-HTMLExporter'!hasNestedChildren	"Answer <true> if the receiver's children are list items and they are nested"	^ (self children second isKindOf: MicListItemBlock) and: [		self children second nestedLevel > self nestedLevel  ]! !!MicListItemBlock methodsFor: '*Microdown-HTMLExporter'!listItemText	^ text! !!ZnUrl methodsFor: '*Microdown-HTMLExporter'!filename	^ self pathSegments last! !"Microdown-HTMLExporter"!!MicCSSNullFileTest commentStamp: '' prior: 0!A MicCSSNullFileTest is a test class for testing the behavior of MicCSSNullFile!!MicCSSProviderTest commentStamp: '' prior: 0!A MicCSSProviderTest is a test class for testing the behavior of MicCSSProvider!!MicHTMLBrushTest commentStamp: '' prior: 0!A MicHTMLBrushTest is a test class for testing the behavior of MicHTMLBrush!!MicHTMLTagTest commentStamp: '' prior: 0!A MicHTMLTagTest is a test class for testing the behavior of MicHTMLTag!!MicHTMLCanvasTest commentStamp: '' prior: 0!A MicHTMLCanvasTest is a test class for testing the behavior of MicHTMLCanvas!!MicHTMLConfigurationTest commentStamp: '' prior: 0!A MicHTMLConfigurationTest is a test class for testing the behavior of MicHTMLConfiguration!!MicHTMLVisitorTest commentStamp: '' prior: 0!A MicHTMLWriterTest is a test class for testing the behavior of MicHTMLWriter!!MicCSSDownloaderTest methodsFor: 'accessing'!cssDownloader	" Answer the cssDownloader of this MicCSSDownloaderTest "	^ cssDownloader! !!MicCSSDownloaderTest methodsFor: 'accessing'!cssDownloader: anObject	" Sets the cssDownloader of this MicCSSDownloaderTest "	cssDownloader := anObject! !!MicCSSDownloaderTest methodsFor: 'autogenerated'!setUp	super setUp.	cssDownloader := MicCSSDownloader new 		cssProvider: MicCSSProvider new;		yourself.! !!MicCSSDownloaderTest methodsFor: 'autogenerated'!testCssProvider	self assert: (cssDownloader cssProvider isKindOf: MicCSSProvider).! !!MicCSSDownloaderTest methodsFor: 'autogenerated'!testDestinationPath	self assert: (cssDownloader destinationPath isKindOf: String).	self deny: cssDownloader destinationPath isEmpty.! !!MicCSSDownloaderTest methodsFor: 'autogenerated'!testFrameworks 	self assert: (cssDownloader frameworks isKindOf: Collection).! !!MicCSSDownloaderTest methodsFor: 'autogenerated'!testHttpClient	self assert: (cssDownloader httpClient isKindOf: ZnClient).! !!MicCSSFileTest methodsFor: 'accessing'!fileRef	" Answer the fileRef of this MicCSSFileTest "	^ fileRef! !!MicCSSFileTest methodsFor: 'accessing'!fileRef: anObject	" Sets the fileRef of this MicCSSFileTest "	fileRef := anObject! !!MicCSSFileTest methodsFor: 'autogenerated'!resources	^ Array with: MicCSSFileResource! !!MicCSSFileTest methodsFor: 'autogenerated'!setUp	super setUp.	fileRef := MicCSSFileResource current micCSSFile! !!MicCSSFileTest methodsFor: 'autogenerated'!testBasename	self assert: (fileRef basename isKindOf: String).	self assert: fileRef basename equals: 'sample.css'! !!MicCSSFileTest methodsFor: 'autogenerated'!testContents	self assert: (fileRef contents isKindOf: String).	self deny: fileRef contents isEmpty.! !!MicCSSFileTest methodsFor: 'autogenerated'!testFileReference	self assert: (fileRef fileReference isKindOf: FileReference).	self assert: (fileRef fileReference basename endsWith: 'css')! !!MicCSSFileTest methodsFor: 'autogenerated'!testFullName	self assert: (fileRef fullName isKindOf: String).	self assert: fileRef fullName equals: '/css/sample.css'! !!MicCSSFileTest methodsFor: 'autogenerated'!testRelativePath	self assert: (fileRef relativePath isKindOf: String).	self assert: fileRef relativePath equals: '/css/sample.css'! !!MicCSSNullFileTest methodsFor: 'autogenerated'!setUp	super setUp.	fileRef := MicCSSNullFile new.! !!MicCSSNullFileTest methodsFor: 'test'!testContents	self assert: (fileRef contents isKindOf: String).	self assert: fileRef contents isEmpty.! !!MicCSSFrameworkTest methodsFor: 'accessing'!cssFramework	" Answer the cssFramework of this MicCSSFrameworkTest "	^ cssFramework! !!MicCSSFrameworkTest methodsFor: 'accessing'!cssFramework: anObject	" Sets the cssFramework of this MicCSSFrameworkTest "	cssFramework := anObject! !!MicCSSFrameworkTest methodsFor: 'autogenerated'!newMicCssTheme	| cssUrl minCssUrl destPath |		cssUrl := 'http://example.st/css/style.css'.	minCssUrl := 'http://example.st/css/style.min.css'.	destPath := FileSystem workingDirectory.	^ MicCSSTheme new		framework: self cssFramework;		name: 'MockTheme';		cssUrl: cssUrl;		minCssUrl: minCssUrl;		cssFile: (MicCSSFile new			fileReference: (destPath asFileReference / cssUrl asZnUrl filename);			yourself);		minCssFile: (MicCSSFile new			fileReference: (destPath asFileReference / minCssUrl asZnUrl filename);			yourself)		yourself! !!MicCSSFrameworkTest methodsFor: 'autogenerated'!newMicCssThemeInfo	^ Dictionary new		at: #name put: 'MockTheme';		at: #cssUrl put: 'http://example.st/css/style.css';		at: #minCss put: 'http://example.st/css/style.min.css';		yourself.! !!MicCSSFrameworkTest methodsFor: 'accessing'!setUp	super setUp.	cssFramework := MicCSSFramework new			name: 'MockFramework';			yourself.! !!MicCSSFrameworkTest methodsFor: 'autogenerated'!testAddTheme	self cssFramework addTheme: self newMicCssTheme.	self assert: cssFramework hasThemes.	self		   assert: cssFramework class		   equals: MicCSSFramework.   self assert: cssFramework hasMinifiedThemes.   self assert: cssFramework name equals: 'MockFramework'.   self assert: cssFramework minCssFile isNil.   self assert: cssFramework fonts isEmpty.   self assert: cssFramework resetUrl isEmpty.   self assert: cssFramework projectUrl isEmpty.   self assert: cssFramework hasNormalThemes.   self assert: cssFramework hasThemes.   self assert: cssFramework cssUrl isNil.   self deny: cssFramework hasMinifiedVersion! !!MicCSSFrameworkTest methodsFor: 'autogenerated'!testFonts	self assert: (cssFramework fonts isKindOf: Collection).! !!MicCSSFrameworkTest methodsFor: 'autogenerated'!testHasMinifiedThemes	self assert: (cssFramework hasMinifiedThemes isKindOf: Boolean).! !!MicCSSFrameworkTest methodsFor: 'autogenerated'!testHasNormalThemes	self assert: (cssFramework hasNormalThemes isKindOf: Boolean).! !!MicCSSFrameworkTest methodsFor: 'autogenerated'!testHasThemes	self assert: (cssFramework hasThemes isKindOf: Boolean).	self deny: cssFramework hasThemes.		cssFramework addTheme: self newMicCssTheme.	self assert: cssFramework hasThemes.! !!MicCSSFrameworkTest methodsFor: 'autogenerated'!testNewCssTheme	self assert: ((cssFramework newCssTheme: self newMicCssThemeInfo) isKindOf: MicCSSTheme).	self deny: cssFramework hasNormalThemes.! !!MicCSSFrameworkTest methodsFor: 'autogenerated'!testNormalizeUrl	self assert: (cssFramework normalizeUrl isKindOf: String).! !!MicCSSFrameworkTest methodsFor: 'autogenerated'!testProjectUrl	self assert: (cssFramework projectUrl isKindOf: String).! !!MicCSSFrameworkTest methodsFor: 'autogenerated'!testResetUrl	self assert: (cssFramework resetUrl isKindOf: String).! !!MicCSSFrameworkTest methodsFor: 'autogenerated'!testThemes	| themes |	themes := cssFramework themes.	self assert: (themes isKindOf: Collection).! !!MicCSSProviderTest methodsFor: 'accessing'!cssProvider	" Answer the cssProvider of this MicCSSProviderTest "	^ cssProvider! !!MicCSSProviderTest methodsFor: 'accessing'!cssProvider: anObject	" Sets the cssProvider of this MicCSSProviderTest "	cssProvider := anObject! !!MicCSSProviderTest methodsFor: 'running'!setUp	super setUp.	cssProvider := MicCSSProvider new.! !!MicCSSProviderTest methodsFor: 'autogenerated'!testCssDownloader	| downloader |	downloader := cssProvider cssDownloader.	self assert: (downloader isKindOf: MicCSSDownloader).	self assert: downloader class equals: MicCSSDownloader.	self assert: downloader destinationPath equals: 'support'.	self assert: downloader httpClient class equals: ZnClient.	self deny: downloader httpClient isConnected.	self		assert: downloader httpClient applicationFormUrlEncodedEntity class		equals: ZnApplicationFormUrlEncodedEntity.	self		assert: downloader httpClient applicationFormUrlEncodedEntity contentType class		equals: ZnMimeType.	self		assert: downloader httpClient applicationFormUrlEncodedEntity fields class		equals: ZnMultiValueDictionary.	self assert: downloader httpClient applicationFormUrlEncodedEntity hasContentType.	self		assert: downloader httpClient applicationFormUrlEncodedEntity contentLength		equals: 0.	self assert: downloader httpClient applicationFormUrlEncodedEntity hasContentLength.	self assert: downloader httpClient applicationFormUrlEncodedEntity isEmpty.	self		assert: downloader httpClient applicationFormUrlEncodedEntity contents class		equals: ZnMultiValueDictionary.	self assert: downloader httpClient connection isNil.	self assert: downloader httpClient request class equals: ZnRequest.	self assert: downloader httpClient request isHttp11.	self		assert: downloader httpClient request requestLine class		equals: ZnRequestLine.	self assert: downloader httpClient request server isNil.	self deny: downloader httpClient request hasSession.	self		assert: downloader httpClient request cookies class		equals: Array.	self assertEmpty: downloader httpClient request cookies.	self assert: downloader httpClient request absoluteUrl isNil.	self deny: downloader httpClient request isConnectionKeepAlive.	self assert: downloader httpClient request host isNil.	self deny: downloader httpClient request isHttp10.	self assert: downloader httpClient request uri isNil.	self assert: downloader httpClient request accept equals: '*/*'.	self deny: downloader httpClient request wantsConnectionClose.	self deny: downloader httpClient request isConnectionClose.	self deny: downloader httpClient request acceptsEncodingGzip.	self		assert: downloader cssProvider newCssDownloader httpClient class		equals: ZnClient.	self		assert: downloader cssProvider newCssDownloader cssProvider class		equals: MicCSSProvider.	self		assert: downloader cssProvider newCssDownloader frameworks class		equals: Array.	self assert: downloader frameworks class equals: Array.! !!MicCSSProviderTest methodsFor: 'autogenerated'!testDefaultFramework	self assert: (cssProvider class defaultFramework isKindOf: String).	self deny: cssProvider class defaultFramework isEmpty! !!MicCSSProviderTest methodsFor: 'autogenerated'!testDefaultFrameworks	self assert: (cssProvider defaultFrameworks isKindOf: Collection).	self assert: (cssProvider frameworks allSatisfy: [ : frw | frw isKindOf: MicCSSFramework ])! !!MicCSSProviderTest methodsFor: 'autogenerated'!testDestinationPath	self assert: (cssProvider destinationPath isKindOf: String).	cssProvider destinationPath: FileSystem workingDirectory fullName.		self assert: cssProvider destinationPath equals: FileSystem workingDirectory fullName.! !!MicCSSProviderTest methodsFor: 'autogenerated'!testFindCssNamed	| attriCss sampleCss |	attriCss := MicCSSFramework new		            name: 'AttriCSS';		            yourself.	sampleCss := cssProvider findCssNamed: 'AttriCSS'.	self		should: [ cssProvider findCssNamed: String empty ]		raise: NotFound.	self		should: [ cssProvider findCssNamed: 'c30ba728-32a0-0d00-af65-cfc80a260270' ]		raise: NotFound.	self should: [ cssProvider findCssNamed: nil ] raise: NotFound.	self assert: sampleCss name equals: attriCss name.	self assert: attriCss class equals: MicCSSFramework.	self assert: attriCss minCssFile isNil.	self deny: attriCss hasMinifiedVersion.	self assert: attriCss resetUrl isEmpty.	self assert: attriCss themes isEmpty.	self assert: attriCss projectUrl isEmpty.	self assert: attriCss name equals: 'AttriCSS'.	self assert: attriCss cssUrl isNil.	self assert: attriCss fonts isEmpty.! !!MicCSSProviderTest methodsFor: 'autogenerated'!testForCSSNamed		| tufte |	self should: [ MicCSSProvider forCSSNamed: 'XXXXXXXX' ] raise: NotFound.	tufte := MicCSSProvider forCSSNamed: 'Tufte'.	self assert: (tufte isKindOf: MicCSSFramework)	.	self assert: tufte name equals: 'Tufte'.! !!MicCSSProviderTest methodsFor: 'autogenerated'!testFrameworks	| frws |	frws := cssProvider frameworks.	self assert: (frws isKindOf: Collection).	self assert: frws class equals: Array.! !!MicCSSProviderTest methodsFor: 'autogenerated'!testFrameworksSpecs	| frwSpecs |	frwSpecs := cssProvider frameworksSpecs.	self assert: (frwSpecs isKindOf: Collection).	self assert: frwSpecs class equals: Array.! !!MicCSSProviderTest methodsFor: 'autogenerated'!testHasFrameworksInstalled	self assert: (cssProvider hasFrameworksInstalled isKindOf: Boolean).! !!MicCSSProviderTest methodsFor: 'autogenerated'!testNewCssDownloader	self assert: (cssProvider newCssDownloader isKindOf: MicCSSDownloader).! !!MicCSSThemeTest methodsFor: 'accessing'!cssTheme	" Answer the cssTheme of this MicCSSThemeTest "	^ cssTheme! !!MicCSSThemeTest methodsFor: 'accessing'!cssTheme: anObject	" Sets the cssTheme of this MicCSSThemeTest "	cssTheme := anObject! !!MicCSSThemeTest methodsFor: 'autogenerated'!setUp	super setUp.	cssTheme := MicCSSTheme new		framework: (MicCSSFramework new name: 'MockFramework'; yourself);		yourself! !!MicCSSThemeTest methodsFor: 'autogenerated'!testFramework	self assert: (cssTheme framework isKindOf: MicCSSFramework).! !!MicHTMLBrushTest methodsFor: 'running'!setUp	super setUp.	tag := MicHTMLTag new		setStream: (MicOutputStream new setStream: (WriteStream on: (String new: 1000)));		yourself.! !!MicHTMLBrushTest methodsFor: 'accessing'!tag	^ tag! !!MicHTMLBrushTest methodsFor: 'tests'!testName	tag name: 'prueba'.	self assert: tag name equals: 'prueba'! !!MicHTMLTagTest methodsFor: 'tests'!sampleMicFigureBlock	^ MicFigureBlock new 		argumentAt: 'label' put: 'sampleClass';		argumentAt: 'width' put: '30';		yourself.! !!MicHTMLTagTest methodsFor: 'tests'!testAddArguments	self tag addArguments: self sampleMicFigureBlock.	self 		assertCollection: ((self tag contents findTokens: '=') collect: #trimBoth)		hasSameElements: #('class' '"sampleClass" width' '"30"').! !!MicHTMLTagTest methodsFor: 'tests'!testClose	tag close.	self assert: tag contents equals: '>'! !!MicHTMLTagTest methodsFor: 'tests'!testContents	tag 		name: 'falop';		with: 'This is a test'.		self assert: tag contents equals: '<falop>This is a test</falop>'! !!MicHTMLTagTest methodsFor: 'tests'!testInitializeArgumentsMap	self 		assert: (tag initializeArgumentsMap isKindOf: Dictionary)		description: 'It test that the arguments map is of type Dictionary'.! !!MicHTMLTagTest methodsFor: 'tests'!testParameterAtPut	| keyString valueString tagContents parsedAssoc |	keyString := 'aKey'.	valueString := 'aValueString'.		tag parameterAt: keyString put: valueString.	tagContents := tag contents.	self 		assert: (tagContents beginsWith: ' ')		description: 'It tests that we write a parameter named keyString with valueString as value.'.	parsedAssoc := tagContents findTokens: '='.	self assert: parsedAssoc first trimBoth equals: keyString.	self assert: parsedAssoc second trimBoth equals: (valueString surroundedBy: '"').	! !!MicHTMLTagTest methodsFor: 'tests'!testWith	tag 		name: '';		with: 'This is a test'.		self assert: tag contents equals: '<>This is a test</>'! !!MicHTMLCanvasTest methodsFor: 'running'!setUp	super setUp.	canvas := MicHTMLCanvas on: (MicOutputStream new setStream: (WriteStream on: (String new: 1000))).! !!MicHTMLCanvasTest methodsFor: 'tests'!testTag		self assert: (canvas tag isKindOf: MicHTMLTag)! !!MicHTMLConfigurationTest methodsFor: 'tests'!docTypeOptions	^ #('<!!DOCTYPE html>''<!!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">''<!!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">''<!!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">' '<!!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">'		'<!!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">'	'<!!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN""http://www.w3.org/TR/html4/frameset.dtd">''<!!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""http://www.w3.org/TR/html4/strict.dtd">'		 '<!!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">'		'<!!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0 Strict Level 2//EN">')! !!MicHTMLConfigurationTest methodsFor: 'running'!setUp	super setUp.	configuration := MicHTMLConfiguration new 		document: doc;		yourself! !!MicHTMLConfigurationTest methodsFor: 'tests'!testAuthor	self		assert: (configuration author isKindOf: String)		description: 'It test that a configuration by default has an empty author'.			configuration author: 'Steve Vai'.	self		assert: configuration author		equals: 'Steve Vai'.! !!MicHTMLConfigurationTest methodsFor: 'tests'!testBeCssEmbedded	self		deny: configuration isCssEmbedded		description: 'It test that by default a configuration is linked'.			configuration beCssEmbedded.	self		assert: configuration isCssEmbedded		description: 'It test that by a configuration is now embedded'.! !!MicHTMLConfigurationTest methodsFor: 'tests'!testBeCssLinked	configuration beCssEmbedded.		self		assert: configuration isCssEmbedded		description: 'It test that a configuration is embedded'.			configuration beCssLinked.	self		deny: configuration isCssEmbedded		equals: 'It test that by a configuration is now linked'.! !!MicHTMLConfigurationTest methodsFor: 'tests'!testBeRobotFollow	self		assert: configuration robots isEmpty		description: 'It test that a configuration has no instructions for robots'.			configuration beRobotFollow.	self		assertCollection: configuration robots		hasSameElements: #('follow').! !!MicHTMLConfigurationTest methodsFor: 'tests'!testBeRobotIndex	self		assert: configuration robots isEmpty		description: 'It test that a configuration has no instructions for robots'.			configuration beRobotIndex.	self		assertCollection: configuration robots		hasSameElements: #('index').! !!MicHTMLConfigurationTest methodsFor: 'tests'!testBeRobotNoArchive	self		assert: configuration robots isEmpty		description: 'It test that a configuration has no instructions for robots'.			configuration beRobotNoArchive.	self		assertCollection: configuration robots		hasSameElements: #('noarchive').! !!MicHTMLConfigurationTest methodsFor: 'tests'!testBeRobotNoCache	self		assert: configuration robots isEmpty		description: 'It test that a configuration has no instructions for robots'.			configuration beRobotNoCache.	self		assertCollection: configuration robots		hasSameElements: #('nocache').! !!MicHTMLConfigurationTest methodsFor: 'tests'!testBeRobotNoFollow	self		assert: configuration robots isEmpty		description: 'It test that a configuration has no instructions for robots'.			configuration beRobotNoFollow.	self		assertCollection: configuration robots		hasSameElements: #('nofollow').! !!MicHTMLConfigurationTest methodsFor: 'tests'!testBeRobotNoImageIndex	self		assert: configuration robots isEmpty		description: 'It test that a configuration has no instructions for robots'.			configuration beRobotNoImageIndex.	self		assertCollection: configuration robots		hasSameElements: #('noimageindex').! !!MicHTMLConfigurationTest methodsFor: 'tests'!testBeRobotNoIndex	self		assert: configuration robots isEmpty		description: 'It test that a configuration has no instructions for robots'.			configuration beRobotNoIndex.	self		assertCollection: configuration robots		hasSameElements: #('noindex').! !!MicHTMLConfigurationTest methodsFor: 'tests'!testBeRobotNoSnippet	self		assert: configuration robots isEmpty		description: 'It test that a configuration has no instructions for robots'.			configuration beRobotNoSnippet.	self		assertCollection: configuration robots		hasSameElements: #('nosnippet').! !!MicHTMLConfigurationTest methodsFor: 'tests'!testBeRobotNoTranslate	self		assert: configuration robots isEmpty		description: 'It test that a configuration has no instructions for robots'.			configuration beRobotNoTranslate.	self		assertCollection: configuration robots		hasSameElements: #('notranslate').! !!MicHTMLConfigurationTest methodsFor: 'tests'!testBeTargetAttributeBlank	configuration beTargetAttributeBlank.	self assert: configuration targetAttribute equals: '_blank'.! !!MicHTMLConfigurationTest methodsFor: 'tests'!testBeTargetAttributeParent	configuration beTargetAttributeParent.	self assert: configuration targetAttribute equals: '_parent'.! !!MicHTMLConfigurationTest methodsFor: 'tests'!testBeTargetAttributeSelf	configuration beTargetAttributeSelf.	self assert: configuration targetAttribute equals: '_self'.! !!MicHTMLConfigurationTest methodsFor: 'tests'!testBeTargetAttributeTop	configuration beTargetAttributeTop.	self assert: configuration targetAttribute equals: '_top'.! !!MicHTMLConfigurationTest methodsFor: 'tests'!testCssFrameworks	self		assert: (configuration cssFrameworks isKindOf: Collection)		description: 'It test that the contained CSS files is a Collection'.			self		assert: configuration cssFrameworks isEmpty		description: 'It test that the contained CSS files collection is empty'! !!MicHTMLConfigurationTest methodsFor: 'tests'!testDate	self		assert: configuration date isNil		description: 'It test that by default a configuration have no date assigned'.			configuration date: '9 August 2022'.	self		assert: configuration date		equals: '9 August 2022'.! !!MicHTMLConfigurationTest methodsFor: 'tests'!testDefaultCharset	self		assert: (configuration defaultCharset isKindOf: String)		description: 'It test that the default character set of a document is a String'.			self		assert: configuration defaultCharset 		equals: 'utf-8'! !!MicHTMLConfigurationTest methodsFor: 'test'!testDefaultDocumentType	self 		assert: (configuration defaultDocumentType isKindOf: String)		description: 'It tests that the default document type identifier is a String'.! !!MicHTMLConfigurationTest methodsFor: 'tests'!testDefaultLanguageId	self		assert: (configuration defaultLanguageId isKindOf: String)		description: 'It test that the default language identifier is a String'.			self		assert: configuration defaultLanguageId notEmpty		description: 'It test that the default language identifier is not empty'! !!MicHTMLConfigurationTest methodsFor: 'tests'!testDefaultTargetAttribute	| validTargetAttributes |	self		assert: (configuration defaultTargetAttribute isKindOf: String)		description: 'It test that a default configuration target is a String'.			validTargetAttributes := #('_blank' '_parent' '_self' '_top').	self		assert: (validTargetAttributes includes: configuration defaultTargetAttribute)		description: 'It test a target should be one of the valid types'		! !!MicHTMLConfigurationTest methodsFor: 'tests'!testDefaultTitle	self		assert: (configuration defaultTitle isKindOf: String)		description: 'It test that the default title of a document is a String'.		! !!MicHTMLConfigurationTest methodsFor: 'tests'!testDefaultViewport	self		assert: (configuration defaultViewport isKindOf: String)		description: 'It test that the default viewport of a document is a String'.		! !!MicHTMLConfigurationTest methodsFor: 'tests'!testDescription	self		assert: configuration description isEmpty		description: 'It test that a configuration has no default description'.			configuration description: 'My cool HTML document'.	self		assert: configuration description		equals: 'My cool HTML document'.! !!MicHTMLConfigurationTest methodsFor: 'tests'!testDocument	self		assert: (configuration document isKindOf: MicHTMLDocument)		description: 'It test a configuration has a MicHTMLDocument'.			configuration document: nil.	self		assert: configuration document isNil		description: 'It test that now configuration does not have a related HTML document'.		! !!MicHTMLConfigurationTest methodsFor: 'tests'!testDocumentType	self 		assert: (configuration documentType isKindOf: String)		description: 'The document type should be described as String'.			configuration documentType: '<!!DOCTYPE html>'.	self		assert: (self docTypeOptions includes: configuration documentType)! !!MicHTMLConfigurationTest methodsFor: 'tests'!testIsCssEmbedded	self deny: configuration isCssEmbedded.		configuration beCssEmbedded.		self assert: configuration isCssEmbedded! !!MicHTMLConfigurationTest methodsFor: 'tests'!testKeywords	self		assert: (configuration keywords isKindOf: Collection)		description: 'It test that the keywords of a document is a Collection'.		self		assert: configuration keywords isEmpty		description: 'It test that the default keywords of a document is empty'.	configuration keywords: #('keyword1' 'keyword2').		self		assertCollection: configuration keywords		equals: #('keyword1' 'keyword2').						! !!MicHTMLConfigurationTest methodsFor: 'tests'!testLanguageId	self		assert: (configuration languageId isKindOf: String)		description: 'It test that the language identifier of a document is a String'.		doc languageId: 'es'.		self		assert: doc languageId		equals: 'es'! !!MicHTMLConfigurationTest methodsFor: 'tests'!testMetadataSelectorMap	self		assert: (configuration metadataSelectorMap isKindOf: Dictionary)		description: 'It test that the metadata mapping to selectors is a Dictionary'.		self		deny: configuration metadataSelectorMap isEmpty		description: 'It test that the metadata mapping to selectors is not empty'.! !!MicHTMLConfigurationTest methodsFor: 'tests'!testRobots	self		assert: (configuration robots isKindOf: Collection)		description: 'It test that robots are a collection'.	self		assert: configuration robots isEmpty		description: 'It test that we have no instructions for robots by default'.			configuration beRobotIndex.		self		assert: (configuration robots size = 1)		description: 'It test that there is at least one instruction for robots'.			configuration beRobotNoCache.		self		assert: configuration robots size		equals: 2						! !!MicHTMLConfigurationTest methodsFor: 'tests'!testTitle	self 		assert: (configuration title isKindOf: String)		description: 'The document title should be described as String'.			configuration title: 'Hello Microdown'.	self		assert: configuration title		equals: 'Hello Microdown'.! !!MicHTMLConfigurationTest methodsFor: 'tests'!testWriteDocumentAuthor	| parsedContents metaElements |	configuration author: 'Alex Lifeson'.	configuration writeDocumentAuthor.	self deny: doc contents isEmpty.	self assert: (doc contents beginsWith: '<meta').	parsedContents := (XMLHTMLParser on: doc contents) parseDocument.	metaElements := parsedContents descendantElementsNamed: 'meta'.	self		assert: ((metaElements elementsDetect: [ : e | (e attributeNodeAt: 'name') value = 'author' ]) attributeAt: 'content')		equals: 'Alex Lifeson'.! !!MicHTMLConfigurationTest methodsFor: 'tests'!testWriteDocumentCSS	"| parsedContents linkElements |"		self skip.	"Need to think about creating referenced CSS files on the fly/on demand"	"doc addCSSNamed: self sampleMicCSSName.	configuration writeDocumentCSS.	self deny: doc contents isEmpty.	doc addCSSNamed: self sampleMicCSSName.	parsedContents := (XMLHTMLParser on: doc contents) parseDocument.	linkElements := parsedContents descendantElementsNamed: 'link'.	self		assert: ((linkElements elementsDetect: [ : e | e includesAttribute: 'rel' ]) attributeAt: 'href')		equals: 'css/awsm.css'."! !!MicHTMLConfigurationTest methodsFor: 'tests'!testWriteDocumentCharSet	| parsedTag |	configuration writeDocumentCharSet.	self deny: doc contents isEmpty.	parsedTag := (doc contents copyWithoutAll: '<">') substrings.	self assert: (parsedTag includes: 'charset=' , doc charSet)! !!MicHTMLConfigurationTest methodsFor: 'tests'!testWriteDocumentDate	| parsedContents metaElements |	configuration date: Date today asString.	configuration writeDocumentDate.	self deny: doc contents isEmpty.	self assert: (doc contents beginsWith: '<meta').	parsedContents := (XMLHTMLParser on: doc contents) parseDocument.	metaElements := parsedContents descendantElementsNamed: 'meta'.	self		assert: ((metaElements elementsDetect: [ : e | (e attributeNodeAt: 'name') value = 'date' ]) attributeAt: 'content')		equals: Date today asString.! !!MicHTMLConfigurationTest methodsFor: 'tests'!testWriteDocumentDescription	| parsedTag |	configuration writeDocumentDescription.	self deny: doc contents isEmpty.	parsedTag := (doc contents copyWithoutAll: '<">') substrings.	self assert: (parsedTag includes: 'content=' , doc description ).	! !!MicHTMLConfigurationTest methodsFor: 'tests'!testWriteDocumentGenerator	| parsedTag |	configuration writeDocumentGenerator.	self deny: doc contents isEmpty.	parsedTag := (doc contents copyWithoutAll: '<">') substrings.	self assert: (parsedTag includes: 'name=generator').	self assert: (parsedTag includes: 'content=Microdown' ).	! !!MicHTMLConfigurationTest methodsFor: 'tests'!testWriteDocumentHead	configuration writeDocumentHead.	self deny: doc contents isEmpty.	self assert: (doc contents beginsWith: '<head>').	self assert: (doc contents endsWith: '</head>')! !!MicHTMLConfigurationTest methodsFor: 'tests'!testWriteDocumentKeywords	| parsedContents metaElements |	configuration keywords: 'keyword1, keyword2, keyword3'.	configuration writeDocumentKeywords.	self deny: doc contents isEmpty.	self assert: (doc contents beginsWith: '<meta').	parsedContents := (XMLHTMLParser on: doc contents) parseDocument.	metaElements := parsedContents descendantElementsNamed: 'meta'.	self		assert: ((metaElements elementsDetect: [ : e | (e attributeNodeAt: 'name') value = 'keywords' ]) attributeAt: 'content')		equals: 'keyword1, keyword2, keyword3'.! !!MicHTMLConfigurationTest methodsFor: 'tests'!testWriteDocumentMetadata	| parsedContents metaElements |	configuration writeDocumentMetadata.	self deny: doc contents isEmpty.	self assert: (doc contents beginsWith: '<meta').	parsedContents := (XMLHTMLParser on: doc contents) parseDocument.	metaElements := parsedContents descendantElementsNamed: 'meta'.	self		assert: ((metaElements elementsDetect: [ : e | e includesAttribute: 'http-equiv' ]) attributeAt: 'content')		equals: 'text/html; charset=utf-8'.	self		assert: ((metaElements elementsDetect: [ : e | (e attributeNodeAt: 'name') value = 'generator' ]) attributeAt: 'content')		equals: 'Microdown'.	self		assert: ((metaElements elementsDetect: [ : e | (e attributeNodeAt: 'name') value = 'viewport' ]) attributeAt: 'content')		equals: 'width=device-width,initial-scale=1.0,user-scalable=yes'.! !!MicHTMLConfigurationTest methodsFor: 'tests'!testWriteDocumentRobots	| parsedContents metaElements |	configuration beRobotNoFollow; beRobotNoIndex.	configuration writeDocumentRobots.	self deny: doc contents isEmpty.	self assert: (doc contents beginsWith: '<meta').	parsedContents := (XMLHTMLParser on: doc contents) parseDocument.	metaElements := parsedContents descendantElementsNamed: 'meta'.	self		assert: ((metaElements elementsDetect: [ : e | (e attributeNodeAt: 'name') value = 'robots' ]) attributeAt: 'content')		equals: 'nofollow, noindex'.! !!MicHTMLConfigurationTest methodsFor: 'tests'!testWriteDocumentTitle	configuration writeDocumentTitle.	self deny: doc contents isEmpty.		self assert: (doc contents beginsWith: '<title>').	self assert: (doc contents endsWith: '</title>')! !!MicHTMLConfigurationTest methodsFor: 'tests'!testWriteDocumentType	configuration writeDocumentType.	self deny: doc contents isEmpty.		self 		assert: doc contents		equals: doc documentType.! !!MicHTMLConfigurationTest methodsFor: 'tests'!testWriteDocumentViewport	| parsedTag |	configuration writeDocumentViewport.	self deny: doc contents isEmpty.	parsedTag := (doc contents copyWithoutAll: '<">') substrings.	self assert: (parsedTag includes: 'name=viewport').		self assert: (parsedTag includes: 'content=' , configuration viewport).	! !!MicHTMLDocumentTest class methodsFor: 'tests'!resources	^ Array with: MicCSSFileResource! !!MicHTMLDocumentTest methodsFor: 'running'!sampleHTMLBody	^ MicDocFactory exampleMicAsHTMLBodyString! !!MicHTMLDocumentTest methodsFor: 'tests'!sampleMicCSSFile	^ MicCSSFileResource current micCSSFile! !!MicHTMLDocumentTest methodsFor: 'tests'!sampleMicCSSName	^ MicCSSProvider defaultFramework! !!MicHTMLDocumentTest methodsFor: 'running'!setUp		super setUp.	docString := self sampleHTMLBody.	doc := MicHTMLDocument new.! !!MicHTMLDocumentTest methodsFor: 'tests'!tearDown 	super tearDown.	doc fullName asFileReference ensureDelete! !!MicHTMLDocumentTest methodsFor: 'tests'!testAddCSSNamed	|micCSSFrw |	micCSSFrw := doc addCSSNamed: self sampleMicCSSName.	self		assertCollection: doc cssFrameworks		hasSameElements: { micCSSFrw }		! !!MicHTMLDocumentTest methodsFor: 'tests'!testAuthor	self		assert: (doc author isKindOf: String)		description: 'It test that the author of a document is a String'.			self		assert: doc author isEmpty		description: 'It test that the default author of a document is empty'.			doc author: 'Nicole Neumann'.	self 		assert: doc author		equals: 'Nicole Neumann'! !!MicHTMLDocumentTest methodsFor: 'tests'!testCanvasClass	self		assert: (doc canvasClass = MicHTMLCanvas)		description: 'It tests that the canvas class of a document is a HTML canvas' ! !!MicHTMLDocumentTest methodsFor: 'tests'!testCharSet	self 		assert: (doc charSet isKindOf: String)		description: 'It tests that the charSet identifier is a String'.			self		assert: doc charSet notNil		description: 'It test that the document charset has beed initialized'.	! !!MicHTMLDocumentTest methodsFor: 'tests'!testConfiguration	self 		assert: (doc configuration isKindOf: MicHTMLConfiguration)		description: 'It tests that the configuration is a MicHTMLConfiguration'.! !!MicHTMLDocumentTest methodsFor: 'tests'!testContents	self 		assert: (doc contents isKindOf: String) 		description: 'It test that a HTML document contents contains a String'.	self 		assert: doc contents isEmpty		description: 'It test that a HTML document contents is not empty'.! !!MicHTMLDocumentTest methodsFor: 'tests'!testCssFrameworks	self		assert: (doc cssFrameworks isKindOf: Collection)		description: 'It test that the contained CSS files is a Collection'.			self		assert: doc cssFrameworks isEmpty		description: 'It test that the contained CSS files collection is empty'! !!MicHTMLDocumentTest methodsFor: 'tests'!testDescription	| sampleDescription |		sampleDescription := 'Sample Microdown HTML document'.	self		assert: (doc description isKindOf: String)		description: 'It test that the description is a String'.			doc description: sampleDescription.	self		assert: doc description		equals: sampleDescription! !!MicHTMLDocumentTest methodsFor: 'tests'!testDestinationPath	self assert: (doc destinationPath isKindOf: String).	self deny: doc destinationPath isEmpty.! !!MicHTMLDocumentTest methodsFor: 'tests'!testDocumentType	self 		assert: (doc documentType isKindOf: String)		description: 'The document type should be described as String'.			doc documentType: ''.	self		assert: doc documentType		equals: String empty! !!MicHTMLDocumentTest methodsFor: 'tests'!testExists	self 		deny: doc exists 		description: 'It tests the document has not been yet created'.	doc writeToFile.	self		assert: doc exists		description: 'It tests the document has been created'! !!MicHTMLDocumentTest methodsFor: 'tests'!testFileName	self 		assert: doc fileName = 'index.html'		description: 'A document default file name is index.html'.! !!MicHTMLDocumentTest methodsFor: 'tests'!testFromMicrodown	| html |		html := doc fromMicrodown: MicDocFactory exampleMic.	self		deny: html contents isEmpty.! !!MicHTMLDocumentTest methodsFor: 'tests'!testKeywords	self		assert: (doc keywords isKindOf: Collection)		description: 'It test that the keywords of a document is a Collection'.		self		assert: doc keywords isEmpty		description: 'It test that the default keywords of a document is empty'.	doc keywords: #('keyword1' 'keyword2').		self		assertCollection: doc keywords		equals: #('keyword1' 'keyword2').						! !!MicHTMLDocumentTest methodsFor: 'tests'!testLanguageId	self		assert: (doc languageId isKindOf: String)		description: 'It test that the language identifier of a document is a String'.		doc languageId: 'es'.		self		assert: doc languageId		equals: 'es'! !!MicHTMLDocumentTest methodsFor: 'tests'!testNewMicStreamOn	self 		assert: ((doc newMicStreamOn: String empty) isKindOf: MicOutputStream)		description: 'It checks that we obtain a new Microdown stream wrapper'! !!MicHTMLDocumentTest methodsFor: 'tests'!testSetCharSetUTF8	doc charSet: nil.	self assert: doc charSet isNil.		doc setCharSetUTF8.	self assert: doc charSet asLowercase  equals: 'utf-8'! !!MicHTMLDocumentTest methodsFor: 'tests'!testTempFileName	self 		assert: (doc tempFileName isKindOf: String)		description: 'It test that a temporary file name is of correct class'.			self		assert: (doc tempFileName endsWith: '.html')		description: 'It test that a temporary file name should have correct HTML extension'.			self		deny: doc tempFileName first		equals: '.'! !!MicHTMLDocumentTest methodsFor: 'tests'!testTitle	self		assert: (doc title isKindOf: String)		description: 'It test that the title of a document is a String'.			self		assert: doc title notEmpty		description: 'It test that the default title of a document is not empty'! !!MicHTMLDocumentTest methodsFor: 'tests'!testWriteDocument	| parsedContents |	doc writeDocument: 'Prueba'.	self deny: doc contents isEmpty.	self assert: (doc contents beginsWith: '<!!DOCTYPE html>').	self assert: (doc contents endsWith: '</html>').	parsedContents := (XMLHTMLParser on: doc contents) parseDocument.	self		assert: ((parsedContents descendantElementsNamed: 'body') contentStringAt: 'body')		equals: 'Prueba'! !!MicHTMLDocumentTest methodsFor: 'tests'!testWriteDocumentBody	doc writeDocumentBody: 'Prueba'.	self deny: doc contents isEmpty.	self assert: (doc contents beginsWith: '<body>').	self assert: (doc contents endsWith: '</body>')! !!MicHTMLDocumentTest methodsFor: 'tests'!testWriteToFile	| fileName file wd |		fileName := 'index.html'.	wd := FileSystem memory workingDirectory / 'testDir'.	file := wd / fileName.	doc 		destinationPath: wd;		writeToFile.	self 		assert: file exists		description: 'It tests that the document was created'.	self 		assert: file basename		equals: fileName.	wd ensureDeleteAllChildren.! !!MicHTMLDocumentTest methodsFor: 'tests'!testWriteToFileNamed	| fileName file wd |		fileName := 'sampleFile.html'.	wd := FileSystem memory workingDirectory / 'testDir'.	file := wd / fileName.	doc 		destinationPath: wd;		writeToFileNamed: fileName.	self 		assert: file exists		description: 'It tests that the document was created'.	self 		assert: file basename		equals: fileName.	wd ensureDeleteAllChildren.! !!MicHTMLExporterTest class methodsFor: 'tests'!testParameters	^ ParametrizedTestMatrix new		  forSelector: #writer addOptions: { MicHTMLVisitor };		  forSelector: #factory addOptions: { MicMicrodownSnippetFactory };		  forSelector: #parser addOptions: { Microdown };		  forSelector: #newLine addOptions: { String cr . String lf . String crlf };		  yourself! !!MicHTMLExporterTest methodsFor: 'accessing'!factory: aFactory	factory := aFactory new! !!MicHTMLExporterTest methodsFor: 'accessing'!newLine: aNewLine	(aNewLine = String cr) ifTrue:[ writer crAsNewLine ].	(aNewLine = String lf) ifTrue:[ writer lfAsNewLine ].	(aNewLine = String crlf) ifTrue:[ writer crlfAsNewLine ].	newLine := aNewLine! !!MicHTMLExporterTest methodsFor: 'utilities'!parse: aString andCheckWeGet: aResultingString		| mic |	mic := parser parse: 	aString.	writer visit: mic.	self assert: writer contents equals: aResultingString! !!MicHTMLExporterTest methodsFor: 'utilities'!parser	^ parser! !!MicHTMLExporterTest methodsFor: 'accessing'!parser: aParser	parser := aParser new! !!MicHTMLExporterTest methodsFor: 'tests - paragraph'!testAccents	self parse: 'éà' andCheckWeGet: newLine,'<p>éà</p>'! !!MicHTMLExporterTest methodsFor: 'utilities'!testAnchor	self parse: factory anchorSample andCheckWeGet:  '<a id="test"></a>'	! !!MicHTMLExporterTest methodsFor: 'utilities'!testCodeCreatesInnerText	| code |	code := (self parser parse: '```a b```') children first.	self assert: code class equals: MicCodeBlock.	self assert: code language equals: 'a b```'! !!MicHTMLExporterTest methodsFor: 'tests'!testCodeWithoutParam	| doc |	doc := (parser parse: '```abfoo bar```') children first.	writer visit: doc.	self assert: writer contents equals: newLine ,'<pre><code>ab', newLine ,'foo bar</code></pre>', newLine! !!MicHTMLExporterTest methodsFor: 'tests'!testFigure	self 		parse: factory figureSample 		andCheckWeGet: newLine ,'<p><figure><img src="/anUrl" alt="Foo" class="figureTest" width="80"><figcaption>Foo</figcaption></img></figure></p>'! !!MicHTMLExporterTest methodsFor: 'tests - formats'!testFigureBold	self 		parse: factory figureBoldSample 		andCheckWeGet: newLine ,'<p><figure><img src="/anUrl" alt="**Foo**" class="figureTest" width="80"><figcaption><strong>Foo</strong></figcaption></img></figure></p>'! !!MicHTMLExporterTest methodsFor: 'tests'!testFigureItalic	self 		parse: factory figureItalicSample 		andCheckWeGet: newLine ,'<p><figure><img src="/anUrl" alt="_Foo_" class="figureTest" width="80"><figcaption><i>Foo</i></figcaption></img></figure></p>'! !!MicHTMLExporterTest methodsFor: 'tests'!testFigureNested	self 		parse: factory figureNestedSample 		andCheckWeGet: newLine ,'<p><figure><img src="/anUrl" alt="**Foo_**" class="figureTest" width="80"><figcaption><strong>Foo_</strong></figcaption></img></figure></p>'! !!MicHTMLExporterTest methodsFor: 'tests'!testFigureReal	self 		parse: factory figureRealSample 		andCheckWeGet: newLine ,'<p><figure><img src="figures/logo.png" alt="A logo png under figures folder" class="figureTest" width="80"><figcaption>A logo png under figures folder</figcaption></img></figure></p>'! !!MicHTMLExporterTest methodsFor: 'tests'!testFigureStrike	self 		parse: factory figureStrikeSample 		andCheckWeGet: newLine ,'<p><figure><img src="/anUrl" alt="~Foo~" class="figureTest" width="80"><figcaption><strike>Foo</strike></figcaption></img></figure></p>'! !!MicHTMLExporterTest methodsFor: 'tests'!testFigureWithLabelWithoutSize	self 		parse: factory figureWithLabelWithoutSizeSample 		andCheckWeGet: newLine ,'<p><figure><img src="/anUrl" alt="Foo" class="figureTest"><figcaption>Foo</figcaption></img></figure></p>'! !!MicHTMLExporterTest methodsFor: 'tests'!testFigureWithoutCaption	self 		parse: factory figureWithoutCaptionSample 		andCheckWeGet: newLine ,'<p><figure><img src="/anUrl" alt="" class="figureTest" width="80"><figcaption></figcaption></img></figure></p>'! !!MicHTMLExporterTest methodsFor: 'tests'!testFigureWithoutSizeAndLabel	self 		parse: factory figureSampleWithoutSizeAndLabel 		andCheckWeGet: newLine ,'<p><figure><img src="/anUrl" alt="Foo"><figcaption>Foo</figcaption></img></figure></p>'! !!MicHTMLExporterTest methodsFor: 'tests'!testGoutDeFraise	self 		parse: factory figureGoutDeFraise 		andCheckWeGet: newLine ,'<p><figure><img src="un-gout-de-fraise.jpg" alt="Proposition pour le thème : _Un goût de fraise_"><figcaption>Proposition pour le thème : <i>Un goût de fraise</i></figcaption></img></figure></p>'! !!MicHTMLExporterTest methodsFor: 'tests'!testHeaderLevel1	self 		parse: factory headerLevel1Sample 		andCheckWeGet: newLine , '<h1>Foo</h1>'	! !!MicHTMLExporterTest methodsFor: 'tests'!testHeaderLevel2	self		parse: factory headerLevel2Sample		andCheckWeGet: newLine , '<h2>Foo</h2>'! !!MicHTMLExporterTest methodsFor: 'tests - paragraph'!testParagraph		self parse: factory paragraphSample andCheckWeGet: newLine ,'<p>Foo</p>'! !!MicHTMLExporterTest methodsFor: 'tests'!testParagraphLongWithAccents	self parse: factory paragraphOnMultipleLinesSample andCheckWeGet: newLine ,'<p>Je ne connais pas la peur, car la peur tue l''esprit. La peur est la petite mort qui conduit à l''oblitération totale. J''affonterai ma peur. Je lui permettrais de passer sur moi, au travers de moi. Et lorsqu''elle sera passée, je tournerai mon oeil interieur sur son chemin. Et là où elle sera passée, il n''y aura plus rien, rien que moi.</p>'! !!MicHTMLExporterTest methodsFor: 'tests - formats'!testParagraphNestedSample	self parse: factory paragraphNestedSample andCheckWeGet:  newLine ,'<p>this is a <strong><i>paragraph</i></strong></p>'! !!MicHTMLExporterTest methodsFor: 'tests - formats'!testParagraphWithBold	self 		parse: factory paragraphBoldSample 		andCheckWeGet:  newLine ,'<p>this is a <strong>paragraph</strong></p>'! !!MicHTMLExporterTest methodsFor: 'tests'!testParagraphWithItalic	self parse: factory paragraphItalicSample andCheckWeGet: newLine ,'<p>this is a <i>paragraph</i></p>'! !!MicHTMLExporterTest methodsFor: 'tests - formats'!testParagraphWithMonospace	self parse: factory paragraphMonospaceSample andCheckWeGet:  newLine ,'<p>this is a <code>paragraph</code></p>'! !!MicHTMLExporterTest methodsFor: 'tests - formats'!testQuote	self parse: factory quoteSample andCheckWeGet: 	'<q>Foo</q>'! !!MicHTMLExporterTest methodsFor: 'tests - formats'!testStrike	self parse: factory strikethroughFormatSample andCheckWeGet: newLine ,'<p><strike>Foo</strike></p>'! !!MicHTMLExporterTest methodsFor: 'tests'!testTable	| micTable |	micTable := parser parse: factory tableSample.	writer visit: micTable.	self assert: writer contents equals: newLine ,'<table>', newLine ,'<tr><th>aaab</th><th>jkhjh</th></tr>', newLine ,'<tr><td>bar</td><td>rab</td></tr>', newLine ,'</table>'! !!MicHTMLExporterTest methodsFor: 'tests - list'!testUnorderedList	self parse: factory unorderedListWithTwoItemsSample andCheckWeGet: newLine ,'<ul>', newLine ,'<li>Foo</li>', newLine ,'<li>Bar</li>', newLine ,'</ul>'! !!MicHTMLExporterTest methodsFor: 'accessing'!writer: aWriter	writer := aWriter new! !!MicHTMLVisitorTest class methodsFor: 'tests'!testParameters	^ ParametrizedTestMatrix new		  forSelector: #writer addOptions: { MicHTMLVisitor };		  forSelector: #fileSystem addOptions: { FileSystem };		  forSelector: #newLine addOptions: { String cr . String lf . String crlf };		  yourself! !!MicHTMLVisitorTest methodsFor: 'accessing'!fileSystem: aFileSystem	fileSystem := aFileSystem memory.! !!MicHTMLVisitorTest methodsFor: 'running'!generateFilesystemExample	| file |	file := fileSystem workingDirectory / 'anExample1.md'.	file writeStreamDo: [ :stream | stream nextPutAll: '# Foo@sec1Pharo is cool```this is a code blu blu```' ].	file := fileSystem workingDirectory / 'anExample2.md'.	file writeStreamDo: [ :stream | stream nextPutAll: '## Bar@sec2Pharo is **cool**```this is a code 2```' ]! !!MicHTMLVisitorTest methodsFor: 'accessing'!newLine: aNewLine	(aNewLine = String cr) ifTrue:[ writer crAsNewLine ].	(aNewLine = String lf) ifTrue:[ writer lfAsNewLine ].	(aNewLine = String crlf) ifTrue:[ writer crlfAsNewLine ].	newLine := aNewLine! !!MicHTMLVisitorTest methodsFor: 'running'!setUp	super setUp.	self generateFilesystemExample.! !!MicHTMLVisitorTest methodsFor: 'tests'!testCanvasClass	self assert: writer canvasClass equals: MicHTMLCanvas! !!MicHTMLVisitorTest methodsFor: 'test'!testConfiguration	self assert: (writer configuration isKindOf: MicHTMLConfiguration). ! !!MicHTMLVisitorTest methodsFor: 'tests'!testContents 	self assert: writer contents equals: String empty.	writer visitItalic: (MicItalicFormatBlock new textElement: (MicTextBlock new substring: 'test')).	self assert: writer contents equals: '<i>test</i>'.! !!MicHTMLVisitorTest methodsFor: 'tests'!testConvertMicFile	writer convertMicFile: (fileSystem / 'anExample1.md') asFileReference.	self assert: (fileSystem / 'anExample1.html') asFileReference exists.	self		assert: (fileSystem / 'anExample1.html') asFileReference contents		equals: newLine , '<h1>Foo</h1><a id="sec1"></a>' , newLine			, '<p>Pharo is cool</p>' , newLine			, '<pre><code>this is a code blu blu</code></pre>' , newLine! !!MicHTMLVisitorTest methodsFor: 'tests'!testConvertMicString	| result |		result := writer convertMicString: MicMicrodownSnippetFactory buildDocument.		self assert: (result isKindOf: String).	self assert: result notEmpty.! !!MicHTMLVisitorTest methodsFor: 'tests'!testConvertMicStringToDoc	| expectedHtmlDoc |		expectedHtmlDoc := Microdown asHTMLString: MicMicrodownSnippetFactory buildDocument.	self 		assert: (expectedHtmlDoc isKindOf: String)		description: 'It tests that result is a String object'.	self 		deny: expectedHtmlDoc isEmpty 		description: 'It test that result is not empty'.			"parsedContents := (XMLHTMLParser on: expectedHtmlDoc contents) parseDocument.	#('code' 'i' 'a' 'pre' 'strike' 'table' 'ul' 'p') do: [ : tag |		self			assert: ((parsedContents descendantElementsNamed: tag) elementNames notEmpty)			description: 'It test that result contains the expected document tag' ]"! !!MicHTMLVisitorTest methodsFor: 'tests'!testCreateAnchorWithLink	| result |	self assert: writer contents equals: String empty.	result := writer convertMicString: '[Pharo Website](http://pharo.org target=blank&rel=bookmark)'.	self assert: result trimBoth equals: '<p><a target="_blank" href="http://pharo.org/" rel="bookmark" target="blank">Pharo Website</a></p>'.! !!MicHTMLVisitorTest methodsFor: 'tests'!testCreateAnnotationCompound	| result |		result := writer convertMicString: '# This is a title!!!!LabelOfAnnotatedBlock Body of annotated blockthis is another string'.	self assert: result trimBoth equals: '<h1>This is a title</h1>', newLine ,'<section id="LabelOfAnnotatedBlock"><label for="LabelOfAnnotatedBlock">Body of annotated block</label></section>', newLine ,'<p>this is another string</p>'.! !!MicHTMLVisitorTest methodsFor: 'tests'!testCreateAnnotationSimple	| result |	self assert: writer contents equals: String empty.		result := writer convertMicString: '!!!!LabelOfAnnotatedBlock Body of annotated block'.	self assert: result trimBoth equals: '<section id="LabelOfAnnotatedBlock"><label for="LabelOfAnnotatedBlock">Body of annotated block</label></section>'.	! !!MicHTMLVisitorTest methodsFor: 'tests'!testCreateCitation	| result |	self assert: writer contents equals: String empty.		result := writer convertMicString: '{!!citation|ref=Duca99a!!}'.	self assert: result trimBoth equals: '<p><cite>Duca99a</cite></p>'.	! !!MicHTMLVisitorTest methodsFor: 'tests'!testCreateItalic	| result |	self assert: writer contents equals: String empty.		result := writer convertMicString: '_Text with italic_'.	self assert: result trimBoth equals: '<p><i>Text with italic</i></p>'.	! !!MicHTMLVisitorTest methodsFor: 'tests'!testVisitAnchor	self assert: writer contents equals: String empty.	writer visitAnchor: (MicAnchorBlock new label: 'target').	self assert: writer contents equals: '<a id="target"></a>'.! !!MicHTMLVisitorTest methodsFor: 'accessing'!writer: aWriter	writer := aWriter new! !!MicDocFactory class methodsFor: 'examples'!exampleMic	^ '#Lorem Ipsum	_Test page for Microdown functionality, exercising Microdown features to check that they render correctly in mobile/desktop._!!!!AbstractLabel Abstract of article summarizing the page. This is a test page which exercises standard functionality and features of Microdown, from standard Microdown like blockquotes/headers/tables/images, to custom features like sidenotes, margin notes, left/right-floated and full-width images, columns, epigraphs, admonitions, small/wide tables, auto-smallcaps, collapse sections, link annotations, link icons.#Heading 1##Heading 2###Heading 3###Heading 4####Heading 5#####Heading 6## ParagraphsBody Text With Smallcaps Introduction: Margin note 1. A random Wikipedia link. Angel Adept Blind Bodice Clique Coast Dunce Docile Enact Eosin Furlong Focal Gnome Gondola Human Hoist Inlet Iodine Justin Jocose Knoll Koala Linden Loads Milliner Modal Number Nodule Onset Oddball Pneumo Poncho Quanta Qophs Rhone Roman Snout Sodium Tundra Tocsin Uncle Udder Vulcan Vocal Whale Woman Xmas Xenon Yunnan Young Zloty Zodiac. Angel angel adept for the nuance loads of the arena cocoa and quaalude. Blind blind bodice for the submit oboe of the club snob and abbot. Clique clique coast for the pouch loco of the franc assoc and accede. Dunce dunce docile for the loudness mastodon of the loud statehood and huddle. Enact enact eosin for the quench coed of the pique canoe and bleep. Furlong furlong focal for the genuflect profound of the motif aloof and offers. Gnome gnome gondola for the impugn logos of the unplug analog and smuggle. Human human hoist for the buddhist alcohol of the riyadh caliph and bathhouse. Inlet inlet iodine for the quince champion of the ennui scampi and shiite. Justin justin jocose for the djibouti sojourn of the oranj raj and hajjis. Knoll knoll koala for the banknote lookout of the dybbuk outlook and trekked. Linden linden loads for the ulna monolog of the consul menthol and shallot. Milliner milliner modal for the alumna solomon of the album custom and summon. Number number nodule for the unmade economic of the shotgun bison and tunnel.1 2 3 Onset onset oddball for the abandon podium of the antiquo tempo and moonlit. Pneumo pneumo poncho for the dauphin opossum of the holdup bishop and supplies. Quanta quanta qophs for the inquest sheqel of the cinq coq and suqqu. Rhone rhone roman for the burnt porous of the lemur clamor and carrot. Snout snout sodium for the ensnare bosom of the genus pathos and missing. Tundra tundra tocsin for the nutmeg isotope of the peasant ingot and ottoman. Uncle uncle udder for the dunes cloud of the hindu thou and continuum. Vulcan vulcan vocal for the alluvial ovoid of the yugoslav chekhov and revved. Whale whale woman for the meanwhile blowout of the forepaw meadow and glowworm. Xmas xmas xenon for the bauxite doxology of the tableaux equinox and exxon. Yunnan yunnan young for the dynamo coyote of the obloquy employ and sayyid. Zloty zloty zodiac for the gizmo ozone of the franz laissez and buzzing.4 The Dow dropped <10% before increasing >5%, and all the traders said “<what>”‽ Because markets never dropped before.##Blockquotes###Consecutive blockquotes:> Margin note 2. Waltz, nymph, for quick jigs vex Bud. Sphinx of black quartz, judge my vow!! Pack my box with five dozen liquor jugs. Glib jocks quiz nymph to vex dwarf. Jackdaws love my big sphinx of quartz. The five boxing wizards jump quickly. How vexingly quick daft zebras jump!! Quick zephyrs blow, vexing daft Jim. Two driven jocks help fax my big quiz. The jay, pig, fox, zebra and my wolves quack!! Sympathizing would fix Quaker objectives. A wizard’s job is to vex chumps quickly in fog. Watch Jeopardy!!, Alex Trebek’s fun TV quiz game. By Jove, my quick study of lexicography won a prize!! Waxy and quivering, jocks fumble the pizza.> Another blockquote. Waltz, nymph, for quick jigs vex Bud. Sphinx of black quartz, judge my vow. Pack my box with five dozen liquor jugs. Glib jocks quiz nymph to vex dwarf. Jackdaws love my big sphinx of quartz. The five boxing wizards jump quickly. How vexingly quick daft zebras jump!! Quick zephyrs blow, vexing daft Jim. Two driven jocks help fax my big quiz. The jay, pig, fox, zebra and my wolves quack!! Sympathizing would fix Quaker objectives. A wizard’s job is to vex chumps quickly in fog. Watch Jeopardy!!, Alex Trebek’s fun TV quiz game. By Jove, my quick study of lexicography won a prize!! Waxy and quivering, jocks fumble the pizza.###Nested blockquotes> Blockquote> > Nested blockquote##Horizontal Rulers****##Tabular Data|First Header | Second Header||-------------| -------------||Content Cell | Content Cell ||Content Cell | Content Cell |##Inline Formatting_Italic element_. **Bold**. _**Bold italics**_.**__Strong emphasized text__**Here is an external link: [http://pharo.org](http://pharo.org).Here is an internal link: [heading-1](#heading-1)##Lists- Bullet List item 1- Bullet List item 2- Bullet List item 3  - Nested item 3.1  - Nested item 3.2- Bullet List item 4  - Nested item 4.1'! !!MicDocFactory class methodsFor: 'examples'!exampleMicAsHTMLBodyString	"Note this answer the HTML <String> matching the body part of a document, it does NOT build a HTML document"	^ Microdown asHTMLString: self exampleMic! !!MicDocFactory class methodsFor: 'examples'!exampleMicAsHTMLDocument	"This example shows specifically how to set up an output directory and file name, as well as a CSS template to decorate the generated document."	<example>	MicHTMLDocument new		addCSSNamed: 'Tufte';		destinationPath: 'html_output';		fromMicrodown: self exampleMic;		writeToFileNamed: 'Chapter1.html'.! !!MicDocFactory class methodsFor: 'examples'!exampleMicAsHTMLDocumentInBrowser	| htmlDoc |		htmlDoc :=  MicHTMLDocument new 		fromMicrodown: self exampleMic;		yourself.	WebBrowser openOn: htmlDoc fullName.! !!MicDocFactory class methodsFor: 'examples'!exampleMicAsHTMLDocumentMWE	"This example is a Minimum Working Example to write a HTML document from Microdown content."	<example>	MicHTMLDocument new		addCSSNamed: 'Tufte';		fromMicrodown: self exampleMicAsHTMLBodyString;		writeToFile.! !!MicDocFactory class methodsFor: 'examples'!exampleMicAsHTMLString	"This example shows specifically how to set up an output directory and file name, as well as a CSS template to decorate the generated document."	<example>	^ MicHTMLDocument new		addCSSNamed: 'Tufte';		destinationPath: 'html_output';		fromMicrodown: self exampleMic;		writeToFileNamed: 'Chapter1.html';		yourself! !!MicDocFactory class methodsFor: 'examples'!exampleMicAsRichText	^ (Microdown asRichText: self exampleMic) inspect! !!MicCSSFileResource methodsFor: 'initialization'!cssPath	^ FileSystem memory workingDirectory / 'css'! !!MicCSSFileResource methodsFor: 'accessing'!micCSSFile	^ micCSSFile! !!MicCSSFileResource methodsFor: 'initialization'!sampleCSSContents	^ '@charset "UTF-8";@font-face{font-family:et-book;src:url(et-book/et-book-roman-line-figures/et-book-roman-line-figures.eot);src:url(et-book/et-book-roman-line-figures/et-book-roman-line-figures.eot?#iefix) format("embedded-opentype"),url(et-book/et-book-roman-line-figures/et-book-roman-line-figures.woff) format("woff"),url(et-book/et-book-roman-line-figures/et-book-roman-line-figures.ttf) format("truetype"),url(et-book/et-book-roman-line-figures/et-book-roman-line-figures.svg#etbookromanosf) format("svg");font-weight:400;font-style:normal;font-display:swap}@font-face{font-family:et-book;src:url(et-book/et-book-display-italic-old-style-figures/et-book-display-italic-old-style-figures.eot);src:url(et-book/et-book-display-italic-old-style-figures/et-book-display-italic-old-style-figures.eot?#iefix) format("embedded-opentype"),url(et-book/et-book-display-italic-old-style-figures/et-book-display-italic-old-style-figures.woff) format("woff"),url(et-book/et-book-display-italic-old-style-figures/et-book-display-italic-old-style-figures.ttf) format("truetype"),url(et-book/et-book-display-italic-old-style-figures/et-book-display-italic-old-style-figures.svg#etbookromanosf) format("svg");font-weight:400;font-style:italic;font-display:swap}@font-face{font-family:et-book;src:url(et-book/et-book-bold-line-figures/et-book-bold-line-figures.eot);src:url(et-book/et-book-bold-line-figures/et-book-bold-line-figures.eot?#iefix) format("embedded-opentype"),url(et-book/et-book-bold-line-figures/et-book-bold-line-figures.woff) format("woff"),url(et-book/et-book-bold-line-figures/et-book-bold-line-figures.ttf) format("truetype"),url(et-book/et-book-bold-line-figures/et-book-bold-line-figures.svg#etbookromanosf) format("svg");font-weight:700;font-style:normal;font-display:swap}@font-face{font-family:et-book-roman-old-style;src:url(et-book/et-book-roman-old-style-figures/et-book-roman-old-style-figures.eot);src:url(et-book/et-book-roman-old-style-figures/et-book-roman-old-style-figures.eot?#iefix) format("embedded-opentype"),url(et-book/et-book-roman-old-style-figures/et-book-roman-old-style-figures.woff) format("woff"),url(et-book/et-book-roman-old-style-figures/et-book-roman-old-style-figures.ttf) format("truetype"),url(et-book/et-book-roman-old-style-figures/et-book-roman-old-style-figures.svg#etbookromanosf) format("svg");font-weight:400;font-style:normal;font-display:swap}html{font-size:15px}body{width:87.5%;margin-left:auto;margin-right:auto;padding-left:12.5%;font-family:et-book,Palatino,"Palatino Linotype","Palatino LT STD","Book Antiqua",Georgia,serif;background-color:#fffff8;color:#111;max-width:1400px;counter-reset:sidenote-counter}@media (prefers-color-scheme:dark){body{background-color:#151515;color:#ddd}}h1{font-weight:400;margin-top:4rem;margin-bottom:1.5rem;font-size:3.2rem;line-height:1}h2{font-style:italic;font-weight:400;margin-top:2.1rem;margin-bottom:1.4rem;font-size:2.2rem;line-height:1}h3{font-style:italic;font-weight:400;font-size:1.7rem;margin-top:2rem;margin-bottom:1.4rem;line-height:1}hr{display:block;height:1px;width:55%;border:0;border-top:1px solid #ccc;margin:1em 0;padding:0}p.subtitle{font-style:italic;margin-top:1rem;margin-bottom:1rem;font-size:1.8rem;display:block;line-height:1}.numeral{font-family:et-book-roman-old-style}.danger{color:red}article{padding:5rem 0}section{padding-top:1rem;padding-bottom:1rem}dl,ol,p,ul{font-size:1.4rem;line-height:2rem}p{margin-top:1.4rem;margin-bottom:1.4rem;padding-right:0;vertical-align:baseline}div.epigraph{margin:5em 0}div.epigraph>blockquote{margin-top:3em;margin-bottom:3em}div.epigraph>blockquote,div.epigraph>blockquote>p{font-style:italic}div.epigraph>blockquote>footer{font-style:normal}div.epigraph>blockquote>footer>cite{font-style:italic}blockquote{font-size:1.4rem}blockquote p{width:55%;margin-right:40px}blockquote footer{width:55%;font-size:1.1rem;text-align:right}section>footer,section>p,section>table{width:55%}section>dl,section>ol,section>ul{width:50%;-webkit-padding-start:5%}dt:not(:first-child),li:not(:first-child){margin-top:.25rem}figure{padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline;max-width:55%;-webkit-margin-start:0;-webkit-margin-end:0;margin:0 0 3em 0}figcaption{float:right;clear:right;margin-top:0;margin-bottom:0;font-size:1.1rem;line-height:1.6;vertical-align:baseline;position:relative;max-width:40%}figure.fullwidth figcaption{margin-right:24%}a:link,a:visited{color:inherit}.no-tufte-underline:link{background:unset;text-shadow:unset}.hover-tufte-underline:hover,.tufte-underline,a:link{text-decoration:none;background:-webkit-linear-gradient(#fffff8,#fffff8),-webkit-linear-gradient(#fffff8,#fffff8),-webkit-linear-gradient(currentColor,currentColor);background:linear-gradient(#fffff8,#fffff8),linear-gradient(#fffff8,#fffff8),linear-gradient(currentColor,currentColor);-webkit-background-size:.05em 1px,.05em 1px,1px 1px;-moz-background-size:.05em 1px,.05em 1px,1px 1px;background-size:.05em 1px,.05em 1px,1px 1px;background-repeat:no-repeat,no-repeat,repeat-x;text-shadow:.03em 0 #fffff8,-.03em 0 #fffff8,0 .03em #fffff8,0 -.03em #fffff8,.06em 0 #fffff8,-.06em 0 #fffff8,.09em 0 #fffff8,-.09em 0 #fffff8,.12em 0 #fffff8,-.12em 0 #fffff8,.15em 0 #fffff8,-.15em 0 #fffff8;background-position:0 93%,100% 93%,0 93%}@media screen and (-webkit-min-device-pixel-ratio:0){.hover-tufte-underline:hover,.tufte-underline,a:link{background-position-y:87%,87%,87%}}@media (prefers-color-scheme:dark){.hover-tufte-underline:hover,.tufte-underline,a:link{text-shadow:.03em 0 #151515,-.03em 0 #151515,0 .03em #151515,0 -.03em #151515,.06em 0 #151515,-.06em 0 #151515,.09em 0 #151515,-.09em 0 #151515,.12em 0 #151515,-.12em 0 #151515,.15em 0 #151515,-.15em 0 #151515}}a:link::-moz-selection,a:link::selection{text-shadow:.03em 0 #b4d5fe,-.03em 0 #b4d5fe,0 .03em #b4d5fe,0 -.03em #b4d5fe,.06em 0 #b4d5fe,-.06em 0 #b4d5fe,.09em 0 #b4d5fe,-.09em 0 #b4d5fe,.12em 0 #b4d5fe,-.12em 0 #b4d5fe,.15em 0 #b4d5fe,-.15em 0 #b4d5fe;background:#b4d5fe}img{max-width:100%}.marginnote,.sidenote{float:right;clear:right;margin-right:-60%;width:50%;margin-top:.3rem;margin-bottom:0;font-size:1.1rem;line-height:1.3;vertical-align:baseline;position:relative}.sidenote-number{counter-increment:sidenote-counter}.sidenote-number:after,.sidenote:before{font-family:et-book-roman-old-style;position:relative;vertical-align:baseline}.sidenote-number:after{content:counter(sidenote-counter);font-size:1rem;top:-.5rem;left:.1rem}.sidenote:before{content:counter(sidenote-counter) " ";font-size:1rem;top:-.5rem}blockquote .marginnote,blockquote .sidenote{margin-right:-82%;min-width:59%;text-align:left}div.fullwidth,table.fullwidth{width:100%}div.table-wrapper{overflow-x:auto;font-family:"Trebuchet MS","Gill Sans","Gill Sans MT",sans-serif}.sans{font-family:"Gill Sans","Gill Sans MT",Calibri,sans-serif;letter-spacing:.03em}code,pre>code{font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;font-size:1rem;line-height:1.42;-webkit-text-size-adjust:100%}.sans>code{font-size:1.2rem}h1>code,h2>code,h3>code{font-size:.8em}.marginnote>code,.sidenote>code{font-size:1rem}pre>code{font-size:.9rem;width:52.5%;margin-left:2.5%;overflow-x:auto;display:block}pre.fullwidth>code{width:90%}.fullwidth{max-width:90%;clear:both}span.newthought{font-variant:small-caps;font-size:1.2em}input.margin-toggle{display:none}label.sidenote-number{display:inline-block;max-height:2rem}label.margin-toggle:not(.sidenote-number){display:none}.iframe-wrapper{position:relative;padding-bottom:56.25%;padding-top:25px;height:0}.iframe-wrapper iframe{position:absolute;top:0;left:0;width:100%;height:100%}@media (max-width:760px){body{width:84%;padding-left:8%;padding-right:8%}hr,section>footer,section>p,section>table{width:100%}pre>code{width:97%}section>dl,section>ol,section>ul{width:90%}figure{max-width:90%}figcaption,figure.fullwidth figcaption{margin-right:0;max-width:none}blockquote{margin-left:1.5em;margin-right:0}blockquote footer,blockquote p{width:100%}label.margin-toggle:not(.sidenote-number){display:inline}.marginnote,.sidenote{display:none}.margin-toggle:checked+.marginnote,.margin-toggle:checked+.sidenote{display:block;float:left;left:1rem;clear:both;width:95%;margin:1rem 2.5%;vertical-align:baseline;position:relative}label{cursor:pointer}div.table-wrapper,table{width:85%}img{width:100%}}'! !!MicCSSFileResource methodsFor: 'running'!setUp 	| cssPath |		super setUp.	cssPath := self cssPath ensureCreateDirectory.	(cssPath / 'sample.css')		ensureCreateFile;		writeStreamDo: [ :stream | stream nextPutAll: self sampleCSSContents ].	micCSSFile := MicCSSFile new fileReference: (cssPath / 'sample.css') asFileReference ! !!MicCSSFileResource methodsFor: 'running'!tearDown 	[ self cssPath ensureDeleteAll ]	on: FileDoesNotExistException 	do: [ : ex | ex pass ].	super tearDown.! !"Microdown-HTMLExporter-Tests"!!ManifestMicrodownLaTeXExporterTests commentStamp: '' prior: 0!```eval=truestream nextPutAll: 'Hello world'```!!MicExportCanvasTest methodsFor: 'running'!setUp	| stream |	super setUp.	stream := MicOutputStream new setStream: (WriteStream on: (String new: 1000)).	canvas := MicExportCanvas on: stream.! !!MicExportCanvasTest methodsFor: 'tests'!testCrAsNewLine 	canvas crAsNewLine.	self assert: canvas stream configuration newLine equals: Character cr! !!MicExportCanvasTest methodsFor: 'tests'!testCrlfAsNewLine 	canvas crlfAsNewLine.	self assert: canvas stream configuration newLine equals: String crlf! !!MicExportCanvasTest methodsFor: 'tests'!testLfAsNewLine 	canvas lfAsNewLine.	self assert: canvas stream configuration newLine equals: Character lf! !!MicExportCanvasTest methodsFor: 'tests'!testWriteAParagraphWithCr	canvas crAsNewLine.	canvas nextPutAllLines: 'Je ne vois pas pourquoicela ne fonctionnerais pascar il a etait fait pour cela'.	self assert: canvas stream contents equals: 'Je ne vois pas pourquoi', String cr ,'cela ne fonctionnerais pas', String cr,'car il a etait fait pour cela'! !!MicExportCanvasTest methodsFor: 'tests'!testWriteAParagraphWithCrButNewLineIsCrlf	canvas crlfAsNewLine.	canvas nextPutAllLines: 'Je ne vois pas pourquoicela ne fonctionnerais pascar il a etait fait pour cela'.	self deny: canvas stream contents equals: 'Je ne vois pas pourquoi', String cr ,'cela ne fonctionnerais pas', String cr,'car il a etait fait pour cela'! !!MicExportCanvasTest methodsFor: 'tests'!testWriteAParagraphWithCrButNewLineIsLf	canvas lfAsNewLine.	canvas nextPutAllLines: 'Je ne vois pas pourquoicela ne fonctionnerais pascar il a etait fait pour cela'.	self deny: canvas stream contents equals: 'Je ne vois pas pourquoi', String cr ,'cela ne fonctionnerais pas', String cr,'car il a etait fait pour cela'! !!MicExportCanvasTest methodsFor: 'tests'!testWriteAParagraphWithCrlf	canvas crlfAsNewLine.	canvas nextPutAllLines: 'Je ne vois pas pourquoicela ne fonctionnerais pascar il a etait fait pour cela'.	self assert: canvas stream contents equals: 'Je ne vois pas pourquoi', String crlf ,'cela ne fonctionnerais pas', String crlf,'car il a etait fait pour cela'! !!MicExportCanvasTest methodsFor: 'tests'!testWriteAParagraphWithCrlfButNewLineIsCr	canvas crAsNewLine.	canvas nextPutAllLines: 'Je ne vois pas pourquoicela ne fonctionnerais pascar il a etait fait pour cela'.	self deny: canvas stream contents equals: 'Je ne vois pas pourquoi', String crlf ,'cela ne fonctionnerais pas', String crlf,'car il a etait fait pour cela'! !!MicExportCanvasTest methodsFor: 'tests'!testWriteAParagraphWithCrlfButNewLineIsLf	canvas lfAsNewLine.	canvas nextPutAllLines: 'Je ne vois pas pourquoicela ne fonctionnerais pascar il a etait fait pour cela'.	self deny: canvas stream contents equals: 'Je ne vois pas pourquoi', String crlf ,'cela ne fonctionnerais pas', String crlf,'car il a etait fait pour cela'! !!MicExportCanvasTest methodsFor: 'tests'!testWriteAParagraphWithLf	canvas lfAsNewLine.	canvas nextPutAllLines: 'Je ne vois pas pourquoicela ne fonctionnerais pascar il a etait fait pour cela'.	self assert: canvas stream contents equals: 'Je ne vois pas pourquoi', String lf ,'cela ne fonctionnerais pas', String lf,'car il a etait fait pour cela'! !!MicExportCanvasTest methodsFor: 'tests'!testWriteAParagraphWithLfButNewLineIsCr	canvas crAsNewLine.	canvas nextPutAllLines: 'Je ne vois pas pourquoicela ne fonctionnerais pascar il a etait fait pour cela'.	self deny: canvas stream contents equals: 'Je ne vois pas pourquoi', String lf ,'cela ne fonctionnerais pas', String lf,'car il a etait fait pour cela'! !!MicExportCanvasTest methodsFor: 'tests'!testWriteAParagraphWithLfButNewLineIsCrlf	canvas crlfAsNewLine.	canvas nextPutAllLines: 'Je ne vois pas pourquoicela ne fonctionnerais pascar il a etait fait pour cela'.	self deny: canvas stream contents equals: 'Je ne vois pas pourquoi', String lf ,'cela ne fonctionnerais pas', String lf,'car il a etait fait pour cela'! !!MicMinimalConfigurationTest methodsFor: 'running'!setUp		super setUp.	config := MicMinimalConfiguration new.! !!MicMinimalConfigurationTest methodsFor: 'tests'!testCrAsNewLine 	config crAsNewLine.	self assert: config newLine equals: Character cr! !!MicMinimalConfigurationTest methodsFor: 'tests'!testCrlfAsNewLine  	config crlfAsNewLine.	self assert: config newLine equals: String crlf! !!MicMinimalConfigurationTest methodsFor: 'tests'!testLfAsNewLine  	config lfAsNewLine.	self assert: config newLine equals: Character lf! !!MicOutputStreamTest methodsFor: 'running'!setUp		super setUp.	stream := MicOutputStream new.! !!MicOutputStreamTest methodsFor: 'tests'!testCrAsNewLine 	stream crAsNewLine.	self assert: stream configuration newLine equals: Character cr! !!MicOutputStreamTest methodsFor: 'tests'!testCrlfAsNewLine 	stream crlfAsNewLine.	self assert: stream configuration newLine equals: String crlf! !!MicOutputStreamTest methodsFor: 'tests'!testLfAsNewLine 	stream lfAsNewLine.	self assert: stream configuration newLine equals: Character lf! !!MicLaTeXWriterTest class methodsFor: 'asserting'!shouldInheritSelectors	^ true! !!MicLaTeXWriterTest class methodsFor: 'asserting'!testParameters	^ ParametrizedTestMatrix new		  forSelector: #writer addOptions: { MicLaTeXWriter };		  forSelector: #factory addOptions: { MicMicrodownSnippetFactory };		  forSelector: #parser addOptions: { Microdown };		  forSelector: #newLine addOptions: { String cr . String lf . String crlf};		  yourself! !!MicLaTeXWriterTest methodsFor: 'running'!actualClass	^ MicLaTeXWriter! !!MicLaTeXWriterTest methodsFor: 'helpers'!assert: result includesSubstring: expected	expected ifEmpty: [ ^ self ].	self 		assert: (result includesSubstring: expected) 		description: ('''{1}'' not in ''{2}''' format: {expected . result})! !!MicLaTeXWriterTest methodsFor: 'helpers'!assertWriting: aDocumentItem includesText: aString	| result |	self writeForElement: aDocumentItem.	result := writer contents.	self assert: result includesSubstring: aString! !!MicLaTeXWriterTest methodsFor: 'helpers'!assertWriting: aDocumentItem includesTexts: aCollection	| resultString |	self writeForElement: aDocumentItem.	resultString := writer contents.	aCollection do: [ :testString | self assert: resultString includesSubstring: testString ]! !!MicLaTeXWriterTest methodsFor: 'accessing'!factory: aFactory	factory := aFactory new! !!MicLaTeXWriterTest methodsFor: 'accessing'!newLine: aNewLine	(aNewLine = String cr) ifTrue:[ writer crAsNewLine ].	(aNewLine = String lf) ifTrue:[ writer lfAsNewLine ].	(aNewLine = String crlf) ifTrue:[ writer crlfAsNewLine ].	newLine := aNewLine! !!MicLaTeXWriterTest methodsFor: 'tests - formats'!parse: aString andCheckWeGet: aResultingString		| mic |	mic := parser parse: 	aString.	writer visit: mic.	self assert: writer contents equals: aResultingString! !!MicLaTeXWriterTest methodsFor: 'tests - formats'!parseInlined: aString andCheckWeGet: aResultingString		| mic |	mic := parser parse: 	aString.	writer visit: mic.	self assert: writer contents equals: newLine , aResultingString, newLine! !!MicLaTeXWriterTest methodsFor: 'accessing'!parser: aParser	parser := aParser new! !!MicLaTeXWriterTest methodsFor: 'tests'!testAnchor	self parse: factory anchorSample andCheckWeGet: '\label{test}'! !!MicLaTeXWriterTest methodsFor: 'tests'!testAnchorReference	"Pay attention that an anchor reference only exists within a paragraph and as such a paragraph emit a newline to start."		self parseInlined: factory anchorReferenceSample andCheckWeGet: '\ref{Foo}'	! !!MicLaTeXWriterTest methodsFor: 'tests - formats'!testBold	self parseInlined: factory boldFormatSample andCheckWeGet: '\textbf{Foo}'! !!MicLaTeXWriterTest methodsFor: 'tests'!testCitation	self parseInlined: '{!!citation|ref=Duca99a!!}' andCheckWeGet: '\cite{Duca99a}'! !!MicLaTeXWriterTest methodsFor: 'tests'!testCodeblock	self writeFor: (factory codeblockNoParamBody: 'this is a code').	self assert: writer contents equals: '\begin{listing}', newLine ,													'this is a code', newLine ,													'\end{listing}', newLine! !!MicLaTeXWriterTest methodsFor: 'tests'!testCodeblockWithCaption	self writeFor: (factory codeblock: 'caption=Pharo is **cool**' body: 'this is a code').	self assert: writer contents equals: '\begin{listing}[caption={Pharo is \textbf{cool}}]', newLine,													'this is a code', newLine,													'\end{listing}', newLine! !!MicLaTeXWriterTest methodsFor: 'tests'!testCodeblockWithLabel	self writeFor: (factory codeblock: 'label=Pharo' body: 'this is a code').	self assert: writer contents equals: '\begin{listing}[label=Pharo]', newLine ,													'this is a code', newLine ,													'\end{listing}', newLine ! !!MicLaTeXWriterTest methodsFor: 'tests - breaklining'!testCrAsNewLine 	writer crAsNewLine.	self assert: writer canvas stream configuration newLine equals: Character cr! !!MicLaTeXWriterTest methodsFor: 'tests - breaklining'!testCrlfAsNewLine 	writer crlfAsNewLine.	self assert: writer canvas stream configuration newLine equals: String crlf! !!MicLaTeXWriterTest methodsFor: 'tests - figure/link'!testFigure	self writeFor: factory figureSample.	self assert: writer contents equals: newLine ,					'\begin{figure}[htpb]', newLine ,					'\begin{center}', newLine ,					'\includegraphics[width=0.8\textwidth]{/anUrl}', newLine ,					'\caption{Foo}\label{figureTest}', newLine ,					'\end{center}', newLine ,					'\end{figure}', newLine, newLine! !!MicLaTeXWriterTest methodsFor: 'tests - figure/link'!testFigureBold	self writeFor: factory figureBoldSample.	self assert: writer contents equals: newLine,					'\begin{figure}[htpb]', newLine ,					'\begin{center}', newLine ,					'\includegraphics[width=0.8\textwidth]{/anUrl}', newLine ,					'\caption{\textbf{Foo}}\label{figureTest}', newLine ,					'\end{center}', newLine ,					'\end{figure}', newLine , newLine! !!MicLaTeXWriterTest methodsFor: 'tests - figure/link'!testFigureRealSample	self writeFor: factory figureRealSample.	self assert: writer contents equals: newLine ,'\begin{figure}[htpb]', newLine ,'\begin{center}', newLine ,'\includegraphics[width=0.8\textwidth]{figures/logo.png}', newLine ,'\caption{A logo png under figures folder}\label{figureTest}', newLine ,'\end{center}', newLine ,'\end{figure}', newLine, newLine.self flag: #todo."may be we should get figures/logo.png when file://figures/logo.png"! !!MicLaTeXWriterTest methodsFor: 'tests'!testFootnote	self parseInlined: factory footnoteSample andCheckWeGet: '\footnote{Pharo is cool}'	! !!MicLaTeXWriterTest methodsFor: 'tests - header'!testHeaderLevel1	self parse: factory headerLevel1Sample andCheckWeGet: newLine , '\part{Foo}'	! !!MicLaTeXWriterTest methodsFor: 'tests - header'!testHeaderLevel2	self parse: factory headerLevel2Sample andCheckWeGet: newLine  , '\chapter{Foo}'! !!MicLaTeXWriterTest methodsFor: 'tests - header'!testHeaderLevel3	self parse: factory headerLevel3Sample andCheckWeGet: newLine , '\section{Foo}'! !!MicLaTeXWriterTest methodsFor: 'tests - header'!testHeaderLevel4	self parse: factory headerLevel4Sample andCheckWeGet: newLine , '\subsection{Foo}'! !!MicLaTeXWriterTest methodsFor: 'tests - header'!testHeaderLevel5	self parse: factory headerLevel5Sample andCheckWeGet: newLine , '\subsubsection{Foo}'! !!MicLaTeXWriterTest methodsFor: 'tests - header'!testHeaderLevel6	   self parse: factory headerLevel6Sample andCheckWeGet: newLine , '\paragraph{Foo}'! !!MicLaTeXWriterTest methodsFor: 'tests'!testHorizontalLine	self parseInlined: factory horizontalLineSample andCheckWeGet: '\rule{\textwidth}{0.1pt}'! !!MicLaTeXWriterTest methodsFor: 'tests - formats'!testItalic	self parseInlined: factory italicFormatSample andCheckWeGet: '\textit{Foo}'! !!MicLaTeXWriterTest methodsFor: 'tests - breaklining'!testLfAsNewLine 	writer lfAsNewLine.	self assert: writer canvas stream configuration newLine equals: Character lf! !!MicLaTeXWriterTest methodsFor: 'tests - figure/link'!testLink	self writeFor: factory linkSample.			self assert: writer contents equals: newLine,'\href{/anUrl}{Foo}\footnotesize{\url{/anUrl}}', newLine! !!MicLaTeXWriterTest methodsFor: 'tests - figure/link'!testLinkBold	self flag: 'caption do not use bold in the caption'.	self writeFor: factory linkBoldSample.	self flag: #toFix.	"\textbf{Foo}" 	self assert: writer contents equals: newLine ,'\href{/anUrl}{**Foo**}\footnotesize{\url{/anUrl}}', newLine! !!MicLaTeXWriterTest methodsFor: 'tests - formats'!testMonospace	self parseInlined: factory monospaceFormatSample andCheckWeGet: '\code{Foo}'! !!MicLaTeXWriterTest methodsFor: 'tests - lists'!testOrderedList		self writeFor: factory orderedListWithTwoItemsSample.	self assert: writer contents equals: newLine,						'\begin{enumerate}', newLine ,						'    \item first', newLine ,						'    \item second', newLine ,						'\end{enumerate}', newLine! !!MicLaTeXWriterTest methodsFor: 'tests - lists'!testOrderedListBold	self writeFor: factory orderedListWithTwoItemsBoldSample.	self assert: writer contents equals: newLine ,						'\begin{enumerate}', newLine ,						'    \item \textbf{first}', newLine ,						'    \item second', newLine ,						'\end{enumerate}', newLine! !!MicLaTeXWriterTest methodsFor: 'tests - lists'!testOrderedListNested	self writeFor:  factory orderedListWithTwoItemsBoldFirstSample.	self assert: writer contents equals: newLine, 						'\begin{enumerate}', newLine ,						'    \item \textbf{\textit{first}}', newLine ,						'    \item second', newLine ,						'\end{enumerate}', newLine! !!MicLaTeXWriterTest methodsFor: 'tests - lists'!testOrderedNestedListNested	self writeFor: factory nestedOrderedListSample. 	self assert: writer contents equals: newLine ,							'\begin{itemize}', newLine ,							'    \item Foo', newLine ,							'    \item Bar', newLine ,							'    \begin{enumerate}', newLine ,							'        \item B', newLine ,							'        \item a', newLine ,							'        \item r', newLine ,							'    \end{enumerate}', newLine ,							'\end{itemize}', newLine! !!MicLaTeXWriterTest methodsFor: 'tests - lists'!testOrderedNestedListNested2	self writeFor: factory nestedOrderedList2Sample. 	self assert: writer contents  equals: newLine ,							'\begin{itemize}', newLine ,							'    \item Foo', newLine ,							'    \item Bar', newLine ,							'    \begin{enumerate}', newLine ,							'        \item B', newLine ,							'        \item a', newLine ,							'        \item r', newLine ,							'        \begin{itemize}', newLine ,							'            \item 3rdlvel', newLine ,							'            \item 3rdlevl2', newLine ,							'        \end{itemize}', newLine ,							'    \end{enumerate}', newLine ,							'    \item Zork', newLine ,							'\end{itemize}', newLine ! !!MicLaTeXWriterTest methodsFor: 'tests - paragraph'!testParagraph		self parse: factory paragraphSample andCheckWeGet: newLine,															'Foo',newLine! !!MicLaTeXWriterTest methodsFor: 'tests - paragraph'!testParagraphLongWithAccents		self parse: factory paragraphOnMultipleLinesSample andCheckWeGet:  newLine,'Je ne connais pas la peur, car la peur tue l''esprit. La peur est la petite mort qui conduit \`{a} l''oblit\''{e}ration totale. J''affonterai ma peur. Je lui permettrais de passer sur moi, au travers de moi. Et lorsqu''elle sera pass\''{e}e, je tournerai mon oeil interieur sur son chemin. Et l\`{a} o\`{u} elle sera pass\''{e}e, il n''y aura plus rien, rien que moi.', newLine! !!MicLaTeXWriterTest methodsFor: 'tests - paragraph'!testParagraphWithBold	self parse: factory paragraphBoldSample andCheckWeGet:  newLine ,									'this is a \textbf{paragraph}', newLine! !!MicLaTeXWriterTest methodsFor: 'tests - paragraph'!testParagraphWithItalic	self parse: factory paragraphItalicSample andCheckWeGet:  newLine ,									'this is a \textit{paragraph}', newLine! !!MicLaTeXWriterTest methodsFor: 'tests - paragraph'!testParagraphWithMonospace		self parse: factory paragraphMonospaceSample andCheckWeGet:  newLine ,'this is a \code{paragraph}', newLine ! !!MicLaTeXWriterTest methodsFor: 'tests - paragraph'!testParagraphWithNested	self parse: factory paragraphNestedSample andCheckWeGet:  newLine ,'this is a \textbf{\textit{paragraph}}', newLine! !!MicLaTeXWriterTest methodsFor: 'tests'!testQuote	self parse: factory quoteSample andCheckWeGet:  '\begin{verbatim}', newLine ,																	'Foo', newLine ,																	'\end{verbatim}', newLine! !!MicLaTeXWriterTest methodsFor: 'tests - figure/link'!testRealLinkSample	self writeFor: factory realLinkSample.		self assert: writer contents equals: newLine ,'\href{http://www.pharo.org}{The Pharo Project}\footnotesize{\url{http://www.pharo.org}}', newLine ! !!MicLaTeXWriterTest methodsFor: 'tests - formats'!testStrike	self parseInlined: factory strikethroughFormatSample andCheckWeGet: '\sout{Foo}'		! !!MicLaTeXWriterTest methodsFor: 'tests'!testTable	self writeFor: factory tableSample.	self assert: writer contents equals: newLine,													'\begin{tabular}{ll}', newLine ,													'\toprule', newLine ,													'\textbf{aaab} & \textbf{jkhjh} \\', newLine ,													'\midrule', newLine ,													'bar & rab \\', newLine ,													'\bottomrule', newLine ,													'\end{tabular}', newLine! !!MicLaTeXWriterTest methodsFor: 'tests'!testTableWhithoutHeader		self writeFor: (factory simpleTableWithoutHeaderTable).	self assert: writer contents equals: newLine,													'\begin{tabular}{ll}', newLine ,													'\toprule', newLine ,													'aaab & jkhjh \\', newLine ,													'bar & rab \\', newLine ,													'\bottomrule', newLine ,													'\end{tabular}', newLine! !!MicLaTeXWriterTest methodsFor: 'tests - lists'!testUnorderedList	self writeFor: factory unorderedListWithTwoItemsSample.	self assert: writer contents equals: newLine, 							'\begin{itemize}', newLine ,							'    \item Foo', newLine ,							'    \item Bar', newLine ,							'\end{itemize}', newLine! !!MicLaTeXWriterTest methodsFor: 'tests - lists'!testUnorderedListBold	self writeFor: factory unorderedListWithTwoItemsBoldSample.	self assert: writer contents equals: newLine ,							'\begin{itemize}', newLine ,							'    \item \textbf{Foo}', newLine ,							'    \item Bar', newLine ,							'\end{itemize}', newLine! !!MicLaTeXWriterTest methodsFor: 'tests - lists'!testUnorderedListNested	self writeFor: factory unorderedListWithTwoItemsNestedSample.	self assert: writer contents equals: newLine ,							'\begin{itemize}', newLine ,							'    \item \sout{\textit{Foo}}', newLine ,							'    \item Bar', newLine ,							'\end{itemize}', newLine! !!MicLaTeXWriterTest methodsFor: 'tests - lists'!testUnorderedNestedListNested	self writeFor: factory nestedUnorderedListSample. 	self assert: writer contents equals: newLine ,							'\begin{itemize}', newLine ,							'    \item Foo', newLine ,							'    \item Bar', newLine ,							'    \begin{itemize}', newLine ,							'        \item B', newLine ,							'        \item a', newLine ,							'        \item r', newLine ,							'    \end{itemize}', newLine ,							'\end{itemize}', newLine! !!MicLaTeXWriterTest methodsFor: 'tests'!testUrlsAreProtected	self assert: (writer protectUrl: '#') equals: '\#'.	self assert: (writer protectUrl: '~') equals: '~'.	self assert: (writer protectUrl: '&') equals: '&'.	self assert: (writer protectUrl: '%') equals: '\%'.	self assert: (writer protectUrl: '\') equals: '\\'.	self assert: (writer protectUrl: '\~#%') equals: '\\~\#\%'.! !!MicLaTeXWriterTest methodsFor: 'tests - breaklining'!testWriteAParagraphWithCr	writer crAsNewLine.	writer canvas nextPutAllLines: 'Je ne vois pas pourquoicela ne fonctionnerais pascar il a etait fait pour cela'.	self assert: writer canvas stream contents equals: 'Je ne vois pas pourquoi', String cr ,'cela ne fonctionnerais pas', String cr,'car il a etait fait pour cela'! !!MicLaTeXWriterTest methodsFor: 'tests - breaklining'!testWriteAParagraphWithCrButNewLineIsCrlf	writer crlfAsNewLine.	writer canvas nextPutAllLines: 'Je ne vois pas pourquoicela ne fonctionnerais pascar il a etait fait pour cela'.	self deny: writer canvas stream contents equals: 'Je ne vois pas pourquoi', String cr ,'cela ne fonctionnerais pas', String cr,'car il a etait fait pour cela'! !!MicLaTeXWriterTest methodsFor: 'tests - breaklining'!testWriteAParagraphWithCrButNewLineIsLf	writer lfAsNewLine.	writer canvas nextPutAllLines: 'Je ne vois pas pourquoicela ne fonctionnerais pascar il a etait fait pour cela'.	self deny: writer canvas stream contents equals: 'Je ne vois pas pourquoi', String cr ,'cela ne fonctionnerais pas', String cr,'car il a etait fait pour cela'! !!MicLaTeXWriterTest methodsFor: 'tests - breaklining'!testWriteAParagraphWithCrlf	writer crlfAsNewLine .	writer canvas nextPutAllLines: 'Je ne vois pas pourquoicela ne fonctionnerais pascar il a etait fait pour cela'.	self assert: writer canvas stream contents equals: 'Je ne vois pas pourquoi', String crlf ,'cela ne fonctionnerais pas', String crlf,'car il a etait fait pour cela'! !!MicLaTeXWriterTest methodsFor: 'tests - breaklining'!testWriteAParagraphWithCrlfButNewLineIsCr	writer crAsNewLine.	writer canvas nextPutAllLines: 'Je ne vois pas pourquoicela ne fonctionnerais pascar il a etait fait pour cela'.	self deny: writer canvas stream contents equals: 'Je ne vois pas pourquoi', String crlf ,'cela ne fonctionnerais pas', String crlf,'car il a etait fait pour cela'! !!MicLaTeXWriterTest methodsFor: 'tests - breaklining'!testWriteAParagraphWithCrlfButNewLineIsLf	writer lfAsNewLine.	writer canvas nextPutAllLines: 'Je ne vois pas pourquoicela ne fonctionnerais pascar il a etait fait pour cela'.	self deny: writer canvas stream contents equals: 'Je ne vois pas pourquoi', String crlf ,'cela ne fonctionnerais pas', String crlf,'car il a etait fait pour cela'! !!MicLaTeXWriterTest methodsFor: 'tests - breaklining'!testWriteAParagraphWithLf	writer lfAsNewLine.	writer canvas nextPutAllLines: 'Je ne vois pas pourquoicela ne fonctionnerais pascar il a etait fait pour cela'.	self assert: writer canvas stream contents equals: 'Je ne vois pas pourquoi', String lf ,'cela ne fonctionnerais pas', String lf,'car il a etait fait pour cela'! !!MicLaTeXWriterTest methodsFor: 'tests - breaklining'!testWriteAParagraphWithLfButNewLineIsCr	writer crAsNewLine.	writer canvas nextPutAllLines: 'Je ne vois pas pourquoicela ne fonctionnerais pascar il a etait fait pour cela'.	self deny: writer canvas stream contents equals: 'Je ne vois pas pourquoi', String lf ,'cela ne fonctionnerais pas', String lf,'car il a etait fait pour cela'! !!MicLaTeXWriterTest methodsFor: 'tests - breaklining'!testWriteAParagraphWithLfButNewLineIsCrlf	writer crlfAsNewLine.	writer canvas nextPutAllLines: 'Je ne vois pas pourquoicela ne fonctionnerais pascar il a etait fait pour cela'.	self deny: writer canvas stream contents equals: 'Je ne vois pas pourquoi', String lf ,'cela ne fonctionnerais pas', String lf,'car il a etait fait pour cela'! !!MicLaTeXWriterTest methodsFor: 'tests'!writeFor: aString 	| mic |	mic := parser parse: aString.	writer visit: mic.! !!MicLaTeXWriterTest methodsFor: 'tests'!writeForElement: aNode	writer visit: aNode.! !!MicLaTeXWriterTest methodsFor: 'accessing'!writer: aWriter	writer := aWriter new! !!MicSBALaTeXWriterTest class methodsFor: 'tests'!testParameters	^ ParametrizedTestMatrix new		  forSelector: #writer addOptions: { MicSBALaTeXWriter };		  forSelector: #factory addOptions: { MicMicrodownSnippetFactory };		  forSelector: #parser addOptions: { Microdown };		  forSelector: #newLine addOptions: { String cr . String lf };		  yourself! !!MicSBALaTeXWriterTest methodsFor: 'private'!actualClass	^ MicSBALaTeXWriter! !!MicSBALaTeXWriterTest methodsFor: 'tests'!testCodeblock	self writeFor: (factory codeblockNoParamBody: 'this is a code').	self assert: writer contents equals: '\begin{displaycode}{smalltalk}', newLine,													'this is a code', newLine ,													'\end{displaycode}', newLine! !!MicSBALaTeXWriterTest methodsFor: 'tests'!testCodeblockWithCaption	self writeFor: (factory codeblock: 'caption=Pharo is **cool**' body: 'this is a code').	self assert: writer contents equals: '\begin{listing}[float]{smalltalk}{Pharo is \textbf{cool}}', newLine ,'this is a code', newLine ,'\end{listing}', newLine! !!MicSBALaTeXWriterTest methodsFor: 'tests'!testCodeblockWithChevron	self writeFor:		(factory			 codeblock: 'caption=Pharo is **cool**'			 body: 'MyClass >> foo this is a code').	self		assert: writer contents		equals:			'\begin{listing}[float]{smalltalk}{Pharo is \textbf{cool}}'			, newLine , 'MyClass >> foo' , newLine , ' this is a code'			, newLine , '\end{listing}' , newLine! !!MicSBALaTeXWriterTest methodsFor: 'tests'!testCodeblockWithLabel	self writeFor: (factory codeblock: 'label=Pharo' body: 'this is a code').	self assert: writer contents equals: '\begin{listing}[float, label=Pharo]{smalltalk}{}', newLine ,													'this is a code', newLine ,													'\end{listing}', newLine! !!MicSBALaTeXWriterTest methodsFor: 'tests'!testFloatingWithBothLabelAndCaption	| codeBlock |	codeBlock := (MicCodeBlock new body: 'foo')					label: 'myScript';					caption: 'a caption';					yourself.	self assertWriting: codeBlock includesTexts: #('label=myScript')! !!MicSBALaTeXWriterTest methodsFor: 'tests'!testInFlowOnTwoLines	| codeBlock |	codeBlock := MicCodeBlock new body: 'foo', newLine , 'bar on another line'.	self writeForElement: codeBlock.		self assert: writer contents equals: '\begin{displaycode}{smalltalk}', newLine ,'foo', newLine ,'bar on another line', newLine ,'\end{displaycode}', newLine! !!MicSBALaTeXWriterTest methodsFor: 'tests'!testMonospace	self parseInlined: factory monospaceFormatSample andCheckWeGet: '\textcode{Foo}'! !!MicSBALaTeXWriterTest methodsFor: 'tests'!testParagraphWithChevron	self writeFor: (factory textWithChevron).	self assert: writer contents equals: newLine ,'Pilou \textgreater{}\textgreater{} bla', newLine! !!MicSBALaTeXWriterTest methodsFor: 'tests'!testParagraphWithMonospace		self parse: factory paragraphMonospaceSample andCheckWeGet: newLine,'this is a \textcode{paragraph}', newLine! !!MicSBALaTeXWriterTest methodsFor: 'tests'!testSimpleFloating	| codeBlock |	codeBlock := (MicCodeBlock new body: 'foo')		caption: 'A caption.';		yourself.	self writeForElement: codeBlock.	self assert: writer contents equals: '\begin{listing}[float]{smalltalk}{A caption.}', newLine ,'foo', newLine ,'\end{listing}', newLine! !!MicSBALaTeXWriterTest methodsFor: 'tests'!testSimpleFloatingNoLanguage	| codeBlock |	codeBlock := (MicCodeBlock new body: 'foo')		caption: 'A caption.';		yourself.	self writeForElement: codeBlock.	self flag: #languageSupport. "smalltalk -> plain"	self assertWriting: codeBlock includesText: '{smalltalk}'! !!MicSBALaTeXWriterTest methodsFor: 'tests'!testTable	self writeFor: factory tableSample.	self assert: writer contents equals: newLine,'\begin{fullwidthtabular}{ll}', newLine ,'\toprule', newLine ,'\textbf{aaab} & \textbf{jkhjh} \\', newLine ,'\midrule', newLine ,'bar & rab \\', newLine ,'\bottomrule', newLine ,'\end{fullwidthtabular}', newLine! !!MicSBALaTeXWriterTest methodsFor: 'tests'!testTableWhithoutHeader		self writeFor: (factory simpleTableWithoutHeaderTable).	self assert: writer contents equals: newLine,'\begin{fullwidthtabular}{ll}', newLine ,'\toprule', newLine ,'aaab & jkhjh \\', newLine ,'bar & rab \\', newLine ,'\bottomrule', newLine ,'\end{fullwidthtabular}', newLine! !"Microdown-LaTeXExporter-Tests"!!MicBeamerWriter commentStamp: '' prior: 0!I export mainly slides in Beamer LaTeX. Note that I do not generate the full beamer but the body of the slides. The beamer template can be for example the one of Pillar/presentation. ```| doc dict aFileReference output| doc := Microdown parse: MicMicrodownSnippetFactory new oneSlide.dict := Dictionary new. dict at: 'content' put: (MicBeamerWriter new visit: doc).dict at: 'title' put: 'ZeCrazy slides'.output := (MustacheTemplate 	on: '/Users/ducasse/.pillar/build/archetypes/presentation/support/templates/beamer/presentation.template' asFileReference readStream contents)	value: dict.aFileReference := FileSystem workingDirectory / 'MyCoolPresentation.tex'.aFileReference ensureDelete.aFileReference parent ensureCreateDirectory.aFileReference writeStreamDo: [ :stream | 		stream nextPutAll: output ]``````| doc dict aFileReference output| doc := Microdown parse: MicMicrodownSnippetFactory new oneSlide.dict := Dictionary new. dict at: 'content' put: (MicBeamerWriter new visit: doc).dict at: 'title' put: 'ZeCrazy slides'.output := (MustacheTemplate on: MicBeamerWriter basicTemplateForTest) value: dict.aFileReference := FileSystem workingDirectory / 'MyCoolPresentation.tex'.aFileReference ensureDelete.aFileReference parent ensureCreateDirectory.aFileReference writeStreamDo: [ :stream | 		stream nextPutAll: output ]```### How to load mustache```Metacello new  baseline: 'Mustache';  repository: 'github://noha/mustache:v1.0/repository';  load```!!MicBeamerWriter class methodsFor: 'basic ressources'!basicTemplateForTest	^ '% -*- mode: latex; -*- mustache tags: {{=« »=}} «!! the ''&'' below prevents HTML escaping. »\documentclass{beamer}\usepackage[frenchb]{babel}\usepackage[T1]{fontenc}\usepackage{pgfpages}\usepackage{listings}\usepackage{color}\definecolor{codegreen}{rgb}{0,0.6,0}\definecolor{codegray}{rgb}{0.5,0.5,0.5}\definecolor{codepurple}{rgb}{0.58,0,0.82}\definecolor{backcolour}{rgb}{0.95,0.95,0.92}\lstdefinestyle{mystyle}{    backgroundcolor=\color{backcolour},    numberstyle=\tiny\color{codegreen},    breaklines=true,    captionpos=b,    tabsize=2,    basicstyle=\ttfamily\scriptsize}\lstset{style=mystyle}\usetheme{Warsaw}\setbeamercolor{structure}{fg=red!!90!!black}\title{«& title»}\subtitle{«& subtitle»}\author{«& author»}\institute{«& complement»}\date{«& date»}\addtobeamertemplate{navigation symbols}{}{%    \usebeamerfont{footline}%    \usebeamercolor[fg]{footline}%    \hspace{1em}%    \insertframenumber/\inserttotalframenumber}\setbeamercolor{footline}{fg=blue}\setbeamerfont{footline}{series=\bfseries}\setbeamertemplate{headline}{}\begin{document}    \frame[plain]{\titlepage}    \frame[plain]{\tableofcontents}    «& content»\end{document}'! !!MicBeamerWriter class methodsFor: 'accessing'!writerName	^ #micBeamer! !!MicBeamerWriter methodsFor: 'helpers'!createFrametitle: aTitle	canvas command		name: 'frametitle';		parameter: aTitle! !!MicBeamerWriter methodsFor: 'helpers'!createLinkToLabelWithAlias: anInternalLink	canvas command		name: 'hyperlink';		parameter: [ canvas raw: anInternalLink anchor ];		parameter: [ canvas raw: anInternalLink alias ]! !!MicBeamerWriter methodsFor: 'accessing'!folderName	^ #beamer! !!MicBeamerWriter methodsFor: 'helpers'!sectionOptionFrom: level To: depth On: parameters	parameters		add:			((1 > level and: [ 1 <= depth ])				ifTrue: [ 'sectionstyle=show/show' ]				ifFalse: [ 'sectionstyle=hide/hide' ]).	parameters		add:			((2 > level and: [ 2 <= depth ])				ifTrue: [ 'subsectionstyle=show/show/show' ]				ifFalse: [ 'subsectionstyle=hide/hide/hide' ]).	parameters		add:			((3 > level and: [ 3 <= depth ])				ifTrue: [ 'subsubsectionstyle=show/show/show' ]				ifFalse: [ 'subsubsectionstyle=hide/hide/hide' ])! !!MicBeamerWriter methodsFor: 'accessing'!templateForConfiguration: aConfiguration	^ 'presentation.template'! !!MicBeamerWriter methodsFor: 'blocks - code'!visitCode: aCodeBlock	| env |	env := (aCodeBlock hasCaption and: [ aCodeBlock hasLabel ])		ifTrue: [			canvas environment 				name: 'listing';				optParameter: 'label=', aCodeBlock label;				optParameter: 'caption={' , (self getStringForAll: aCodeBlock captionElements), '}';				yourself ]		ifFalse: [			env := aCodeBlock hasCaption 				ifTrue: [ 					canvas environment 						name: 'listing';						optParameter: 'caption={' , (self getStringForAll: aCodeBlock captionElements), '}';						yourself ]				ifFalse: [ 					env := aCodeBlock hasLabel 						ifTrue: [							canvas environment 								name: 'listing';								optParameter: 'label=', aCodeBlock label;								yourself ]						ifFalse: [							canvas environment 								name: 'listing';								yourself ]]].	env with: [ canvas nextPutAllLines: aCodeBlock body. canvas newLine ]! !!MicBeamerWriter methodsFor: 'visiting'!visitColumn: aColumn	canvas environment		name: 'column';		parameter: [ 					canvas						nextPutAll: (aColumn width asNumber / 100.0) printString;						raw: '\textwidth' ];		with: [ self visitAll: aColumn children ].	canvas newLine! !!MicBeamerWriter methodsFor: 'visiting'!visitColumns: aColumns	canvas environment		name: 'columns';		with: [ 					self visitAll: aColumns children].	canvas newLine! !!MicBeamerWriter methodsFor: 'blocks - inline'!visitFigure: aFigure	canvas environment		name: 'center';		with: [ self includeGraphicsFor: aFigure ]! !!MicBeamerWriter methodsFor: 'visiting - extensions'!visitSlide: aSlide	canvas newLine.	canvas environment		name: 'frame';		optParameter: 'fragile';		with: [ 					canvas newLine.					self createFrametitle: aSlide title.					canvas newLine.					super visitSlide: aSlide ].	canvas newLine! !"Microdown-BeamerExporter"!!MicBeamerWriterTest class methodsFor: 'tests'!testParameters	^ ParametrizedTestMatrix new		  forSelector: #writer addOptions: { MicBeamerWriter };		  forSelector: #factory addOptions: { MicMicrodownSnippetFactory };		  forSelector: #parser addOptions: { Microdown };		  forSelector: #newLine addOptions: { String cr . String lf };		  yourself! !!MicBeamerWriterTest methodsFor: 'running'!actualClass 	^ MicBeamerWriter ! !!MicBeamerWriterTest methodsFor: 'tests'!testCode	self writeFor: (factory codeblockNoParamBody: 'this is a code').	self assert: writer contents equals: '\begin{listing}', newLine ,													'this is a code', newLine ,													'\end{listing}', newLine! !!MicBeamerWriterTest methodsFor: 'tests'!testCodeWithCaption	self writeFor: (factory codeblock: 'caption=Pharo is **cool**' body: 'this is a code').	self assert: writer contents equals: '\begin{listing}[caption={Pharo is \textbf{cool}}]', newLine ,													'this is a code', newLine ,													'\end{listing}', newLine! !!MicBeamerWriterTest methodsFor: 'tests'!testCodeWithLabel	self writeFor: (factory codeblock: 'label=Pharo' body: 'this is a code').	self assert: writer contents equals: '\begin{listing}[label=Pharo]', newLine ,'this is a code', newLine ,'\end{listing}', newLine! !!MicBeamerWriterTest methodsFor: 'tests'!testColumn	self writeFor: (factory columnSample).	self assert: writer contents equals:'\begin{column}{0.42\textwidth}', newLine , newLine, 'this is a \textbf{text}', newLine ,'\end{column}', newLine, newLine! !!MicBeamerWriterTest methodsFor: 'tests'!testColumns	self writeFor: (factory columnsSample).	self assert: writer contents equals:'\begin{columns}', newLine ,'\end{columns}', newLine , newLine! !!MicBeamerWriterTest methodsFor: 'tests'!testColumnsWithChildren	self writeFor: factory columnsWithChildrenSample.	self assert: writer contents equals:'\begin{columns}', newLine ,'\begin{column}{0.42\textwidth}', newLine , newLine ,'this is a \textbf{text}', newLine ,'\end{column}', newLine , newLine ,'\begin{column}{0.42\textwidth}', newLine, newLine,'this is a \textbf{text}', newLine ,'\end{column}', newLine , newLine ,'\end{columns}', newLine , newLine! !!MicBeamerWriterTest methodsFor: 'tests - figure/link'!testFigure	self writeFor: factory figureSample.	self assert: writer contents equals: newLine,'\begin{center}', newLine ,'\includegraphics[width=0.8\textwidth]{/anUrl}\end{center}', newLine, newLine! !!MicBeamerWriterTest methodsFor: 'tests - figure/link'!testFigureBold	"in beamer we do not display caption so bld and the rest goes away."	self writeFor: factory figureBoldSample.	self assert: writer contents equals: newLine ,'\begin{center}', newLine ,'\includegraphics[width=0.8\textwidth]{/anUrl}\end{center}', newLine , newLine! !!MicBeamerWriterTest methodsFor: 'tests - figure/link'!testFigureRealSample	self writeFor: factory figureRealSample.	self assert: writer contents equals: newLine ,'\begin{center}', newLine ,'\includegraphics[width=0.8\textwidth]{figures/logo.png}\end{center}', newLine , newLine! !!MicBeamerWriterTest methodsFor: 'tests'!testFrameWithoutOption	self		parse: '<!!slide|title=Slide title', newLine ,						'Presentation text', newLine		andCheckWeGet: newLine ,'\begin{frame}[fragile]', newLine ,newLine ,'\frametitle{Slide title}', newLine ,newLine ,'Presentation text', newLine ,'\end{frame}', newLine, newLine! !"Microdown-BeamerExporter-Tests"!!MicRealDumper methodsFor: 'accessing'!contents 	^ stream contents! !!MicRealDumper methodsFor: 'visit - section'!element: anElement during: aBlock		stream nextPut: $(.	self emitClassNameOf: anElement.	stream space.	stream		nextPutAll: 'new';		space.	aBlock value.	stream nextPut: $)! !!MicRealDumper methodsFor: 'utilities'!emitClassNameOf: aMicElement	stream nextPutAll: aMicElement class asString! !!MicRealDumper methodsFor: 'visit - section'!emitList: aList	self 		element: aList 		during: [			stream nextPutAll: 'children: { '.			aList children				do: [ :each | each accept: self ]				separatedBy: [ stream nextPutAll: ' . ' ].	stream nextPutAll: ' }; yourself']! !!MicRealDumper methodsFor: 'build'!emitParameters: aCodeBlock	stream nextPutAll: 'arguments: { '.	self parametersPrint: aCodeBlock arguments withoutDefaultValue.	stream nextPutAll: ' } asDictionary ; '! !!MicRealDumper methodsFor: 'initialization'!initialize	super initialize.	stream := MicOutputStream new setStream: (WriteStream on: (String new: 1000)).! !!MicRealDumper methodsFor: 'build'!parametersPrint: aDictionnary	| lastKey |	lastKey := aDictionnary keys last.	aDictionnary keysAndValuesDo: [ :k :v | 		stream			nextPut: $#;			nextPutAll: k;			nextPutAll: ' ->'.			v class = Array				ifTrue: [ 					stream nextPutAll: ''''.					v do: [ :each | stream nextPutAll: each text ].					stream nextPutAll: '''' ]				ifFalse: [ stream nextPutAll: v asString ].		k = lastKey ifFalse: [ stream nextPutAll: ' . ' ] ]! !!MicRealDumper methodsFor: 'visit - format'!visit: aMicElement	aMicElement accept: self.	stream contents! !!MicRealDumper methodsFor: 'visit - section'!visitAnchor: aMicAnchor	self		element: aMicAnchor 		during: [			stream nextPutAll: 'textElement: '.			stream				nextPutAll: '" ';				nextPutAll: aMicAnchor label;				nextPutAll: ' "' ]! !!MicRealDumper methodsFor: 'visit - format'!visitAttributedText: aMicBold	self 		element: aMicBold 		during: [			stream nextPutAll: 'textElements: '.			stream nextPutAll: '{'.			aMicBold children do: [ :each | each accept: self ] separatedBy: [ stream nextPutAll: ' . '].			stream nextPutAll: '}' ]! !!MicRealDumper methodsFor: 'visit - format'!visitBold: aMicItalic	self visitAttributedText: aMicItalic! !!MicRealDumper methodsFor: 'visit - section'!visitCode: aCodeBlock	self 		element: aCodeBlock 		during: [			aCodeBlock hasNonDefaultArguments ifTrue: [ self emitParameters: aCodeBlock ].			aCodeBlock hasBody ifTrue: [ 				stream nextPutAll: 'body: '.				stream					nextPutAll: '''';					nextPutAll: aCodeBlock body;					nextPutAll: '''' ]]! !!MicRealDumper methodsFor: 'visit - section'!visitComment: aComment		self flag: #argh.	self 		element: aComment 		during: [			stream nextPutAll: 'textElement: '.			stream nextPutAll: '''Foo''' ]! !!MicRealDumper methodsFor: 'visit - section'!visitFigure: aMicFigure	self flag: #arg.	self 		element: aMicFigure 		during: [			aMicFigure hasArguments ifTrue: [ self emitParameters: aMicFigure ].			stream nextPutAll: 'url: '.			stream print: aMicFigure reference fullName.			stream				space;				nextPutAll: ';'.			stream nextPutAll: ' caption: { '.			aMicFigure captionElements				do: [ :each | self visit: each ]				separatedBy: [ stream nextPutAll: ' . ' ].			stream nextPutAll: '}; yourself' ]! !!MicRealDumper methodsFor: 'visit - section'!visitHeader: aHeader		self 		element: aHeader 		during: [			stream nextPutAll: 'level: '.			aHeader level printOn: stream. 			stream nextPutAll: '; '.			stream nextPutAll: 'headerElements: '.			stream nextPut: ${.			self visitChildrenOf: aHeader.			stream nextPut: $}]! !!MicRealDumper methodsFor: 'visit - format'!visitItalic: aMicItalic	self visitAttributedText: aMicItalic! !!MicRealDumper methodsFor: 'visit - section'!visitLink: aMicLink	self 		element: aMicLink 		during: [			stream nextPutAll: 'captionElements: '.			stream nextPutAll: '{'.			aMicLink captionElements do: [ :each | self visit: each  ] separatedBy: [ stream nextPutAll: ' . ' ].			stream nextPutAll: '} ; url: '.			stream print: aMicLink url.			stream nextPutAll: ' ; yourself' ]! !!MicRealDumper methodsFor: 'visit - section'!visitListItem: anItem	self flag: #arg.	self 		element: anItem 		during: [			anItem children 				do: [ :each | each accept: self ]				separatedBy: [ ''.	'' ] ]! !!MicRealDumper methodsFor: 'visit - format'!visitMonospace: aMonospace	self 		element: aMonospace 		during: [			stream nextPutAll: 'textElement: '.			aMonospace children first accept: self ]	! !!MicRealDumper methodsFor: 'visit - section'!visitOrderedList: anOrderedList	self emitList: anOrderedList! !!MicRealDumper methodsFor: 'visit - section'!visitParagraph: aParagraph	stream nextPut: $(.	self emitClassNameOf: aParagraph.	stream space.	stream		nextPutAll: 'new';		space.	stream		nextPutAll: 'textElements: '. 	stream nextPut: ${.	self visitChildrenOf: aParagraph.	stream nextPut: $}.	stream nextPut: $)! !!MicRealDumper methodsFor: 'visit - section'!visitQuote: aQuote	stream nextPut: $(.	self emitClassNameOf: aQuote.	stream space.	stream		nextPutAll: 'new';		space.	stream nextPutAll: 'textElement: '.	aQuote children first accept: self.	stream nextPut: $)! !!MicRealDumper methodsFor: 'visit - section'!visitRaw: aMicRaw	self 		element: aMicRaw 		during: [			stream nextPutAll: 'substring: ' ; print: aMicRaw substring			]! !!MicRealDumper methodsFor: 'visit - format'!visitStrike: aMicItalic	self visitAttributedText: aMicItalic! !!MicRealDumper methodsFor: 'visit - section'!visitTable: aTable	self flag: #arg.	self 		element: aTable 		during: [				stream nextPutAll: 'string: '.	aTable children first accept: self ]! !!MicRealDumper methodsFor: 'visit - section'!visitText: aText		self 		element: aText 		during: [			stream				nextPutAll: 'substring: ';				nextPutAll: '''';				nextPutAll: aText substring;				nextPutAll: '''' ]! !!MicRealDumper methodsFor: 'visit - section'!visitUnorderedList: aUnOrderedList	self emitList: aUnOrderedList! !!MicTextualMicrodownExporter methodsFor: 'helpers'!backSlashString: aString	^ String streamContents: [ :st | 		aString doWithIndex: [ :each :i | 			((Delimiters includes: each asString) or:				 (Delimiters includes:					  each asString , (aString at: (i + 1 min: aString size)) asString)) 			ifTrue: [ st nextPutAll: '\' ].		st nextPutAll: each asString ]]! !!MicTextualMicrodownExporter methodsFor: 'build'!blockPrint: aMicText	| text |	text := self classPrint: aMicText.	text := text , ' "' , aMicText substring , '"'.	^ text! !!MicTextualMicrodownExporter methodsFor: 'API'!buildRowHeader: row	builder newLine.	row do: [ :cell | builder headCell ].	^ builder raw: '|'! !!MicTextualMicrodownExporter methodsFor: 'build'!classPrint: aMicFigure	^ aMicFigure class asString! !!MicTextualMicrodownExporter methodsFor: 'accessing'!contents 	^ stream contents! !!MicTextualMicrodownExporter methodsFor: 'io'!folderName	^ 'mic'! !!MicTextualMicrodownExporter methodsFor: 'accessing'!inList	^ inList! !!MicTextualMicrodownExporter methodsFor: 'initialization'!initialize 	super initialize.	stream := (String new: 10000) writeStream.	builder := Microdown builder.	builder setStream: stream.	builder setNewLineCharacterString: String cr.	inList := false! !!MicTextualMicrodownExporter methodsFor: 'build'!parametersPrint: aDictionnary	| text lastKey |	lastKey := aDictionnary keys last.	text := 'parameters:'.	aDictionnary keysAndValuesDo: [ :k :v |		text := text , k ,'=', v.		k = lastKey 			ifFalse: [ 				text := text , '&' ]].	^ text! !!MicTextualMicrodownExporter methodsFor: 'setting'!setFalseInList	inList := false! !!MicTextualMicrodownExporter methodsFor: 'setting'!setTrueInList	inList := true! !!MicTextualMicrodownExporter methodsFor: 'API'!visit: aMicElement	aMicElement accept: self.	^ stream contents! !!MicTextualMicrodownExporter methodsFor: 'visit - block'!visitAnchor: anAnchor		builder anchor: anAnchor label! !!MicTextualMicrodownExporter methodsFor: 'visit - format'!visitAnchorReference: anAnchorReference	builder anchorReference: anAnchorReference substring! !!MicTextualMicrodownExporter methodsFor: 'visit - block'!visitAnnotated: anAnnotated	builder 		annotated: anAnnotated label 		paragraph:  [ super visitAnnotated: anAnnotated  ] ! !!MicTextualMicrodownExporter methodsFor: 'visit - format'!visitAnnotation: anAnnotation	builder raw: anAnnotation printString! !!MicTextualMicrodownExporter methodsFor: 'visit - format'!visitBold: aBoldFormat	builder bold: [ super visitBold: aBoldFormat ]! !!MicTextualMicrodownExporter methodsFor: 'visit - block'!visitChildrenWithoutBackslash: aChildren	aChildren do: [ :each | self visitTextWithoutBackslash: each ]! !!MicTextualMicrodownExporter methodsFor: 'visit - block'!visitCode: aMicCodeBlock 	builder newLine.	builder		  codeblock: aMicCodeBlock body		  firstLineAssociations: aMicCodeBlock arguments withoutDefaultValue associations		  withCaption: [ super visitCode: aMicCodeBlock ]! !!MicTextualMicrodownExporter methodsFor: 'visit - block'!visitComment: aComment	builder comment: aComment text! !!MicTextualMicrodownExporter methodsFor: 'visit - block'!visitEnvironment: anEnvironment	builder newLine.	builder		environment: anEnvironment environmentName 		body: [ super visitEnvironment: anEnvironment ]		arguments: anEnvironment arguments justTheArguments .	! !!MicTextualMicrodownExporter methodsFor: 'visit - format'!visitFigure: aFigure		builder newLine.	builder		figureURL: aFigure originUrl		withCaption: [ super visitFigure: aFigure ]		! !!MicTextualMicrodownExporter methodsFor: 'visit - block'!visitHeader: aHeader		builder newLine.	builder 		header: [ aHeader headerElements do: [ :each | each accept: self ] ] 		withLevel: aHeader level! !!MicTextualMicrodownExporter methodsFor: 'visit - block'!visitHorizontalLine: aHorizontalLine	builder horizontalLine! !!MicTextualMicrodownExporter methodsFor: 'visit - format'!visitInputFile: anInputfile	 builder inputFile: anInputfile path originalString! !!MicTextualMicrodownExporter methodsFor: 'visit - format'!visitItalic: anItalicFormatBlock	builder italic: [ super visitItalic: anItalicFormatBlock ]! !!MicTextualMicrodownExporter methodsFor: 'visit - format'!visitLink: aLink	builder 		externalLink: aLink url 		withDescription: [ super visitLink: aLink ]! !!MicTextualMicrodownExporter methodsFor: 'visit - block'!visitListItem: anItem	builder item: [ super visitListItem: anItem ]! !!MicTextualMicrodownExporter methodsFor: 'visit - block'!visitMath: aMicMath	 builder		  mathblock: aMicMath body		  firstLineAssociations: aMicMath arguments associations		  withCaption: [ super visitMath: aMicMath ]! !!MicTextualMicrodownExporter methodsFor: 'visit - format'!visitMathInline: aMicMathInline	builder mathInline: aMicMathInline substring! !!MicTextualMicrodownExporter methodsFor: 'visit - block'!visitMetaData: aMetaData	builder metaDataFromAssociations: aMetaData body! !!MicTextualMicrodownExporter methodsFor: 'visit - format'!visitMonospace: aMonospaceFormat	builder 		writeDuring: [ self visitChildrenWithoutBackslash: aMonospaceFormat children ] 		surroundBy: aMonospaceFormat openingDelimiter and: aMonospaceFormat closingDelimiter! !!MicTextualMicrodownExporter methodsFor: 'visit - block'!visitOrderedList: anOrderedList	| block |	block := [  ].	self inList ifFalse: 		[ builder newLine.		 self setTrueInList.		 block := [ self setFalseInList ] ].	builder unorderedListDuring: [ super visitOrderedList: anOrderedList ].	block value! !!MicTextualMicrodownExporter methodsFor: 'visit - block'!visitOrderedListItem: anItem	builder orderedItem: [ super visitListItem: anItem ]! !!MicTextualMicrodownExporter methodsFor: 'visit - block'!visitParagraph: aParagraph	builder newLine.	builder 		paragraph: [ super visitParagraph: aParagraph ]! !!MicTextualMicrodownExporter methodsFor: 'visit - format'!visitQuote: aQuote	builder quoteBlock: aQuote text! !!MicTextualMicrodownExporter methodsFor: 'visit - format'!visitRaw: aRawFormat	builder rawFormat: aRawFormat substring! !!MicTextualMicrodownExporter methodsFor: 'visit - block'!visitRoot: aRoot	builder 		root: [ super visitRoot: aRoot ] ! !!MicTextualMicrodownExporter methodsFor: 'API'!visitRow: row in: aTable at: i	row do: [ :cell | 		builder cell: [ cell do: [ :child | child accept: self ] ] ].	builder raw: '|'.	^ (aTable hasHeader and: i = 1) ifTrue: [ self buildRowHeader: row ]! !!MicTextualMicrodownExporter methodsFor: 'visit - format'!visitStrike: aStrikeFormat	builder strike: [ super visitStrike: aStrikeFormat ]! !!MicTextualMicrodownExporter methodsFor: 'API'!visitTable: aTable	aTable rows doWithIndex: [ :row :i | 		builder newLine.		self visitRow: row in: aTable at: i ]! !!MicTextualMicrodownExporter methodsFor: 'visit - block'!visitText: aMicTextBlock		builder text:  (self backSlashString: aMicTextBlock substring)! !!MicTextualMicrodownExporter methodsFor: 'visiting'!visitTextWithoutBackslash: aMicTextBlock	builder text: aMicTextBlock substring! !!MicTextualMicrodownExporter methodsFor: 'visit - block'!visitUnorderedList: aUnorderedList		| block |	block := [  ].	self inList ifFalse: 		[ builder newLine.		 self setTrueInList.		 block := [ self setFalseInList ] ].	builder unorderedListDuring: [ super visitUnorderedList: aUnorderedList ].	block value! !"Microdown-PrettyPrinter"!!MicDumperTest methodsFor: 'tests - section'!parse: aString andCheckWeGet: anExpectedString	| mic |	mic := parser parse: aString.	visitor visit: mic children first.	self assert: visitor contents equals: anExpectedString! !!MicDumperTest methodsFor: 'running'!setUp 	super setUp.	parser := Microdown new.	factory := MicMicrodownSnippetFactory new.	visitor := MicRealDumper new.! !!MicDumperTest methodsFor: 'test - inline - blocks'!testAnchorFormat	| micAnchor result |	micAnchor := parser parse: factory anchorSample.	result := visitor visit: micAnchor children first.	self		assert: result contents		equals: '(MicAnchorBlock new textElement: " test ")'! !!MicDumperTest methodsFor: 'test - inline - blocks'!testBold	self 		assert: (MicRealDumper new 						visit: (Microdown parse: '**aaa_bbb_ccc**')) contents  								equals: '(MicParagraphBlock new textElements: {(MicBoldFormatBlock new textElements: {(MicTextBlock new substring: ''aaa'') . (MicItalicFormatBlock new textElements: {(MicTextBlock new substring: ''bbb'')}) . (MicTextBlock new substring: ''ccc'')})})'						! !!MicDumperTest methodsFor: 'test - inline - blocks'!testBoldFormat	| micBold |	micBold := (parser parse: factory boldFormatSample) children first		           children first.	self assert: micBold children first class equals: MicTextBlock.	visitor visit: micBold.	self		assert: visitor contents		equals:		'(MicBoldFormatBlock new textElements: {(MicTextBlock new substring: ''Foo'')})'! !!MicDumperTest methodsFor: 'test - inline - blocks'!testCodeBlockNewLine	| micCodeBlock result |	micCodeBlock := (parser parse: factory blockWithNewLineSample)		                children first.	result := micCodeBlock accept: visitor.	self		assert: result contents		equals: '(MicCodeBlock new body: ''foo'')'! !!MicDumperTest methodsFor: 'test - inline - blocks'!testCodeBlockOnMultipleLines	| micCodeBlock result |	micCodeBlock := (parser parse: factory blockSampleOnMultipleLines)		                children first.	result := micCodeBlock accept: visitor.	self		assert: result contents		equals: '(MicCodeBlock new body: ''first line second linethird line **b**'')'! !!MicDumperTest methodsFor: 'test - inline - blocks'!testCodeBlockWithCaption	| micCodeBlock result |	micCodeBlock := (parser parse:		                 factory blockWithParametersWithCaptionSample)		                children first.	result := micCodeBlock accept: visitor.	self		assert: result contents		equals:		'(MicCodeBlock new arguments: { #caption ->''Color is beautifull'' . #bar ->2 } asDictionary ; body: ''bla'')'! !!MicDumperTest methodsFor: 'test - inline - blocks'!testCodeBlockWithFloatParam	| micCodeBlock result |	micCodeBlock := (parser parse:		                 factory blockWithParameterWithFloatSample) children		                first.	result := micCodeBlock accept: visitor.	self		assert: result contents		equals: '(MicCodeBlock new arguments: { #ratio ->0.8 } asDictionary ; body: ''bar'')'! !!MicDumperTest methodsFor: 'test - inline - blocks'!testCodeBlockWithLanguage	| micCodeBlock result |	micCodeBlock := (parser parse: factory blockWithLanguageSample)		                children first.	result := micCodeBlock accept: visitor.	self		assert: result contents		equals:		'(MicCodeBlock new arguments: { #language ->smalltalk } asDictionary ; body: ''foo'')'! !!MicDumperTest methodsFor: 'test - inline - blocks'!testCodeBlockWithLiteralArray	| micCodeBlock result |	micCodeBlock := (parser parse:		                 factory blockParameterWithLiteralArraySample)		                children first.	result := micCodeBlock accept: visitor.	self		assert: result contents		equals:		'(MicCodeBlock new arguments: { #foo ->#(1 2 true) } asDictionary ; )'! !!MicDumperTest methodsFor: 'test - inline - blocks'!testCodeBlockWithNoValues	| micCodeBlock result |	micCodeBlock := (parser parse:		                 factory blockWithParameterWithNoValuesSample)		                children first.	result := micCodeBlock accept: visitor.	self		assert: result contents		equals:		'(MicCodeBlock new arguments: { #foo -> } asDictionary ; body: ''bar'')'! !!MicDumperTest methodsFor: 'test - inline - blocks'!testCodeBlockWithParameterTrueByDefault	| micCodeBlock result |	micCodeBlock := (parser parse:		                 factory blockWithParameterTrueByDefaultSample)		                children first.	result := micCodeBlock accept: visitor.	self		assert: result contents		equals: '(MicCodeBlock new arguments: { #language ->foo } asDictionary ; body: ''bar'')'! !!MicDumperTest methodsFor: 'test - inline - blocks'!testCodeBlockWithParameters	| micCodeBlock result |	micCodeBlock := (parser parse: factory blockWithParametersSample)		                children first.	result := micCodeBlock accept: visitor.	self		assert: result contents		equals:		'(MicCodeBlock new arguments: { #foo ->true . #bar ->2 } asDictionary ; body: ''bla'')'! !!MicDumperTest methodsFor: 'test - inline - blocks'!testCodeBlockWithSpaceAtTheEnd	| micCodeBlock result |	micCodeBlock := (parser parse: factory blockWithSpaceAtTheEndSample)		                children first.	result := micCodeBlock accept: visitor.	self		assert: result contents		equals:		'(MicCodeBlock new body: ''foo'')'! !!MicDumperTest methodsFor: 'test - inline - blocks'!testCodeBlockWithSpacedParameters	| micCodeBlock result |	micCodeBlock := (parser parse:		                 factory blockWithSpacedParametersSample) children		                first.	result := micCodeBlock accept: visitor.	self		assert: result contents		equals:		'(MicCodeBlock new arguments: { #foo -> true  . #bar -> 2 } asDictionary ; body: ''bla'')'! !!MicDumperTest methodsFor: 'test - inline - blocks'!testCodeBlockWithoutParam	| micCodeBlock result |	micCodeBlock := (parser parse: factory blockSampleOnMultipleLines)		                children first.	result := micCodeBlock accept: visitor.	self		assert: result contents		equals: '(MicCodeBlock new body: ''first line second linethird line **b**'')'! !!MicDumperTest methodsFor: 'test - inline - blocks'!testComment	| micComment |  	micComment := (parser parse: factory commentSample) children first.	self assert: micComment class equals: MicCommentBlock.	visitor visit: micComment.		self		assert: visitor contents		equals: '(MicCommentBlock new textElement: ''Foo'')'! !!MicDumperTest methodsFor: 'test - inline - blocks'!testFigureBoldFormat	| micFigure result |	micFigure := (parser parse: factory figureBoldSample) children first		             children first.	self assert: micFigure class equals: MicFigureBlock.	result := micFigure accept: visitor.	self		assert: result contents		 equals: '(MicFigureBlock new arguments: { #label ->figureTest . #width ->80 } asDictionary ; url: ''/anUrl'' ; caption: { (MicBoldFormatBlock new textElements: {(MicTextBlock new substring: ''Foo'')})}; yourself)'		! !!MicDumperTest methodsFor: 'test - inline - blocks'!testFigureBoldFormat2	| micFigure result |	micFigure := (parser parse: '!![**Bold** and not bold and **bold**](/anUrl label=figureTest&size=80)') children first		             children first.	self assert: micFigure class equals: MicFigureBlock.	result := micFigure accept: visitor.	self		assert: result contents 		equals:		'(MicFigureBlock new arguments: { #label ->figureTest . #size ->80 } asDictionary ; url: ''/anUrl'' ; caption: { (MicBoldFormatBlock new textElements: {(MicTextBlock new substring: ''Bold'')}) . (MicTextBlock new substring: '' and not bold and '') . (MicBoldFormatBlock new textElements: {(MicTextBlock new substring: ''bold'')})}; yourself)'! !!MicDumperTest methodsFor: 'test - inline - blocks'!testFigureFormat	| micFigure result |	micFigure := (parser parse: factory figureSample) children first		             children first.	self assert: micFigure class equals: MicFigureBlock.	result := micFigure accept: visitor.	self		assert: result contents		equals:		'(MicFigureBlock new arguments: { #label ->figureTest . #width ->80 } asDictionary ; url: ''/anUrl'' ; caption: { (MicTextBlock new substring: ''Foo'')}; yourself)'! !!MicDumperTest methodsFor: 'test - inline - blocks'!testFigureItalicFormat	| micFigure result |	micFigure := (parser parse: factory figureItalicSample) children		             first children first.	self assert: micFigure class equals: MicFigureBlock.	result := micFigure accept: visitor.	self		assert: result contents		equals:		'(MicFigureBlock new arguments: { #label ->figureTest . #width ->80 } asDictionary ; url: ''/anUrl'' ; caption: { (MicItalicFormatBlock new textElements: {(MicTextBlock new substring: ''Foo'')})}; yourself)'! !!MicDumperTest methodsFor: 'test - inline - blocks'!testFigureMonospaceFormat	| micFigure result |	micFigure := (parser parse: factory figureMonospaceSample) children		             first children first.	self assert: micFigure class equals: MicFigureBlock.	result := micFigure accept: visitor.	self		assert: result contents 		equals:		'(MicFigureBlock new arguments: { #label ->figureTest . #width ->80 } asDictionary ; url: ''/anUrl'' ; caption: { (MicMonospaceFormatBlock new textElement: (MicTextBlock new substring: ''Foo''))}; yourself)'! !!MicDumperTest methodsFor: 'test - inline - blocks'!testFigureNestedFormat	| micFigure result |	micFigure := (parser parse: factory figureNestedSample) children		             first children first.	self assert: micFigure class equals: MicFigureBlock.	result := micFigure accept: visitor.	self		assert: result contents		equals:		'(MicFigureBlock new arguments: { #label ->figureTest . #width ->80 } asDictionary ; url: ''/anUrl'' ; caption: { (MicBoldFormatBlock new textElements: {(MicTextBlock new substring: ''Foo_'')})}; yourself)'! !!MicDumperTest methodsFor: 'test - inline - blocks'!testFigureStrikeFormat	| micFigure result |	micFigure := (parser parse: factory figureStrikeSample) children		             first children first.	self assert: micFigure class equals: MicFigureBlock.	result := micFigure accept: visitor.	self		assert: result contents  		equals:		'(MicFigureBlock new arguments: { #label ->figureTest . #width ->80 } asDictionary ; url: ''/anUrl'' ; caption: { (MicStrikeFormatBlock new textElements: {(MicTextBlock new substring: ''Foo'')})}; yourself)'! !!MicDumperTest methodsFor: 'test - inline - blocks'!testFileFigureFormat	| micFigure result |	micFigure := (parser parse: factory fileFigureSample) children first		             children first.	self assert: micFigure class equals: MicFigureBlock.	result := micFigure accept: visitor.	self		assert: result contents		equals:		'(MicFigureBlock new arguments: { #label ->figureTest . #width ->80 } asDictionary ; url: ''image.png/'' ; caption: { (MicTextBlock new substring: ''Foo'')}; yourself)'! !!MicDumperTest methodsFor: 'tests - section'!testHeader	| micHeader |	micHeader := (parser parse: factory headerLevel3Sample) children		             first.	self assert: micHeader class equals: MicHeaderBlock.	self assert: micHeader children first class equals: MicTextBlock.	visitor visit: micHeader.	self		assert: visitor contents		equals:		'(MicHeaderBlock new level: 3; headerElements: {(MicTextBlock new substring: ''Foo'')})'! !!MicDumperTest methodsFor: 'test - inline - blocks'!testItalicFormat	| micItalic result |	micItalic := (parser parse: factory italicFormatSample) children		             first children first.	result := micItalic accept: visitor.	self		assert: result contents		equals: '(MicItalicFormatBlock new textElements: {(MicTextBlock new substring: ''Foo'')})'! !!MicDumperTest methodsFor: 'test - inline - blocks'!testMonospaceFormat	| mic result |	mic := parser parse: factory monospaceFormatSample.	result := visitor visit: mic children first children first.	self		assert: result contents		equals: '(MicMonospaceFormatBlock new textElement: (MicTextBlock new substring: ''Foo''))'! !!MicDumperTest methodsFor: 'tests - section'!testOrderedList	| micList |	micList := (parser parse: factory orderedListSample) children first.	self assert: micList class equals: MicOrderedListBlock.	visitor visit: micList.	self		assert: visitor contents		equals:		'(MicOrderedListBlock new children: { (MicListItemBlock new (MicTextBlock new substring: ''Foo'')) }; yourself)'! !!MicDumperTest methodsFor: 'tests - section'!testOrderedListWithTwoItems	| micList |	micList := (parser parse: factory orderedListWithTwoItemsSample)		           children first.	self assert: micList class equals: MicOrderedListBlock.	visitor visit: micList.	self		assert: visitor contents		equals:		'(MicOrderedListBlock new children: { (MicListItemBlock new (MicTextBlock new substring: ''first'')) . (MicListItemBlock new (MicTextBlock new substring: ''second'')) }; yourself)'! !!MicDumperTest methodsFor: 'tests - section'!testOrderedListWithTwoItemsBold	| micList |	micList := (parser parse: factory orderedListWithTwoItemsBoldSample)		           children first.	self assert: micList class equals: MicOrderedListBlock.	visitor visit: micList.	self		assert: visitor contents		equals:		'(MicOrderedListBlock new children: { (MicListItemBlock new (MicBoldFormatBlock new textElements: {(MicTextBlock new substring: ''first'')})) . (MicListItemBlock new (MicTextBlock new substring: ''second'')) }; yourself)'! !!MicDumperTest methodsFor: 'tests - section'!testOrderedListWithTwoItemsItalic	| micList |		micList := (parser parse: factory orderedListWithTwoItemsItalicSample)		           children first.	self assert: micList class equals: MicOrderedListBlock.	visitor visit: micList.	self		assert: visitor contents		equals:		'(MicOrderedListBlock new children: { (MicListItemBlock new (MicItalicFormatBlock new textElements: {(MicTextBlock new substring: ''first'')})) . (MicListItemBlock new (MicTextBlock new substring: ''second'')) }; yourself)'! !!MicDumperTest methodsFor: 'tests - section'!testOrderedListWithTwoItemsMonospace	| micList |	micList := (parser parse: factory orderedListWithTwoItemsMonospaceSample)		           children first.	self assert: micList class equals: MicOrderedListBlock.	visitor visit: micList.	self		assert: visitor contents		equals:		'(MicOrderedListBlock new children: { (MicListItemBlock new (MicMonospaceFormatBlock new textElement: (MicTextBlock new substring: ''first''))) . (MicListItemBlock new (MicTextBlock new substring: ''second'')) }; yourself)'! !!MicDumperTest methodsFor: 'tests - section'!testOrderedListWithTwoItemsStrike	| micList |	micList := (parser parse: factory orderedListWithTwoItemsStrikeSample)		           children first.	self assert: micList class equals: MicOrderedListBlock.	visitor visit: micList.	self		assert: visitor contents		equals:		'(MicOrderedListBlock new children: { (MicListItemBlock new (MicStrikeFormatBlock new textElements: {(MicTextBlock new substring: ''first'')})) . (MicListItemBlock new (MicTextBlock new substring: ''second'')) }; yourself)'! !!MicDumperTest methodsFor: 'tests - section'!testParagraph	| resString |	resString := '(MicParagraphBlock new textElements: {(MicTextBlock new substring: ''Foo'')})'.	self parse: factory paragraphSample andCheckWeGet: resString! !!MicDumperTest methodsFor: 'tests - section'!testPrintHeader		| resString |	resString := '(MicHeaderBlock new level: 3; headerElements: {(MicTextBlock new substring: ''Foo'')})'.	self parse: factory headerLevel3Sample andCheckWeGet: resString.			! !!MicDumperTest methodsFor: 'tests - section'!testPrintOrderedList	| resString |	resString := '(MicOrderedListBlock new children: { (MicListItemBlock new (MicBoldFormatBlock new textElements: {(MicTextBlock new substring: ''first'')})) . (MicListItemBlock new (MicTextBlock new substring: ''second'')) }; yourself)'.	self		parse: factory orderedListWithTwoItemsBoldSample		andCheckWeGet: resString! !!MicDumperTest methodsFor: 'tests - section'!testPrintParagraph	| resString |	resString := '(MicParagraphBlock new textElements: {(MicTextBlock new substring: ''Foo'')})'.	self parse: factory paragraphSample andCheckWeGet: resString! !!MicDumperTest methodsFor: 'tests - section'!testPrintUnorderedList	| resString |	resString := '(MicUnorderedListBlock new children: { (MicListItemBlock new (MicTextBlock new substring: ''Foo'')) }; yourself)'.	self parse: factory unorderedListSample andCheckWeGet: resString! !!MicDumperTest methodsFor: 'test - inline - blocks'!testQuote	| micQuote |	micQuote := (parser parse: factory quoteSample) children first.	self assert: micQuote children first class equals: MicTextBlock.	visitor visit: micQuote.	self		assert: visitor contents		equals:		'(MicQuoteBlock new textElement: (MicTextBlock new substring: ''Foo''))'! !!MicDumperTest methodsFor: 'test - inline - blocks'!testRawBlock	| micRaw |	micRaw := (parser parse: factory rawFormatSample) children first children second.	self assert: micRaw class equals: MicRawBlock.	visitor visit: micRaw.	self		assert: visitor contents		equals:		'(MicRawBlock new substring: ''Foo'')'! !!MicDumperTest methodsFor: 'test - inline - blocks'!testSimpleLinkFormat	| micLink result |	micLink := (parser parse: '[Pharo url](http://www.pharo.org)') children first children first.	self assert: micLink class equals: MicLinkBlock.	result := micLink accept: visitor.	self		assert: result contents		equals: '(MicLinkBlock new captionElements: {(MicTextBlock new substring: ''Pharo url'')} ; url: ''http://www.pharo.org'' ; yourself)'! !!MicDumperTest methodsFor: 'test - inline - blocks'!testStrike	| micStrike result |	micStrike := (parser parse: factory strikethroughFormatSample) children first children first.	result := micStrike accept: visitor.	self assert: result contents equals: '(MicStrikeFormatBlock new textElements: {(MicTextBlock new substring: ''Foo'')})'! !!MicDumperTest methodsFor: 'tests - section'!testTable	| micTable |	self skip.	micTable := (parser parse: factory tableSample) children first.	self assert: (micTable accept: visitor) equals: 'MicTableBlock'! !!MicDumperTest methodsFor: 'test - inline - blocks'!testTextBlock	| micText |	micText := (parser parse: factory textSentenceSample) children first		           children first.	visitor visit: micText.	self		assert: visitor contents		equals:		'(MicTextBlock new substring: ''Je ne connaitrais pas la peur'')'! !!MicDumperTest methodsFor: 'tests - section'!testUnOrderedEmptyList	| micList |	micList := (parser parse: factory unorderedListEmptySample) children		           first.	self assert: micList class equals: MicUnorderedListBlock.	visitor visit: micList.	self		assert: visitor contents		equals:		'(MicUnorderedListBlock new children: { (MicListItemBlock new (MicTextBlock new substring: ''-'')) }; yourself)'! !!MicDumperTest methodsFor: 'tests - section'!testUnOrderedList	| micList |	micList := (parser parse: factory unorderedListSample) children first.	self assert: micList class equals: MicUnorderedListBlock.	visitor visit: micList.	self		assert: visitor contents 		equals:		'(MicUnorderedListBlock new children: { (MicListItemBlock new (MicTextBlock new substring: ''Foo'')) }; yourself)'! !!MicDumperTest methodsFor: 'tests - section'!testUnOrderedListWithTwoItems	| micList |	micList := (parser parse: factory unorderedListWithTwoItemsSample)		           children first.	self assert: micList class equals: MicUnorderedListBlock.	visitor visit: micList.	self		assert: visitor contents		equals:		'(MicUnorderedListBlock new children: { (MicListItemBlock new (MicTextBlock new substring: ''Foo'')) . (MicListItemBlock new (MicTextBlock new substring: ''Bar'')) }; yourself)'! !!MicDumperTest methodsFor: 'tests - section'!testUnOrderedListWithTwoItemsBold	| micList |	micList := (parser parse: factory unorderedListWithTwoItemsBoldSample)		           children first.	self assert: micList class equals: MicUnorderedListBlock.	visitor visit: micList.	self		assert: visitor contents		equals:		'(MicUnorderedListBlock new children: { (MicListItemBlock new (MicBoldFormatBlock new textElements: {(MicTextBlock new substring: ''Foo'')})) . (MicListItemBlock new (MicTextBlock new substring: ''Bar'')) }; yourself)'! !!MicDumperTest methodsFor: 'tests - section'!testUnOrderedListWithTwoItemsMonospace	| micList |		micList := (parser parse:		            factory unorderedListWithTwoItemsMonospaceSample) children		           first.	self assert: micList class equals: MicUnorderedListBlock.	visitor visit: micList.	self		assert: visitor contents		equals:		'(MicUnorderedListBlock new children: { (MicListItemBlock new (MicMonospaceFormatBlock new textElement: (MicTextBlock new substring: ''Foo''))) . (MicListItemBlock new (MicTextBlock new substring: ''Bar'')) }; yourself)'! !!MicDumperTest methodsFor: 'tests - section'!testUnOrderedListWithTwoItemsNested	| micList |		micList := (parser parse:		            factory unorderedListWithTwoItemsNestedSample) children		           first.	self assert: micList class equals: MicUnorderedListBlock.	visitor visit: micList.	self		assert: visitor contents		equals:		'(MicUnorderedListBlock new children: { (MicListItemBlock new (MicStrikeFormatBlock new textElements: {(MicItalicFormatBlock new textElements: {(MicTextBlock new substring: ''Foo'')})})) . (MicListItemBlock new (MicTextBlock new substring: ''Bar'')) }; yourself)'! !!MicDumperTest methodsFor: 'tests - section'!testUnOrderedListWithTwoItemsStrike	| micList |		micList := (parser parse: factory unorderedListWithTwoItemsStrikeSample )		           children first.	self assert: micList class equals: MicUnorderedListBlock.	visitor visit: micList.	self		assert: visitor contents		equals:		'(MicUnorderedListBlock new children: { (MicListItemBlock new (MicStrikeFormatBlock new textElements: {(MicTextBlock new substring: ''Foo'')})) . (MicListItemBlock new (MicTextBlock new substring: ''Bar'')) }; yourself)'! !!MicTextualMicrodownExporterTest class methodsFor: 'tests'!testParameters 	^ super testParameters			addCase: { #visitorClass -> MicTextualMicrodownExporter };		yourself.! !!MicTextualMicrodownExporterTest methodsFor: 'accessing'!factory 	^ factory! !!MicTextualMicrodownExporterTest methodsFor: 'accessing'!factory: aFactory	factory := aFactory! !!MicTextualMicrodownExporterTest methodsFor: 'running'!setUp	super setUp.	factory := MicMicrodownSnippetFactory new.	visitor := self visitorClass new.	parser := Microdown new! !!MicTextualMicrodownExporterTest methodsFor: 'tests-anchor'!testAnchor	| micAnchor |	micAnchor := parser parse: factory anchorSample.	self assert: (visitor visit: micAnchor) first asString equals: AnchorMarkup! !!MicTextualMicrodownExporterTest methodsFor: 'tests-anchor'!testAnchorAutomatic	self verifyObtain: factory anchorSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests-anchor'!testAnchorReference	"Pay attention an anchor reference is inside a paragraph and a paragraph emits 	a newline "	| micElement |	micElement := parser parse: factory anchorReferenceSample.	self assert: (visitor visit: micElement) equals: '*@Foo@*'.	self flag: #newline.	! !!MicTextualMicrodownExporterTest methodsFor: 'tests-anchor'!testAnnotated	self verifyObtain: factory annotatedSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests-anchor'!testAnnotation	self verifyObtain: factory annotationSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests-codeblock'!testCodeBlock	self verifyObtain: factory blockWithParametersSample, String cr! !!MicTextualMicrodownExporterTest methodsFor: 'tests-codeblock'!testCodeBlockNewLine	| mic |	mic := parser parse: '```this is a codeblock```'.	self assert: (mic accept: visitor) contents equals: '```this is a codeblock```'! !!MicTextualMicrodownExporterTest methodsFor: 'tests-codeblock'!testCodeBlockWithCaption	self verifyObtain: factory blockWithParametersWithCaptionSample, String cr! !!MicTextualMicrodownExporterTest methodsFor: 'tests-anchor'!testComment	self verifyObtain: factory commentSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests - environment'!testEnvironment	self verifyObtain: factory environmentSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests - environment'!testEnvironmentWithInnerBlock	self skip.	"The parsing of environment is plain wrong. It should recursively parse subelements"		self verifyObtain: factory environmentWithInnerBlockSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests - figure'!testFigure	self verifyObtain: factory figureSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests - figure'!testFigureNewLine		| mic |	"there is two newLine because a figure is a inlineblock which is in a paragraph"	mic := parser parse: '!![Pharo is is cool](http://pharo.org/)'.	self assert: (mic accept: visitor) contents equals: '!![Pharo is is cool](http://pharo.org/)'! !!MicTextualMicrodownExporterTest methodsFor: 'tests - figure'!testFigureWithBold	self verifyObtain: factory figureBoldSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests - figure'!testFigureWithItalic	self verifyObtain: factory figureItalicSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests - figure'!testFigureWithMicroDownMarkup	| mic |	"there is two newLine because a figure is a inlineblock which is in a paragraph"	mic := parser parse: '!![Pharo is \~is c\**ool](http://pharo.org/)'.	self assert: (mic accept: visitor) contents equals: '!![Pharo is \~is c\**ool](http://pharo.org/)'! !!MicTextualMicrodownExporterTest methodsFor: 'tests - figure'!testFigureWithMonospace	self verifyObtain: factory figureMonospaceSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests - figure'!testFigureWithNested	self verifyObtain: factory figureNestedSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests - figure'!testFigureWithStrike	self verifyObtain: factory figureStrikeSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests - figure'!testFileFigure	self verifyObtain: factory fileFigureSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests-header'!testHeaderNewLine	| mic |	mic := parser parse: '# header 1# header 2'.	self assert: (mic accept: visitor) contents equals: '# header 1# header 2'! !!MicTextualMicrodownExporterTest methodsFor: 'tests-header'!testHeaderWithBold		self verifyObtain: factory headerWithFormatSampleWithNewLine! !!MicTextualMicrodownExporterTest methodsFor: 'tests-header'!testHeaderWithMicroDownMarkup	| mic |	mic := parser parse: '# header\~ 1'.	self assert: (mic accept: visitor) contents equals: '# header\~ 1'! !!MicTextualMicrodownExporterTest methodsFor: 'tests-header'!testHeaderWithNestedFormatSampleWithNewLine		self verifyObtain: factory headerWithNestedFormatSampleWithNewLine.! !!MicTextualMicrodownExporterTest methodsFor: 'tests-anchor'!testHorizontalLine	self verifyObtain: factory horizontalLineSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests-anchor'!testInputfile	| inputFile |	inputFile := parser parse: factory inputfileSample.	self assert: inputFile children first path path equals: 'Chapters/text.md'! !!MicTextualMicrodownExporterTest methodsFor: 'tests - link'!testLink	self verifyObtain: factory linkSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests - link'!testLinkWithBold	self verifyObtain: factory linkBoldSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests - link'!testLinkWithItalic	self verifyObtain: factory linkItalicSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests - link'!testLinkWithMicroDownMarkup	| mic |	"there is two newLine because a figure is a inlineblock which is in a paragraph"	mic := parser parse: '[Pharo is \~is c\**ool](http://pharo.org/)'.	self assert: (mic accept: visitor) contents equals: '[Pharo is \~is c\**ool](http://pharo.org/)'! !!MicTextualMicrodownExporterTest methodsFor: 'tests - link'!testLinkWithMonospace	self verifyObtain: factory linkMonospaceSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests - link'!testLinkWithNested		self verifyObtain: factory linkNestedSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests - link'!testLinkWithStrike	self verifyObtain: factory linkStrikeSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests - math'!testMathBlock	self verifyObtain: factory mathParametersSample, String cr! !!MicTextualMicrodownExporterTest methodsFor: 'tests - math'!testMathBlockWithCaption	self verifyObtain: factory mathParametersWithCaptionSample, String cr! !!MicTextualMicrodownExporterTest methodsFor: 'tests - math'!testMathInline	self verifyObtain: factory mathInlineSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests-anchor'!testMetaData	self skip.	self flag: #fixme.	"the builder wait a collection of associotion or a dictionnary but a metaData has not that"	self verifyObtain: factory metaDataSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests-header'!testNestedHeader	| header res |	header := parser parse: factory headerWithNestedFormatSampleWithNewLine.	res := visitor visit: header.	self assert: (res at: res size -1)  asString equals: ItalicMarkup.	self assert: (res copyFrom: res size -3 to: res size - 2) equals: BoldMarkup! !!MicTextualMicrodownExporterTest methodsFor: 'tests - list'!testOrderedList	self verifyObtain: factory orderedListWithTwoItemsSample ! !!MicTextualMicrodownExporterTest methodsFor: 'tests - list'!testOrderedListNewLine	| mic |	mic := parser parse: '1. item11. item2'.	self assert: (mic accept: visitor) contents equals: '1. item11. item2'! !!MicTextualMicrodownExporterTest methodsFor: 'tests - list'!testOrderedListWithBold	self verifyObtain: factory orderedListWithTwoItemsBoldSample  ! !!MicTextualMicrodownExporterTest methodsFor: 'tests - list'!testOrderedListWithItalic	self verifyObtain: factory orderedListWithTwoItemsItalicSample  ! !!MicTextualMicrodownExporterTest methodsFor: 'tests - list'!testOrderedListWithMonospace	self verifyObtain: factory orderedListWithTwoItemsMonospaceSample  ! !!MicTextualMicrodownExporterTest methodsFor: 'tests - list'!testOrderedListWithNested	self verifyObtain: factory orderedListWithTwoItemsBoldFirstSample  ! !!MicTextualMicrodownExporterTest methodsFor: 'tests - list'!testOrderedListWithStrike	self verifyObtain: factory orderedListWithTwoItemsStrikeSample  ! !!MicTextualMicrodownExporterTest methodsFor: 'tests - paragraph'!testParagraph	self verifyObtain: factory paragraphSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests - paragraph'!testParagraphNewLine		| mic |	mic := parser parse: 'blabla1'.	self assert: (mic accept: visitor) contents equals: 'blabla1'! !!MicTextualMicrodownExporterTest methodsFor: 'tests - paragraph'!testParagraphWithBold	self verifyObtain: factory paragraphBoldSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests - paragraph'!testParagraphWithItalic	self verifyObtain: factory paragraphItalicSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests - paragraph'!testParagraphWithMicroDownMarkup	| mic |	mic := parser parse: 'blab\~l\**a*1'.	self assert: (mic accept: visitor) contents equals: 'blab\~l\**a*1'! !!MicTextualMicrodownExporterTest methodsFor: 'tests - paragraph'!testParagraphWithMonospace	self verifyObtain: factory paragraphMonospaceSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests - paragraph'!testParagraphWithNested	self verifyObtain: factory paragraphNestedSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests - paragraph'!testParagraphWithStrike	self verifyObtain: factory paragraphStrikeSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests-header'!testPlainHeader	self verifyObtain: factory headerLevel3SampleWithNewLine ! !!MicTextualMicrodownExporterTest methodsFor: 'tests-anchor'!testQuote	self verifyObtain: factory quoteSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests-anchor'!testRawFormat	self verifyObtain: factory rawFormatSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests-anchor'!testRoot	self verifyObtain: factory rootSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests'!testSimpleTable	self verifyObtain: factory simpleTable! !!MicTextualMicrodownExporterTest methodsFor: 'tests'!testSimpleTableWithFormatting	self verifyObtain: factory simpleTableFormat! !!MicTextualMicrodownExporterTest methodsFor: 'tests'!testSimpleTableWithFormattingWithShortRow	self verifyObtain: factory simpleTableShortRow! !!MicTextualMicrodownExporterTest methodsFor: 'tests'!testSimpleTableWithFormattingWithSomeElements	self verifyObtain: factory simpleTableMoreFormat! !!MicTextualMicrodownExporterTest methodsFor: 'tests - list'!testUnorderedList	self verifyObtain: factory unorderedListWithTwoItemsSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests - list'!testUnorderedListNestedNewLine	| mic |	mic := parser parse: '- item 1  - item 1.1  - item 1.2- item 2'.	self assert: (mic accept: visitor) contents equals: '- item 1  - item 1.1  - item 1.2- item 2'! !!MicTextualMicrodownExporterTest methodsFor: 'tests - list'!testUnorderedListNestedWithOrderedNewLine	| mic |	mic := parser parse: '- item 1  1. item 1.1  1. item 1.2- item 2'.	self assert: (mic accept: visitor) contents equals: '- item 1  1. item 1.1  1. item 1.2- item 2'! !!MicTextualMicrodownExporterTest methodsFor: 'tests - list'!testUnorderedListNewLine	| mic |	mic := parser parse: '- item1- item2'.	self assert: (mic accept: visitor) contents equals: '- item1- item2'! !!MicTextualMicrodownExporterTest methodsFor: 'tests - list'!testUnorderedListWithBold	self verifyObtain: factory unorderedListWithTwoItemsBoldSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests - list'!testUnorderedListWithItalic	self verifyObtain: factory unorderedListWithTwoItemsItalicSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests - list'!testUnorderedListWithMonospace	self verifyObtain: factory unorderedListWithTwoItemsMonospaceSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests - list'!testUnorderedListWithNested	self verifyObtain: factory unorderedListWithTwoItemsNestedSample! !!MicTextualMicrodownExporterTest methodsFor: 'tests - list'!testUnorderedListWithStrike	self verifyObtain: factory unorderedListWithTwoItemsStrikeSample! !!MicTextualMicrodownExporterTest methodsFor: 'utilities'!verifyObtain: aString	| micElement |	micElement := parser parse: aString.	self assert: (visitor visit: micElement) equals: aString! !!MicTextualMicrodownExporterTest methodsFor: 'accessing'!visitor	^ visitor! !!MicTextualMicrodownExporterTest methodsFor: 'accessing'!visitor: anObject	visitor := anObject! !!MicTextualMicrodownExporterTest methodsFor: 'accessing'!visitorClass	^ visitorClass! !!MicTextualMicrodownExporterTest methodsFor: 'accessing'!visitorClass: anObject	visitorClass := anObject! !"Microdown-PrettyPrinter-Tests"!!MustacheParser commentStamp: '<historical>' prior: 0!A MustacheParser is the internally used parser that is used my MustacheTemplate to compile a template string into a template structure!!MustachePart commentStamp: '<historical>' prior: 0!A MustachePart is the base class for all entities that are parsed from a template string. The structure is held internally by MustacheTemplate to render a string from a template.For public access have a look at MustacheTemplate!!MustacheTemplate commentStamp: '<historical>' prior: 0!A MustacheTemplate is the main class to interact when dealing with mustache templates.A MustacheTemplate can be created from a string containing mustache template markup either withMustacheTemplate on: aStringoraString asMustacheTemplate To fill out a template just provide a context object and doaMustacheTemplate value: aContextObject Nested templates can be used be providing a dictionary with keys as the names used in the master template and values being individual mustache templates!!MustacheWriteVisitor commentStamp: '<historical>' prior: 0!A MustacheWriteVisitor is the main visitor produces a final string from a template and a context object. It is used by MustacheTemplate!!AbstractFileReference methodsFor: '*mustache-core' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!asMustacheTemplate	^ MustacheTemplate on: self readStream contents asString! !!AbstractFileReference methodsFor: '*mustache-core' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!mustacheTemplateDuring: aBlock	^ self		readStreamDo: [ :input | | input2 |			"The following are here because of case #12259: 'FileSystem memory reads/writes using a binary stream by default'."			input2 := input.			(self fileSystem store isKindOf: MemoryStore)				ifTrue: [ input2 := input2 contents asString readStream ].			aBlock value: (MustacheTemplate on: input2) ]! !!False methodsFor: '*mustache-core' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!mustacheDo: aBlock inverted: aBoolean	aBoolean ifTrue:  [ aBlock value: nil ]! !!UndefinedObject methodsFor: '*mustache-core' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!mustacheDo: aBlock inverted: aBoolean 	aBoolean mustacheDo: aBlock! !!HashedCollection methodsFor: '*mustache-core' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!mustacheDo: aBlock	aBlock value: self! !!HashedCollection methodsFor: '*mustache-core' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!mustacheDo: aBlock inverted: aBoolean	aBoolean ifFalse: [ aBlock cull: self ]! !!True methodsFor: '*mustache-core' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!mustacheDo: aBlock inverted: aBoolean	aBoolean ifFalse:  [ aBlock value: nil ]! !!MustacheParser class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!on: aStringOrStream 	^ self new		stream: aStringOrStream readStream ! !!MustacheParser methodsFor: 'accessing' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!addPart: aMustachePart	stack top addPart: aMustachePart	! !!MustacheParser methodsFor: 'accessing' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!buildDelimiterExtensions	^ Dictionary new		at: $# put: [ self startSection: MustacheSection ];		at: $/ put: [ self endSection ];		at: ${ put: [ self readDefaultUnescapedToken ];		at: $& put: [ self readUnescapedToken  ];		at: $!! put: [ self readComment ];		at: $^ put: [ self startSection: MustacheInvertedSection ];		at: $= put: [ self readChangeDelimiter ];		at: $> put: [ self readPartial ];		yourself! !!MustacheParser methodsFor: 'generating' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!compile	|  sequenceStart |	sequenceStart := [ 		self readStringChunk.		[ self readTag. sequenceStart ] ].	self readUpToEndUsing: sequenceStart ! !!MustacheParser methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!compileTemplate: aTemplate	self push: aTemplate.	self compile! !!MustacheParser methodsFor: 'reading' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!consumeWhiteSpace	[ stream atEnd not and: [ stream peek isSeparator ] ] whileTrue: [ 		stream next ]! !!MustacheParser methodsFor: 'accessing' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!defaultEndDelimiter	^ '}}'! !!MustacheParser methodsFor: 'accessing' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!defaultStartDelimiter	^ '{{'! !!MustacheParser methodsFor: 'accessing' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!delimiterExtensions	^ delimiterExtensions ifNil: [ 		delimiterExtensions := self buildDelimiterExtensions ]! !!MustacheParser methodsFor: 'accessing' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!endDelimiter	^ endDelimiter ifNil: [ 		endDelimiter := self defaultEndDelimiter  ]! !!MustacheParser methodsFor: 'accessing' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!endDelimiter: aString	endDelimiter := aString! !!MustacheParser methodsFor: 'reading' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!endSection	| token |	token := self readToken.	(stack top selector = token) ifFalse: [ 		Error signal: 'end section does not match ', stack top selector asString ].	stack pop! !!MustacheParser methodsFor: 'initialize-release' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!initialize 	super initialize.	stack := Stack new! !!MustacheParser methodsFor: 'testing' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!isDelimiterExtension: aCharacter	^ self delimiterExtensions keys includes: aCharacter! !!MustacheParser methodsFor: 'accessing' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!push: aTemplate 	stack push: aTemplate ! !!MustacheParser methodsFor: 'reading' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!readChangeDelimiter	self startDelimiter: (String streamContents: [ :s| 		[ stream peek isSeparator ] whileFalse: [ 			s nextPut: stream next ]]).	self consumeWhiteSpace.	self endDelimiter: (stream upToAll: self endDelimiter) allButLast! !!MustacheParser methodsFor: 'reading' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!readComment	"just read and forget"	self readToken! !!MustacheParser methodsFor: 'reading' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!readDefaultTag	self readHtmlEscapedToken! !!MustacheParser methodsFor: 'reading' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!readDefaultUnescapedToken	self readUnescapedToken.	(stream next = $}) ifFalse: [ 		Error signal: $} asString, ' character expected' ].! !!MustacheParser methodsFor: 'reading' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!readExtendedTag	 ^ (self delimiterExtensions at: stream next) value! !!MustacheParser methodsFor: 'reading' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!readHtmlEscapedToken	self addPart: (MustacheHtmlEscapedToken token: self readToken)! !!MustacheParser methodsFor: 'reading' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!readPartial	self addPart: (MustachePartial name: self readToken)! !!MustacheParser methodsFor: 'reading' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!readStringChunk	(stream upToAll: self startDelimiter) ifNotNil: [:chunk|		self addPart: (MustacheStringChunk string: chunk) ].! !!MustacheParser methodsFor: 'reading' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!readTag	(self isDelimiterExtension: stream peek)		ifTrue: [  self readExtendedTag  ]		ifFalse: [  self readDefaultTag  ]! !!MustacheParser methodsFor: 'reading' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!readToken	^ (stream upToAll: self endDelimiter) trimBoth! !!MustacheParser methodsFor: 'reading' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!readUnescapedToken	self addPart: (MustacheToken token: self readToken)! !!MustacheParser methodsFor: 'reading' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!readUpToEndUsing: aBlock	| nextRead |	nextRead := aBlock.	[ stream atEnd ] whileFalse: [  		 nextRead := nextRead value ]! !!MustacheParser methodsFor: 'accessing' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!startDelimiter	^ startDelimiter ifNil: [		startDelimiter := self defaultStartDelimiter ]! !!MustacheParser methodsFor: 'accessing' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!startDelimiter: aString	startDelimiter := aString! !!MustacheParser methodsFor: 'reading' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!startSection: aSectionClass	| section |	section := aSectionClass selector: self readToken.	self addPart: section. 	stack push: section	! !!MustacheParser methodsFor: 'accessing' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!stream: aStream 	stream := aStream! !!MustacheCompositePart methodsFor: 'adding' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!addPart: aMustachePart	parts add: aMustachePart ! !!MustacheCompositePart methodsFor: 'initialize-release' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!initialize 	super initialize.	parts := OrderedCollection new.! !!MustacheCompositePart methodsFor: 'accessing' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!parts	^ parts! !!MustacheInvertedSection methodsFor: 'testing' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!isInverted	^ true! !!MustacheSection class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!selector: aString 	^ self new		selector: aString! !!MustacheSection methodsFor: 'visiting' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!accept: aVisitor 	aVisitor visitSection: self! !!MustacheSection methodsFor: 'testing' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!isInverted	^ false! !!MustacheSection methodsFor: 'accessing' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!lookupInContext: anObject	^ self lookup: selector inContext: anObject! !!MustacheSection methodsFor: 'resolving' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!mustacheDo: aBlock inContext: aContext 	aContext mustacheDo: aBlock inverted: self isInverted! !!MustacheSection methodsFor: 'accessing' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!selector	^ selector! !!MustacheSection methodsFor: 'accessing' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!selector: aString 	selector := aString! !!MustacheSection methodsFor: 'accessing' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!valueInContext: anObject	^ self lookupInContext: anObject! !!MustacheTemplate class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!on: aStringOrStream 	^ self new		compile: aStringOrStream readStream;		yourself! !!MustacheTemplate methodsFor: 'visiting' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!accept: aVisitor 	aVisitor visitTemplate: self! !!MustacheTemplate methodsFor: 'resolving' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!compile: aStream 	(self parserClass on: aStream)		compileTemplate: self			! !!MustacheTemplate methodsFor: 'accessing' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!parserClass	^ MustacheParser ! !!MustacheTemplate methodsFor: 'resolving' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!value: anObject 	| visitor |	visitor := MustacheWriteVisitor new		context: anObject.	self accept: visitor.	^ visitor string! !!MustacheTemplate methodsFor: 'resolving' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!value: anObject partials: aDictionary	| visitor |	visitor := MustacheWriteVisitor new		partials: aDictionary;		context: anObject.	self accept: visitor.	^ visitor string! !!MustachePart methodsFor: 'resolving' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!lookup: aToken inContext: anObject	^ anObject mustacheLookup: aToken! !!MustachePartial class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!name: aString 	^ self new		name: aString! !!MustachePartial methodsFor: 'visiting' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!accept: aVisitor 	aVisitor visitPartial: self ! !!MustachePartial methodsFor: 'accessing' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!name	^ name! !!MustachePartial methodsFor: 'accessing' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!name: aString 	name := aString! !!MustacheStringChunk class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!string: aString 	^ self new		string: aString! !!MustacheStringChunk methodsFor: 'visiting' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!accept: aVisitor 	aVisitor visitStringChunk: self! !!MustacheStringChunk methodsFor: 'accessing' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!string	^ string! !!MustacheStringChunk methodsFor: 'accessing' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!string: aString 	string := aString! !!MustacheHtmlEscapedToken methodsFor: 'visiting' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!accept: aVisitor 	aVisitor visitHtmlEscapedToken: self ! !!MustacheHtmlEscapedToken methodsFor: 'resolving' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!valueInContext: anObject	^ (super valueInContext: anObject) asHTMLString ! !!MustacheToken class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!token: aString 	^ self new		token: aString! !!MustacheToken methodsFor: 'visting' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!accept: aVisitor 	aVisitor visitToken: self! !!MustacheToken methodsFor: 'resolving' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!lookupInContext: anObject	^ self lookup: token inContext: anObject! !!MustacheToken methodsFor: 'accessing' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!token: aString 	token := aString! !!MustacheToken methodsFor: 'resolving' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!valueInContext: anObject	"lookup to token, perfrom value on it in case we have a block and 	finally convert it to string"	^ (self lookupInContext: anObject) 		ifNotNil: [ :object | object value asString ]		ifNil: [ '' ]! !!MustacheVisitor methodsFor: 'accessing' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!partialAt: aString 	| template |	partials ifNil: [ Error signal: 'template has no partials' ].	template := partials at: aString.	template isString ifTrue: [ 		template := MustacheTemplate on: template.		partials at: aString put: template ].	^ template! !!MustacheVisitor methodsFor: 'accessing' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!partials: aDictionary	partials := aDictionary! !!MustacheVisitor methodsFor: 'visiting' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!visit: aMustachePart	aMustachePart accept: self! !!MustacheVisitor methodsFor: 'visiting' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!visitAll: aCollection 	aCollection do: [ :each |		self visit: each ]! !!MustacheVisitor methodsFor: 'visiting' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!visitCompositePart: aCompositePart	self visitAll: aCompositePart parts! !!MustacheVisitor methodsFor: 'visiting' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!visitHtmlEscapedToken: aMustacheHTMLEscapedToken 	! !!MustacheVisitor methodsFor: 'visiting' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!visitPartial: aMustachePartial 	self visit: (self partialAt: aMustachePartial name)! !!MustacheVisitor methodsFor: 'visiting' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!visitSection: aMustacheSection 	self visitCompositePart: aMustacheSection ! !!MustacheVisitor methodsFor: 'visiting' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!visitStringChunk: aMustacheStringChunk 	! !!MustacheVisitor methodsFor: 'visiting' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!visitTemplate: aMustacheTemplate 	self visitCompositePart: aMustacheTemplate ! !!MustacheVisitor methodsFor: 'visiting' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!visitToken: aMustacheToken	self visitHtmlEscapedToken: aMustacheToken  	! !!MustacheWriteVisitor methodsFor: 'accessing' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!addString: aString	aString ifNotEmpty: [ 		strings add: aString ]! !!MustacheWriteVisitor methodsFor: 'accessing' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!context: anObject	context := anObject! !!MustacheWriteVisitor methodsFor: 'initialize-release' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!initialize 	super initialize.	strings := OrderedCollection new: 50.! !!MustacheWriteVisitor methodsFor: 'rendering' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!renderSection: aSection withBlock: aBlock	"generate a render continuation block and hand it over to block	in the template. Return value will be a string that add as a whole	to the local string stack"	self addString: (aBlock value: [ 		self class new 			context: context;			visitCompositePart: aSection;			string ]) ! !!MustacheWriteVisitor methodsFor: 'rendering' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!renderSection: aSection withObject: anObject	aSection 		mustacheDo: [:item|			"if we are in collection context the lookup context			is shifted to the actual element of the collection"			item notNil ifTrue: [  context := item ].			self visitCompositePart: aSection ]		inContext: anObject! !!MustacheWriteVisitor methodsFor: 'accessing' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!string	^ strings		ifNotEmpty: [   			String 				new: ( strings sum: #size ) 				streamContents: [ :stream|					strings do: [ :string| 					stream nextPutAll: string ] ] ]		ifEmpty: [ '' ]! !!MustacheWriteVisitor methodsFor: 'visiting' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!visitHtmlEscapedToken: aToken	self addString: (aToken valueInContext: context)! !!MustacheWriteVisitor methodsFor: 'visiting' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!visitSection: aSection 	 | oldContext value |	oldContext := context.	value := aSection valueInContext: context.	[ value isClosure 		ifTrue: [ self renderSection: aSection withBlock: value ]		ifFalse: [ self renderSection: aSection withObject: value ]]			ensure: [ context := oldContext ]! !!MustacheWriteVisitor methodsFor: 'visiting' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!visitStringChunk: aStringChunk	self addString: aStringChunk string! !!Object methodsFor: '*mustache-core' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!mustacheDefaultWhenLookupFails	^ nil! !!Object methodsFor: '*mustache-core' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!mustacheDo: aBlock	self mustacheDo: aBlock inverted: false! !!Object methodsFor: '*mustache-core' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!mustacheDo: aBlock inverted: aBoolean	aBoolean ifFalse:  [ aBlock cull: self ]! !!Object methodsFor: '*mustache-core' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!mustacheLookup: aString	(aString = '.') ifTrue: [ ^ self ].	^ (self respondsTo: aString asSymbol) 		ifTrue: [ self perform: aString asSymbol ]		ifFalse: [  self mustacheLookupComplex: aString ]! !!Object methodsFor: '*mustache-core' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!mustacheLookupComplex: aString	| stream firstPart |	stream := aString readStream.	firstPart := stream upTo: $. .	^ stream atEnd		ifTrue: [ self mustacheDefaultWhenLookupFails ]		ifFalse: [ (self mustacheLookup: firstPart) mustacheLookup: stream upToEnd ]! !!String methodsFor: '*mustache-core' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!asMustacheTemplate	^ MustacheTemplate on: self ! !!String methodsFor: '*mustache-core' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!mustacheDo: aBlock	"as strings are collections we need to prevent it from iterating	over all of the characters. Invoke the block with self instead"	aBlock value: self ! !!Collection methodsFor: '*mustache-core' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!mustacheDo: aBlock	self do: aBlock! !!Collection methodsFor: '*mustache-core' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!mustacheDo: aBlock inverted: aBoolean	aBoolean		ifTrue: [ self notEmpty mustacheDo: aBlock inverted: aBoolean ]		ifFalse: [ self mustacheDo: aBlock ]! !!Dictionary methodsFor: '*mustache-core' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!mustacheLookup: aString	(aString = '.') ifTrue: [ ^ self ].	^ self at: aString ifAbsent: [ self mustacheLookupComplex: aString ]! !"Mustache-Core"!!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testBlockSection	| template result |	template := MustacheTemplate on: '{{#wrapped}} {{name}} is awesome {{/wrapped}}'.	result := template value: { 		'name' -> 'Willy'.		'wrapped' -> [ :render | '<b>',  render value, '</b>' ]  } asDictionary  .	self assert: result = '<b> Willy is awesome </b>'.	! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testBlockValue	| template result |	template := MustacheTemplate on: 'This is a test for {{ name }}.'.	result := template value: { 'name' -> [ 'blockcontent' ] } asDictionary .	self assert: result = 'This is a test for blockcontent.'.	! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testChangeDelimiter	| template result |	template := MustacheTemplate on: 'This is a test for {{ name }} {{=<% %>=}} and something that uses <% delimiter %> delimiter. And change it back to <%={{ }}=%>{{back}}.'.	result := template value: { 		'name' -> 'simpletoken' . 		'delimiter' -> 'another' . 		'back' -> 'normal' } asDictionary .	self assert: result = 'This is a test for simpletoken  and something that uses another delimiter. And change it back to normal.'. ! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testComment	| template result |	template := MustacheTemplate on: 'This is a test for {{!! ignore me }}.'.	result := template value: { 'name' -> 'simpletoken' } asDictionary .	self assert: result = 'This is a test for .' 	! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testContextDo	| called block |	called := 0.	block := [ :el |called := called + 1 ].		false mustacheDo:  block inverted: false.	self assert: called = 0.		called := 0.	true mustacheDo:  block inverted: false.	self assert: called = 1.		called := 0.	nil mustacheDo:  block inverted: false.	self assert: called = 0.		called := 0.	Object new mustacheDo:  block inverted: false.	self assert: called = 1.		called := 0.	#() mustacheDo:  block inverted: false.	self assert: called = 0.		called := 0.	#(1 2 3) mustacheDo:  block inverted: false.	self assert: called = 3.! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testContextDoInverted	| called block |	called := 0.	block := [ :el |called := called + 1 ].		false mustacheDo:  block inverted: true.	self assert: called = 1.		called := 0.	true mustacheDo:  block inverted: true.	self assert: called = 0.		called := 0.	nil mustacheDo:  block inverted: true.	self assert: called = 1.		called := 0.	Object new mustacheDo:  block inverted: true.	self assert: called = 0.		called := 0.	#() mustacheDo:  block inverted: true.	self assert: called = 1.		called := 0.	#(1 2 3) mustacheDo:  block inverted: true.	self assert: called = 0.! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testDefaultUnescapedToken	| template result |	template := MustacheTemplate on: 'This is a test for {{{ name }}}.'.	result := template value: { 'name' -> '&' } asDictionary .	self assert: result = 'This is a test for &.'.	! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testDictionaryInDictionary	| template result |	template := MustacheTemplate on: '{{#person?}} Hi {{name}}!! {{/person?}}' .	result := template 		value: { 'person?' -> 			{ 'name' -> 'Jon' } asDictionary  } asDictionary.	self assert: result = ' Hi Jon!! ' ! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testDotToken	| template result |	template := MustacheTemplate on: '{{ . }}'.	result := template value: #a.	self assert: result = 'a' ! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testDotTokenWithDictionary	| template result |	template := MustacheTemplate on: '{{ . }}'.	result := template value: {		'foo' -> 'bar' } asDictionary.	self assert: result = 'a Dictionary(''foo''-&gt;''bar'' )' ! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testHTMLEscapedToken	| template result |	template := MustacheTemplate on: 'This is a test for {{ name }}.'.	result := template value: { 'name' -> '&' } asDictionary .	self assert: result = 'This is a test for &amp;.'.	! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testHTMLMenuExample	| template result |	template := MustacheTemplate on: '<ul>	{{#entries}}<li class="menuEntry{{#active}} active{{/active}}">{{label}}</li>	{{/entries}}</ul>' .	result := template 		value: { 'entries' -> {   			{ 'label' -> 'first' } asDictionary. 			{ 'label' -> 'second' . 'active' -> true } asDictionary.			{ 'label' -> 'third' } asDictionary } } asDictionary.	self assert: result = '<ul>	<li class="menuEntry">first</li>	<li class="menuEntry active">second</li>	<li class="menuEntry">third</li>	</ul>' ! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testInvertedSectionWithEmptyListContext	| template result |	template := MustacheTemplate on: 'list{{^ list }} is {{/ list}}displayed'.	result := template value: { 		'list' -> { }	} asDictionary.	self assert: result = 'list is displayed' ! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testInvertedSectionWithFalseContext	| template result |	template := MustacheTemplate on: 'list{{^ list }} is {{/ list}}displayed'.	result := template value: { 		'list' -> false	} asDictionary.	self assert: result = 'list is displayed' ! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testInvertedSectionWithNonEmptyListContext	| template result |	template := MustacheTemplate on: 'list{{^ list }} is {{/ list}}displayed'.	result := template value: { 		'list' -> { 1 }	} asDictionary.	self assert: result = 'listdisplayed' ! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testInvertedSectionWithTrueContext	| template result |	template := MustacheTemplate on: 'list{{^ list }} is {{/ list}}displayed'.	result := template value: { 		'list' -> false	} asDictionary.	self assert: result = 'list is displayed' ! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testMultipleTokens	| template result |	template := MustacheTemplate on: '1 = {{ one }}, 2 = {{ two }}, and so on'.	result := template value: { 'one' -> 1 . 'two' -> 2 } asDictionary .	self assert: result = '1 = 1, 2 = 2, and so on' 	! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testObject	| template result |	template := MustacheTemplate on: '{{#stream}}Class: {{class}}, Position: {{position}}, Next: {{next}}, Position: {{position}}{{/stream}}' .	result := template 		value: { 'stream' -> 'Hello' readStream } asDictionary.	self assert: result = 'Class: ReadStream, Position: 0, Next: H, Position: 1' ! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testObjectNoSection	| template result |	template := MustacheTemplate on: 'Class: {{stream.class}}, Position: {{stream.position}}, Next: {{stream.next}}, Position: {{stream.position}}' .	result := template 		value: { 'stream' -> 'Hello' readStream } asDictionary.	self assert: result = 'Class: ReadStream, Position: 0, Next: H, Position: 1' ! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testObjectNoSectionBreakingDemeterLaw	| template result |	template := MustacheTemplate on: '{{stream.class.name.first.lowercase}}' .	result := template 		value: { 'stream' -> 'Hello' readStream } asDictionary.	self assert: result = 'r' ! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testPartialAsString	| template result |	template := 'This is a test for {{> partial }} .' asMustacheTemplate.	result := template 		value: { 'name' -> 'partial template' } asDictionary		partials: { 'partial' ->  '{{name}} rendering' } asDictionary.	self assert: result = 'This is a test for partial template rendering .'! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testPartialListContext	| template result |	template := MustacheTemplate on: 'We can have a lists ({{# list}} [ {{> partial }} ] {{/ list}}) .'.	result := template 		value: { 'list' -> {			{ 'name' -> 'first list' } asDictionary.			{ 'name' -> 'last list' } asDictionary  } } asDictionary		partials: (Dictionary new			at: 'partial' put: (MustacheTemplate on: 'including {{name}} item');			yourself) .	self assert: result = 'We can have a lists ( [ including first list item ]  [ including last list item ] ) .' ! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testPartialObjectContext	| template result |	template := MustacheTemplate on: 'This is a test for {{> partial }} .'.	result := template 		value: { 'name' -> 'partial template' } asDictionary		partials: (Dictionary new			at: 'partial' put: (MustacheTemplate on: '{{name}} rendering');			yourself) .	self assert: result = 'This is a test for partial template rendering .'! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testSectionWithDotAsTokenListValue	| template result |	template := MustacheTemplate on: '{{# list }}<{{ . }}>{{/ list}}'.	result := template value: { 		'list' -> #( a b c )	} asDictionary.	self assert: result = '<a><b><c>' ! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testSectionWithDotAsTokenStringValue	| template result |	template := MustacheTemplate on: '{{# list }}<{{ . }}>{{/ list}}'.	result := template value: { 		'list' -> 'abc'	} asDictionary.	self assert: result = '<abc>' ! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testSectionWithEmptyListContext	| template result |	template := MustacheTemplate on: 'list {{# list }}{{  label }} {{/ list}}trailer'.	result := template value: { 		'list' -> {  		}} asDictionary.	self assert: result = 'list trailer' ! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testSectionWithFalseContext	| template result |	template := MustacheTemplate on: 'list{{# list }} is {{/ list}}displayed'.	result := template value: { 		'list' -> false	} asDictionary.	self assert: result = 'listdisplayed' ! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testSectionWithNonEmptyListContext	| template result |	template := MustacheTemplate on: 'list {{# list }}{{  label }} {{/ list}}trailer'.	result := template value: { 		'list' -> {  			{ 'label' -> 'has 2' } asDictionary.			{ 'label' -> 'elements'} asDictionary 		}} asDictionary.	self assert: result = 'list has 2 elements trailer' ! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testSectionWithStringContextUsingDot	| template result |	template := MustacheTemplate on: '{{#list}}before {{.}} after{{/list}}'.	result := template value: { 		'list' -> 'list'	} asDictionary.	self assert: result = 'before list after' ! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testSectionWithTrueContext	| template result |	template := MustacheTemplate on: 'list{{# list }} is {{/ list}}displayed'.	result := template value: { 		'list' -> true	} asDictionary.	self assert: result = 'list is displayed' ! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testSetDelimiter	| template result |	template := MustacheTemplate on: '* {{default_tags}} {{=<% %>=}} * <%erb_style_tags%> <%={{ }}=%> * {{default_tags_again}} *'.	result := template value: (Array with: 'default_tags' -> '1' with: 'erb_style_tags' -> '2' with: 'default_tags_again' -> '3') asDictionary .	self assert: result = '* 1  * 2  * 3 *'.! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testSingleToken	| template result |	template := MustacheTemplate on: 'This is a test for {{ name }}.'.	result := template value: { 'name' -> 'simpletoken' } asDictionary .	self assert: result = 'This is a test for simpletoken.' 	! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testSingleTokenBegin	| template result |	template := MustacheTemplate on: '{{ name }} test it is.'.	result := template value: { 'name' -> 'simpletoken' } asDictionary .	self assert: result = 'simpletoken test it is.' 	! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testSingleTokenEnd	| template result |	template := MustacheTemplate on: 'test for {{ name }}'.	result := template value: { 'name' -> 'simpletoken' } asDictionary .	self assert: result = 'test for simpletoken' 	! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testSingleTokenNoneExisting	| template result |	template := MustacheTemplate on: 'This is a test for {{ name }}.'.	result := template value: { 'noname' -> 'simpletoken' } asDictionary .	self assert: result = 'This is a test for .' 	! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testSingleTokenUndefinedValue	| template result |	template := MustacheTemplate on: 'This is a test for {{ name }}.'.	result := template value: { 'name' -> nil } asDictionary .	self assert: result = 'This is a test for .' 	! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testTemplateFromFile	| file template result |	file := FileSystem memory root / 'file'.	file writeStreamDo: [ :stream | stream nextPutAll: '12{{i}}4' ].	template := file asMustacheTemplate.	result := template value: { 'i' -> '3' } asDictionary .	self assert: result asString equals: '1234' ! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testTemplateFromFileWithBlock	| file result |	file := FileSystem memory root / 'file'.	file writeStreamDo: [ :stream | stream nextPutAll: '12{{i}}4' ].	file mustacheTemplateDuring: [ :template | result := template value: {('i' -> '3')} asDictionary ].	self assert: result asString equals: '1234'! !!MustacheTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/20/2017 13:46:49'!testUnescapedToken	| template result |	template := MustacheTemplate on: 'This is a test for {{& name }}.'.	result := template value: { 'name' -> '&' } asDictionary .	self assert: result = 'This is a test for &.'.	! !"Mustache-Tests"!!PP2AbstractStrategy commentStamp: '' prior: 0!Base class for all PP2 strategies. See PP2Strategy for more details.!!PP2NilStrategy commentStamp: '' prior: 0!Null-object pattern for the PP2Strategy!!PP2Strategy commentStamp: '' prior: 0!Base class for all PP2 strategies. All PP2Strategy is 'strategy' design pattern. Each PP2Node has default parsing strategy, which specifies how the given node parses an input. During optimization, default strategies can be replaced with more specific (and hopefully faster) parsing strategies.!!PP2Action commentStamp: '' prior: 0!Default Strategy of PP2ActionNode.!!PP2Adaptable commentStamp: '' prior: 0!Default strategy for PP2AdaptableNode.!!PP2And commentStamp: '' prior: 0!Default strategy for PP2AndNode.!!PP2AndLiteralObject commentStamp: '' prior: 0!Optimization for 'PP2And -> PP2LiteralObject' combinator.!!PP2AndPredicateObject commentStamp: '' prior: 0!Optimization for 'PP2And -> PP2PredicateObject' combinator.!!PP2Choice commentStamp: '' prior: 0!Default strategy for PP2ChoiceNode.!!PP2CreateToken commentStamp: '' prior: 0!Default strategy for PP2TCreateToken.!!PP2Delegate commentStamp: '' prior: 0!Default strategy for PP2DelegateNode.!!PP2End commentStamp: '' prior: 0!Default strategy for PP2EndNode.!!PP2EndOfInput commentStamp: '' prior: 0!Default strategy for PP2EndOfInputNode.!!PP2EndOfLine commentStamp: '' prior: 0!Default strategy for PP2EndOfLineNode.!!PP2Epsilon commentStamp: '' prior: 0!Default strategy for PP2EpsilonNode.!!PP2Failing commentStamp: '' prior: 0!Default strategy for PP2FailingNode.!!PP2Flatten commentStamp: '' prior: 0!Default strategy for PP2FlattenNode.!!PP2LiteralObject commentStamp: '' prior: 0!Default strategy for PP2LiteralObjectNode.!!PP2LiteralSequence commentStamp: '' prior: 0!Default strategy for PP2LiteralSequenceNode.!!PP2Mapping commentStamp: '' prior: 0!Default strategy for PP2MappingNode.!!PP2NewLine commentStamp: '' prior: 0!Default strategy for PP2NewLineNode.!!PP2NonEpsilon commentStamp: '' prior: 0!Default strategy for PP2NonEpsilonNode.!!PP2Not commentStamp: '' prior: 0!Default strategy for PP2NotNode.!!PP2Optional commentStamp: '' prior: 0!Default strategy for PP2OptionalNode.!!PP2Pluggable commentStamp: '' prior: 0!Default strategy for PP2PluggableNode.!!PP2PossesiveRepeating commentStamp: '' prior: 0!Default strategy for PP2PossesiveRepeatingNode.!!PP2PredicateObject commentStamp: '' prior: 0!Default strategy for PP2PredicateObjectNode.!!PP2PredicateSequence commentStamp: '' prior: 0!Default strategy for PP2PredicateSequenceNode.!!PP2Sea commentStamp: '' prior: 0!Default strategy for PP2Sea.!!PP2Sequence commentStamp: '' prior: 0!Default strategy for PP2Sequence.!!PP2StartOfLine commentStamp: '' prior: 0!Default strategy for PP2StartOfLineNode.!!PP2Trimming commentStamp: '' prior: 0!Default strategy for PP2TrimmingNode.!!PP2Water commentStamp: '' prior: 0!Default strategy for PP2WaterNode.!!PP2Wrapping commentStamp: '' prior: 0!Default strategy for PP2WrappingNode.!!PP2WrappingStrategy commentStamp: '' prior: 0!Decorator pattern around another strategy.!!PP2Cache commentStamp: '' prior: 0!Remembers result of the underlying strategy for for the given position.In case the same strategy is invoked for the second time at the same position, the previous result is returned. This is very lightweight and fast cache.!!PP2RecordingDebuggingStrategy commentStamp: '' prior: 0!todo: Refactor to two strategies:- profiling- debugging!!PP2MemoizedSea commentStamp: '' prior: 0!Memoization cache for bounded seas.!!PP2Packrat commentStamp: '' prior: 0!Packrat cache. Remembers the result of parsing for every position (contrary to the PP2Cache, which remembers only one position). Can improve performance for heavily backtracking grammars, but lookup can be expensive.!!PP2ParsingGuard commentStamp: '' prior: 0!If the following input matches classification, returns result without invoking the underlying strategy.The result is typically PP2Failure. Guard is used to fail choices early, without invoking them.!!PP2TrimmingCache commentStamp: '' prior: 0!Similar to PP2Cache, remembers the result of the last trimming. Prevents repeated trimming in cases like:$a asPParser trim / $b asPParser trim parse: '    b   '!!PP2AsyncStream commentStamp: '' prior: 0!Implementation of stream filled by asynchronous input. Can be converted to PP2Stream by calling asPetit2Stream to be parsed by PetitParser2.For example, keyboard source can be used as an input to PetitParser2.!!PP2BufferStream commentStamp: '' prior: 0!Adapter from minimal stream implementation to the interface consumed by PP2Nodes.Given minimal stream interface with two methods:- atEnd- nextPP2BufferStream will provide extra functionality and buffering to ensure the minimal stream can be consumed by PP2Nodes.Note: Everyting in this stream is indexed from 0 and not from 1. Modulo arithmetics that works better when indexed from 0.!!PP2CcResult commentStamp: '' prior: 0!An abstract class representing a result of context change analysis.!!PP2CharSetPredicate commentStamp: '' prior: 0!Cache for character set. Pre-evaluates block for the first 255 characters and remembers its result.Serves as parsing optimization, if the next character in a stream does not match, the whole parser is going to fail. !!PP2Context commentStamp: '' prior: 0!PP2 Wrapper around stream. Contains additional state to used by PP2.!!PP2ContextMemento commentStamp: '' prior: 0!Remembers the state of the context.!!PP2Failure commentStamp: '' prior: 0!Represents a PP2 failure.!!PP2Memento commentStamp: '' prior: 0!Memento pattern used by bounded seas.!!PP2Node commentStamp: '' prior: 0!Base class for all the nodes of PP2. PP2 parsers are graphs consisting of PP2 nodes. Each PP2 node is a parser combinator that provides information about the combinator and refers to other nodes. Each parser combinator does one thing and delegates other work to other nodes. For example:   'a' asParser, 'b' asParseris a sequence node (which knows how to parse sequence), while 'a' and 'b' are represented by literal nodes (which know how to parse literals).Each PP2 node is visitable. Visitors are mainly used to implement optimizations and aditional analyses, but can be used for other purposes if needed. !!PP2AdaptableNode commentStamp: '' prior: 0!This node is refers to a subset of grammar that changes dynamically, during parsing. The node is used to tell PP2 optimizations that input parsed by this node can change at any time.!!PP2DelegateNode commentStamp: '' prior: 0!Matches if the underlying parsers, delegate, matches. Delegate is the only child.Instance Variables:	child		<PP2Node>	The parser to delegate to.!!PP2AbstractActionNode commentStamp: '' prior: 0!Abstract base class for action nodes.!!PP2ActionNode commentStamp: '' prior: 0!Performs an action block with the successful parse result of the delegate. Fails if the delegate fails.Instance Variables:	block	<BlockClosure>	The action block to be executed.Example:$a asPParser ==> [ :a | a uppercase ] parse: 'a'!!PP2MappingNode commentStamp: '' prior: 0!Performs an action block with the given number of arguments with the successful parse result of the delegate. The delegate must return result with the expected number of arguments.Example:($a asPParser, $b asPParser map: [ :a :b | Array with: a uppercase with: b uppercase ])  parse: 'ab'!!PP2WrappingNode commentStamp: '' prior: 0!Performs an action block upon activation with the stream and a continuation block.!!PP2AndNode commentStamp: '' prior: 0!The and-predicate, succeeds whenever its delegate does, but does not consume the input stream [Parr 1994, 1995].Example:$a asPParser and parse: 'a'!!PP2CompositeNode commentStamp: '' prior: 0!A PPCompositeParser is composed parser built from various primitive parsers. Every production in the receiver is specified as a method that returns its parser. Note that every production requires an instance variable of the same name, otherwise the production is not cached and cannot be used in recursive grammars. Productions should refer to each other by reading the respective inst-var. Note: these inst-vars are typically not written, as the assignment happens in the initialize method using reflection.The start production is defined in the method start. It is aliased to the inst-var parser defined in the superclass of PPCompositeParser.!!PP2HtmlHeaderGrammar commentStamp: '' prior: 0!Extracts HTML headers from an html file without downloading the whole file. Try with:PP2HtmlHeaderGrammar exampleThe example starts a  ZincClient in streaming mode and utilizes PP2 capabilities to work on streams. It reads the stream up until the end of a header or until start of a body.!!PP2CreateTokenNode commentStamp: '' prior: 0!Creates token out of successful parse. It delegates the creation of the token to the context to create the token.Example:$a asPParser token parse: 'a' !!PP2EndNode commentStamp: '' prior: 0!Succeeds if delegating parser consumed the whole input, fails otherwise.Examples:$a asPParser end parse: 'a'.$a asPParser end parse: 'ab'.!!PP2FlattenNode commentStamp: '' prior: 0!A parser that answers a flat copy of the range my delegate parses.Examples:$a asPParser star parse: 'aa'$a asPParser star flatten parse: 'aa'!!PP2NonEpsilonNode commentStamp: '' prior: 0!Matches only if the underlying parser consumes at least one character.Example:$a asPParser optional nonEpsilon parse: 'a'$a asPParser optional nonEpsilon parse: 'b'!!PP2NotNode commentStamp: '' prior: 0!The not-predicate, a parser that succeeds whenever its delegate does not, but consumes no input [Parr 1994, 1995].!!PP2OptionalNode commentStamp: '' prior: 0!Optionally parsers its delegate, or answers nil.Examples:$a asPParser optional parse: 'b'!!PP2RepeatingNode commentStamp: '' prior: 0!An abstract parser that repeatedly parses between 'min' and 'max' instances of its delegate. The default configuration parses an infinite number of elements, as 'min' is set to 0 and 'max' to infinity (SmallInteger maxVal).!!PP2PossesiveRepeatingNode commentStamp: '' prior: 0!The default repeating parser with standard PEG semantics (i.e. possessive, blind, eager).Examples:$a asPParser star parse: 'aaaa'"always fails, because star is greedy"($a asPParser star, $a asPParser) parse: 'aaa' Use #starLazy if you want a non-greedy parse:($a asPParser starLazy, ($a asPParser, #endOfInput asPParser)) parse: 'aaa'Note that #starLazy consumes as little as possible, contrary to your expectations:($a asPParser starLazy, $a asPParser) parse: 'aaa'!!PP2TrimmingNode commentStamp: '' prior: 0!Silently consumes spaces before and after the delegate parser.!!PP2EndOfInputNode commentStamp: '' prior: 0!Matches a virtual character that is at the end of input.Examples:#eoi asPParser parse: ''.#eoi asPParser parse: 'a'.!!PP2EndOfLineNode commentStamp: '' prior: 0!Matches end of a line.!!PP2EpsilonNode commentStamp: '' prior: 0!Matches empty string, always succeeds.#epsilon asPParser parse: ''!!PP2FailingNode commentStamp: '' prior: 0!Always fails.!!PP2ListNode commentStamp: '' prior: 0!Abstract base class for list nodes, nodes with multiple children.!!PP2ChoiceNode commentStamp: '' prior: 0!Returns a result of the first parser that succeeds, if none of the children succeeds, fails.Example:$a asPParser / $b asPParser parse: 'a'$a asPParser / $b asPParser parse: 'b'$a asPParser / $b asPParser parse: 'c'!!PP2SequenceNode commentStamp: '' prior: 0!Returns an array with all the results of all its children. All children must succeed, otherwise returns failure.Example:$a asPParser, $b asPParser parse: 'ab'$a asPParser, $b asPParser parse: 'ac'!!PP2LiteralNode commentStamp: '' prior: 0!Abstract literal parser that parses some kind of literal type (to be specified by subclasses).!!PP2LiteralObjectNode commentStamp: '' prior: 0!Matches single character.Example:$a asPParser parse: 'a'!!PP2LiteralSequenceNode commentStamp: '' prior: 0!Matches string.'hello' asPParser parse: 'hello'!!PP2NewLineNode commentStamp: '' prior: 0!Matches beginning of a line.Example:#newline asPParser parse: String cr.#newline asPParser parse: ''!!PP2PluggableNode commentStamp: '' prior: 0!Creates PP2 node from a block. The block has to follow the rules of parser combinators:- return result or PP2Failure- no side effects- return PP2Context to its original position in case of failureExample:[ :context | 	context peek = $a 	  ifTrue: [ 'CORRECT!!' ] 	  ifFalse: [ PP2Failure message: 'Not good' context: context ] ] asPParser parse: 'a'!!PP2PredicateNode commentStamp: '' prior: 0!Abstract base for predicate nodes.!!PP2PredicateObjectNode commentStamp: '' prior: 0!Matches if next character in input matches the given predicate.Examples:#letter asPParser!!PP2PredicateSequenceNode commentStamp: '' prior: 0!Matches if next 'size' characters in input satisfy the given predicate.!!PP2SeaNode commentStamp: '' prior: 0!Represents 'sea' element in bounded seas: imprecise and tolerant parsers. See http://kursjan.github.io/petitparser2/ for more information.See is an input that matches anything until island (the input of interest) followed by any input until the rest of an uninteresting input.!!PP2StartOfLineNode commentStamp: '' prior: 0!Matches start of a line, returns nil or PP2Failure in case of failure.Example:#startOfLine asPParser parse: ''!!PP2StartOfWordNode commentStamp: '' prior: 0!Matches start of word.!!PP2WaterNode commentStamp: '' prior: 0!Represents 'water' element in bounded seas: imprecise and tolerant parsers. See http://kursjan.github.io/petitparser2/ for more information.!!PP2NodeFactory commentStamp: '' prior: 0!Creates PP2 parsers from literals.Example:#letter asPParser.#hex asPParser!!PP2NodeVisitor commentStamp: '' prior: 0!Defines base interface for PP2Node visitors.!!PP2NoopVisitor commentStamp: '' prior: 0!Traverses all PP2Nodes, takes care about recursive sub-structures.!!PP2ContextChangesVisitor commentStamp: '' prior: 0!Gives an information if a given node does not change a context, pushes, pops, or does some other changes (e.g. push in a loop).- To override the behavior, set the #contextChanges  property.!!PP2IsNullableVisitor commentStamp: '' prior: 0!I return true, if parser ALWAYS accepts epsilon without a failure, i.e it cannot fail.		- I do not chache the result- I do allow to everride the behaviour by setting the #isNullable  property!!PP2TransformVisitor commentStamp: '' prior: 0!Rewriting visitor. Handles cycles.!!PP2Stream commentStamp: '' prior: 0!Basic stream used by PetitParser2. Any input passed to PP2Node>>parse is converted to PP2Stream or compatible interface (e.g. PP2BufferStream) calling asPetit2Stream.If PP2Stream is not suitable for your needs, consider using PP2BufferStream.!!PP2Token commentStamp: '' prior: 0!Represents a language token. Can be created by using #token message: #letter asPParser plus token parse: 'hi there'!!PP2UnknownCharSetPredicate commentStamp: '' prior: 0!Represents unknown set of characters. For example, start of line node does not consume any character and therefore char set optimization cannot be used to quickly fail the parsing. See PP2CharSetPredicate.!!PP2CharacterStream commentStamp: '' prior: 0!Adapter from stream of bytes (stream is the instance varaible) to stream of characters.  Encoder (instance variable) translates incoming bytes into characters. Can be used to convert Zinc byte streams:	byteStream := ZnClient new 		url: 'http://pharo.org';  		streaming: true;  		get.	stream := PP2CharacterStream on: byteStream encoder: ZnUTF8Encoder new.	Call #asPetit2Stream to convert to the interface accepted by PP2Node>>parse:!!ManifestPetitParser commentStamp: '' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!PP2InMemoryContext commentStamp: '' prior: 0!Optimized version of PP2Context. When input fits into the memory, PP2InMemoryContext can be used, providing slightly better perfomance.!!TPP2AnalysisCache methodsFor: 'hooks'!afterAccept: ctx result: result	ctx node propertyAt: self propertySymbol ifAbsentPut: result! !!TPP2AnalysisCache methodsFor: 'optimizations'!doPass: node	| children child |	self visit: node.	children := node allNodes.		[(child := children detect: [ :e | (e hasProperty: self propertySymbol) not ] 							ifNone: [ nil ]) notNil ] whileTrue: [ 				self visit: child	]! !!TPP2AnalysisCache methodsFor: 'accessing'!propertySymbol	self explicitRequirement! !!TPP2Context methodsFor: 'reparsing'!applyChange: change	change updateContext: self.	change updateTokens: self returnValue.	change updateParser: self parser! !!TPP2Context methodsFor: 'debugging'!currentDebugResult	^ self globalAt: #debugResult ifAbsentPut: [ PP2DebugResult new context: self; yourself ]! !!TPP2Context methodsFor: 'debugging'!currentDebugResult: anObject	self globalAt: #debugResult put: anObject ! !!TPP2Context methodsFor: 'debugging'!debugResult	^ self globalAt: #debugResult ifAbsentPut: [ 		self restore: self startMemento.		self parser enableDebug parseWithContext: self.		self currentDebugResult	]! !!TPP2Context methodsFor: 'context'!defaultStack	^ self stackNamed: #defaultStack! !!TPP2Context methodsFor: 'testing'!isRecording	^ false! !!TPP2Context methodsFor: 'accessing'!parsedValue	"to provide some compatibility with PPToken"	^ self returnValue! !!TPP2Context methodsFor: 'requirements'!position	self explicitRequirement! !!TPP2Context methodsFor: 'requirements'!returnValue	self explicitRequirement! !!TPP2Context methodsFor: 'requirements'!returnValue: anObject	self explicitRequirement! !!TPP2Context methodsFor: 'requirements'!setAsStartState	self startMemento: self remember! !!TPP2Context methodsFor: 'context'!stackNamed: identifier	^ self propertyAt: identifier ifAbsentPut: [ PP2Stack new ]! !!TPP2Context methodsFor: 'accessing'!start	^ self startMemento position! !!TPP2Context methodsFor: 'requirements'!startMemento	self explicitRequirement! !!TPP2Context methodsFor: 'requirements'!startMemento: contextMemento	self explicitRequirement! !!TPP2Context methodsFor: 'accessing'!stop	^ self position! !!TPP2Context methodsFor: 'seas'!waterPosition	^ self globalAt: #waterPosition ifAbsent: -1! !!TPP2Context methodsFor: 'seas'!waterPosition: anInteger	self globalAt: #waterPosition put: anInteger! !!TPP2Debuggable methodsFor: 'debugging'!debugResult	self explicitRequirement! !!TPP2Globals methodsFor: 'accessing - globals'!globalAt: aKey	"Answer the global property value associated with aKey."		^ self globalAt: aKey ifAbsent: [ self error: 'Property not found' ]! !!TPP2Globals methodsFor: 'accessing - globals'!globalAt: aKey ifAbsent: aBlock	"Answer the global property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		^ self globals isNil		ifTrue: [ aBlock value ]		ifFalse: [ self globals at: aKey ifAbsent: aBlock ]! !!TPP2Globals methodsFor: 'accessing - globals'!globalAt: aKey ifAbsentPut: aBlock	"Answer the global property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self globalAt: aKey ifAbsent: [ self globalAt: aKey put: aBlock value ]! !!TPP2Globals methodsFor: 'accessing - globals'!globalAt: aKey put: anObject	"Set the global property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (self globals ifNil: [ self globals: (IdentityDictionary new: 1) ])		at: aKey put: anObject! !!TPP2Globals methodsFor: 'accessing - globals'!globals	self explicitRequirement! !!TPP2Globals methodsFor: 'accessing - globals'!hasGlobal: aKey	"Test if the global property aKey is present."		^ self globals notNil and: [ self globals includesKey: aKey ]! !!TPP2Globals methodsFor: 'accessing - globals'!removeGlobal: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeGlobal: aKey ifAbsent: [ self error: 'Property not found' ]! !!TPP2Globals methodsFor: 'accessing - globals'!removeGlobal: aKey ifAbsent: aBlock	"Remove the global property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	self globals isNil ifTrue: [ ^ aBlock value ].	answer := self globals removeKey: aKey ifAbsent: aBlock.	self globals isEmpty ifTrue: [ self globals: nil ].	^ answer! !!TPP2NullProfiling methodsFor: 'profiling'!cacheHit: context! !!TPP2NullProfiling methodsFor: 'profiling'!invocation! !!TPP2Properties methodsFor: 'accessing - properties'!hasProperty: aKey	"Test if the property aKey is present."		^ self properties notNil and: [ self properties includesKey: aKey ]! !!TPP2Properties methodsFor: 'accessing - properties'!properties	self explicitRequirement! !!TPP2Properties methodsFor: 'accessing - properties'!properties: newProperties	self explicitRequirement! !!TPP2Properties methodsFor: 'accessing - properties'!propertiesCopy	self properties isNil ifTrue: [ ^ nil ].	^ self properties collect: #copy! !!TPP2Properties methodsFor: 'accessing - properties'!propertyAt: aKey	"Answer the property value associated with aKey."		^ self propertyAt: aKey ifAbsent: [ self error: 'Property not found' ]! !!TPP2Properties methodsFor: 'accessing - properties'!propertyAt: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		^ self properties isNil		ifTrue: [ aBlock value ]		ifFalse: [ self properties at: aKey ifAbsent: aBlock ]! !!TPP2Properties methodsFor: 'accessing - properties'!propertyAt: aKey ifAbsentPut: aBlock	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]! !!TPP2Properties methodsFor: 'accessing - properties'!propertyAt: aKey put: anObject	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (self properties ifNil: [ self properties: (IdentityDictionary new: 1) ])		at: aKey put: anObject! !!TPP2Properties methodsFor: 'accessing - properties'!removeProperty: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeProperty: aKey ifAbsent: [ self error: 'Property not found' ]! !!TPP2Properties methodsFor: 'accessing - properties'!removeProperty: aKey ifAbsent: aBlock	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	self properties isNil ifTrue: [ ^ aBlock value ].	answer := self properties removeKey: aKey ifAbsent: aBlock.	self properties isEmpty ifTrue: [ self properties: nil ].	^ answer! !!TPP2RecordingCache methodsFor: 'recording'!cacheHit: context	self hits: self hits + 1.	context cacheHit.! !!TPP2RecordingCache methodsFor: 'accessing - statistics'!hitRatio	^ self hits / (self invocations max: 1) asFloat! !!TPP2RecordingCache methodsFor: 'recording'!hits	self explicitRequirement! !!TPP2RecordingCache methodsFor: 'recording'!hits: anInteger	self explicitRequirement! !!TPP2RecordingCache methodsFor: 'initialization'!initialize	super initialize.	self resetCounters.! !!TPP2RecordingCache methodsFor: 'recording'!invocation	self invocations: self invocations + 1! !!TPP2RecordingCache methodsFor: 'recording'!invocations	self explicitRequirement! !!TPP2RecordingCache methodsFor: 'recording'!invocations: anInteger	self explicitRequirement! !!TPP2RecordingCache methodsFor: 'testing'!isRecording	^ true! !!TPP2RecordingCache methodsFor: 'conversion'!recording	^ self! !!TPP2RecordingCache methodsFor: 'recording'!resetCounters	self invocations: 0.	self hits: 0.! !!Object methodsFor: '*PetitParser2'!asArray	^ Array with: self! !!Object methodsFor: '*PetitParser2'!asMapArgument	"JK: Hack alert. OrderedCollection is returned from the repeating parsers.		Array is returned from the sequence parser.				As an argument into the mapping parser, ordered collection is transformed into an array		with that collection. Array is passed unmodified.	"	^ Array with: self! !!Object methodsFor: '*PetitParser2'!isPetit2Failure	^ false! !!Object methodsFor: '*PetitParser2'!isPetit2Parser	^ false! !!Object methodsFor: '*PetitParser2'!isPetit2Success	^ true! !!Object methodsFor: '*PetitParser2'!isToken	^ false! !!Object methodsFor: '*PetitParser2-Reparsing'!nodesDo: aBlock	"JK: this is kind of hack, I don't like having this method here"	"nothing to do"! !!PP2AbstractStrategy methodsFor: 'accessing'!allChildren	self shouldBeImplemented ! !!PP2AbstractStrategy methodsFor: 'conversion'!cache	^ PP2Cache on: self! !!PP2AbstractStrategy methodsFor: 'conversion'!debug	^ PP2DebuggingStrategy on: self! !!PP2AbstractStrategy methodsFor: 'analysis'!includesCache	^ self allChildren anySatisfy: [ :s | s isCache ]! !!PP2AbstractStrategy methodsFor: 'testing'!isCache	^ false! !!PP2AbstractStrategy methodsFor: 'testing'!isDebugging	^ false! !!PP2AbstractStrategy methodsFor: 'testing'!isMemoized	^ false! !!PP2AbstractStrategy methodsFor: 'testing'!isRecording	^ false! !!PP2AbstractStrategy methodsFor: 'conversion'!memoize	^ PP2Packrat on: self! !!PP2AbstractStrategy methodsFor: 'conversion'!parsingGuard: classification	^ (PP2ParsingGuard on: self)		classification: classification;		retval: (PP2Failure message: 'Early failure, no first set character found')		yourself! !!PP2AbstractStrategy methodsFor: 'conversion'!recognizer	^ self! !!PP2AbstractStrategy methodsFor: 'conversion'!recording	^ self! !!PP2AbstractStrategy methodsFor: 'conversion'!trimmingCache	^ PP2TrimmingCache on: self! !!PP2AbstractStrategy methodsFor: 'accessing'!withoutDebugStrategy	^ self! !!PP2NilStrategy methodsFor: 'accessing'!displayName	^ 'nil'! !!PP2NilStrategy methodsFor: 'accessing'!node	^ nil! !!PP2Action methodsFor: 'parsing'!parseOn: aPP2Context	| retval |	^ (retval := node child parseOn: aPP2Context) isPetit2Success		ifTrue: [ node block value: retval  ]		ifFalse: [ retval ]! !!PP2Adaptable methodsFor: 'parsing'!parseOn: context	^ node child parseOn: context! !!PP2And methodsFor: 'parsing'!parseOn: context	| memento retval |	memento := self remember: context.	retval := node child parseOn: context.	self restore: context from: memento. 		^ retval isPetit2Success 		ifTrue: [	retval ]		ifFalse: [ PP2Failure message: retval message context: context  ]! !!PP2AndLiteralObject methodsFor: 'initialization'!initializeFor: aNode	super initializeFor: aNode.	literal := aNode child literal! !!PP2AndLiteralObject methodsFor: 'parsing'!parseOn: context	^ (context peek == literal )		ifTrue: [ literal ] 		ifFalse: [ PP2Failure message: 'literal expected' context: context ]! !!PP2AndPredicateObject methodsFor: 'as yet unclassified'!initializeFor: aNode	super initializeFor: aNode.	predicate := aNode child predicate! !!PP2AndPredicateObject methodsFor: 'as yet unclassified'!parseOn: context	| peek |	peek := context peek.	^ (peek isNil not and: [ predicate value: peek ])		ifTrue: [ peek ] 		ifFalse: [ PP2Failure message: 'predicate expected' context: context ]! !!PP2Choice methodsFor: 'parsing'!parseOn: aPP2Context	| retval |		1 to: node children size do: [ :index |		(retval := (node childAt: index) parseOn: aPP2Context) isPetit2Success ifTrue: [ ^ retval ] 	].		^ retval! !!PP2CreateToken methodsFor: 'parsing'!parseOn: aPP2Context	| start retval |	start := aPP2Context position.	(retval := node child parseOn: aPP2Context) isPetit2Failure ifTrue: [ ^ retval ].	^ aPP2Context newToken: (node tokenClass) from: start! !!PP2Delegate methodsFor: 'parsing'!parseOn: aPP2Context	^ node child parseOn: aPP2Context! !!PP2End methodsFor: 'parsing'!parseOn: aPP2Context	| memento retval |	memento := aPP2Context remember.	retval := node child parseOn: aPP2Context.		^ (aPP2Context atEnd or: [ retval isPetit2Failure ]) ifTrue: [ 		retval 	] ifFalse: [		| failure | 		failure := PP2Failure message: 'end of input expected' context: aPP2Context. 		aPP2Context restore: memento. 		^ failure	]! !!PP2EndOfInput methodsFor: 'as yet unclassified'!initializeFor: aPP2Node	super initializeFor: aPP2Node.		failure := PP2Failure message: 'end of input expected'! !!PP2EndOfInput methodsFor: 'parsing'!parseOn: context	^ context atEnd ifTrue: [ nil ] ifFalse: [ failure context: context ]! !!PP2EndOfLine methodsFor: 'initialization'!initializeFor: aPP2Node	super initializeFor: aPP2Node.		failure := PP2Failure message: 'end of line expected'! !!PP2EndOfLine methodsFor: 'newline handling'!insideCRLF: context	(context position < 1) ifTrue: [ ^ false ].		^ (context peek = (Character codePoint: 10)) and: [ context peekBack = (Character codePoint: 13) ]! !!PP2EndOfLine methodsFor: 'newline handling'!isEndOfLine: context	context atEnd ifTrue: [ ^ true ].	(self insideCRLF: context) ifTrue: [ ^ false ].	^ (context peek = (Character codePoint: 13) or: [ context peek = (Character codePoint: 10)]).! !!PP2EndOfLine methodsFor: 'parsing'!parseOn: context	^ (self isEndOfLine: context) ifTrue: [ ^ nil ] ifFalse: [ failure context: context ]! !!PP2Epsilon methodsFor: 'parsing'!parseOn: aPP2Context	^ nil! !!PP2Failing methodsFor: 'parsing'!parseOn: aPP2Context	^ PP2Failure message: 'failure' context: aPP2Context! !!PP2Flatten methodsFor: 'parsing'!parseOn: aPP2Context	| retval start |	start := aPP2Context position.	^ (retval := node child parseOn: aPP2Context) isPetit2Success ifTrue: [ 		aPP2Context copyFrom: start + 1 to: aPP2Context position	] ifFalse: [ 		retval	]! !!PP2LiteralObject methodsFor: 'parsing'!initializeFor: aPP2Node	super initializeFor: aPP2Node! !!PP2LiteralObject methodsFor: 'parsing'!parseOn: aPP2Context	| literal |	literal := node literal.		^ (aPP2Context nextFor: literal)		ifTrue: [ literal ]		ifFalse: [ PP2Failure message: node message context: aPP2Context ]		! !!PP2LiteralSequence methodsFor: 'parsing'!parseOn: aPP2Context	| position |	position := aPP2Context rememberPosition.	(node literal = (aPP2Context next: node size)) ifTrue: [  		^ node literal	].	aPP2Context restorePosition: position.	^ PP2Failure message: 'literal not found' context: aPP2Context! !!PP2Mapping methodsFor: 'parsing'!parseOn: aPP2Context	| retval |	^ (retval := node child parseOn: aPP2Context) isPetit2Success		ifTrue: [ node block valueWithArguments: retval asMapArgument ]		ifFalse: [ retval ]! !!PP2MappingOfThree methodsFor: 'as yet unclassified'!parseOn: context	| retval |	^ (retval := node child parseOn: context) isPetit2Success		ifTrue: [ node block value: (retval at: 1) value: (retval at: 2) value: (retval at: 3)  ]		ifFalse: [ retval ]! !!PP2MappingOfTwo methodsFor: 'parsing'!parseOn: context	| retval |	^ (retval := node child parseOn: context) isPetit2Success		ifTrue: [ node block value: (retval at: 1) value: (retval at: 2)  ]		ifFalse: [ retval ]! !!PP2Match methodsFor: 'parsing'!parseOn: context	| retval stackTop memento stack |	memento := self remember: context.	retval := node child parseOn: context.	retval isPetit2Failure ifTrue: [ ^ retval ].	stack := context stackNamed: node stackId.		^ (stack isEmpty not and: [(stackTop :=  stack top) = retval]) ifTrue: [  		retval	] ifFalse: [ 		self restore: context from: memento.		PP2Failure message: ('context stack value: "', stackTop asString, 								   '" does not match ', retval asString)					  context: context	]! !!PP2NewLine methodsFor: 'initialization'!initializeFor: aPP2Node	super initializeFor: aPP2Node.	failure := PP2Failure message: 'new line expected'! !!PP2NewLine methodsFor: 'parsing'!parseOn: context	context atEnd ifTrue: [ ^ failure ].		(context uncheckedPeek == Character lf) ifTrue: [ 		context shift.		^ String lf	].	(context uncheckedPeek == Character cr) ifTrue: [  		context shift.		(context peek == Character lf) ifTrue: [ 			context shift.			^ String crlf.		].		^ String cr	].	^ failure! !!PP2NonEpsilon methodsFor: 'as yet unclassified'!parseOn: context	| start memento retval |	memento := self remember: context.	start := context position.	retval := node child parseOn: context.	(retval isPetit2Success and: [ context position = start ]) ifTrue: [ 		self restore: context from: memento.		^ PP2Failure message: 'epsilon parse not allowed' context: context	].	^ retval! !!PP2Not methodsFor: 'parsing'!parseOn: context	| memento retval |	memento := self remember: context.	retval := node child parseOn: context.		self restore: context from: memento.	^ retval isPetit2Failure 		ifTrue: [ nil ]		ifFalse: [ PP2Failure message: 'Child was not expected to pass' context: context  ]! !!PP2NotLiteralObject methodsFor: 'initialization'!initializeFor: aNode	super initializeFor: aNode.	literal := aNode child literal! !!PP2NotLiteralObject methodsFor: 'parsing'!parseOn: context	^ (context peek == literal )		ifFalse: [ nil ] 		ifTrue: [ PP2Failure message: 'literal expected' context: context ]! !!PP2NotPredicateObject methodsFor: 'as yet unclassified'!initializeFor: aNode	super initializeFor: aNode.	predicate := aNode child predicate! !!PP2NotPredicateObject methodsFor: 'as yet unclassified'!parseOn: context	| peek |	peek := context peek.	^ (peek isNil not and: [ predicate value: peek ])		ifFalse: [ nil ] 		ifTrue: [ PP2Failure message: 'predicate not expected' context: context ]! !!PP2Optional methodsFor: 'parsing'!parseOn: aPP2Context	| memento retval |	memento := aPP2Context remember.		^ (retval := node child parseOn: aPP2Context) isPetit2Success		ifTrue: [ retval ]		ifFalse: [ aPP2Context restore: memento. nil ]! !!PP2Optional methodsFor: 'as yet unclassified'!parsingGuard: classification	^ (super parsingGuard: classification)		retval: nil		yourself! !!PP2OptionalLiteralObject methodsFor: 'initialization'!initializeFor: aPP2Node	super initializeFor: aPP2Node.	character := node child literal! !!PP2OptionalLiteralObject methodsFor: 'parsing'!parseOn: aPP2Context	^ (aPP2Context peek == character) ifTrue: [ 		aPP2Context uncheckedNext 	] ifFalse: [  		nil	]! !!PP2Pluggable methodsFor: 'parsing'!parseOn: aPP2Context	^ node block value: aPP2Context! !!PP2Pop methodsFor: 'as yet unclassified'!parseOn: context	| retval |	retval := node child parseOn: context.		retval isPetit2Failure ifFalse: [  		(context stackNamed: node stackId) pop	].	^ retval! !!PP2Plus methodsFor: 'accessing'!bypass: aChild to: target	self assert: aChild == child.		child := target! !!PP2Plus methodsFor: 'accessing'!child	^ child! !!PP2Plus methodsFor: 'initialization'!initializeFor: aNode	super initializeFor: aNode.	child := aNode child! !!PP2Plus methodsFor: 'parsing'!parseOn: aPP2Context	| elements retval |		(retval := child parseOn: aPP2Context) isPetit2Failure		ifTrue: [ ^ retval ].	elements := OrderedCollection with: retval.	[ (retval := child parseOn: aPP2Context) isPetit2Failure		ifTrue: [ ^ elements ].		elements addLast: retval 	] repeat.	^ elements! !!PP2Plus methodsFor: 'conversion'!recognizer	^ PP2PlusRecognizer on: self node! !!PP2PlusPredicateObject methodsFor: 'initialization'!initializeFor: aPP2Node	super initializeFor: aPP2Node.		predicate := node child predicate.	failure := PP2Failure message: 'predicate not found'! !!PP2PlusPredicateObject methodsFor: 'parsing'!parseOn: aPP2Context	| elements |		(aPP2Context atEnd not and: [predicate value: aPP2Context uncheckedPeek]) ifFalse: [ 		^ failure	].	elements := OrderedCollection with: aPP2Context uncheckedNext.		[aPP2Context atEnd not and: [ predicate value: aPP2Context uncheckedPeek ]] whileTrue: [  		elements addLast: aPP2Context uncheckedNext	].	^ elements! !!PP2PlusRecognizer methodsFor: 'parsing'!parseOn: aPP2Context	| retval |			(retval := node child parseOn: aPP2Context) isPetit2Failure		ifTrue: [ ^ retval ].	[ (retval := node child parseOn: aPP2Context) isPetit2Failure ] whileFalse.! !!PP2PossesiveRepeating methodsFor: 'parsing'!parseOn: context	| memento elements retval |	elements := OrderedCollection new.	memento := context remember.		[ elements size < node min ] whileTrue: [		(retval := node child parseOn: context) isPetit2Failure ifTrue: [			context restore: memento.			^ retval		].		elements addLast: retval 	].		[ elements size < node max ] whileTrue: [	 	(retval := node child parseOn: context) isPetit2Failure ifTrue: [ 			^ elements 		].		elements addLast: retval 	].	^ elements! !!PP2Star methodsFor: 'transformations'!bypass: aChild to: target	self assert: aChild == child.		child := target! !!PP2Star methodsFor: 'accessing'!child	^ child! !!PP2Star methodsFor: 'parsing'!initializeFor: aNode	super initializeFor: aNode.	child := aNode child! !!PP2Star methodsFor: 'parsing'!parseOn: aPP2Context	| elements retval |	elements := OrderedCollection new.		[ (retval := child parseOn: aPP2Context) isPetit2Failure		ifTrue: [ ^ elements ].		elements addLast: retval 	] repeat.		^ elements! !!PP2Star methodsFor: 'conversion'!parsingGuard: classification	^ (super parsingGuard: classification)		retval: #();		yourself! !!PP2Star methodsFor: 'conversion'!recognizer	^ PP2StarRecognizer on: self node! !!PP2StarPredicateObject class methodsFor: 'as yet unclassified'!on: node predicate: predicate	^ (super on: node)		predicate: predicate;		yourself! !!PP2StarPredicateObject methodsFor: 'parsing'!parseOn: aPP2Context	| collection |	collection := OrderedCollection new.		[aPP2Context atEnd not and: [ predicate value: aPP2Context uncheckedPeek ]] whileTrue: [  		collection addLast: aPP2Context uncheckedNext	].	^ collection	! !!PP2StarPredicateObject methodsFor: 'accessing'!predicate: newPredicate	predicate := newPredicate ! !!PP2StarPredicateObject methodsFor: 'conversion'!recognizer	^ PP2StarPredicateObjectRecognizer on: self node! !!PP2StarPredicateObjectRecognizer methodsFor: 'as yet unclassified'!initializeFor: aPP2Node	super initializeFor: aPP2Node.	predicate := node child predicate! !!PP2StarPredicateObjectRecognizer methodsFor: 'as yet unclassified'!parseOn: aPP2Context	[aPP2Context atEnd not and: [ predicate value: aPP2Context uncheckedPeek ]] whileTrue: [  		aPP2Context shift	].	^ #()	! !!PP2StarRecognizer methodsFor: 'parsing'!parseOn: aPP2Context	| retval |			[ (retval := node child parseOn: aPP2Context) isPetit2Failure ] whileFalse.! !!PP2StarRecognizer methodsFor: 'parsing'!parsingGuard: classification	^ (super parsingGuard: classification)		retval: #();		yourself! !!PP2PredicateObject methodsFor: 'parsing'!parseOn: aPP2Context	^ (aPP2Context atEnd not and: [ node predicate value: aPP2Context uncheckedPeek ])		ifFalse: [ PP2Failure message: node predicateMessage context: aPP2Context  ]		ifTrue: [ aPP2Context uncheckedNext ]! !!PP2PredicateObject methodsFor: 'conversion'!recognizer	^ PP2PredicateObjectRecognizer on: self node! !!PP2PredicateObjectRecognizer methodsFor: 'as yet unclassified'!parseOn: aPP2Context	^ (aPP2Context atEnd not and: [ node predicate value: aPP2Context uncheckedPeek ])		ifFalse: [ PP2Failure message: node predicateMessage context: aPP2Context  ]		ifTrue: [ aPP2Context shift ]! !!PP2PredicateSequence methodsFor: 'parsing'!parseOn: aPP2Context	| retval position |	position := aPP2Context rememberPosition.	retval := aPP2Context next: node size.		^ (retval isNil not and: [ node predicate value: retval ]) 		ifTrue: [ retval ]		ifFalse: [ 			aPP2Context restorePosition: position.			PP2Failure message: node predicateMessage context: aPP2Context 		]! !!PP2Push methodsFor: 'parsing'!parseOn: context	| retval |	retval := (node child parseOn: context).	retval isPetit2Failure ifTrue: [ ^ retval ].		(context stackNamed: node stackId) push: retval.	^ retval! !!PP2Sea methodsFor: 'conversion'!memoize	^ PP2MemoizedSea on: self! !!PP2Sea methodsFor: 'parsing'!parseOn: context	| awr bwr ir memento |	memento := self remember: context.	node reset: context.		(bwr := node beforeWater parseOn: context) isPetit2Failure ifTrue: [		^ bwr	].	(ir := node island parseOn: context) isPetit2Failure ifTrue: [  		self restore: context from: memento.		^ PP2Failure message: 'island not found' context: context	].	(awr := node afterWater parseOn: context) isPetit2Failure ifTrue: [  		self restore: context from: memento.		^  PP2Failure message: 'boundary not found' context: context	].	^ Array with: bwr with: ir with: awr! !!PP2Sequence methodsFor: 'parsing'!parseOn: context	| retval elements memento |	memento := self remember: context.	elements := Array new: node children size.		1 to: elements size do: [ :index |		retval := (node childAt: index) parseOn: context.		retval isPetit2Failure ifTrue: [ 			self restore: context from: memento. 			^ retval		].		elements at: index put: retval 	].		^ elements! !!PP2SequenceOfThree methodsFor: 'initialization'!initializeFor: aPP2SequenceNode	super initializeFor: aPP2SequenceNode.		firstChild := aPP2SequenceNode firstChild.	secondChild := aPP2SequenceNode secondChild.	thirdChild := aPP2SequenceNode thirdChild.! !!PP2SequenceOfThree methodsFor: 'parsing'!parseOn: context	| retval elements memento |	memento := self remember: context.	(retval := firstChild parseOn: context) isPetit2Failure ifTrue: [ 		^ retval	].	elements := Array new: 3.	elements at: 1 put: retval.		(retval := secondChild parseOn: context) isPetit2Failure ifTrue: [ 		self restore: context from: memento.		^ retval	].	elements at: 2 put: retval.	(retval := thirdChild parseOn: context) isPetit2Failure ifTrue: [ 		self restore: context from: memento.		^ retval	].	elements at: 3 put: retval.		^ elements! !!PP2SequenceOfTwo methodsFor: 'transformation'!bypass: child to: target	firstChild == child ifTrue: [ firstChild := target ].	secondChild == child ifTrue: [ secondChild := target ]! !!PP2SequenceOfTwo methodsFor: 'accessing'!firstChild	^ firstChild! !!PP2SequenceOfTwo methodsFor: 'initialization'!initializeFor: aPP2SequenceNode	super initializeFor: aPP2SequenceNode.		firstChild := aPP2SequenceNode firstChild.	secondChild := aPP2SequenceNode secondChild.! !!PP2SequenceOfTwo methodsFor: 'parsing'!parseOn: context	| retval elements memento |	memento := self remember: context.	(retval := firstChild parseOn: context) isPetit2Failure ifTrue: [ 		^ retval	].	elements := Array new: 2.	elements at: 1 put: retval.		(retval := secondChild parseOn: context) isPetit2Failure ifTrue: [ 		self restore: context from: memento.		^ retval	].	elements at: 2 put: retval.	^ elements! !!PP2SequenceOfTwo methodsFor: 'conversion'!recognizer	^ PP2SequenceOfTwoRecognizer on: self node! !!PP2SequenceOfTwo methodsFor: 'accessing'!secondChild	^ secondChild! !!PP2SequenceOfTwoRecognizer methodsFor: 'transformation'!bypass: child to: target	firstChild == child ifTrue: [ firstChild := target ].	secondChild == child ifTrue: [ secondChild := target ]! !!PP2SequenceOfTwoRecognizer methodsFor: 'as yet unclassified'!firstChild	^ firstChild! !!PP2SequenceOfTwoRecognizer methodsFor: 'initialization'!initializeFor: aPP2SequenceNode	super initializeFor: aPP2SequenceNode.		firstChild := aPP2SequenceNode firstChild.	secondChild := aPP2SequenceNode secondChild.! !!PP2SequenceOfTwoRecognizer methodsFor: 'parsing'!parseOn: context	| retval memento |	memento := self remember: context.	(retval := firstChild parseOn: context) isPetit2Failure ifTrue: [ 		^ retval	].	(retval := secondChild parseOn: context) isPetit2Failure ifTrue: [ 		self restore: context from: memento.		^ retval	].! !!PP2SequenceOfTwoRecognizer methodsFor: 'as yet unclassified'!secondChild	^ secondChild! !!PP2AnyStarLazyLiteralObject class methodsFor: 'instance creation'!on: node literal: literal	^ (super on: node)		literal: literal;		yourself! !!PP2AnyStarLazyLiteralObject methodsFor: 'accessing'!literal	^ literal! !!PP2AnyStarLazyLiteralObject methodsFor: 'accessing'!literal: newLiteral	literal := newLiteral ! !!PP2AnyStarLazyLiteralObject methodsFor: 'parsing'!parseOn: context	| retval position |	retval := OrderedCollection new.	position := context rememberPosition.		[ 		context atEnd ifTrue: [ 			context restorePosition: position.			^ PP2Failure message: 'boundary not found' context: context		].		context uncheckedPeek == literal	] whileFalse: [  		retval addLast: context uncheckedNext	].	^ retval! !!PP2AnyStarLazyPredicateObject class methodsFor: 'as yet unclassified'!on: node predicate: predicate	^ (super on: node)		predicate: predicate;		yourself! !!PP2AnyStarLazyPredicateObject methodsFor: 'parsing'!parseOn: context	| retval position |	retval := OrderedCollection new.	position := context rememberPosition.	[ 		context atEnd ifTrue: [ 			context restorePosition: position.			^ PP2Failure message: 'boundary not found' context: context		].		predicate value: context uncheckedPeek	] whileFalse: [  		retval addLast: context uncheckedNext	].	^ retval! !!PP2AnyStarLazyPredicateObject methodsFor: 'accessing'!predicate	^ predicate! !!PP2AnyStarLazyPredicateObject methodsFor: 'accessing'!predicate: newPredicate	predicate := newPredicate ! !!PP2StartOfLine methodsFor: 'initialization'!initializeFor: aPP2Node	super initializeFor: aPP2Node.		failure := PP2Failure message: 'start of line expected'! !!PP2StartOfLine methodsFor: 'newline handling'!insideCRLF: context	(context position < 1) ifTrue: [ ^ false ].		^ (context peek = (Character codePoint: 10)) and: [ context peekBack = (Character codePoint: 13) ]! !!PP2StartOfLine methodsFor: 'newline handling'!isStartOfLine: context	(context position = 0) ifTrue: [ ^ true ].	(self insideCRLF: context) ifTrue: [ ^ false ].		^ (context peekBack = (Character codePoint: 13)) or: [ context peekBack = (Character codePoint: 10)].! !!PP2StartOfLine methodsFor: 'parsing'!parseOn: context	^ (self isStartOfLine: context) ifTrue: [ ^ nil ] ifFalse: [ failure context: context ]! !!PP2Strategy class methodsFor: 'instance creation'!new	^ self error: 'Use "#on: aPP2Node" instead'! !!PP2Strategy class methodsFor: 'instance creation'!on: aPP2Node	^ self basicNew initializeFor:	aPP2Node! !!PP2Strategy methodsFor: 'accessing'!allChildren	^ OrderedCollection with: self! !!PP2Strategy methodsFor: 'transformation'!bypass: aPP2Node to: target	"nothing to do really"! !!PP2Strategy methodsFor: 'initialization'!initializeFor: aPP2Node	node := aPP2Node! !!PP2Strategy methodsFor: 'accessing'!node	^ node! !!PP2Strategy methodsFor: 'accessing'!node: anObject	node := anObject! !!PP2Strategy methodsFor: 'parsing'!parseOn: aPP2Context	self subclassResponsibility ! !!PP2Strategy methodsFor: 'memoization'!remember: context	^ node memoizationStrategy remember: context! !!PP2Strategy methodsFor: 'memoization'!restore: context from: memento	node memoizationStrategy restore: context from: memento! !!PP2Trimming methodsFor: 'parsing'!parseOn: aPP2Context	| position retval |	position := aPP2Context position.	node trimmer parseOn: aPP2Context.		(retval := node child parseOn: aPP2Context) isPetit2Failure ifTrue: [ 		aPP2Context restorePosition: position.		^ retval	].		node trimmer parseOn: aPP2Context.	^ retval! !!PP2TrimmingLiteralObjectToken methodsFor: 'as yet unclassified'!initializeFor: aNode	| token |	super initializeFor: aNode.		token := aNode child.	literal := token childSkipDelegate literal.	failure := PP2Failure message: 'literal expected'! !!PP2TrimmingLiteralObjectToken methodsFor: 'as yet unclassified'!literal	^ literal! !!PP2TrimmingLiteralObjectToken methodsFor: 'as yet unclassified'!parseOn: context	| position retval |	position := context rememberPosition.	trimmer parseOn: context.		(context nextFor: literal) ifTrue: [		retval := context newToken: tokenClass from: context position - 1	] ifFalse: [  		context restorePosition: position.		^ failure	].		trimmer parseOn: context.	^ retval! !!PP2TrimmingToken methodsFor: 'parsing'!initializeFor: aNode	super initializeFor: aNode.		tokenClass := aNode child tokenClass.	tokenChild := aNode child child.	trimmer := aNode trimmer.! !!PP2TrimmingToken methodsFor: 'parsing'!parseOn: context	| position retval start |	position := context rememberPosition.	trimmer parseOn: context.	start := context position.	(retval := tokenChild parseOn: context) isPetit2Failure ifTrue: [ 		context restorePosition: position.		^ retval	].	retval := context newToken: tokenClass from: start.	trimmer parseOn: context.	^ retval! !!PP2TrimmingToken methodsFor: 'accessing'!tokenChild	^ tokenChild! !!PP2TrimmingToken methodsFor: 'accessing'!tokenChild: anObject	tokenChild := anObject! !!PP2TrimmingToken methodsFor: 'accessing'!tokenClass	^ tokenClass! !!PP2TrimmingToken methodsFor: 'accessing'!tokenClass: anObject	tokenClass := anObject! !!PP2TrimmingToken methodsFor: 'accessing'!trimmer	^ trimmer! !!PP2TrimmingToken methodsFor: 'accessing'!trimmer: anObject	trimmer := anObject! !!PP2Water methodsFor: 'initialization'!initializeFor: aPP2Node	super initializeFor: aPP2Node! !!PP2Water methodsFor: 'parsing'!parseOn: context	| result contents memento startWaterPosition |	memento := self remember: context.	startWaterPosition := context waterPosition.	contents := OrderedCollection new.		"Recursive Water case"	(context waterPosition = context position) ifTrue: [  ^ '' ].		[		context waterPosition: context position.		(node boundary parseOn: context) isPetit2Failure 	] whileTrue: [  		(result := node waterToken parseOn: context) isPetit2Failure ifTrue: [  			self restore: context from: memento.			context waterPosition: startWaterPosition.			^ PP2Failure message: 'water boundary not found' context: context.		].		contents add: result.	].	context waterPosition: startWaterPosition.	^ contents! !!PP2Wrapping methodsFor: 'parsing'!parseOn: aPP2Context	^ node block value: aPP2Context value: [ node child parseOn: aPP2Context ]! !!PP2Cache methodsFor: 'conversion'!cache	^ self! !!PP2Cache methodsFor: 'profiling'!cacheHit: context	"profiling not implemented"! !!PP2Cache methodsFor: 'profiling'!invocation	"profiling not implemented"! !!PP2Cache methodsFor: 'testing'!isCache	^ true! !!PP2Cache methodsFor: 'parsing'!parseOn: context	| start |	self invocation.	(context position == position) ifTrue: [ 		self cacheHit: context.		context position: endPosition.		^ retval	].	start := context position.	retval := strategy parseOn: context.	position := start.	endPosition := context position.		^ retval! !!PP2Cache methodsFor: 'conversion'!recording	^ PP2RecordingCache on: strategy! !!PP2Cache methodsFor: 'initialization'!reset	position := -1! !!PP2RecordingCache methodsFor: 'accessing'!hits	^ hits! !!PP2RecordingCache methodsFor: 'accessing'!hits: anInteger	hits := anInteger! !!PP2RecordingCache methodsFor: 'initialization'!initialize	super initialize.	self resetCounters.! !!PP2RecordingCache methodsFor: 'accessing'!invocations	^ invocations ! !!PP2RecordingCache methodsFor: 'accessing'!invocations: anInteger	invocations := anInteger! !!PP2DebuggingStrategy class methodsFor: 'instance creation'!on: aPP2Strategy	^ self new initializeFor: aPP2Strategy! !!PP2DebuggingStrategy methodsFor: 'conversion'!cache	strategy := strategy cache! !!PP2DebuggingStrategy methodsFor: 'caching'!cacheIfNeeded: result debugResult: debugResult	(strategy includesCache) ifFalse: [  		^ self	].  "    For interoperability with VW/Gemstone, see https://github.com/kursjan/petitparser2/issues/35:    Ignore nil results: this will not show debug results for cached nils.  "  result isNil ifTrue: [ ^ self ].	"		If the underlying strategy is cache, try to provide debug result even for cached results by		remembering debug result for each result.	"	((resultCache includesKey: result) and: [ (debugResult allResults size = 1 )]) ifTrue:[		debugResult children: (Array with: (PP2DebugResultLink on: (resultCache at: result)))	] ifFalse: [		resultCache at: result put: debugResult.	]! !!PP2DebuggingStrategy methodsFor: 'conversion'!debug	^ self! !!PP2DebuggingStrategy methodsFor: 'initialization'!initialize	resultCache := IdentityDictionary new.! !!PP2DebuggingStrategy methodsFor: 'testing'!isDebugging	^ true! !!PP2DebuggingStrategy methodsFor: 'parsing'!parseOn: context	| parentDebugResult debugResult result |	parentDebugResult := context currentDebugResult.		debugResult := PP2DebugResult new		parser: self node;		start: context position + 1;		parent: parentDebugResult;		yourself.		parentDebugResult children add: debugResult.			context currentDebugResult: debugResult.	result := strategy parseOn: context.	self cacheIfNeeded: result debugResult: debugResult.	context currentDebugResult: parentDebugResult.		debugResult 		stop: context position;		result: result.		^ result! !!PP2DebuggingStrategy methodsFor: 'conversion'!parsingGuard: classification	strategy := strategy parsingGuard: classification! !!PP2DebuggingStrategy methodsFor: 'conversion'!recording	^ PP2RecordingDebuggingStrategy on: strategy ! !!PP2DebuggingStrategy methodsFor: 'conversion'!reparsable	strategy := strategy reparsable! !!PP2DebuggingStrategy methodsFor: 'accessing'!withoutDebugStrategy	^ strategy withoutDebugStrategy! !!PP2RecordingDebuggingStrategy methodsFor: 'testing'!isRecording	^ true! !!PP2RecordingDebuggingStrategy methodsFor: 'parsing'!parseOn: context	| result entry |	self node hasName ifTrue: [ context namedInvoked 	] ifFalse: [ context invoked ].	entry := context eventsTrace last.	entry start: context eventsTrace entriesCount.		result := super parseOn: context.		entry stop: context eventsTrace entriesCount.	entry debugResult: context lastDebugResult.	"JK: I don't like this reference from debugResult to entry..."	context lastDebugResult invocationEntry: entry.		^ result! !!PP2RecordingDebuggingStrategy methodsFor: 'conversion'!recording	^ self! !!PP2MemoizedSea methodsFor: 'conversion'!cache	^ self! !!PP2MemoizedSea methodsFor: 'profiling'!cacheHit: context! !!PP2MemoizedSea methodsFor: 'initialization'!initialize	super initialize.	"	Would be nice to call this, but there is some mess in initializations.	This would be called before underlying strategy knows, what is its node :(		self reset	"! !!PP2MemoizedSea methodsFor: 'profiling'!invocation! !!PP2MemoizedSea methodsFor: 'testing'!isCache	^ true! !!PP2MemoizedSea methodsFor: 'testing'!isMemoized	^ true! !!PP2MemoizedSea methodsFor: 'conversion'!memoize	^ self! !!PP2MemoizedSea methodsFor: 'parsing'!parseOn: context	| contextMemento returnValue |	self invocation.	contextMemento := self remember: context.	buffer at: contextMemento ifPresent: [:memento |		self cacheHit: context.		self restore: context from: memento contextMemento.		^ memento returnValue	].	returnValue := strategy parseOn: context.	(context waterPosition == context position) ifFalse: [  		| result |		result := PP2Memento new 			returnValue: returnValue;			contextMemento: (self remember: context);			yourself.		buffer at: contextMemento put: result	].	^ returnValue! !!PP2MemoizedSea methodsFor: 'conversion'!recording	^ PP2RecordingMemoizedSea on: strategy! !!PP2MemoizedSea methodsFor: 'memoization'!remember: context	^ memoizationStrategy remember: context! !!PP2MemoizedSea methodsFor: 'initialization'!reset	self node isContextSensitive ifTrue: [  		memoizationStrategy := PP2CSMemoization new.		buffer := Dictionary new.	] ifFalse: [  		memoizationStrategy := PP2CFMemoization new.		buffer := IdentityDictionary new	]! !!PP2MemoizedSea methodsFor: 'memoization'!restore: context from: memento	^ memoizationStrategy restore: context from: memento! !!PP2RecordingMemoizedSea methodsFor: 'profiling'!hits	^ hits! !!PP2RecordingMemoizedSea methodsFor: 'profiling'!hits: anInteger	hits := anInteger! !!PP2RecordingMemoizedSea methodsFor: 'initialization'!initialize	super initialize.	self resetCounters.! !!PP2RecordingMemoizedSea methodsFor: 'profiling'!invocations	^ invocations! !!PP2RecordingMemoizedSea methodsFor: 'profiling'!invocations: anInteger	invocations := anInteger! !!PP2Packrat methodsFor: 'accessing'!buffer	^ buffer! !!PP2Packrat methodsFor: 'profiling'!cacheHit: context! !!PP2Packrat methodsFor: 'profiling'!invocation! !!PP2Packrat methodsFor: 'testing'!isCache	^ true! !!PP2Packrat methodsFor: 'testing'!isMemoized	^ true! !!PP2Packrat methodsFor: 'conversion'!memoize	^ self! !!PP2Packrat methodsFor: 'parsing'!parseOn: context	| contextMemento returnValue result |	self invocation.	contextMemento := self remember: context.	buffer at: contextMemento ifPresent: [:memento |		self cacheHit: context.		self restore: context from: memento contextMemento.		^ memento returnValue	].	returnValue := strategy parseOn: context.	result := PP2Memento new 		returnValue: returnValue;		contextMemento: (self remember: context);		yourself.	buffer at: contextMemento put: result.	^ returnValue! !!PP2Packrat methodsFor: 'conversion'!recording	^ PP2RecordingPackrat on: strategy! !!PP2Packrat methodsFor: 'memoization'!remember: context	^ memoizationStrategy remember: context! !!PP2Packrat methodsFor: 'accessing'!reset	self node isContextSensitive ifTrue: [  		memoizationStrategy := PP2CSMemoization new.		buffer := Dictionary new	] ifFalse: [  		memoizationStrategy := PP2CFMemoization new.		buffer := IdentityDictionary new	]! !!PP2Packrat methodsFor: 'memoization'!restore: context from: memento	^ memoizationStrategy restore: context from: memento! !!PP2RecordingPackrat methodsFor: 'accessing'!hits	^ hits! !!PP2RecordingPackrat methodsFor: 'accessing'!hits: anObject	hits := anObject! !!PP2RecordingPackrat methodsFor: 'initialization'!initialize	super initialize.	self resetCounters.! !!PP2RecordingPackrat methodsFor: 'accessing'!invocations	^ invocations! !!PP2RecordingPackrat methodsFor: 'accessing'!invocations: anObject	invocations := anObject! !!PP2ParsingGuard methodsFor: 'accessing'!classification	^ classification ! !!PP2ParsingGuard methodsFor: 'accessing'!classification: anArray	"I am experimenting with smaller classification, but not 100% sure this improves performance"	classification := (anArray copyFrom: 1 to: 128)! !!PP2ParsingGuard methodsFor: 'parsing'!parseOn: context	| intValue |	context atEnd ifTrue: [ ^ retval ].	intValue := context uncheckedPeek asInteger.	"TODO(kurs): why 0-128?"	(intValue between: 0 and: 128) ifFalse: [  		^ strategy parseOn: context	].		(classification at: intValue) ifFalse: [ 		^ retval	].	^ strategy parseOn: context! !!PP2ParsingGuard methodsFor: 'conversion'!parsingGuard: anArray	self		assert: classification = (anArray copyFrom: 1 to: classification size).	^ self! !!PP2ParsingGuard methodsFor: 'accessing'!retval	^ retval ! !!PP2ParsingGuard methodsFor: 'accessing'!retval: anObject	retval := anObject! !!PP2RecordingStrategy methodsFor: 'parsing'!parseOn: context	| result entry lastDebugResult |	self node hasName ifTrue: [ context namedInvoked 	] ifFalse: [ context invoked ].	entry := context eventsTrace last.	entry start: context eventsTrace entriesCount.		result := strategy parseOn: context.		entry stop: context eventsTrace entriesCount.	(lastDebugResult := context lastDebugResult) isNil ifFalse: [ 		entry debugResult: lastDebugResult.		lastDebugResult invocationEntry: entry.	].	^ result! !!PP2RecordingTrimmingCache methodsFor: 'accessing'!hits	^ hits ! !!PP2RecordingTrimmingCache methodsFor: 'accessing'!hits: anInteger	hits := anInteger! !!PP2RecordingTrimmingCache methodsFor: 'accessing'!invocations	^ invocations ! !!PP2RecordingTrimmingCache methodsFor: 'accessing'!invocations: anInteger	invocations := anInteger! !!PP2TrimmingCache methodsFor: 'conversion'!cache	"I already cache trimming, no need to add another layer of caches"	^ self! !!PP2TrimmingCache methodsFor: 'profiling'!cacheHit: context! !!PP2TrimmingCache methodsFor: 'initialization'!initializeFor: aPP2Strategy	super initializeFor: aPP2Strategy.		failure := PP2Failure message: 'no more whitespace'! !!PP2TrimmingCache methodsFor: 'profiling'!invocation! !!PP2TrimmingCache methodsFor: 'testing'!isCache	^ true! !!PP2TrimmingCache methodsFor: 'parsing'!parseOn: context	| retval |	self invocation.	(context position == lastTrimming) ifTrue: [ 		self cacheHit: context.		^ failure 	].	retval := strategy parseOn: context.	lastTrimming := context position.	^ retval! !!PP2TrimmingCache methodsFor: 'conversion'!recording	^ PP2RecordingTrimmingCache on: strategy! !!PP2TrimmingCache methodsFor: 'initialization'!reset	lastTrimming := nil! !!PP2TrimmingCache methodsFor: 'conversion'!trimmingCache	^ self! !!PP2WrappingStrategy class methodsFor: 'instance creation'!on: aPP2Strategy	^ self new initializeFor: aPP2Strategy! !!PP2WrappingStrategy methodsFor: 'accessing'!allChildren	^ (strategy allChildren) 		addFirst: self;		yourself! !!PP2WrappingStrategy methodsFor: 'transformation'!bypass: aChild to: target	strategy bypass: aChild to: target! !!PP2WrappingStrategy methodsFor: 'parsing'!changeStrategy: newStrategy	self halt: 'JK: delete?'.	strategy := newStrategy! !!PP2WrappingStrategy methodsFor: 'initialization'!initializeFor: aPP2Strategy	strategy := aPP2Strategy.		self assert: aPP2Strategy class ~= self class! !!PP2WrappingStrategy methodsFor: 'testing'!isCache	^ false! !!PP2WrappingStrategy methodsFor: 'accessing'!node	^ strategy node! !!PP2WrappingStrategy methodsFor: 'accessing'!node: anObject	^ strategy node: anObject! !!PP2WrappingStrategy methodsFor: 'parsing'!parseOn: aPP2Context	^ strategy parseOn: aPP2Context! !!PP2WrappingStrategy methodsFor: 'copying'!postCopy	super postCopy.		strategy := strategy copy.! !!PP2WrappingStrategy methodsFor: 'conversion'!recognizer	strategy := strategy recognizer! !!PP2WrappingStrategy methodsFor: 'memoization'!remember: context	^ self node memoizationStrategy remember: context! !!PP2WrappingStrategy methodsFor: 'memoization'!restore: context from: memento	^ self node memoizationStrategy restore: context from: memento! !!PP2WrappingStrategy methodsFor: 'accessing'!strategy	^ strategy! !!PP2WrappingStrategy methodsFor: 'accessing'!strategy: newStrategy	strategy := newStrategy! !!PP2AsyncStream methodsFor: 'converting'!asPetit2Stream	^ PP2BufferStream on: self! !!PP2AsyncStream methodsFor: 'minimal interface'!atEnd	^ queue isEmpty and: closed! !!PP2AsyncStream methodsFor: 'initialize-release'!close	closed := true.	"I need to queue some character at the end, because next is waiting for an input"	queue addLast: (Character codePoint: 4).! !!PP2AsyncStream methodsFor: 'initialization'!initialize	super initialize.		closed := false.	queue := OrderedCollection new.	! !!PP2AsyncStream methodsFor: 'minimal interface'!next	| delay |	"		Poor man implementation of polling...	"	delay := Delay forMilliseconds: 50.		[ queue isEmpty] whileTrue: [ delay wait  ].	^  queue removeFirst! !!PP2AsyncStream methodsFor: 'events'!queueChar: aCharacter	closed ifFalse: [  queue addLast: aCharacter ]! !!PP2BufferStream class methodsFor: 'instance creation'!new	"for compatibility reasons"	^ self basicNew		initialize! !!PP2BufferStream class methodsFor: 'instance creation'!on: stream	^ self on: stream bufferSize: 1024! !!PP2BufferStream class methodsFor: 'instance creation'!on: stream bufferSize: bufferSize	^ (self basicNew)		initializeForSize: bufferSize;		stream: stream;		yourself! !!PP2BufferStream methodsFor: 'converting'!asPetit2Context	^ PP2Context on: self! !!PP2BufferStream methodsFor: 'converting'!asPetit2Stream	^ self! !!PP2BufferStream methodsFor: 'converting'!asPetitStream	^ stream asPetitStream! !!PP2BufferStream methodsFor: 'context interface'!atEnd: readPosition	self upToPosition: readPosition.		^ (readPosition >= position) and: [ stream atEnd ]! !!PP2BufferStream methodsFor: 'context interface'!atPosition: readPosition	(readPosition == position) ifTrue: [ 		^ self last.	].	(readPosition > position) ifTrue: [ 		self upToPosition: readPosition.		(readPosition > position) ifTrue: [ PP2OutOfBoundsException signalFor: readPosition ].		^ self last	].	"backtrack case"	(position - readPosition >= bufferSize) ifTrue: [ 		PP2OutOfBoundsException signalFor: readPosition.	].	^ buffer at: ((readPosition - 1) \\ bufferSize) + 1.! !!PP2BufferStream methodsFor: 'accessing - private'!buffer	^ buffer ! !!PP2BufferStream methodsFor: 'accessing - private'!bufferSize	^ bufferSize! !!PP2BufferStream methodsFor: 'accessing'!contents	"Not sure, what is the best think to return..."	^ buffer contents copyFrom: 1 to: position! !!PP2BufferStream methodsFor: 'context interface'!copyFrom: start to: stop	"start - end should be in range <0, size)"	| bufferStart bufferStop |		(stop - start >= bufferSize ) ifTrue: [ 		"range bigger than buffer"		PP2OutOfBoundsException signalFor: start.	].	(position - start >= bufferSize) ifTrue: [ 		"buffer not big enough"		PP2OutOfBoundsException signalFor: start.	].	self upToPosition: stop.		(position < stop) ifTrue: [ 		PP2OutOfBoundsException signalFor: stop.	].	bufferStart := ((start - 1) \\ bufferSize) + 1.	bufferStop := ((stop -1) \\ bufferSize) + 1.		(bufferStart <= bufferStop) ifTrue: [ 		^ buffer copyFrom: bufferStart to: bufferStop	] ifFalse: [		| retval |		retval := String new: stop - start + 1. 		0 to: stop - start do: [ :index |			retval at: (index + 1) put: (buffer at: ((start - 1 + index) \\ bufferSize) + 1)		].		^ retval	]! !!PP2BufferStream methodsFor: 'initialization'!initialize	self initializeForSize: 1024! !!PP2BufferStream methodsFor: 'initialization'!initializeForSize: size	"nothing to do"	bufferSize := size.	buffer := String new: bufferSize.	position := 0.! !!PP2BufferStream methodsFor: 'testing'!isBuffered	^ true! !!PP2BufferStream methodsFor: 'private'!last	^ buffer at: ((position - 1) \\ bufferSize) + 1! !!PP2BufferStream methodsFor: 'context interface'!newToken: tokenClass from: start to: stop	| collection |	collection := self copyFrom: start to: stop.		^ tokenClass 		on: collection 		start:  1		stop: 	(stop - start + 1)! !!PP2BufferStream methodsFor: 'testing'!printOn: writeStream position: currentPosition	"TODO: show the position as well"	stream contents printOn: writeStream! !!PP2BufferStream methodsFor: 'initialization'!reset	! !!PP2BufferStream methodsFor: 'accessing'!stream: aStream	stream := aStream! !!PP2BufferStream methodsFor: 'private'!uncheckedNext	| bufferIndex |	bufferIndex := (position \\ bufferSize) + 1.	position := position + 1.		buffer at: bufferIndex put: stream next.	^ buffer at: bufferIndex! !!PP2BufferStream methodsFor: 'private'!upToPosition: readPosition	[position < (readPosition) and: [ stream atEnd not ]] whileTrue: [  		self uncheckedNext	]! !!PP2CcChange methodsFor: 'testing'!isContextChange	^ true! !!PP2CcChange methodsFor: 'testing'!isNotContextChange	^ true! !!PP2CcChange methodsFor: 'testing'!isUnknownChange	^ true! !!PP2CcDoesNotChange methodsFor: 'as yet unclassified'!isContextChange	^ false! !!PP2CcDoesNotChange methodsFor: 'as yet unclassified'!isNotContextChange	^ true! !!PP2CcPop methodsFor: 'testing'!isContextChange	^ true! !!PP2CcPop methodsFor: 'testing'!isContextPop	^ true! !!PP2CcPush methodsFor: 'as yet unclassified'!isContextChange	^ true! !!PP2CcPush methodsFor: 'as yet unclassified'!isContextPush	^ true! !!PP2CcResult class methodsFor: 'instance creation'!change	^ PP2CcChange instance! !!PP2CcResult class methodsFor: 'instance creation'!instance	Instance isNil ifTrue: [  		Instance := self new	].	^ Instance! !!PP2CcResult class methodsFor: 'instance creation'!noChange	^ PP2CcDoesNotChange instance! !!PP2CcResult class methodsFor: 'instance creation'!pop	^ PP2CcPop instance! !!PP2CcResult class methodsFor: 'instance creation'!push	^ PP2CcPush instance! !!PP2CcResult methodsFor: 'testing'!isContextChange	self subclassResponsibility ! !!PP2CcResult methodsFor: 'testing'!isContextPop	^ false! !!PP2CcResult methodsFor: 'testing'!isContextPush	^ false! !!PP2CcResult methodsFor: 'testing'!isNotContextChange	^ self isContextChange not! !!PP2CcResult methodsFor: 'testing'!isUnknownChange	^ false! !!PP2CharSetPredicate class methodsFor: 'instance creation'!any	^ self on: [ :e | true ]! !!PP2CharSetPredicate class methodsFor: 'instance creation'!empty	^ self on: [ :e | false ]! !!PP2CharSetPredicate class methodsFor: 'instance creation'!on: aBlock	^ self basicNew initializeOn: aBlock! !!PP2CharSetPredicate methodsFor: 'converting'!asCharSetPredicate	^ self! !!PP2CharSetPredicate methodsFor: 'accessing'!classification	^ classification! !!PP2CharSetPredicate methodsFor: 'initialization'!initializeOn: aBlock	block := aBlock.	classification := Array new: 255.	1 to: classification size do: [ :index |		classification at: index put: (block			value: (Character codePoint: index)) ]! !!PP2CharSetPredicate methodsFor: 'testing'!isUnknown	^ false! !!PP2CharSetPredicate methodsFor: 'evaluating'!value: aCharacter	| index |	index := aCharacter asInteger.	index == 0	ifTrue: [ ^ block value: aCharacter ].	index > 255	ifTrue: [ ^ block value: aCharacter ].			^ classification at: index! !!PP2Context class methodsFor: 'instance creation'!on: stream	^ self on: stream position: 0! !!PP2Context class methodsFor: 'instance creation'!on: stream position: position	^ self new 		stream: stream;		position: position;		yourself! !!PP2Context methodsFor: 'converting'!asPositionableStream	^ (ReadStream on: stream collection)		position: position;		yourself! !!PP2Context methodsFor: 'stream mimicry'!atEnd	^ stream atEnd: position! !!PP2Context methodsFor: 'accessing'!contents	^ stream contents! !!PP2Context methodsFor: 'copying'!copyFrom: start to: end	^ stream copyFrom: start to: end! !!PP2Context methodsFor: 'debugging'!debugResult	^ self globalAt: #debugResult ifAbsentPut: [ 		| context |		context := self copy.		context restore: self startMemento.		context parser duplicate enableDebug parseWithContext: context.		context currentDebugResult	]! !!PP2Context methodsFor: 'accessing-globals'!globals	^ globals! !!PP2Context methodsFor: 'accessing-globals'!globals: anObject	^ globals := anObject! !!PP2Context methodsFor: 'initialization'!initialize	super initialize! !!PP2Context methodsFor: 'testing'!isPetit2Context	^ true! !!PP2Context methodsFor: 'tokenization'!newToken: tokenClass from: start	^ stream newToken: tokenClass from: start + 1 to: position! !!PP2Context methodsFor: 'stream mimicry'!next	^ (stream atEnd: position) not ifTrue: [ 		position := position + 1.		stream atPosition: position	] ifFalse: [  		nil	]! !!PP2Context methodsFor: 'stream mimicry'!next: size	^ ((stream atEnd: position + size - 1) not) ifTrue: [ 		stream copyFrom: (position + 1) to: (position := position + size)	] ifFalse: [ 		nil	]! !!PP2Context methodsFor: 'stream mimicry'!nextFor: aCharacter	^ (stream atEnd: position) not ifTrue: [ 		position := position + 1.		^ ((stream atPosition: position) == aCharacter )			ifTrue: [ true ]			ifFalse:[ position := position - 1 . false ].	] ifFalse: [  		false	]! !!PP2Context methodsFor: 'accessing'!parser	^ parser! !!PP2Context methodsFor: 'accessing'!parser: aPP2Parser	parser := aPP2Parser ! !!PP2Context methodsFor: 'stream mimicry'!peek	^ (stream atEnd: position) not ifTrue: [ 		stream atPosition: position + 1	]! !!PP2Context methodsFor: 'stream mimicry'!peekBack"	Funny, stream throws an exception, so I should too :)				^ (position > 0) ifTrue: [ 		stream atPosition: position	]"		^ stream atPosition: position! !!PP2Context methodsFor: 'stream mimicry'!peekFor: anObject 	"Answer false and do not move over the next element if it is not equal to 	the argument, anObject, or if the receiver is at the end. Answer true 	and increment the position for accessing elements, if the next element is 	equal to anObject."	| nextObject |	self atEnd ifTrue: [^false].	nextObject := self next.	"peek for matching element"	anObject = nextObject ifTrue: [^true].	"gobble it if found"	position := position - 1.	^false! !!PP2Context methodsFor: 'accessing'!position	^ position! !!PP2Context methodsFor: 'accessing'!position: anInteger	position := anInteger! !!PP2Context methodsFor: 'copying'!postCopy	super postCopy.	globals := globals copy.	! !!PP2Context methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPut: $:.	aStream nextPut: $ .	stream printOn: aStream! !!PP2Context methodsFor: 'accessing - properties'!properties	^ properties! !!PP2Context methodsFor: 'accessing - properties'!properties: newProperties	^ properties := newProperties! !!PP2Context methodsFor: 'memoization'!remember	^ PP2ContextMemento new		stream: stream;		position: position;		properties: self propertiesCopy;		yourself.! !!PP2Context methodsFor: 'memoization'!rememberPosition	^ position! !!PP2Context methodsFor: 'initialization'!reset	globals := nil! !!PP2Context methodsFor: 'memoization'!restore: contextMemento	position := contextMemento position.	properties := contextMemento propertiesCopy.! !!PP2Context methodsFor: 'memoization'!restorePosition: anInteger	position := anInteger! !!PP2Context methodsFor: 'accessing'!returnValue	^ returnValue! !!PP2Context methodsFor: 'accessing'!returnValue: anObject	returnValue := anObject! !!PP2Context methodsFor: 'stream extras'!shift	position := position + 1! !!PP2Context methodsFor: 'requirements'!startMemento	^ startMemento! !!PP2Context methodsFor: 'requirements'!startMemento: anObject	startMemento := anObject! !!PP2Context methodsFor: 'accessing'!stream	^ stream! !!PP2Context methodsFor: 'accessing'!stream: aStream	stream := aStream! !!PP2Context methodsFor: 'stream extras'!uncheckedNext	position := position + 1.	^ stream atPosition: position! !!PP2Context methodsFor: 'stream extras'!uncheckedPeek	^ stream atPosition: position + 1! !!PP2Context methodsFor: 'stream mimicry'!upTo: character	| start |	start := position := position + 1.		[ 		(stream atEnd: position) ifTrue: [  			^ stream copyFrom: start to: position			].		(stream atPosition: position) = character			] whileFalse: [ position := position + 1 ].	^ stream copyFrom: start to: position ! !!PP2Context methodsFor: 'stream mimicry'!upToEnd	| start |	start := position.		[ stream atEnd: position ] whileFalse: [ position := position + 1 ].	^ stream copyFrom: start + 1 to: position! !!PP2Context methodsFor: 'evaluating'!value	^ returnValue! !!PP2ContextMemento methodsFor: 'arithmetic'!+ anInteger	^ (self copy)		position: position + anInteger;		yourself! !!PP2ContextMemento methodsFor: 'arithmetic'!- anInteger	^ (self copy)		position: position - anInteger;		yourself! !!PP2ContextMemento methodsFor: 'comparison'!= anotherMemento	self class == anotherMemento class ifFalse: [ ^ false ].		self position == anotherMemento position ifFalse: [ ^ false ].	self stream == anotherMemento stream ifFalse: [ ^ false ].		^ self properties = anotherMemento properties! !!PP2ContextMemento methodsFor: 'comparison'!hash	^ self position hash! !!PP2ContextMemento methodsFor: 'accessing'!position	^ position! !!PP2ContextMemento methodsFor: 'accessing'!position: anObject	position := anObject! !!PP2ContextMemento methodsFor: 'copying'!postCopy	properties := properties copy! !!PP2ContextMemento methodsFor: 'accessing - properties'!properties	^ properties! !!PP2ContextMemento methodsFor: 'accessing - properties'!properties: newProperties	^ properties := newProperties! !!PP2ContextMemento methodsFor: 'accessing'!stream	^ stream! !!PP2ContextMemento methodsFor: 'accessing'!stream: anObject	stream := anObject! !!PP2DebugResult methodsFor: 'analysis'!allResults	^ allChildren ifNil: [  		| collection |		collection := IdentitySet new.		self allResultsTo: collection.		allChildren := collection		]! !!PP2DebugResult methodsFor: 'analysis'!allResultsTo: set	set add: self.	self children do: [ :child | child allResultsTo: set ].! !!PP2DebugResult methodsFor: 'accessing'!children	^ children! !!PP2DebugResult methodsFor: 'accessing'!children: anObject	children := anObject! !!PP2DebugResult methodsFor: 'accessing'!contents	^ self findContextContents! !!PP2DebugResult methodsFor: 'accessing'!context		^ context! !!PP2DebugResult methodsFor: 'accessing'!context: anObject		context := anObject! !!PP2DebugResult methodsFor: 'accessing'!debugResult	^ self! !!PP2DebugResult methodsFor: 'accessing'!findContext		context ifNil: [ ^ parent ifNotNil: [ parent findContext ] ].	^ context! !!PP2DebugResult methodsFor: 'accessing'!findContextContents	^ (self findContext ifNotNil: [ :s | s contents ]) ifNil: [ '' ]! !!PP2DebugResult methodsFor: 'printing'!formattedText	self result isPetit2Failure ifTrue: [ 		^ Text string: self printString attribute: TextColor gray 	].		(self isBiggestChild) ifTrue: [  		^ Text string: self printString attribute: (TextColor new color: Color red muchDarker)	].		^ self printString! !!PP2DebugResult methodsFor: 'accessing'!furthestPosition	^ furthestPosition! !!PP2DebugResult methodsFor: 'accessing'!furthestPosition: anObject	furthestPosition := anObject! !!PP2DebugResult methodsFor: 'initialization'!initialize 	children := OrderedCollection new! !!PP2DebugResult methodsFor: 'accessing'!invocationEntry	self flag: 'JK: I don''t like the cyclic dependency between debug result and profiling info. Is there a better architecture for this?'.		^ invocationEntry! !!PP2DebugResult methodsFor: 'accessing'!invocationEntry: entry	invocationEntry := entry! !!PP2DebugResult methodsFor: 'printing'!isBiggestChild	parent isNil ifTrue: [ ^ false ].	^ (parent children sort: [ :c1 :c2 | c1 allResults size > c2 allResults size ]) first == self! !!PP2DebugResult methodsFor: 'accessing'!parent	^ parent! !!PP2DebugResult methodsFor: 'accessing'!parent: anObject	parent := anObject! !!PP2DebugResult methodsFor: 'accessing'!parser	^ parser! !!PP2DebugResult methodsFor: 'accessing'!parser: anObject	parser := anObject! !!PP2DebugResult methodsFor: 'printing'!printOn: aStream 	self parser ifNil: [ ^ super printOn: aStream ].	aStream 		nextPutAll: self parser displayName;		nextPutAll: '[';		nextPutAll: self parser withoutDebugStrategy displayName;	"first ones are the debugging ones, skip them"		nextPutAll: ']';		nextPutAll: '(';		nextPutAll: self allResults size asString;"		nextPutAll: ':';		nextPutAll: self events size asString;"		nextPutAll: ')';		nextPutAll: ' - ';   		nextPutAll: (self result printStringLimitedTo: 50).! !!PP2DebugResult methodsFor: 'accessing'!result	^ result! !!PP2DebugResult methodsFor: 'accessing'!result: anObject	result := anObject! !!PP2DebugResult methodsFor: 'accessing'!start	^ start! !!PP2DebugResult methodsFor: 'accessing'!start: anObject	start := anObject! !!PP2DebugResult methodsFor: 'accessing'!startStopInterval	(start isNil or: [stop isNil]) ifTrue: [ ^ 1 to: 0 ].		^ start to: stop ! !!PP2DebugResult methodsFor: 'analysis'!steps	^ self allResults size! !!PP2DebugResult methodsFor: 'accessing'!stop	^ stop! !!PP2DebugResult methodsFor: 'accessing'!stop: anObject	stop := anObject! !!PP2DebugResultLink class methodsFor: 'instance creation'!on: aPP2DebugResult	^ (self new)		reference: aPP2DebugResult;		yourself! !!PP2DebugResultLink methodsFor: 'analysis'!allResults	^ #()! !!PP2DebugResultLink methodsFor: 'analysis'!allResultsTo: aSet	^ aSet! !!PP2DebugResultLink methodsFor: 'converting'!asEventsMorph	^ reference asEventsMorph! !!PP2DebugResultLink methodsFor: 'accessing'!children	^ Array with: reference ! !!PP2DebugResultLink methodsFor: 'accessing'!contents	^ reference contents! !!PP2DebugResultLink methodsFor: 'accessing'!debugResult	^ self! !!PP2DebugResultLink methodsFor: 'printing'!formattedText	^ Text string: self printString attribute: (TextColor new color: Color blue muchDarker)! !!PP2DebugResultLink methodsFor: 'printing'!printOn: aStream 	super printOn: aStream.	aStream nextPutAll: ': reference'! !!PP2DebugResultLink methodsFor: 'accessing'!reference	^ reference! !!PP2DebugResultLink methodsFor: 'accessing'!reference: anObject	reference := anObject! !!PP2DebugResultLink methodsFor: 'accessing'!startStopInterval	^ reference startStopInterval! !!PP2EventRecord methodsFor: 'accessing'!event	^ event! !!PP2EventRecord methodsFor: 'accessing'!event: anObject	event := anObject! !!PP2EventRecord methodsFor: 'testing'!isInvocation	^ false! !!PP2EventRecord methodsFor: 'accessing'!node	^ strategy node! !!PP2EventRecord methodsFor: 'accessing'!position	^ position! !!PP2EventRecord methodsFor: 'accessing'!position: anObject	position := anObject! !!PP2EventRecord methodsFor: 'accessing'!strategy	^ strategy! !!PP2EventRecord methodsFor: 'accessing'!strategy: anObject	strategy := anObject! !!PP2InvocationRecord methodsFor: 'accessing'!debugResult	^ debugResult! !!PP2InvocationRecord methodsFor: 'accessing'!debugResult: anObject	debugResult := anObject! !!PP2InvocationRecord methodsFor: 'testing'!isInvocation	^ true! !!PP2InvocationRecord methodsFor: 'accessing'!start	^ start! !!PP2InvocationRecord methodsFor: 'accessing'!start: anObject	start := anObject! !!PP2InvocationRecord methodsFor: 'accessing'!stop	^ stop! !!PP2InvocationRecord methodsFor: 'accessing'!stop: anObject	stop := anObject! !!PP2EventsTrace methodsFor: 'adding'!addLast: aPP2ProfilingEvent	entries addLast: aPP2ProfilingEvent ! !!PP2EventsTrace methodsFor: 'accessing'!entries	^ entries! !!PP2EventsTrace methodsFor: 'accessing'!entries: aCollection	entries := aCollection! !!PP2EventsTrace methodsFor: 'enumerating'!entriesCollect: aBlock	^ entries collect: aBlock! !!PP2EventsTrace methodsFor: 'accessing'!entriesCount	^ entries size! !!PP2EventsTrace methodsFor: 'enumerating'!entriesDo: aBlock	^ entries do: aBlock! !!PP2EventsTrace methodsFor: 'accessing'!entryAt: index	^ entries at: index! !!PP2EventsTrace methodsFor: 'private'!filterEvents: eventsCollection	fEntries := OrderedCollection new.	self halt: 'obsolete?'.		self interval do: [ :index | | e |		e := self entries at: index.		(eventsCollection isNil or: [ eventsCollection includes: e event]) ifTrue: [			fEntries add: e.		]	].		^ fEntries! !!PP2EventsTrace methodsFor: 'initialization'!initialize	super initialize.		entries := OrderedCollection new! !!PP2EventsTrace methodsFor: 'accessing'!interval"		(start isNil not and: [stop isNil not]) ifTrue: [ 		^ (start to: stop)	]."	^ 1 to: entries size.! !!PP2EventsTrace methodsFor: 'accessing'!last	^ entries last! !!PP2EventsTrace methodsFor: 'accessing'!limit: eventsCollection	| limit |		eventsCollection isNil ifTrue: [ ^ entries size ].	limit := 0.			self interval do: [ :index | | e |		e := self entries at: index.		(eventsCollection includes: e event) ifTrue: [			limit := limit + 1		]	].		^ limit! !!PP2EventsTrace methodsFor: 'accessing'!selection	^ selection! !!PP2EventsTrace methodsFor: 'accessing'!selection: invocationEntry	selection := invocationEntry! !!PP2EventsTrace methodsFor: 'accessing'!selectionNode	^ selection isNil ifFalse: [ selection node ] ifTrue: [ nil  ]! !!PP2EventsTrace methodsFor: 'accessing'!selectionPosition	^ selection isNil ifFalse: [ selection position ] ifTrue: [ SmallInteger maxVal  ]! !!PP2EventsTrace methodsFor: 'accessing'!selectionStart	^ selection isNil ifFalse: [ selection start ] ifTrue: [ SmallInteger maxVal  ]! !!PP2EventsTrace methodsFor: 'accessing'!selectionStop	^ selection isNil ifFalse: [ selection stop ] ifTrue: [ SmallInteger minVal  ]! !!PP2EventsTrace methodsFor: 'accessing'!strategies	^ entries collect: #strategy! !!PP2Failure class methodsFor: 'instance creation'!message: aString	^ (self new )		message: aString;		position: 0		! !!PP2Failure class methodsFor: 'instance creation'!message: aString context: aPP2Context	^ self basicNew message: aString position: aPP2Context position! !!PP2Failure methodsFor: 'accessing'!context: aPP2Context	self flag: 'TODO FIX: so far use #setContext: as a setter'.	position := aPP2Context position! !!PP2Failure methodsFor: 'debugging'!debugResult	^ context debugResult! !!PP2Failure methodsFor: 'accessing'!furthestPosition	^ context furthestPosition! !!PP2Failure methodsFor: 'testing'!isPetit2Failure	^ true! !!PP2Failure methodsFor: 'testing'!isPetit2Success	^ false! !!PP2Failure methodsFor: 'accessing'!message	^ message! !!PP2Failure methodsFor: 'accessing'!message: anObject	message := anObject! !!PP2Failure methodsFor: 'accessing'!message: aString position: anInteger	message := aString.	position := anInteger! !!PP2Failure methodsFor: 'accessing'!parser	^ context parser! !!PP2Failure methodsFor: 'accessing'!position	^ position! !!PP2Failure methodsFor: 'accessing'!position: anObject	position := anObject! !!PP2Failure methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ': '.	self message printOn: aStream ! !!PP2Failure methodsFor: 'accessing'!returnValue	^ self! !!PP2Failure methodsFor: 'accessing'!setContext: aPP2Context	context := aPP2Context! !!PP2Memento methodsFor: 'accessing'!contextMemento	^ contextMemento! !!PP2Memento methodsFor: 'accessing'!contextMemento: anObject	contextMemento := anObject! !!PP2Memento methodsFor: 'accessing'!furthestPosition	^ furthestPosition! !!PP2Memento methodsFor: 'accessing'!furthestPosition: anObject	furthestPosition := anObject! !!PP2Memento methodsFor: 'testing'!isPromise	^ false! !!PP2Memento methodsFor: 'resolving'!resolveFor: parser in: context	^ self! !!PP2Memento methodsFor: 'accessing'!returnValue	^ returnValue! !!PP2Memento methodsFor: 'accessing'!returnValue: anObject	returnValue := anObject! !!PP2CFMemoization methodsFor: 'testing'!isContextFree	^ true! !!PP2CFMemoization methodsFor: 'memoization'!remember: context	^ context rememberPosition ! !!PP2CFMemoization methodsFor: 'memoization'!restore: context from: memento	context restorePosition: memento! !!PP2CSMemoization methodsFor: 'testing'!isContextFree	^ false! !!PP2CSMemoization methodsFor: 'memoization'!remember: context	^ context remember ! !!PP2CSMemoization methodsFor: 'memoization'!restore: context from: memento	context restore: memento! !!PP2Memoization methodsFor: 'memoization'!remember: context	self subclassResponsibility ! !!PP2Memoization methodsFor: 'memoization'!restore: context from: memento	self subclassResponsibility ! !!PP2PopMemoization methodsFor: 'memoization'!remember: context	"TODO JK: make it working with other than default stacks"	^ PP2PopMemento new 		position: context rememberPosition;		stackSize: context defaultStack size;		stackTop: context defaultStack top;		yourself	! !!PP2PopMemoization methodsFor: 'memoization'!restore: context from: memento	context restorePosition: memento position.	context defaultStack size < memento stackSize ifTrue: [ 			context defaultStack push: memento stackTop.	]! !!PP2PushMemoization methodsFor: 'memoization'!remember: context	"TODO JK: make it working with other than default stacks"	^ PP2PushMemento new 		position: context rememberPosition;		stackSize: context defaultStack size;		yourself	! !!PP2PushMemoization methodsFor: 'memoization'!restore: context from: memento	context restorePosition: memento position.	context defaultStack size > memento stackSize ifTrue: [ 			context defaultStack pop	]! !!PP2AdaptableNode methodsFor: 'visiting'!accept: visitor	^ visitor visitAdaptable: self! !!PP2AdaptableNode methodsFor: 'transforming'!changeChild: newChild	child := newChild! !!PP2AdaptableNode methodsFor: 'visiting'!child	^ child! !!PP2AdaptableNode methodsFor: 'accessing'!children	^ child isNil ifTrue: [ Array new ] ifFalse: [ Array with: child ]! !!PP2AdaptableNode methodsFor: 'testing'!isAdaptable	^ true! !!PP2AdaptableNode methodsFor: 'testing'!isFirstSetTerminal	^ false! !!PP2AdaptableNode methodsFor: 'transforming'!resetStrategy	strategy := PP2Delegate on: self! !!PP2AbstractActionNode class methodsFor: 'instance creation'!on: node block: aBlock	^ self new		child: node;		block: aBlock;		yourself! !!PP2AbstractActionNode methodsFor: 'accessing'!block	"Answer the action block of the receiver."	^ block! !!PP2AbstractActionNode methodsFor: 'accessing'!block: anObject	block := anObject! !!PP2AbstractActionNode methodsFor: 'comparing'!localEquals: anotherNode	(super localEquals: anotherNode) ifFalse: [ ^ false ].		^ (self block printString = anotherNode block printString)! !!PP2AbstractActionNode methodsFor: 'comparing'!localHash	^ super localHash bitXor: block printString hash! !!PP2ActionNode methodsFor: 'visiting'!accept: aPP2Visitor	^ aPP2Visitor visitAction: self! !!PP2ActionNode methodsFor: 'initialization'!resetStrategy	strategy := PP2Action on: self! !!PP2MappingNode methodsFor: 'visiting'!accept: aPP2Visitor	^ aPP2Visitor visitMapping: self! !!PP2MappingNode methodsFor: 'initialization'!resetStrategy	strategy := PP2Mapping on: self! !!PP2WrappingNode methodsFor: 'visiting'!accept: aPP2Visitor	^ aPP2Visitor visitWrapping: self! !!PP2WrappingNode methodsFor: 'testing'!doesFunctionalChanges	^ self propertyAt: #functionalChanges! !!PP2WrappingNode methodsFor: 'analysis - first'!firstCharSet	^ self doesFunctionalChanges ifTrue: [ 		PP2UnknownCharSetPredicate instance	] ifFalse: [  		child firstCharSet	]! !!PP2WrappingNode methodsFor: 'accessing'!functionalChanges: aBoolean	self propertyAt: #functionalChanges put: aBoolean! !!PP2WrappingNode methodsFor: 'initialization'!initialize	super initialize.	self functionalChanges: true.! !!PP2WrappingNode methodsFor: 'analysis - first'!isFirstSetTerminal	"lets be conservative here"	self doesFunctionalChanges ifTrue: [  		^ true	].	^ false! !!PP2WrappingNode methodsFor: 'initialization'!resetStrategy	strategy := PP2Wrapping on: self! !!PP2AndNode methodsFor: 'visiting'!accept: aPP2Visitor	^ aPP2Visitor visitAnd: self! !!PP2AndNode methodsFor: 'operators'!and	^ self! !!PP2AndNode methodsFor: 'initialization'!resetStrategy	strategy := PP2And on: self! !!PP2CompositeNode class methodsFor: 'accessing'!ignoredNames	"Answer a collection of instance-variables that should not be automatically initialized with productions, but that are used internal to the composite parser."	^ PP2CompositeNode allInstVarNames! !!PP2CompositeNode class methodsFor: 'instance creation'!new	"Answer a new parser starting at the default start symbol."	^ self newStartingAt: self startSymbol! !!PP2CompositeNode class methodsFor: 'instance creation'!newStartingAt: aSymbol	"Answer a new parser starting at aSymbol."	^ self basicNew		initializeStartingAt: aSymbol;		yourself! !!PP2CompositeNode class methodsFor: 'parsing'!parse: anObject	^ self parse: anObject startingAt: self startSymbol! !!PP2CompositeNode class methodsFor: 'parsing'!parse: anObject onError: aBlock	^ self parse: anObject startingAt: self startSymbol onError: aBlock! !!PP2CompositeNode class methodsFor: 'parsing'!parse: anObject startingAt: aSymbol	^ (self newStartingAt: aSymbol) parse: anObject! !!PP2CompositeNode class methodsFor: 'parsing'!parse: anObject startingAt: aSymbol onError: aBlock	^ (self newStartingAt: aSymbol) parse: anObject onError: aBlock! !!PP2CompositeNode class methodsFor: 'accessing'!startSymbol	"Answer the method that represents the default start symbol."	^ #start! !!PP2CompositeNode methodsFor: 'visiting'!accept: visitor	^ visitor visitComposite: self! !!PP2CompositeNode methodsFor: 'initialization'!initializeStartingAt: aSymbol	| parser |	self initialize.	self productionNames keysAndValuesDo: [ :key :value |		self instVarAt: key put: (PP2DelegateNode named: value) 	].	self productionNames keysAndValuesDo: [ :key :value |		parser := self perform: value.		self assert: parser ~= self description: 'you probably forgot to return the parser in "', value, '"'.		(self instVarAt: key) child: parser 	].	child := (self perform: aSymbol)! !!PP2CompositeNode methodsFor: 'testing'!isProduction	^ false! !!PP2CompositeNode methodsFor: 'querying'!productionAt: aSymbol	"Answer the production named aSymbol."		^ self productionAt: aSymbol ifAbsent: [ nil ]! !!PP2CompositeNode methodsFor: 'querying'!productionAt: aSymbol ifAbsent: aBlock	"Answer the production named aSymbol, if there is no such production answer the result of evaluating aBlock."		(self class ignoredNames includes: aSymbol asString)		ifTrue: [ ^ aBlock value ].	(self class startSymbol = aSymbol)		ifTrue: [ ^ child ].	^ self instVarAt: (self class allInstVarNames		indexOf: aSymbol asString		ifAbsent: [ ^ aBlock value ])! !!PP2CompositeNode methodsFor: 'querying'!productionNames	"Answer a dictionary of slot indexes and production names."		| productionNames ignoredNames |	productionNames := Dictionary new.	ignoredNames := self class ignoredNames		collect: [ :each | each asSymbol ].	self class allInstVarNames keysAndValuesDo: [ :key :value |		(ignoredNames includes: value asSymbol)			ifFalse: [ productionNames at: key put: value asSymbol ] ].	^ productionNames! !!PP2CompositeNode methodsFor: 'accessing'!start	"Answer the production to start this parser with."		self subclassResponsibility! !!PP2ExpressionGrammar methodsFor: 'grammar'!addition	^ primary, plus trim, terms! !!PP2ExpressionGrammar methodsFor: 'tokens'!closeBracket	^ $) asPParser! !!PP2ExpressionGrammar methodsFor: 'grammar'!multiplication	^ primary, star trim, terms! !!PP2ExpressionGrammar methodsFor: 'tokens'!number	^ ($- asPParser optional , #digit asPParser plus , ($. asPParser, #digit asPParser plus) optional) flatten! !!PP2ExpressionGrammar methodsFor: 'tokens'!openBracket	^ $( asPParser! !!PP2ExpressionGrammar methodsFor: 'grammar'!parentheses	^ openBracket trim , terms , closeBracket trim! !!PP2ExpressionGrammar methodsFor: 'tokens'!plus	^ $+ asPParser! !!PP2ExpressionGrammar methodsFor: 'grammar'!primary	^ number / parentheses! !!PP2ExpressionGrammar methodsFor: 'tokens'!star	^ $* asPParser! !!PP2ExpressionGrammar methodsFor: 'accessing'!start	^ terms end! !!PP2ExpressionGrammar methodsFor: 'grammar'!terms	^ addition / multiplication / primary! !!PP2ExpressionParser methodsFor: 'tokens'!number	^ super number ==> #asNumber! !!PP2HtmlHeaderGrammar class methodsFor: 'example'!example	| byteStream stream |	byteStream := ZnClient new 		url: 'http://pharo.org';  		streaming: true;  		get.	stream := PP2CharacterStream on: byteStream encoder: ZnUTF8Encoder new.	^ PP2HtmlHeaderGrammar new optimize parse: stream! !!PP2HtmlHeaderGrammar methodsFor: 'rules'!bodyStart	^ '<body' asPParser! !!PP2HtmlHeaderGrammar methodsFor: 'rules'!header	^ '<head>' asPParser, #any asPParser starLazy, '</head>' asPParser		map: [ :_begin :_content :_end |		(_content inject: (WriteStream on: String new) into: [ :stream :char | stream nextPut: char. stream ]) 			contents	]! !!PP2HtmlHeaderGrammar methodsFor: 'rules'!headerStart	^ '<head' asPParser! !!PP2HtmlHeaderGrammar methodsFor: 'rules'!htmlFragment	^ (#any asPParser starLazy: (headerStart / bodyStart)), header ==> #second! !!PP2HtmlHeaderGrammar methodsFor: 'accessing'!start	^ htmlFragment! !!PP2CreateTokenNode methodsFor: 'visiting'!accept: aPP2Visitor	self flag: 'JK: rename to visitCreateTokenNode: (???)'.	^ aPP2Visitor visitToken: self! !!PP2CreateTokenNode methodsFor: 'private'!defaultTokenClass	^ PP2Token! !!PP2CreateTokenNode methodsFor: 'initialization'!initialize	super initialize.	tokenClass := self defaultTokenClass! !!PP2CreateTokenNode methodsFor: 'testing'!isToken	^ true! !!PP2CreateTokenNode methodsFor: 'comparing'!localEquals: anotherNode	(super localEquals: anotherNode) ifFalse: [ ^ false ].	^ self tokenClass == anotherNode tokenClass! !!PP2CreateTokenNode methodsFor: 'comparing'!localHash	^ super localHash bitXor: tokenClass hash! !!PP2CreateTokenNode methodsFor: 'visiting'!nodeName	^ self name! !!PP2CreateTokenNode methodsFor: 'initialization'!resetStrategy	strategy := PP2CreateToken on: self! !!PP2CreateTokenNode methodsFor: 'accessing'!tokenClass	^ tokenClass! !!PP2CreateTokenNode methodsFor: 'accessing'!tokenClass: anObject	tokenClass := anObject! !!PP2CsNode methodsFor: 'visiting'!accept: visitor	self subclassResponsibility ! !!PP2CsNode methodsFor: 'initialization'!resetStrategy	self subclassResponsibility ! !!PP2CsNode methodsFor: 'accessing'!stackId	^ stackId ifNil: [ #defaultStack ] ifNotNil: [ stackId ]! !!PP2CsNode methodsFor: 'accessing'!stackId: id	^ stackId := id! !!PP2MatchNode methodsFor: 'visiting'!accept: visitor	^ visitor visitMatch: self! !!PP2MatchNode methodsFor: 'initialization'!resetStrategy	strategy := PP2Match on: self! !!PP2PopNode methodsFor: 'visiting'!accept: visitor	^ visitor visitPop: self! !!PP2PopNode methodsFor: 'initialization'!resetStrategy	strategy := PP2Pop on: self! !!PP2PushNode methodsFor: 'visiting'!accept: visitor	^ visitor visitPush: self! !!PP2PushNode methodsFor: 'initialization'!resetStrategy	strategy := PP2Push on: self! !!PP2DelegateNode class methodsFor: 'instance creation'!on: node	^ self new child: node			! !!PP2DelegateNode methodsFor: 'visiting'!accept: aPP2Visitor	^ aPP2Visitor visitDelegate: self! !!PP2DelegateNode methodsFor: 'transforming'!changeChild: newChild	self assert: child isAdaptable.	child changeChild: newChild.! !!PP2DelegateNode methodsFor: 'accessing'!child	^ child! !!PP2DelegateNode methodsFor: 'accessing'!child: newChild	child := newChild! !!PP2DelegateNode methodsFor: 'accessing'!childSkipDelegate	^ child isJustDelegate ifTrue: [  child child ] ifFalse: [	^ child ]! !!PP2DelegateNode methodsFor: 'accessing'!children	^ Array with: child! !!PP2DelegateNode methodsFor: 'optimizations - caching'!isCacheForbidden	self isJustDelegate ifFalse: [  		^ super isCacheForbidden 	].	^ super isCacheForbidden or: [ self child isCacheForbidden  ]! !!PP2DelegateNode methodsFor: 'testing'!isDelegate	^ true! !!PP2DelegateNode methodsFor: 'testing'!isJustDelegate	^ self class == PP2DelegateNode ! !!PP2DelegateNode methodsFor: 'transforming'!replace: node with: anotherNode	child == node ifTrue: [ child := anotherNode ]! !!PP2DelegateNode methodsFor: 'initialization'!resetStrategy	strategy := PP2Delegate on: self! !!PP2EndNode methodsFor: 'visiting'!accept: aPP2Visitor	^ aPP2Visitor visitEnd: self! !!PP2EndNode methodsFor: 'operators'!end	^ self! !!PP2EndNode methodsFor: 'initialization'!resetStrategy	strategy := PP2End on: self! !!PP2FlattenNode methodsFor: 'visiting'!accept: aPP2Visitor	^ aPP2Visitor visitFlatten: self! !!PP2FlattenNode methodsFor: 'initialization'!resetStrategy	strategy := PP2Flatten on: self! !!PP2NonEpsilonNode methodsFor: 'visiting'!accept: visitor	^ visitor visitNonEpsilon: self! !!PP2NonEpsilonNode methodsFor: 'initialization'!resetStrategy	strategy := PP2NonEpsilon on: self! !!PP2NotNode methodsFor: 'visiting'!accept: aPP2Visitor	^ aPP2Visitor visitNot: self! !!PP2NotNode methodsFor: 'analysis - first'!firstCharSet	^ PP2UnknownCharSetPredicate instance! !!PP2NotNode methodsFor: 'analysis - first'!isFirstSetTerminal	^ true! !!PP2NotNode methodsFor: 'parsing - private'!parseOn: aPP2Context	^ strategy parseOn: aPP2Context ! !!PP2NotNode methodsFor: 'initialization'!resetStrategy	strategy := PP2Not on: self! !!PP2OptionalNode methodsFor: 'visiting'!accept: aPP2Visitor	^ aPP2Visitor visitOptional: self! !!PP2OptionalNode methodsFor: 'parsing - private'!parseOn: aPP2Context	^ strategy parseOn: aPP2Context ! !!PP2OptionalNode methodsFor: 'initialization'!resetStrategy	strategy := PP2Optional on: self! !!PP2PossesiveRepeatingNode methodsFor: 'visiting'!accept: aPP2Visitor	^ aPP2Visitor visitPossesiveRepeating: self! !!PP2PossesiveRepeatingNode methodsFor: 'comparing'!hash	^ super hash bitXor: (min hash bitXor: max hash)! !!PP2PossesiveRepeatingNode methodsFor: 'comparing'!localEquals: anotherNode	(super localEquals: anotherNode) ifFalse: [ ^ false ].		self min = anotherNode min ifFalse: [ ^ false ].	self max = anotherNode max ifFalse: [ ^ false ].	^ true! !!PP2PossesiveRepeatingNode methodsFor: 'initialization'!resetStrategy	strategy := PP2PossesiveRepeating on: self! !!PP2RepeatingNode methodsFor: 'visiting'!accept: aPP2Visitor	^ aPP2Visitor visitRepeating: self! !!PP2RepeatingNode methodsFor: 'initialization'!initialize	super initialize.	min := 0.	max := Float infinity.! !!PP2RepeatingNode methodsFor: 'testing'!isRepeating	^ true! !!PP2RepeatingNode methodsFor: 'accessing'!max	^ max! !!PP2RepeatingNode methodsFor: 'accessing'!max: anObject	max := anObject! !!PP2RepeatingNode methodsFor: 'accessing'!min	^ min! !!PP2RepeatingNode methodsFor: 'accessing'!min: anObject	min := anObject! !!PP2TrimmingNode methodsFor: 'visiting'!accept: aPP2Visitor	^ aPP2Visitor visitTrimming: self! !!PP2TrimmingNode methodsFor: 'accessing'!children	^ Array with: trimmer with: child! !!PP2TrimmingNode methodsFor: 'testing'!isTrimming	^ true! !!PP2TrimmingNode methodsFor: 'testing'!isTrimmingToken	^ self child isToken! !!PP2TrimmingNode methodsFor: 'parsing - private'!parseOn: aPP2Context	^ strategy parseOn: aPP2Context ! !!PP2TrimmingNode methodsFor: 'transforming'!replace: node with: anotherNode	node == child ifTrue: [ child := anotherNode ].	node == trimmer ifTrue: [ trimmer := anotherNode ].! !!PP2TrimmingNode methodsFor: 'initialization'!resetStrategy	strategy := PP2Trimming on: self! !!PP2TrimmingNode methodsFor: 'accessing'!trimmer	^ trimmer ! !!PP2TrimmingNode methodsFor: 'accessing'!trimmer: aPP2arser	trimmer := aPP2arser! !!PP2EndOfInputNode methodsFor: 'visiting'!accept: aPP2Visitor	^ aPP2Visitor visitEndOfInput: self! !!PP2EndOfInputNode methodsFor: 'accessing'!firstCharSet	"	 Because the end of input is not 'real' character in the input stream,	 PP2 cannot compare end of input with a peek character.	"	^ PP2UnknownCharSetPredicate instance! !!PP2EndOfInputNode methodsFor: 'testing'!isEOI	^ true	! !!PP2EndOfInputNode methodsFor: 'initialization'!resetStrategy	strategy := PP2EndOfInput on: self! !!PP2EndOfLineNode methodsFor: 'visiting'!accept: visitor	^ visitor visitEndOfLine: self! !!PP2EndOfLineNode methodsFor: 'accessing'!firstCharSet	^ PP2UnknownCharSetPredicate instance! !!PP2EndOfLineNode methodsFor: 'accessing'!resetStrategy	strategy := PP2EndOfLine on: self! !!PP2EpsilonNode class methodsFor: 'accessing'!instance	instance isNil ifTrue: [ 		instance := PP2EpsilonNode basicNew initialize	].	instance resetStrategies.	^ instance! !!PP2EpsilonNode class methodsFor: 'instance creation'!new	^ self instance! !!PP2EpsilonNode methodsFor: 'visiting'!accept: aPP2Visitor	^ aPP2Visitor visitEpsilon: self! !!PP2EpsilonNode methodsFor: 'analysis - first'!firstCharSet	^ PP2CharSetPredicate any! !!PP2EpsilonNode methodsFor: 'testing'!isEpsilon	^ true! !!PP2EpsilonNode methodsFor: 'operators'!nonEpsilon	^	#failure asPParser! !!PP2EpsilonNode methodsFor: 'initialization'!resetStrategy	strategy := PP2Epsilon on: self! !!PP2FailingNode class methodsFor: 'as yet unclassified'!instance	instance isNil ifTrue: [ 		instance := PP2FailingNode message: 'failing'	].	^ instance! !!PP2FailingNode class methodsFor: 'as yet unclassified'!message: aString	^ self new message: aString! !!PP2FailingNode methodsFor: 'visiting'!accept: aPP2Visitor	^ aPP2Visitor visitFailing: self! !!PP2FailingNode methodsFor: 'analysis'!firstCharSet	^ PP2CharSetPredicate empty! !!PP2FailingNode methodsFor: 'comparing'!localEquals: anotherNode	(super localEquals: anotherNode) ifFalse: [ ^ false ].		^ self message = anotherNode message! !!PP2FailingNode methodsFor: 'comparing'!localHash	^ super localHash bitXor: message hash! !!PP2FailingNode methodsFor: 'accessing'!message	^ message! !!PP2FailingNode methodsFor: 'accessing'!message: anObject	message := anObject! !!PP2FailingNode methodsFor: 'initialization'!resetStrategy	strategy := PP2Failing on: self! !!PP2ChoiceNode methodsFor: 'operators'!/ aRule 	^ self copyWith: aRule! !!PP2ChoiceNode methodsFor: 'visiting'!accept: aPP2Visitor	^ aPP2Visitor visitChoice: self! !!PP2ChoiceNode methodsFor: 'parsing - private'!parseOn: aPP2Context	^ strategy parseOn: aPP2Context ! !!PP2ChoiceNode methodsFor: 'initialization'!resetStrategy	strategy := PP2Choice on: self! !!PP2ListNode class methodsFor: 'as yet unclassified'!with: aParser	^ self withAll: (Array with: aParser)! !!PP2ListNode class methodsFor: 'as yet unclassified'!with: aFirstParser with: aSecondParser	^ self withAll: (Array with: aFirstParser with: aSecondParser)! !!PP2ListNode class methodsFor: 'as yet unclassified'!withAll: aCollection	^ self new		children: aCollection;		yourself! !!PP2ListNode methodsFor: 'visiting'!accept: aPP2Visitor	^ self subclassResponsibility! !!PP2ListNode methodsFor: 'accessing'!children	^ children! !!PP2ListNode methodsFor: 'accessing'!children: aCollection	^ children := aCollection! !!PP2ListNode methodsFor: 'copying'!copyWith: aParser	^ self species withAll: (children copyWith: aParser)! !!PP2ListNode methodsFor: 'accessing'!firstChild	^ self children at: 1! !!PP2ListNode methodsFor: 'initialization'!initialize	super initialize.	self children: #()! !!PP2ListNode methodsFor: 'copying'!postCopy	super postCopy.	children := children copy! !!PP2ListNode methodsFor: 'transforming'!replace: child with: anotherChild	children keysAndValuesDo: [ :index :e |		e == child ifTrue: [ children at: index put: anotherChild ] 	]! !!PP2ListNode methodsFor: 'accessing'!secondChild	^ self children at: 2! !!PP2ListNode methodsFor: 'accessing'!thirdChild	^ self children at: 3! !!PP2SequenceNode methodsFor: 'operators'!, aRule	^ self copyWith: aRule! !!PP2SequenceNode methodsFor: 'visiting'!accept: aPP2Visitor	^ aPP2Visitor visitSequence: self! !!PP2SequenceNode methodsFor: 'accessing'!children: newChildren	super children: newChildren! !!PP2SequenceNode methodsFor: 'initialization'!resetStrategy	strategy := PP2Sequence on: self! !!PP2LiteralNode class methodsFor: 'as yet unclassified'!on: literal	^ self on: literal message: 'literal ', literal printString, ' expected'! !!PP2LiteralNode class methodsFor: 'as yet unclassified'!on: literal message: message	^ self new		literal: literal;		message: message;		yourself! !!PP2LiteralNode methodsFor: 'visiting'!accept: aPP2Visitor	^ aPP2Visitor visitLiteral: self! !!PP2LiteralNode methodsFor: 'accessing'!literal	^ literal! !!PP2LiteralNode methodsFor: 'accessing'!literal: anObject	literal := anObject! !!PP2LiteralNode methodsFor: 'comparing'!localEquals: anotherNode	(super localEquals: anotherNode) ifFalse: [ ^ false ].		self literal = anotherNode literal ifFalse: [ ^ false ].	self message = anotherNode message ifFalse: [ ^ false ].		^ true! !!PP2LiteralNode methodsFor: 'comparing'!localHash	^ super localHash bitXor: (self literal hash bitXor: self message hash)! !!PP2LiteralNode methodsFor: 'accessing'!message	^ message! !!PP2LiteralNode methodsFor: 'accessing'!message: anObject	message := anObject! !!PP2LiteralObjectNode methodsFor: 'visiting'!accept: aPP2Visitor	^ aPP2Visitor visitLiteralObject: self! !!PP2LiteralObjectNode methodsFor: 'operators'!caseInsensitive	"Answer a parser that can parse the receiver case-insensitive."		literal asUppercase = literal asLowercase ifTrue: [ ^ self ].	^ PP2PredicateObjectNode on: [ :value | literal sameAs: value ] message: message! !!PP2LiteralObjectNode methodsFor: 'analysis - first'!firstCharSet	^ PP2CharSetPredicate on: [ :e | e = literal ]! !!PP2LiteralObjectNode methodsFor: 'operators'!negate	^ (PP2PredicateObjectNode expect: literal message: message) negate! !!PP2LiteralObjectNode methodsFor: 'parsing - private'!parseOn: aPP2Context	^ strategy parseOn: aPP2Context ! !!PP2LiteralObjectNode methodsFor: 'initialization'!resetStrategy	strategy := PP2LiteralObject on: self! !!PP2LiteralSequenceNode methodsFor: 'visiting'!accept: aPP2Visitor	^ aPP2Visitor visitLiteralSequence: self! !!PP2LiteralSequenceNode methodsFor: 'operators'!caseInsensitive	"Answer a parser that can parse the receiver case-insensitive."		literal asUppercase = literal asLowercase ifTrue: [ ^ self ].	^ PP2PredicateSequenceNode 		on: [ :value | literal sameAs: value ] 		message: message		size: literal size! !!PP2LiteralSequenceNode methodsFor: 'analysis - first'!firstCharSet	^ (literal = '') ifTrue: [ 		PP2CharSetPredicate any	] ifFalse: [ 		PP2CharSetPredicate on: [ :e | self literal first = e ]	]! !!PP2LiteralSequenceNode methodsFor: 'parsing - private'!parseOn: aPP2Context	^ strategy parseOn: aPP2Context ! !!PP2LiteralSequenceNode methodsFor: 'initialization'!resetStrategy	strategy := PP2LiteralSequence  on: self! !!PP2LiteralSequenceNode methodsFor: 'accessing'!size	^ literal size! !!PP2NewLineNode methodsFor: 'visiting'!accept: visitor	^ visitor visitNewLine: self! !!PP2NewLineNode methodsFor: 'accessing'!firstCharSet	^ PP2CharSetPredicate on: [ :e | e = Character cr or: [ e = Character lf ] ]! !!PP2NewLineNode methodsFor: 'initialization'!resetStrategy	strategy := PP2NewLine on: self! !!PP2Node class methodsFor: 'instance creation'!named: aString	^ self new name: aString! !!PP2Node class methodsFor: 'instance creation'!new	"for compatibility reasons with Smalltalk/X"	^ self basicNew 		initialize! !!PP2Node methodsFor: 'operators'!, anotherParser	^ PP2SequenceNode with: self with: anotherParser! !!PP2Node methodsFor: 'operators'!/ aParser 	"Answer a new parser that parses the receiver, if the receiver fails try with aParser (ordered-choice)."		^ PP2ChoiceNode with: self with: aParser! !!PP2Node methodsFor: 'comparing'!= anotherNode	^ self equals: anotherNode visitedSet: IdentitySet new		"			Note: should not be really overriden by children, try to 				override #equals:, unless you know what you are doing, 				of course :)	"! !!PP2Node methodsFor: 'operators'!==> aBlock	"Answer a new parser that performs aBlock as action handler on success."	^ PP2ActionNode on: self block: aBlock! !!PP2Node methodsFor: 'operators'!>==> aBlock	"		Make sure that the block does not perform any functional changes, otherwise all the optimizations break.			Use #>=> if you need to do functional changes.	"	^ (PP2WrappingNode on: self block: aBlock)		functionalChanges: false;		yourself! !!PP2Node methodsFor: 'operators'!>=> aBlock	"Answer a new parser that performs aBlock as action handler on success."	^ PP2WrappingNode on: self block: aBlock! !!PP2Node methodsFor: 'visiting'!accept: aPP2ParserVisitor	self subclassResponsibility ! !!PP2Node methodsFor: 'optimizations'!addParent: value	self parents add: value! !!PP2Node methodsFor: 'optimizations - warnings'!addWarning: warning	self warnings add: warning.		"Transcript crShow: warning"! !!PP2Node methodsFor: 'optimizations - caching'!allCaches	^ self propertyAt: #allCaches ifAbsent: [		self collectCaches	]! !!PP2Node methodsFor: 'enumerating'!allNodes"	^ PP2ChildrenVisitor new visit: self"	"faster version than visitor:"	| result |	result := OrderedCollection new.	self allNodesDo: [ :parser | result addLast: parser ].	^ result! !!PP2Node methodsFor: 'enumerating'!allNodesDo: aBlock	^ self allNodesDo: aBlock seen: IdentitySet new! !!PP2Node methodsFor: 'enumerating'!allNodesDo: aBlock seen: aSet	"		Iterate over all the parse nodes of the receiver, do not visit the ones contained in aSet.	"	(aSet includes: self) ifTrue: [ ^ self ].	aSet add: self.		aBlock value: self.	self children do: [ :each | each allNodesDo: aBlock seen: aSet ]! !!PP2Node methodsFor: 'optimizations - warnings'!allWarnings	| warnings |	warnings := Dictionary new.	self allNodesDo: [ :node | 		node warnings do: [ :w | warnings at: node put: w ]	].	^ warnings! !!PP2Node methodsFor: 'operators'!and	^ PP2AndNode on: self! !!PP2Node methodsFor: 'converting'!asPParser	^ self! !!PP2Node methodsFor: 'parsing'!changeStrategy: aPP2Strategy	"		Contrary to the #strategy:, I do not assert the identity equivalence of the node.		This means you can you the same strategy with multiple nodes, as long as the nodes		are equivalent (i.e. nodeOne = node2)	"	self assert: (aPP2Strategy node = self).	strategy := aPP2Strategy! !!PP2Node methodsFor: 'accessing'!childAt: index	^ self children at: index! !!PP2Node methodsFor: 'accessing'!children	^ #()! !!PP2Node methodsFor: 'comparing'!childrenEqual: anotherNode visitedSet: visitedSet	"		Invokes the comparison function on all children, while passing the visited		set to avoid infinite loops.	"	self children size = anotherNode children size ifFalse: [ ^ false ].		self children with: anotherNode children do: [ :child :anotherChild |		(child equals: anotherChild visitedSet: visitedSet) ifFalse: [ ^ false ]	].	^ true! !!PP2Node methodsFor: 'comparing'!childrenHash: visitedSet	| hash |	hash := '' hash.	self children do: [ :child |		hash := hash bitXor: (child hash: visitedSet)	].	^ hash! !!PP2Node methodsFor: 'optimizations - caching'!collectCaches	| caches |	caches := IdentitySet new. 	self allNodesDo: [ :c | c strategies do: [ :s | s isCache ifTrue: [ caches add: s ] ] ].	^ caches asArray! !!PP2Node methodsFor: 'analysis - context'!contextChanges	^ self propertyAt: #contextChanges ifAbsent: [  		PP2ContextChangesVisitor new visit: self	]! !!PP2Node methodsFor: 'analysis - context'!contextChanges: aPP2CaResult	self assert: (aPP2CaResult isKindOf: PP2CcResult).	^ self propertyAt: #contextChanges put: aPP2CaResult! !!PP2Node methodsFor: 'accessing'!debug: input	^ self 		enableDebug enableRecording 		parse: input withContext: PP2RecordingContext new! !!PP2Node methodsFor: 'debugging'!debug: input withContext: startContext	^ self enableDebug parse: input withContext: startContext! !!PP2Node methodsFor: 'debugging'!debugAdaptableWithContext: context	^ self enableDebug parseAdaptableWithContext: context! !!PP2Node methodsFor: 'operators'!def: node	"Redefine the receiver as the argument 'node'. This method is useful when defining recursive parsers: instantiate a PP2UnresolvedNode and later redefine it with another one."	^ self becomeForward: (node name: self name)! !!PP2Node methodsFor: 'operators - convenience'!delimitedBy: aParser	"Answer a new parser that parses the receiver one or more times, separated and possibly ended by aParser."		^ (self separatedBy: aParser) , (aParser optional) ==> [ :node |		node second isNil			ifTrue: [ node first ]			ifFalse: [ node first copyWith: node second ] ]! !!PP2Node methodsFor: 'optimizations'!deoptimize	self isOptimized ifFalse: [ ^ self ].	self allNodesDo: [ :node | node resetStrategies ].	self unsetOptimized.! !!PP2Node methodsFor: 'copying'!duplicate	^ self transform: [ :node | node copy ]! !!PP2Node methodsFor: 'debugging'!enableDebug	self allNodesDo: [ :child | child strategy: child strategy debug ]! !!PP2Node methodsFor: 'debugging'!enableRecording	| parent |	self allNodesDo: [ :node | 		parent := node.		node strategies do: [ :s | 			parent := self switchToRecording: s parent: parent.		]	].	"The caches has been changed to their recording equivalents, the info needs to be updated"	self refreshCaches.! !!PP2Node methodsFor: 'operators'!end	"		$a asPParser end parse: 'a'.		$a asPParser end parse: 'ab'.			"	^ PP2EndNode on: self! !!PP2Node methodsFor: 'comparing'!equals: anotherNode visitedSet: visitedSet	self == anotherNode ifTrue: [ ^ true ].		"		Manages visited set in order to avoid inifinite loops, I don't see much reasons to		override this method.	"	(visitedSet includes: self) ifTrue: [ ^ true ].	(visitedSet add: self).	(self localEquals: anotherNode) ifFalse: [ ^ false ].		(self childrenEqual: anotherNode visitedSet: visitedSet) ifFalse: [ ^ false ].		^ true! !!PP2Node methodsFor: 'analysis - first'!firstProductionSet	^ self propertyAt: #firstProductionSet ifAbsent: [		PP2FirstSetVisitor productionSet visit: self	]! !!PP2Node methodsFor: 'analysis - first'!firstSeasOrTerminalsSet	^ self propertyAt: #firstSeasOrTerminals ifAbsent: [		PP2FirstSetVisitor seasOrTerminalsSet visit: self	]! !!PP2Node methodsFor: 'analysis - first'!firstSet	^ self propertyAt: #firstSet ifAbsent: [		PP2FirstSetVisitor firstSet visit: self	]! !!PP2Node methodsFor: 'operators'!flatten	^ PP2FlattenNode on: self! !!PP2Node methodsFor: 'operators - mapping'!foldLeft: aBlock	"Answer a new parser that that folds the result of the receiver from left-to-right into aBlock. The argument aBlock must take two or more arguments."		| size args |	size := aBlock numArgs.	args := Array new: size.	^ self ==> [ :nodes |		args at: 1 put: nodes first.		2 to: nodes size by: size - 1 do: [ :index |			args				replaceFrom: 2 to: size with: nodes startingAt: index;				at: 1 put: (aBlock valueWithArguments: args) ].		args first ]! !!PP2Node methodsFor: 'operators - mapping'!foldRight: aBlock	"Answer a new parser that that folds the result of the receiver from right-to-left into aBlock. The argument aBlock must take two or more arguments."	| size args |	size := aBlock numArgs.	args := Array new: size.	^ self ==> [ :nodes |		args at: size put: nodes last.		nodes size - size + 1 to: 1 by: 1 - size do: [ :index |			args				replaceFrom: 1 to: size - 1 with: nodes startingAt: index;				at: size put: (aBlock valueWithArguments: args) ].		args at: size ]! !!PP2Node methodsFor: 'optimizations - caching'!forbidCache	^ self propertyAt: #cacheAllowed put: false! !!PP2Node methodsFor: 'testing'!hasName	^ self name isNil not! !!PP2Node methodsFor: 'comparing'!hash	^ self hash: IdentitySet new! !!PP2Node methodsFor: 'comparing'!hash: visitedSet	"		Manages visited set in order to avoid inifinite loops, I don't see much reasons to		override this method.	"	(visitedSet includes: self) ifTrue: [ ^ '' hash ].	(visitedSet add: self).	^ self localHash bitXor: (self childrenHash: visitedSet)! !!PP2Node methodsFor: 'initialization'!initialize	self resetStrategies! !!PP2Node methodsFor: 'testing'!isAdaptable	^ false! !!PP2Node methodsFor: 'optimizations - caching'!isCacheForbidden	(self hasProperty: #cacheAllowed) ifTrue: [ 		^ (self propertyAt: #cacheAllowed) not	].	^ false! !!PP2Node methodsFor: 'analysis - context'!isContextFree	^ self isContextSensitive not! !!PP2Node methodsFor: 'analysis - context'!isContextSensitive	^ self propertyAt: #isContextSensitive ifAbsent: [  		PP2ContextSensitivityVisitor new visit: self	]! !!PP2Node methodsFor: 'testing'!isDebugging	^ self strategies anySatisfy: [ :s | s isDebugging ]! !!PP2Node methodsFor: 'testing'!isDelegate	^ false! !!PP2Node methodsFor: 'testing'!isEOI	^ false! !!PP2Node methodsFor: 'testing'!isEpsilon	^ false! !!PP2Node methodsFor: 'analysis - first'!isFirstSetTerminal	^ self isTerminal! !!PP2Node methodsFor: 'testing'!isJustDelegate	^ false! !!PP2Node methodsFor: 'testing'!isMemoized	^ self strategies anySatisfy: [ :s | s isMemoized ]! !!PP2Node methodsFor: 'analysis - abstract simulation'!isNullable	"		I return true, if parser ALWAYS can accept epsilon and I NEVER fail.				Use #acceptsEpsilon if it can accept epsilon, but it can fail as well.	"	^ self propertyAt: #isNullable ifAbsent: [ 		PP2IsNullableVisitor new visit: self	]! !!PP2Node methodsFor: 'analysis - abstract simulation'!isNullable: aBoolean	self propertyAt: #isNullable put: aBoolean! !!PP2Node methodsFor: 'optimizations'!isOptimized	^ self propertyAt: #optimized ifAbsent: false! !!PP2Node methodsFor: 'testing'!isPetit2Parser	^ true! !!PP2Node methodsFor: 'testing'!isProduction	^ self name notNil! !!PP2Node methodsFor: 'testing'!isRepeating	^ false! !!PP2Node methodsFor: 'testing'!isSea	^ false! !!PP2Node methodsFor: 'testing'!isTerminal	^ self children isEmpty! !!PP2Node methodsFor: 'testing'!isToken	^ false! !!PP2Node methodsFor: 'testing'!isTrimming	^ false! !!PP2Node methodsFor: 'testing'!isTrimmingToken	^ false! !!PP2Node methodsFor: 'operators'!islandInSea	^ self sea ==> #second! !!PP2Node methodsFor: 'comparing'!localEquals: anotherNode	"		This method is supposed to be overriden by children	"	self == anotherNode ifTrue: [ ^ true ].	self class == anotherNode class ifFalse: [ ^ false ].		"		JK: properties? Most probably not, they can contain first/follow etc.		Cherrypick manually the ones you care about.	"	self name = anotherNode name ifFalse: [ ^ false ].	"JK: strategy? Probably not"	^ true! !!PP2Node methodsFor: 'comparing'!localHash	"		This method is supposed to be overriden by children	"	^ self class hash bitXor: self name hash! !!PP2Node methodsFor: 'operators'!map: block	^ PP2MappingNode on: self block: block! !!PP2Node methodsFor: 'optimizations'!markNoRecognizer	((self hasProperty: #recognizer) and: [ self propertyAt: #recognizer ]) ifTrue: [  		self warnShouldNotBeShared. 	].	self propertyAt: #recognizer put: false! !!PP2Node methodsFor: 'optimizations'!markRecognizer	((self hasProperty: #recognizer) and: [ (self propertyAt: #recognizer) not ]) ifTrue: [  		self warnShouldNotBeShared. 	].	self propertyAt: #recognizer ifAbsentPut: true! !!PP2Node methodsFor: 'operators - context'!match	^ PP2MatchNode on: self! !!PP2Node methodsFor: 'parsing'!matches: anObject	"Answer if anObject can be parsed by the receiver."		^ (self parseContext: anObject) isPetit2Failure not! !!PP2Node methodsFor: 'accessing'!memoizationStrategy	^ memoizationStrategy! !!PP2Node methodsFor: 'accessing'!memoizationStrategy: anObject	memoizationStrategy := anObject! !!PP2Node methodsFor: 'optimizations - caching'!memoize	self propertyAt: #memoize put: true! !!PP2Node methodsFor: 'operators - repeating'!min: aMinInteger max: aMaxInteger	"Answer a new parser that parses the receiver at least aMinInteger and at most aMaxInteger times."		^ self star 		min: aMinInteger; 		max: aMaxInteger;		yourself! !!PP2Node methodsFor: 'accessing'!name	"Answer the production name of the receiver."		^ self propertyAt: #name ifAbsent: [ nil ]! !!PP2Node methodsFor: 'accessing'!name: aString	self propertyAt: #name put: aString! !!PP2Node methodsFor: 'operators'!negate	"Answer a new parser consumes any input token but the receiver."		^ self not , #any asPParser ==> #second! !!PP2Node methodsFor: 'analysis - next'!nextSetIn: root	^ root nextSets at: self! !!PP2Node methodsFor: 'analysis - next'!nextSets	^ self propertyAt: #nextSets ifAbsent: [  		(PP2NextSetsVisitor new )			visit: self;			nextSets.	]! !!PP2Node methodsFor: 'operators'!nonEpsilon	^ PP2NonEpsilonNode on: self! !!PP2Node methodsFor: 'operators'!not	^ PP2NotNode on: self! !!PP2Node methodsFor: 'optimizations'!optimize	self isOptimized ifTrue: [ ^ self ].		PP2SeaOptimizationVisitor new doPass: self.		PP2SpecializingVisitor new doPass: self.	PP2RecognizerVisitor new doPass: self.	"		Pre-compute isNullable and firstSet properties	"	PP2IsNullableCache new doPass: self.	PP2FirstSetCache new doPass: self.	"		Should be called before CommonPrefix. Both do caching, but trimming is tailored to the		whitespace handling in PP2 and has more suitable cache.	"	PP2TrimmingCacheVisitor new doPass: self.	"Use packrat parsing"	PP2PackratVisitor new doPass: self.	"Cache the intermediate results for the Guard and Common Prefix visitors"	PP2AllNodesCache new doPass: self.	PP2FirstProductionSetCache new doPass: self.	PP2CommonPrefixVisitor new doPass: self.		PP2GuardVisitor new doPass: self.		PP2BypassVisitor new doPass: self.		"		TODO(JanKurs): hack to inject reparsable visitor from experiments.	"	(Smalltalk at: #PP2ReparsableVisitor ifAbsent: nil) ifNotNil: [ :reparsableVisitor |		reparsableVisitor new doPass: self.	].		"Inject CF memoizations when possible"	PP2ContextChangesCache new doPass: self.	PP2ContextSensitivityCache new doPass: self.	PP2ContextMemoizationVisitor new doPass: self.		self propertyAt: #allCaches put: self collectCaches.	self setOptimized.! !!PP2Node methodsFor: 'operators'!optional	^ PP2OptionalNode on: self! !!PP2Node methodsFor: 'optimizations'!parent: value	self parents add: value! !!PP2Node methodsFor: 'optimizations'!parents	^ self propertyAt: #parents ifAbsentPut: [ OrderedCollection new ]! !!PP2Node methodsFor: 'parsing'!parse: input	^ (self parseContext: input) returnValue! !!PP2Node methodsFor: 'parsing'!parse: anObject onError: aBlock	"Parse anObject with the receiving parser and answer the parse-result or answer the result of evaluating aBlock. Depending on the number of arguments of the block it is simply evaluated, evaluated with the failure object, or evaluated with the error message and position."		| result |	result := self parse: anObject.	result isPetit2Success ifTrue: [ ^ result ].		(aBlock numArgs = 0) ifTrue: [ ^ aBlock value ].	(aBlock numArgs = 1) ifTrue: [ ^ aBlock value: result ].	^ aBlock value: result message value: result position! !!PP2Node methodsFor: 'parsing'!parse: input withContext: startContext	^ self parseAdaptable: input withContext: startContext! !!PP2Node methodsFor: 'parsing - adaptable'!parseAdaptable: input	^ self parseAdaptableWithContext: input asPetit2Stream asPetit2Context! !!PP2Node methodsFor: 'parsing - adaptable'!parseAdaptable: input withContext: context	context stream: input asPetit2Stream.	context position: 0.	context parser: self.	^ self parseAdaptableWithContext: context	! !!PP2Node methodsFor: 'parsing - adaptable'!parseAdaptableWithContext: context	| returnValue |	context parser: self.	self resetCaches.		context startMemento: context remember.	returnValue := self parseOn: context.	^ returnValue isPetit2Success ifTrue: [ 		context returnValue: returnValue 	] ifFalse: [ 		returnValue 			setContext: context;			yourself 	]! !!PP2Node methodsFor: 'parsing'!parseContext: input	^ self parseAdaptable: input! !!PP2Node methodsFor: 'parsing - adaptable'!parseOn: context	^ strategy parseOn: context ! !!PP2Node methodsFor: 'parsing'!parseWithContext: startContext	^ self parseAdaptableWithContext: startContext! !!PP2Node methodsFor: 'operators'!plus	^ (PP2PossesiveRepeatingNode on: self)		min: 1;		yourself! !!PP2Node methodsFor: 'operators - context'!pop	^ PP2PopNode on: self! !!PP2Node methodsFor: 'copying'!postCopy	"JK: I am not sure, if this works properly for optimized version!!"	super postCopy.		properties := properties copy.	strategy := strategy copy.	strategy node: self! !!PP2Node methodsFor: 'printing'!printOn: aStream	super printOn: aStream.		self name isNil ifFalse: [ 		aStream nextPut: $(.		self name printOn: aStream.		aStream nextPut: $).	] ifTrue: [  		aStream nextPut: $#.		aStream nextPutAll: self identityHash asString	]! !!PP2Node methodsFor: 'accessing - properties'!properties	^ properties! !!PP2Node methodsFor: 'accessing - properties'!properties: anObject	^ properties := anObject ! !!PP2Node methodsFor: 'operators - context'!push	^ PP2PushNode on: self! !!PP2Node methodsFor: 'optimizations'!recognizer	^ self propertyAt: #recognizer! !!PP2Node methodsFor: 'optimizations - caching'!refreshCaches	^ self propertyAt: #allCaches put: self collectCaches! !!PP2Node methodsFor: 'optimizations'!reparsable	self propertyAt: #reparsable put: true! !!PP2Node methodsFor: 'transforming'!replace: node with: anotherNode	"Replace the references of the receiver pointing to aParser with anotherParser."! !!PP2Node methodsFor: 'optimizations - caching'!resetCaches	self isOptimized ifFalse: [ ^ self ].	self allCaches do: [ :cache | cache reset ].	! !!PP2Node methodsFor: 'initialization'!resetMemoizationStrategy	memoizationStrategy := PP2CSMemoization new! !!PP2Node methodsFor: 'optimizations - caching'!resetNonReparsableCaches	self isOptimized ifFalse: [ ^ self ].	self allCaches reject: [:e | e isReparsable ] thenDo: [ :cache | cache reset ].	! !!PP2Node methodsFor: 'initialization'!resetStrategies	self resetStrategy.	self resetMemoizationStrategy.! !!PP2Node methodsFor: 'initialization'!resetStrategy	self subclassResponsibility! !!PP2Node methodsFor: 'operators'!sea	^ PP2SeaNode on: self! !!PP2Node methodsFor: 'operators'!sea: waterToken	^ (PP2SeaNode on: self)		waterToken: waterToken;		yourself! !!PP2Node methodsFor: 'accessing'!selfSkipDelegate	^ self isJustDelegate ifTrue: [  self child ] ifFalse: [	^ self ]! !!PP2Node methodsFor: 'operators - convenience'!separatedBy: aParser	"Answer a new parser that parses the receiver one or more times, separated by aParser."		^ (PP2SequenceNode with: self with: (PP2SequenceNode with: aParser with: self) star) ==> [ :nodes |		| result |		result := Array new: 2 * nodes second size + 1.		result at: 1 put: nodes first.		nodes second 			keysAndValuesDo: [ :index :pair | result replaceFrom: 2 * index to: 2 * index + 1 with: pair startingAt: 1 ].		result ]! !!PP2Node methodsFor: 'optimizations'!setOptimized	^ self allNodesDo: [ :node | node propertyAt: #optimized put: true ]! !!PP2Node methodsFor: 'optimizations - caching'!shouldCache	^ self propertyAt: #cacheAllowed ifAbsent: [ ^ false ]! !!PP2Node methodsFor: 'optimizations - caching'!shouldMemoize	^ self propertyAt: #memoize ifAbsent: false! !!PP2Node methodsFor: 'operators'!star	^ (PP2PossesiveRepeatingNode on: self)		min: 0;		yourself! !!PP2Node methodsFor: 'operators'!starLazy	^ ((#epsilon asPParser sea)		waterToken: self)	map: [:_before :_epsilon :_after | 		"return just before water, because island is nil and after water is empty"		_before	] ! !!PP2Node methodsFor: 'operators'!starLazy: predicate	^ (predicate not, self) star! !!PP2Node methodsFor: 'accessing'!strategies	^ strategy allChildren! !!PP2Node methodsFor: 'accessing'!strategy	^ strategy! !!PP2Node methodsFor: 'accessing'!strategy: aPP2Strategy	(strategy == aPP2Strategy) ifTrue: [ ^ self ].	self assert: aPP2Strategy node == self.	strategy := aPP2Strategy! !!PP2Node methodsFor: 'recording'!switchToRecording: toBeSwitched parent: nodeOrStrategy	| recordingStrategy |	recordingStrategy := toBeSwitched recording.	recordingStrategy == toBeSwitched ifTrue: [ ^ toBeSwitched ].	nodeOrStrategy strategy: recordingStrategy.	^ recordingStrategy ! !!PP2Node methodsFor: 'operators'!times: anInteger	"Answer a new parser that parses the receiver exactly anInteger times."		^ (PP2PossesiveRepeatingNode on: self)		min: anInteger;		max: anInteger;		yourself! !!PP2Node methodsFor: 'operators'!token	^ PP2CreateTokenNode on: self! !!PP2Node methodsFor: 'operators'!token: tokenClass	^ (PP2CreateTokenNode on: self)		tokenClass: tokenClass;		yourself! !!PP2Node methodsFor: 'transforming'!transform: aBlock	^ self transform: aBlock suchThat: [ :node | true ]! !!PP2Node methodsFor: 'transforming'!transform: aBlock suchThat: predicate	^ PP2TransformVisitor new		block: aBlock;		predicate: predicate;		visit: self! !!PP2Node methodsFor: 'operators-trimming'!trim	"Answer a new parser that consumes spaces before and after the receiving parser."		^ self trimSpaces! !!PP2Node methodsFor: 'operators-trimming'!trim: aParser	"Answer a new parser that consumes and ignores aParser repeatedly before and after the receiving parser."		^ (PP2TrimmingNode on: self)		trimmer: aParser;		yourself! !!PP2Node methodsFor: 'operators-trimming'!trimBlanks	"Answer a new parser that consumes spaces before and after the receiving parser."		^ self trim: #blank asPParser star! !!PP2Node methodsFor: 'operators-trimming'!trimLeft	"Answer a new parser that consumes spaces before and after the receiving parser."		^ self trimSpacesLeft! !!PP2Node methodsFor: 'operators-trimming'!trimRight	"Answer a new parser that consumes spaces before and after the receiving parser."		^ self trimSpacesRight! !!PP2Node methodsFor: 'operators-trimming'!trimSpaces	"Answer a new parser that consumes spaces before and after the receiving parser."		^ self trim: #space asPParser star! !!PP2Node methodsFor: 'operators-trimming'!trimSpacesLeft	"Answer a new parser that consumes spaces before the receiving parser."		^ (#space asPParser star, self) ==> #second! !!PP2Node methodsFor: 'operators-trimming'!trimSpacesRight	"Answer a new parser that consumes spaces after the receiving parser."		^ (self, #space asPParser star) ==> #first! !!PP2Node methodsFor: 'optimizations'!unsetOptimized	^ self allNodesDo: [ :node | node propertyAt: #optimized put: false ]! !!PP2Node methodsFor: 'optimizations - warnings'!warnActionInToken	"		(($a asParser2, $b asParser2) ==> [ :e | e second ] token) optimize	"	| warning |	warning := self asString, ' is in token, there shouldnt be actions in tokens. but it might be necessary, I admit :('.		self addWarning: warning.! !!PP2Node methodsFor: 'optimizations - warnings'!warnDifferentTrimmer	"give user feedback about this issues"! !!PP2Node methodsFor: 'optimizations - warnings'!warnShouldNotBeShared	"give user feedback about this issues"	| warning |	warning := self asString, ' should not be shared, because it cannot be optimized'.		self addWarning: warning.! !!PP2Node methodsFor: 'optimizations - warnings'!warnings	^ self propertyAt: #warnings ifAbsentPut: [ OrderedCollection new ]! !!PP2Node methodsFor: 'accessing'!withoutDebugStrategy	^ strategy withoutDebugStrategy! !!PP2Node methodsFor: 'operators - convenience'!withoutSeparators	"Filters out the separators from a parse result produced by one of the productions #delimitedBy: or #separatedBy:."		^ self ==> [ :items |		| result |		result := Array new: items size + 1 // 2.		1 to: result size do: [ :index | result at: index put: (items at: 2 * index - 1) ].		result ]! !!PP2Node methodsFor: 'operators'!wrapped	^ PP2DelegateNode on: self! !!PP2Node methodsFor: 'operators'!| aParser	"Answer a new parser that either parses the receiver or aParser. Fail if both pass or fail (exclusive choice, unordered choice)."	^ (self not , aParser) / (aParser not , self) ==> #second! !!PP2PluggableNode class methodsFor: 'as yet unclassified'!on: block	^ self new		block: block;		yourself! !!PP2PluggableNode methodsFor: 'visiting'!accept: aPP2Visitor	^ aPP2Visitor visitPluggable: self! !!PP2PluggableNode methodsFor: 'accessing'!block	^ block! !!PP2PluggableNode methodsFor: 'accessing'!block: anObject	block := anObject! !!PP2PluggableNode methodsFor: 'accessing'!firstCharSet	^ PP2UnknownCharSetPredicate instance! !!PP2PluggableNode methodsFor: 'analysis - first'!isFirstSetTerminal	"lets be conservative here"	^ true! !!PP2PluggableNode methodsFor: 'comparing'!localEquals: anotherNode	(super localEquals: anotherNode) ifFalse: [ ^ false ].		^ (self block printString = anotherNode block printString)! !!PP2PluggableNode methodsFor: 'comparing'!localHash	^ super localHash bitXor: self block printString hash! !!PP2PluggableNode methodsFor: 'parsing - private'!parseOn: aPP2Context	^ strategy parseOn: aPP2Context ! !!PP2PluggableNode methodsFor: 'initialization'!resetStrategy	strategy := PP2Pluggable on: self! !!PP2PredicateNode class methodsFor: 'instance creation'!on: predicate message: message	^ self new		predicate: predicate;		predicateMessage: message;		negated: [ :arg | (predicate value: arg) not ];		negatedMessage: 'no ', message;		yourself! !!PP2PredicateNode methodsFor: 'visiting'!accept: aPP2ParserVisitor	self subclassResponsibility! !!PP2PredicateNode methodsFor: 'comparing'!localEquals: anotherNode	(super localEquals: anotherNode) ifFalse: [ ^ false ].		self predicate printString = anotherNode predicate printString ifFalse: [ ^ false ].	self predicateMessage = anotherNode predicateMessage ifFalse: [ ^ false ].	^ true! !!PP2PredicateNode methodsFor: 'comparing'!localHash	^ super localHash bitXor: (predicate printString hash bitXor: predicateMessage hash)! !!PP2PredicateNode methodsFor: 'operators'!negate	"Answer a parser that is the negation of the receiving predicate parser."		^ (self class new)		predicate: negated;		predicateMessage: negatedMessage;		negated: predicate;		negatedMessage: predicateMessage! !!PP2PredicateNode methodsFor: 'accessing'!negated	^ negated! !!PP2PredicateNode methodsFor: 'accessing'!negated: anObject	negated := anObject! !!PP2PredicateNode methodsFor: 'accessing'!negatedMessage	^ negatedMessage! !!PP2PredicateNode methodsFor: 'accessing'!negatedMessage: anObject	negatedMessage := anObject! !!PP2PredicateNode methodsFor: 'accessing'!predicate	^ predicate! !!PP2PredicateNode methodsFor: 'accessing'!predicate: anObject	predicate := anObject! !!PP2PredicateNode methodsFor: 'accessing'!predicateMessage	^ predicateMessage! !!PP2PredicateNode methodsFor: 'accessing'!predicateMessage: anObject	predicateMessage := anObject! !!PP2PredicateNode methodsFor: 'initialization'!resetStrategy  self subclassResponsibility ! !!PP2PredicateObjectNode class methodsFor: 'factory-objects'!anyOf: aCollection	^ self new		predicate: [ :each | aCollection includes: each ];		predicateMessage: 'any of ' , aCollection printString , ' expected';		negated: [ :each | (aCollection includes: each) not ];		negatedMessage: 'none of ' , aCollection printString ,  'expected'! !!PP2PredicateObjectNode class methodsFor: 'factory-objects'!expect: anObject message: aString	^ (self new)		predicate: [ :each | each = anObject ];		predicateMessage: aString;		negated: [ :each | each ~= anObject ];		negatedMessage: 'no ' , aString! !!PP2PredicateObjectNode class methodsFor: 'factory-objects'!noneOf: aCollection	^ self new		predicate: [ :each | (aCollection includes: each) not ];		predicateMessage: 'none of ' , aCollection printString , ' expected';		negated: [ :each | (aCollection includes: each) ];		negatedMessage: 'any of ' , aCollection printString ,  'expected'! !!PP2PredicateObjectNode methodsFor: 'visiting'!accept: aPP2Visitor	^ aPP2Visitor visitPredicateObject: self! !!PP2PredicateObjectNode methodsFor: 'analysis - first'!firstCharSet	^ predicate asCharSetPredicate! !!PP2PredicateObjectNode methodsFor: 'accessing'!predicate: aPP2CharSetPredicateOrBlock	"Using char set predicate is a performance optimization"	predicate := aPP2CharSetPredicateOrBlock asCharSetPredicate! !!PP2PredicateObjectNode methodsFor: 'initialization'!resetStrategy	strategy := PP2PredicateObject on: self! !!PP2PredicateSequenceNode class methodsFor: 'instance creation'!on: predicate message: message size: size	^ (self on: predicate message: message)		size: size;		yourself! !!PP2PredicateSequenceNode methodsFor: 'visiting'!accept: aPP2Visitor	^ aPP2Visitor visitPredicateSequence: self! !!PP2PredicateSequenceNode methodsFor: 'analysis - first'!firstCharSet	"		TODO(JanKurs): We can optimize a bit here. For example, for 			'abc' asPParser caseInsensitive				the first chare set can be derived.	"	^ PP2UnknownCharSetPredicate new! !!PP2PredicateSequenceNode methodsFor: 'comparing'!localEquals: anotherNode	(super localEquals: anotherNode) ifFalse: [ ^ false ].		^ self size = anotherNode size! !!PP2PredicateSequenceNode methodsFor: 'comparing'!localHash	^ super localHash bitXor: size hash! !!PP2PredicateSequenceNode methodsFor: 'operators'!negate	"Answer a parser that is the negation of the receiving predicate parser."		^ super negate		size: size;		yourself! !!PP2PredicateSequenceNode methodsFor: 'initialization'!resetStrategy	strategy := PP2PredicateSequence on: self! !!PP2PredicateSequenceNode methodsFor: 'accessing'!size	^ size! !!PP2PredicateSequenceNode methodsFor: 'accessing'!size: anObject	size := anObject! !!PP2SeaNode class methodsFor: 'instance creation'!on: island	^ (self new)		island: island;		yourself! !!PP2SeaNode methodsFor: 'visiting'!accept: aPP2Visitor	^ aPP2Visitor visitSea: self! !!PP2SeaNode methodsFor: 'accessing'!afterWater	^ afterWater ! !!PP2SeaNode methodsFor: 'accessing'!beforeWater	^ beforeWater! !!PP2SeaNode methodsFor: 'accessing'!children	^ Array with: beforeWater with: island with: afterWater! !!PP2SeaNode methodsFor: 'initialization'!initialize	super initialize.		beforeWater := PP2WaterNode new		waterToken: self waterToken;		yourself.	afterWater := PP2WaterNode new		waterToken: self waterToken;		yourself.! !!PP2SeaNode methodsFor: 'testing'!isMemoized	^ self strategies anySatisfy: [ :s | s isMemoized ]! !!PP2SeaNode methodsFor: 'testing'!isSea	^ true! !!PP2SeaNode methodsFor: 'accessing'!island	^ island! !!PP2SeaNode methodsFor: 'accessing'!island: anObject	island := anObject! !!PP2SeaNode methodsFor: 'private - operators'!nonEpsilon: node	^ node isNullable ifTrue: [ node nonEpsilon  ] ifFalse: [ node ]! !!PP2SeaNode methodsFor: 'transforming'!replace: node with: anotherNode	island == node ifTrue: [ island := anotherNode ].	beforeWater == node ifTrue: [ beforeWater := anotherNode ].	afterWater == node ifTrue: [ afterWater := anotherNode ]		! !!PP2SeaNode methodsFor: 'initialization'!reset: newContext	(root ~= newContext parser) ifTrue: [  		self updateForRoot: newContext parser	]! !!PP2SeaNode methodsFor: 'initialization'!resetStrategy	strategy := PP2Sea on: self! !!PP2SeaNode methodsFor: 'accessing'!root: newRoot	root := newRoot! !!PP2SeaNode methodsFor: 'boundaries'!updateAfterWater: rootParser	| next |	self assert: rootParser isPetit2Parser.		next := self nextSetIn: rootParser.	afterWater boundaryElements: (OrderedCollection withAll: next)! !!PP2SeaNode methodsFor: 'boundaries'!updateBeforeWater: rootParser	| next elements |	self assert: rootParser isPetit2Parser.	next := self nextSetIn: rootParser.	elements := OrderedCollection with: island.	elements addAll: next.	beforeWater	boundaryElements: elements.	! !!PP2SeaNode methodsFor: 'initialization'!updateForRoot: newRoot	root := newRoot.	self updateBeforeWater: root.	self updateAfterWater: root! !!PP2SeaNode methodsFor: 'accessing'!waterToken	^ self propertyAt: #waterToken ifAbsent: [  		#any asPParser 	]! !!PP2SeaNode methodsFor: 'accessing'!waterToken: waterToken	self propertyAt: #waterToken put: waterToken.		beforeWater waterToken: waterToken.	afterWater waterToken: waterToken.! !!PP2StartOfLineNode methodsFor: 'visiting'!accept: visitor	^ visitor visitStartOfLine: self! !!PP2StartOfLineNode methodsFor: 'analysis - first'!firstCharSet	"	 Because the start of a line is not 'real' character in the input stream,	 I don't know if the peek character in a stream is in my first set.	"	^ PP2UnknownCharSetPredicate instance! !!PP2StartOfLineNode methodsFor: 'initialization'!resetStrategy	strategy := PP2StartOfLine on: self! !!PP2UnresolvedNode methodsFor: 'testing'!isUnresolved	^ true! !!PP2UnresolvedNode methodsFor: 'parsing'!parseOn: aStream	self error: self printString , ' need to be resolved before execution.'! !!PP2UnresolvedNode methodsFor: 'initialization'!resetStrategy	"nothing to do here"! !!PP2WaterNode class methodsFor: 'accessing'!boundary: aPP2Node	^ (self new) 		boundary: aPP2Node;		yourself! !!PP2WaterNode methodsFor: 'visiting'!accept: visitor	^ visitor visitWater: self! !!PP2WaterNode methodsFor: 'accessing'!boundary	^ boundary! !!PP2WaterNode methodsFor: 'accessing'!boundary: anObject	self boundaryElements: (self toCollection: anObject)! !!PP2WaterNode methodsFor: 'accessing'!boundaryElements	^ boundary children collect: #child! !!PP2WaterNode methodsFor: 'accessing'!boundaryElements: collectionOrElement	| elements |	elements := collectionOrElement isCollection ifTrue: [ collectionOrElement ] ifFalse: [ OrderedCollection with: collectionOrElement ].	"		#rejectXYZ are optimizations. 				This is kind of design issue, but I need to make seas at least a bit useable		in in non-optimized mode as well.	"	elements := elements collect: [:e | self rejectSeas: e ].	elements := elements collect: [:e | self rejectPossessive: e ].	elements := elements collect: [:e | self nonEpsilon: e ].	elements := elements collect: #and.			boundary := (PP2ChoiceNode withAll: elements).		self strategy isDebugging ifTrue: [ boundary enableDebug ]! !!PP2WaterNode methodsFor: 'accessing'!children	^ Array with: boundary with: waterToken ! !!PP2WaterNode methodsFor: 'initialization'!initialize	super initialize.		waterToken := #any asPParser.	boundary := (PP2ChoiceNode with: PP2EndOfInputNode new and).! !!PP2WaterNode methodsFor: 'private'!nonEpsilon: node	^ node isNullable ifTrue: [ node nonEpsilon  ] ifFalse: [ node ]! !!PP2WaterNode methodsFor: 'private'!rejectPossessive: node	^ node selfSkipDelegate isRepeating ifTrue: [ node child  ] ifFalse: [ node ]! !!PP2WaterNode methodsFor: 'private'!rejectSeas: nodeOrDelegate	| node |	node := nodeOrDelegate selfSkipDelegate.		^ node isSea ifTrue: [ node island  ] ifFalse: [ node ]! !!PP2WaterNode methodsFor: 'initialization'!resetStrategy	strategy := PP2Water on: self! !!PP2WaterNode methodsFor: 'private'!toCollection: object	object isCollection ifTrue: [ ^ object ].		^ object asOrderedCollection! !!PP2WaterNode methodsFor: 'accessing'!waterToken	^ waterToken! !!PP2WaterNode methodsFor: 'accessing'!waterToken: anObject	waterToken := anObject! !!PP2NodeFactory class methodsFor: 'accessing'!instance	Instance isNil ifTrue: [  		Instance := PP2NodeFactory new	].	^ Instance! !!PP2NodeFactory class methodsFor: 'accessing'!reset	Instance := nil! !!PP2NodeFactory methodsFor: 'predicates'!any	^ PP2PredicateObjectNode new		predicate: [ :each | true ];		predicateMessage: 'input expected';		negated: [ :each | false ];		negatedMessage: 'no input expected';		yourself! !!PP2NodeFactory methodsFor: 'predicates'!blank	| collection |	collection := OrderedCollection with: Character space with: Character tab.	^ PP2PredicateObjectNode new 		predicate: (PP2CharSetPredicate on: [ :char | collection includes: char ]);		predicateMessage: 'blank expected';		negated: (PP2CharSetPredicate on: [:char | (collection includes: char) not ]);		negatedMessage: 'blank not expected';		yourself! !!PP2NodeFactory methodsFor: 'predicates'!digit	^ PP2PredicateObjectNode new		predicate: (PP2CharSetPredicate on: [ :char | char isDigit ]);		predicateMessage: 'digit expected';		negated: (PP2CharSetPredicate on: [ :char | char isDigit not ]);		negatedMessage: 'digit not expected';		yourself! !!PP2NodeFactory methodsFor: 'instance creation'!endOfInput	^ PP2EndOfInputNode new! !!PP2NodeFactory methodsFor: 'instance creation'!endOfLine	^ PP2EndOfLineNode new! !!PP2NodeFactory methodsFor: 'instance creation'!eoi	^ PP2EndOfInputNode new! !!PP2NodeFactory methodsFor: 'instance creation'!epsilon	^ PP2EpsilonNode instance! !!PP2NodeFactory methodsFor: 'instance creation'!failure	^ PP2FailingNode new! !!PP2NodeFactory methodsFor: 'predicates'!hex	| hexBlock |	hexBlock := [ :char | (char between: $0 and: $9) 					or: [ (char between: $a and: $f) 					or: [ (char between: $A and: $F) ] ]  ].			^ PP2PredicateObjectNode new		predicate: (PP2CharSetPredicate on: hexBlock);		predicateMessage: 'hex digit expected';		negated: (PP2CharSetPredicate on: [:char | (hexBlock value: char) not]);		negatedMessage: 'hex digit not expected';		yourself! !!PP2NodeFactory methodsFor: 'predicates'!letter	^ PP2PredicateObjectNode new		predicate: (PP2CharSetPredicate on: [ :char | char isLetter ]);		predicateMessage: 'letter expected';		negated: (PP2CharSetPredicate on: [ :char | char isLetter not ]);		negatedMessage: 'letter not expected';		yourself! !!PP2NodeFactory methodsFor: 'instance creation'!newline	^ PP2NewLineNode new! !!PP2NodeFactory methodsFor: 'context'!pop	^ nil asPParser pop! !!PP2NodeFactory methodsFor: 'predicates'!space	^ PP2PredicateObjectNode new 		predicate: (PP2CharSetPredicate on: [ :char | char isSeparator ]);		predicateMessage: 'separator expected';		negated: (PP2CharSetPredicate on: [ :char | char isSeparator not ]);		negatedMessage: 'separator not expected';		yourself! !!PP2NodeFactory methodsFor: 'instance creation'!startOfLine	^ PP2StartOfLineNode new! !!PP2NodeFactory methodsFor: 'seas'!water	^ nil asPParser sea flatten! !!PP2NodeFactory methodsFor: 'predicates'!word	^ PP2PredicateObjectNode new		predicate: (PP2CharSetPredicate on: [ :char | char isAlphaNumeric ]);		predicateMessage: 'letter or digit expected';		negated: (PP2CharSetPredicate on: [ :char | char isAlphaNumeric not ]);		negatedMessage: 'letter or digit not expected';		yourself! !!PP2NodeVisitor methodsFor: 'visiting'!visit: aPP2Parser	^ aPP2Parser accept: self! !!PP2NodeVisitor methodsFor: 'visiting'!visitAction: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2NodeVisitor methodsFor: 'visiting'!visitAdaptable: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2NodeVisitor methodsFor: 'visiting'!visitAnd: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2NodeVisitor methodsFor: 'visiting'!visitChoice: aPP2Parser	^ self visitPP2Node: aPP2Parser! !!PP2NodeVisitor methodsFor: 'visiting'!visitComposite: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2NodeVisitor methodsFor: 'visiting'!visitDelegate: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2NodeVisitor methodsFor: 'visiting'!visitEnd: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2NodeVisitor methodsFor: 'visiting'!visitEndOfInput: node	^ self visitPP2Node: node	! !!PP2NodeVisitor methodsFor: 'visiting'!visitEndOfLine: node	^ self visitPP2Node: node	! !!PP2NodeVisitor methodsFor: 'visiting'!visitEpsilon: node	^ self visitPP2Node: node	! !!PP2NodeVisitor methodsFor: 'visiting'!visitFailing: node	^ self visitPP2Node: node	! !!PP2NodeVisitor methodsFor: 'visiting'!visitFlatten: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2NodeVisitor methodsFor: 'visiting'!visitLiteralObject: aPP2Parser	^ self visitPP2Node: aPP2Parser! !!PP2NodeVisitor methodsFor: 'visiting'!visitLiteralSequence: aPP2Parser	^ self visitPP2Node: aPP2Parser! !!PP2NodeVisitor methodsFor: 'visiting'!visitMapping: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2NodeVisitor methodsFor: 'visiting'!visitMatch: node	^ self visitPP2Node: node! !!PP2NodeVisitor methodsFor: 'visiting'!visitNewLine: node	^ self visitPP2Node: node	! !!PP2NodeVisitor methodsFor: 'visiting'!visitNewline: node	^ self visitPP2Node: node	! !!PP2NodeVisitor methodsFor: 'visiting'!visitNonEpsilon: node	^ self visitPP2Node: node! !!PP2NodeVisitor methodsFor: 'visiting'!visitNot: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2NodeVisitor methodsFor: 'visiting'!visitOptional: aPP2Parser	^ self visitPP2Node: aPP2Parser! !!PP2NodeVisitor methodsFor: 'visiting'!visitPP2Node: aPP2Node	"nothing to do here"	! !!PP2NodeVisitor methodsFor: 'visiting'!visitPluggable: aPP2Parser	^ self visitPP2Node: aPP2Parser! !!PP2NodeVisitor methodsFor: 'visiting'!visitPop: node	^ self visitPP2Node: node! !!PP2NodeVisitor methodsFor: 'visiting'!visitPossesiveRepeating: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2NodeVisitor methodsFor: 'visiting'!visitPredicateObject: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2NodeVisitor methodsFor: 'visiting'!visitPredicateSequence: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2NodeVisitor methodsFor: 'visiting'!visitPush: node	^ self visitPP2Node: node! !!PP2NodeVisitor methodsFor: 'visiting'!visitSea: node	^ self visitPP2Node: node! !!PP2NodeVisitor methodsFor: 'visiting'!visitSequence: aPP2Parser	^ self visitPP2Node: aPP2Parser! !!PP2NodeVisitor methodsFor: 'visiting'!visitStartOfLine: node	^ self visitPP2Node: node	! !!PP2NodeVisitor methodsFor: 'visiting'!visitToken: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2NodeVisitor methodsFor: 'visiting'!visitTrimming: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2NodeVisitor methodsFor: 'visiting'!visitTrimmingToken: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2NodeVisitor methodsFor: 'visiting'!visitUnresolved: node	^ self visitPP2Node: node	! !!PP2NodeVisitor methodsFor: 'visiting'!visitWater: node	^ self visitPP2Node: node! !!PP2NodeVisitor methodsFor: 'visiting'!visitWrapping: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2AllNodesCache methodsFor: 'as yet unclassified'!afterAccept: ctx result: result	ctx node propertyAt: #allNodesSize ifAbsentPut: result size! !!PP2AllNodesCache methodsFor: 'as yet unclassified'!doPass: node	self visit: node! !!PP2AllNodesVisitor methodsFor: 'visiting'!allNodes	^ closeSet collect: [ :ctx | ctx node ]! !!PP2AllNodesVisitor methodsFor: 'visiting'!children	self halt: 'deprecated'.	^ closeSet collect: [ :ctx | ctx node ]! !!PP2AllNodesVisitor methodsFor: 'visiting'!visitPP2Node: node	| retval |	retval := IdentitySet new.	node children do: [ :child | 		retval addAll: (self visit: child)	].	retval add: node.		^ retval! !!PP2BypassVisitor methodsFor: 'optimizations'!doPass: node	^ self visit: node! !!PP2BypassVisitor methodsFor: 'visiting'!visitComposite: node	self visit: node child.! !!PP2BypassVisitor methodsFor: 'visiting'!visitPP2Node: node	| target |	node children do: [ :child | 		(child class == PP2DelegateNode and: [ child strategy class == PP2Delegate]) ifTrue: [  			target := child child.			node strategy bypass: child to: target		].		self visit: child.	]! !!PP2CommonPrefixVisitor methodsFor: 'caching'!cache: node	node isCacheForbidden ifTrue: [ ^ self ].	node contextChanges isContextChange ifTrue: [ ^ self ].	node isMemoized ifTrue: [ ^ self ].		node strategy: node strategy cache.! !!PP2CommonPrefixVisitor methodsFor: 'caching - choice'!cache: node production: production	| strategy |	node isCacheForbidden ifTrue: [ ^ self ].		strategy := production strategy cache.	node changeStrategy: strategy ! !!PP2CommonPrefixVisitor methodsFor: 'caching'!cacheIfMakesSense: node	(self cacheMakesSense: node) ifTrue: [  		self cache: node	]! !!PP2CommonPrefixVisitor methodsFor: 'support'!cacheMakesSense: production	| node target |	node := production isJustDelegate ifTrue: [ production child ] ifFalse: [ production ].	target := node.	"trimmers are already optimized, I care about the body"	node isTrimming ifTrue: [ target := node child ].	node isTrimmingToken ifTrue: [ target := node child child ].		^ (target propertyAt: #allNodesSize ifAbsentPut: [ node allNodes size ]) > 2! !!PP2CommonPrefixVisitor methodsFor: 'caching - choice'!cacheProductions: productions	| names |	names := productions collect: [:p | p name ].		"		Small magic alert: I take all the equivalent productions and set the same caching 		strategy for all production that occur in the first set of more than one alternives.	"	names do: [ :name |		| occurences production |		occurences := productions select: [ :p | p name = name ].		production := occurences first.				(occurences size > 1 and: [self cacheMakesSense: production ]) ifTrue: [ 			occurences do: [ :o |				"note that we are sharing the same strategy over multiple productions!!"				self cache: o production: production.			] 		]	].! !!PP2CommonPrefixVisitor methodsFor: 'optimizations'!doPass: node	^ self visit: node	! !!PP2CommonPrefixVisitor methodsFor: 'visiting'!visitChoice: choice	| productions |	super visitChoice: choice.	productions := OrderedCollection new.	(choice children do: [ :c | productions addAll: c firstProductionSet ]).	self assert: (productions allSatisfy: [ :e | e isProduction ]).	self cacheProductions: productions! !!PP2CommonPrefixVisitor methodsFor: 'visiting'!visitPP2Node: node	node shouldCache ifTrue: [ 		self cache: node	].	super visitPP2Node: node! !!PP2CommonPrefixVisitor methodsFor: 'visiting'!visitSea: node	self visit: node island.		node isMemoized ifFalse: [ 		self cache: node island.		node beforeWater boundaryElements do: [ :e | self cache: e ].		node afterWater boundaryElements do: [ :e | self cache: e ].	]! !!PP2CommonPrefixVisitor methodsFor: 'visiting'!visitSequence: sequence	| productions |	super visitSequence: sequence.	"First child is nullable, i.e. it cannot fail, the cache would be superfluous"	sequence firstChild isNullable ifFalse: [ ^ self ].	"so far only for the first two children"	productions := OrderedCollection new.	productions	addAll: (sequence firstChild firstProductionSet).	productions addAll: (sequence secondChild firstProductionSet).		self assert: (productions allSatisfy: [ :e | e isProduction ]).		self cacheProductions: productions! !!PP2ContextChangesCache methodsFor: 'optimizations'!doPass: node	| children child |	self visit: node.	children := node allNodes.		[(child := children detect: [ :e | (e hasProperty: self propertySymbol) not ] 							ifNone: [ nil ]) notNil ] whileTrue: [ 				self visit: child	]! !!PP2ContextChangesCache methodsFor: 'accessing'!propertySymbol	^ #contextChanges! !!PP2ContextChangesVisitor methodsFor: 'loop control'!openedResultFor: context	^ PP2CcResult noChange ! !!PP2ContextChangesVisitor methodsFor: 'visiting'!sequenceResult: node	| childrenResult pushes pops |	childrenResult := node children collect: [ :child | self visit: child ].		(childrenResult noneSatisfy: [:result | result isContextChange ]) ifTrue: [  		^ PP2CcResult noChange	].	(childrenResult anySatisfy: [:result | result isUnknownChange ]) ifTrue: [  		^ PP2CcResult change	].	pushes := (node children select: [ :child | (self visit: child) isContextPush ]).	pops := (node children select: [ :child | (self visit: child) isContextPop ]).		pushes size > 1 ifTrue: [ ^ PP2CcResult change ].	pops size > 1 ifTrue: [ ^ PP2CcResult change ].		((pushes size = 1) and: [ pops size = 0 ]) ifTrue: [  ^ PP2CcResult push	].	((pops size = 1) and: [ pushes size = 0 ]) ifTrue: [ ^ PP2CcResult pop ].		(pushes size = 1 and: [ pops size = 1 ]) ifTrue: [ 		| pushIndex popIndex |		pushIndex := node children indexOf: pushes first.		popIndex := node children indexOf: pops first.				pushIndex < popIndex ifTrue: [ ^ PP2CcResult noChange  ] ifFalse: [ ^ PP2CcResult change ]	].	self error: 'should happen?'.! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitAction: node	^ self visitDelegate: node! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitAdaptable: node	^ node propertyAt: #contextChanges ifAbsent: [ 		PP2CcChange change	]! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitAnd: node	^ node propertyAt: #contextChanges ifAbsent: [ 		PP2CcChange noChange 	]! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitChoice: node	^ node propertyAt: #contextChanges ifAbsent: [ 		| results |		results := node children collect: [:child | self visit: child ].		results asSet size = 1 ifTrue: [ results anyOne ] ifFalse: [  			PP2CcChange change		]	]! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitComposite: node	^ self visitDelegate: node! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitDelegate: node	^ node propertyAt: #contextChanges ifAbsent: [ 		self visit: node child	]! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitEnd: node	^ self visitDelegate: node! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitEndOfInput: node	^ node propertyAt: #contextChanges ifAbsent: [ 		PP2CcChange noChange 	]! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitEndOfLine: node	^ node propertyAt: #contextChanges ifAbsent: [ 		PP2CcChange noChange 	]! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitEpsilon: node	^ node propertyAt: #contextChanges ifAbsent: [ 		PP2CcChange noChange 	]! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitFailing: node	^ node propertyAt: #contextChanges ifAbsent: [ 		PP2CcChange noChange 	]! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitFlatten: node	^ self visitDelegate: node! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitLiteralObject: node	^ node propertyAt: #contextChanges ifAbsent: [ 		PP2CcResult noChange 	]! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitLiteralSequence: node	^ node propertyAt: #contextChanges ifAbsent: [ 		PP2CcChange noChange 	]! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitMapping: node	^ self visitDelegate: node! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitMatch: node	^ self visitDelegate: node! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitNewLine: node	^ node propertyAt: #contextChanges ifAbsent: [ 		PP2CcChange noChange 	]! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitNonEpsilon: node	^ self visitDelegate: node! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitNot: node	^ node propertyAt: #contextChanges ifAbsent: [ 		PP2CcChange noChange 	]! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitOptional: node	^ node propertyAt: #contextChanges ifAbsent: [ 		| result |		result := self visit: node child.				result isContextChange ifTrue: [  			PP2CcResult change		] ifFalse: [  			PP2CcResult noChange 		]	]! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitPP2Node: node	"		If you see this, you have probably added your own parser. 				If your parser is not context-sensitive or you don't know what context-sensitive mean, 		for terminal parsers return 						PP2CcChange change		or for delegating parsers get inspired by			#visitDelegate:	"	self error: 'should provide specific implementation, it is usually easy!!'! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitPluggable: node	^ node propertyAt: #contextChanges ifAbsent: [ 		^ PP2CcChange change	]! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitPop: node	^ node propertyAt: #contextChanges ifAbsent: [ 		(self visit: node child) isContextChange ifFalse: [			PP2CcChange pop		] ifTrue: [  			PP2CcChange change		]	]! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitPossesiveRepeating: node	^ node propertyAt: #contextChanges ifAbsent: [ 		| result |		result := self visit: node child.				result isContextChange ifTrue: [  			PP2CcResult change		] ifFalse: [  			PP2CcResult noChange 		]	]! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitPredicateObject: node	^ node propertyAt: #contextChanges ifAbsent: [ 		PP2CcChange noChange 	]! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitPredicateSequence: node	^ node propertyAt: #contextChanges ifAbsent: [ 		PP2CcChange noChange 	]! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitPush: node	^ node propertyAt: #contextChanges ifAbsent: [ 		(self visit: node child) isContextChange ifFalse: [			PP2CcChange push		] ifTrue: [  			PP2CcChange change		]	]! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitSea: node	^ node propertyAt: #contextChanges ifAbsent: [ 		"			These two asserts are probably not essential, but I cannot imagine the use case 			right now. If it is the case, the logic should be re-written.		"		self assert: (self visit: node beforeWater) isContextChange not.		self assert: (self visit: node afterWater) isContextChange not.		^ self visit: node island	]! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitSequence: node	^ node propertyAt: #contextChanges ifAbsent: [ 		self sequenceResult: node	]! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitStartOfLine: node	^ node propertyAt: #contextChanges ifAbsent: [ 		PP2CcChange noChange 	]! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitToken: node	^ self visitDelegate: node! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitTrimming: node	^ node propertyAt: #contextChanges ifAbsent: [ 		self assert: (self visit: node trimmer) isContextChange not.		self visit: node child	]! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitWater: node	^ node propertyAt: #contextChanges ifAbsent: [ 		self assert: (self visit: node waterToken) isContextChange not.		self assert: (self visit: node boundary) isContextChange not.		PP2CcChange noChange 	]! !!PP2ContextChangesVisitor methodsFor: 'visiting'!visitWrapping: node	^ node propertyAt: #contextChanges ifAbsent: [ 		^ PP2CcChange change	]! !!PP2ContextMemoizationVisitor methodsFor: 'optimizations'!doPass: node	^ self visit: node	! !!PP2ContextMemoizationVisitor methodsFor: 'visiting'!visitAnd: node	node child contextChanges isNotContextChange ifTrue: [ 		node memoizationStrategy: PP2CFMemoization new.		^ 	super visitAnd: node.	].	node child contextChanges isContextPop ifTrue: [ 		node memoizationStrategy: PP2PopMemoization new.		^ 	super visitAnd: node.	].	node child contextChanges isContextPush ifTrue: [ 		node memoizationStrategy: PP2PushMemoization new.		^ 	super visitAnd: node.	].	^ 	super visitAnd: node.! !!PP2ContextMemoizationVisitor methodsFor: 'visiting'!visitFlatten: node	node contextChanges isContextChange ifFalse: [ 		node memoizationStrategy: PP2CFMemoization new	].	super visitFlatten: node.	! !!PP2ContextMemoizationVisitor methodsFor: 'visiting'!visitMatch: node	node child contextChanges isNotContextChange ifTrue: [ 		node memoizationStrategy: PP2CFMemoization new	].	^ 	super visitWater: node! !!PP2ContextMemoizationVisitor methodsFor: 'visiting'!visitNonEpsilon: node	node child contextChanges isNotContextChange ifTrue: [ 		node memoizationStrategy: PP2CFMemoization new.		^ 	super visitAnd: node.	].	^ 	super visitAnd: node.! !!PP2ContextMemoizationVisitor methodsFor: 'visiting'!visitNot: node	node child contextChanges isNotContextChange ifTrue: [ 		node memoizationStrategy: PP2CFMemoization new.		^ 	super visitNot: node.	].	node child contextChanges isContextPop ifTrue: [ 		node memoizationStrategy: PP2PopMemoization new.		^ 	super visitNot: node.	].	node child contextChanges isContextPush ifTrue: [ 		node memoizationStrategy: PP2PushMemoization new.		^ 	super visitNot: node.	].	^ 	super visitAnd: node.! !!PP2ContextMemoizationVisitor methodsFor: 'visiting'!visitSea: node	node contextChanges isContextChange ifFalse: [ 		node memoizationStrategy: PP2CFMemoization new	].	^ 	super visitSea: node! !!PP2ContextMemoizationVisitor methodsFor: 'visiting'!visitSequence: node	(node children noneSatisfy: [:child | child contextChanges isContextChange ]) ifTrue: [ 		node memoizationStrategy: PP2CFMemoization new.		^ 	super visitSequence: node	].	node contextChanges isContextPop ifTrue: [ 		node memoizationStrategy: PP2PopMemoization new.		^ 	super visitSequence: node	].	node contextChanges isContextPush ifTrue: [ 		node memoizationStrategy: PP2PushMemoization new.		^ 	super visitSequence: node	].	((node children anySatisfy: [ :child | child contextChanges isContextChange  ]) and: [	  node contextChanges isNotContextChange ]) ifTrue: [ 			"JK: PUSH-POP case, can be handled by the PushMemoization, let me know if not :)"			node memoizationStrategy: PP2PushMemoization new.			^ 	super visitSequence: node	].	^ 	super visitSequence: node! !!PP2ContextMemoizationVisitor methodsFor: 'visiting'!visitWater: node	node waterToken contextChanges isContextChange ifFalse: [ 		node memoizationStrategy: PP2CFMemoization new	].	^ 	super visitWater: node! !!PP2ContextSensitivityCache methodsFor: 'optimizations'!doPass: node	| children child |	self visit: node.	children := node allNodes.		[(child := children detect: [ :e | (e hasProperty: self propertySymbol) not ] 							ifNone: [ nil ]) notNil ] whileTrue: [ 				self visit: child	]! !!PP2ContextSensitivityCache methodsFor: 'accessing'!propertySymbol	^ #isContextSensitive! !!PP2ContextSensitivityVisitor methodsFor: 'loop control'!openedResultFor: context	^ false! !!PP2ContextSensitivityVisitor methodsFor: 'visiting'!sequenceResult: node	| pushes matches pushIndex matchIndices childrenResult |	childrenResult := node children collect: [ :child | child -> (self  visit: child) ].		pushes := node children select: [ :child | child contextChanges isContextPush ].	matches := childrenResult select: [ :assoc | assoc value ] thenCollect: #key.		matches isEmpty ifTrue: [ ^ false ].	pushes isEmpty ifTrue: [ ^ true ].	"probably can better here"	pushes size > 1 ifTrue: [ ^ true ].	"			JK: The idea here is, if there is a match after push, the result of the whole sequence 		does not depend on the stacks, because the match will be compared to the value from push.				E.g.  		self assert: (#letter asPParser push, #letter asPParser match) isContextFree	"		matchIndices := matches collect: [ :match | node children indexOf: match ].	pushIndex := node children indexOf: pushes anyOne.		^ matchIndices anySatisfy: [ :i | i < pushIndex ].! !!PP2ContextSensitivityVisitor methodsFor: 'visiting'!visitMatch: node	^ node propertyAt: #isContextSensitive ifAbsent: [ 		true	]! !!PP2ContextSensitivityVisitor methodsFor: 'visiting'!visitPP2Node: node	^ node propertyAt: #isContextSensitive ifAbsent: [ 		node children anySatisfy: [:child | self visit: child ]	]! !!PP2ContextSensitivityVisitor methodsFor: 'visiting'!visitSequence: node	^ node propertyAt: #isContextSensitive ifAbsent: [ 		super visitSequence: node.		self sequenceResult: node	]! !!PP2ContextSensitivityVisitor methodsFor: 'visiting'!visitTerminal: node	^ node propertyAt: #isContextSensitive ifAbsent: [ 		false	]! !!PP2FirstProductionSetCache methodsFor: 'hooks'!afterAccept: ctx result: result	ctx node propertyAt: #firstProductionSet ifAbsentPut: result! !!PP2FirstProductionSetCache methodsFor: 'optimizations'!doPass: node	| allNodes child |	self visit: node.	allNodes := node allNodes.		[(child := allNodes detect: [ :e | (e hasProperty: #firstProductionSet) not ] 							ifNone: [ nil ]) notNil ] whileTrue: [ 				self visit: child	]! !!PP2FirstProductionSetCache methodsFor: 'initialization'!initialize	super initialize.	predicateBlock := [ :e | e isProduction  ]! !!PP2FirstSetCache methodsFor: 'optimizations'!doPass: node	| children child |	self visit: node.	children := node allNodes.		[(child := children detect: [ :e | (e hasProperty: self propertySymbol) not ] 							ifNone: [ nil ]) notNil ] whileTrue: [ 				self visit: child	]! !!PP2FirstSetCache methodsFor: 'as yet unclassified'!propertySymbol	^ #firstSet! !!PP2FirstSetVisitor class methodsFor: 'instance creation'!firstSet	^ self on: [ :e | e isFirstSetTerminal ] on: [ :e | e isFirstSetTerminal ]! !!PP2FirstSetVisitor class methodsFor: 'instance creation'!new	^ self firstSet! !!PP2FirstSetVisitor class methodsFor: 'instance creation'!on: aBlock	^ self basicNew initialize 		terminalBlock: aBlock;		predicateBlock: aBlock;		yourself! !!PP2FirstSetVisitor class methodsFor: 'instance creation'!on: terminalBlock on: predicateBlock	^ self basicNew 		terminalBlock: terminalBlock;		predicateBlock: predicateBlock;		initialize;		yourself! !!PP2FirstSetVisitor class methodsFor: 'instance creation'!productionSet	^ self on: [ :e | e isFirstSetTerminal ] on: [ :e | e isProduction ]! !!PP2FirstSetVisitor class methodsFor: 'instance creation'!seasOrTerminalsSet	^ self 		on: [ :e | e isSea or: [ e isFirstSetTerminal ] ] 		on: [ :e | e isSea or: [ e isFirstSetTerminal ] ]! !!PP2FirstSetVisitor class methodsFor: 'instance creation'!tokenSet	^ self on: [ :e | e isToken or: [ e isFirstSetTerminal  ] ]! !!PP2FirstSetVisitor methodsFor: 'support'!addIfPossible: node to: collection	(predicateBlock value: node) ifTrue: [ collection add: node ]! !!PP2FirstSetVisitor methodsFor: 'initialization'!initialize	super initialize.		leftRecursionAllowed := false! !!PP2FirstSetVisitor methodsFor: 'testing'!isTerminal: node	^ terminalBlock value: node! !!PP2FirstSetVisitor methodsFor: 'loop control'!openedResultFor: context	leftRecursionAllowed ifTrue: [ 		^ super openedResultFor: context	].	"		JK: I am not 100% sure, but this should never happen. If this happens, the grammar		    contains an infinite loop.	"	self error: 'There seems to be a left recursive loop in your grammar!!'! !!PP2FirstSetVisitor methodsFor: 'accessing'!predicateBlock	^ predicateBlock! !!PP2FirstSetVisitor methodsFor: 'accessing'!predicateBlock: anObject	predicateBlock := anObject! !!PP2FirstSetVisitor methodsFor: 'support'!setWithPossible: node 	^ self setWithPossible: node withAll: #()! !!PP2FirstSetVisitor methodsFor: 'support'!setWithPossible: node withAll: aCollection	| set |	set := IdentitySet withAll: aCollection.		(predicateBlock value: node) ifTrue: [ 		set add: node	].	^ set! !!PP2FirstSetVisitor methodsFor: 'accessing'!terminalBlock	^ terminalBlock! !!PP2FirstSetVisitor methodsFor: 'accessing'!terminalBlock: aBlock	terminalBlock := aBlock! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitAction: node	^ self visitDelegate: node! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitAdaptable: node	| set |	set := (self setWithPossible: node).	"Node can be adpated to anything"	self addIfPossible: #any asPParser to: set.	"We don't know if Epsilon is possible or not so we rather add it"	self addIfPossible: PP2EpsilonNode instance to: set.		^ set! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitAnd: node	^ self visitDelegate: node! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitChoice: node	| returnSet |	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].		returnSet := self setWithPossible: node.	node children do: [ :child | 		returnSet addAll: (self visit: child).	].	^ returnSet! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitComposite: node	^ self visitDelegate: node! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitDelegate: node	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	^ self setWithPossible: node withAll: (self visit: node child) ! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitEnd: node	^ self visitDelegate: node! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitEndOfInput: node	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	self warn: 'I guess you have some issues with your terminal block.'! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitEndOfLine: node	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	self warn: 'I guess you have some issues with your terminal block.'! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitEpsilon: node	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	self warn: 'guess you have some issues with your terminal block'! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitFailing: node	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	self warn: 'guess you have some issues with your terminal block'! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitFlatten: node	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	^ self setWithPossible: node withAll: (self visit: node child) ! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitLiteralObject: node	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	self warn: 'guess you have some issues with your terminal block'! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitLiteralSequence: node	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	self warn: 'guess you have some issues with your terminal block'! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitMapping: node	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	^ self setWithPossible: node withAll: (self visit: node child) ! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitMatch: node	^ self visitDelegate: node! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitNewLine: node	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	self warn: 'I guess you have some issues with your terminal block.'! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitNonEpsilon: node	| set |	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	set := (self setWithPossible: node).	set addAll: (self visit: node child).	set remove: PP2EpsilonNode instance ifAbsent: nil.		^ set! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitNot: node	^ self visitDelegate: node! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitOptional: node	| set |	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	set := (self setWithPossible: node).	set addAll: (self visit: node child).	self addIfPossible: PP2EpsilonNode instance to: set.		^ set! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitPP2Node: node	self error: 'should provide specific implementation'! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitPluggable: node	^ self visitDelegate: node! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitPop: node	^ self visitDelegate: node! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitPossesiveRepeating: node	| set |	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	set := self setWithPossible: node withAll: (self visit: node child).	(node min = 0) ifTrue: [ 		self addIfPossible: PP2EpsilonNode instance to: set.	].	^ set! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitPredicateObject: node	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	self warn: 'guess you have some issues with your terminal block'! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitPredicateSequence: node	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	self warn: 'guess you have some issues with your terminal block'! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitPush: node	^ self visitDelegate: node! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitSea: node	| returnSet |	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	returnSet := (self setWithPossible: node).	returnSet addAll: (self visit: node beforeWater).	returnSet removeAllSuchThat: [ :e | e = #eoi asPParser ].	returnSet addAll: (self visit: node island).	node island isNullable ifTrue: [ 		returnSet addAll: (self visit: node afterWater).	].			^ returnSet reject: [ :e | e isEpsilon ] ! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitSequence: node	| returnSet |	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	returnSet := self setWithPossible: node.	node children do: [ :child | 		returnSet addAll: (self visit: child).		child isNullable ifFalse: [ ^ returnSet reject: [ :e | e isEpsilon ] ]	].	self addIfPossible: PP2EpsilonNode instance to: returnSet.	^ returnSet! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitStartOfLine: node	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	self warn: 'I guess you have some issues with your terminal block.'! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitToken: node	^ self visitDelegate: node! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitTrimming: node	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	^ (self setWithPossible: node) 		addAll: ((self visit: node trimmer) reject: [ :e | e isEpsilon ]);		addAll: (self visit: node child);		yourself! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitWater: node	| retval lrStatus |	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	lrStatus := leftRecursionAllowed.	leftRecursionAllowed := true.	retval := (self setWithPossible: node) 		addAll: (self visit: node waterToken);		addAll: (self visit: node boundary);		yourself.			leftRecursionAllowed := lrStatus.				^ retval! !!PP2FirstSetVisitor methodsFor: 'visiting'!visitWrapping: node	^ self visitDelegate: node! !!PP2FirstSetVisitor methodsFor: 'warnings'!warn: aMessage	Transcript crShow: aMessage.	self error: 'this should not really happen.'.! !!PP2GuardVisitor methodsFor: 'support'!classificationFor: node	| classification charSet firstSet |	classification := Array new: 255 withAll: false.	firstSet := node firstSet.	firstSet do: [ :first |  		charSet := first firstCharSet.				charSet isUnknown ifTrue: [ ^ anythingClassification  ].				charSet classification withIndexDo: [ :value :index |  			value ifTrue: [ classification at: index put: true ]		]	].	^ classification! !!PP2GuardVisitor methodsFor: 'optimizations'!doPass: node	self visit: node! !!PP2GuardVisitor methodsFor: 'support'!guardOf: classification makesSenseFor: node	| size allNodesSize |	allNodesSize := node propertyAt: #allNodesSize ifAbsentPut: [ node allNodes size ].		"if there are too little children, the overhead of a guard is too high"	(allNodesSize < 4) ifTrue: [ ^ false ].	size := ((1 to: 255) 	collect: [ :index | classification at: index ]							  	thenSelect: [ :e | e ]) size.	"if guard passes for so many characters, it is probably(!!!!!!) better not to guard"	(size > 250) ifTrue: [ ^ false ].									"for small parsers"	(allNodesSize < 20 and: [size > 128 ]) ifTrue: [ ^ false ].			"It is already guarded"	(self isWellGuarded: classification) ifTrue: [ ^ false ].		^ true! !!PP2GuardVisitor methodsFor: 'initialization'!initialize	super initialize.		anythingClassification := (Array new: 255 withAll: true).	guarded := Stack with: anythingClassification.	! !!PP2GuardVisitor methodsFor: 'testing'!isGuarded	^ guarded isEmpty! !!PP2GuardVisitor methodsFor: 'testing'!isWellGuarded: classification	| topClassification changes |	topClassification := guarded top.	changes := 0.		topClassification with: classification do: [ :topC :localC |		localC ifTrue: [ self assert: topC ].		"is single change enough?"				(topC and: localC not) ifTrue: [  			changes := changes + 1.		].		].	^ changes == 0	"		(DiffMorph 		from: (topClassification joinUsing: Character lf) 		to: (classification joinUsing: Character lf)) openInWindow	"! !!PP2GuardVisitor methodsFor: 'support'!visit: node guardedWith: classification	guarded push: classification.	self visit: node.	guarded pop.	! !!PP2GuardVisitor methodsFor: 'visiting'!visitChoice: node	| alternatives classification |	alternatives := node children.	alternatives do: [ :alternative | 		classification := self classificationFor: alternative.		(self guardOf: classification makesSenseFor: alternative) ifTrue: [  			alternative strategy: (alternative strategy parsingGuard: classification).			self visit: alternative guardedWith: classification		] ifFalse: [  			self visit: alternative		]	].! !!PP2GuardVisitor methodsFor: 'visiting'!visitDelegate: node	| classification |	(node children size = 1) ifFalse: [ ^ super visitDelegate: node ].		classification := self classificationFor: node.	(self guardOf: classification makesSenseFor: node) ifTrue: [  		node strategy: (node strategy parsingGuard: classification).		self visit: node child guardedWith: classification	] ifFalse: [  		self visit: node child	]! !!PP2GuardVisitor methodsFor: 'visiting'!visitOptional: node	| classification |	"		Classify for the child, because classification for optional contains always 'true'		and therefore makes not much sense.	"	classification := self classificationFor: node child.	(self guardOf: classification makesSenseFor: node) ifTrue: [  		node strategy: (node strategy parsingGuard: classification).		self visit: node child guardedWith: classification	] ifFalse: [		self visit: node child	]! !!PP2GuardVisitor methodsFor: 'visiting'!visitPossesiveRepeating: node	| classification |		classification := self classificationFor: node child.	(self guardOf: classification makesSenseFor: node) ifTrue: [ 		node strategy: (node strategy parsingGuard: classification).	].		"repetition is kind of sequence, so all but first are not really guarded"	self visitUnguarded: node child! !!PP2GuardVisitor methodsFor: 'visiting'!visitSequence: node	self visit: node firstChild.		node children allButFirst do: [ :child |		self visitUnguarded: child.	].! !!PP2GuardVisitor methodsFor: 'visiting'!visitTrimming: node	| trimmerClassification topClassification childClassification |	trimmerClassification := self classificationFor: node trimmer.	childClassification := self classificationFor: node child. 	topClassification := guarded top copy.		1 to: 255 do: [ :index |		| topC trimC childC |		topC := topClassification at: index.		trimC := trimmerClassification at: index.		childC := childClassification at: index.				"child is not, but top is"		(childC not and: topC) ifTrue: [  			"actually, caused by trimmer"			trimC ifTrue: [ topClassification at: index put: false ]		]	].	"visit the child without the classification caused by trimmer"	self visit: node child guardedWith: topClassification! !!PP2GuardVisitor methodsFor: 'support'!visitUnguarded: node	^ self visit: node guardedWith: anythingClassification ! !!PP2IsNullableCache methodsFor: 'optimizations'!doPass: node	| children child |	self visit: node.	children := node allNodes.		[(child := children detect: [ :e | (e hasProperty: self propertySymbol) not ] 							ifNone: [ nil ]) notNil ] whileTrue: [ 				self visit: child	]! !!PP2IsNullableCache methodsFor: 'optimizations'!propertySymbol	^ #isNullable! !!PP2IsNullableVisitor methodsFor: 'loop control'!openedResultFor: node	"		JK: I am not sure, but this should never happen. If this happens, the grammar 			 contains an infinite loop.						If you think I am wrong, you probably also know what to return (I don't).	"	self error: 'There seems to be a left recursive loop in your grammar!!'! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitAction: node	^ node propertyAt: #isNullable ifAbsent: [ 		self visit: node child 	]! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitAdaptable: node	^ node propertyAt: #isNullable ifAbsent: [ 		"Be conservative, we don't know for sure, so it is safer to report false"		false	]! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitAnd: node	^ node propertyAt: #isNullable ifAbsent: [ 		self visit: node child 	]! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitChoice: node	^ node propertyAt: #isNullable ifAbsent: [ 		node children anySatisfy: [ :child | self visit: child  ]	]! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitComposite: node	^ node propertyAt: #isNullable ifAbsent: [ 		self visit: node child 	]! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitDelegate: node	^ node propertyAt: #isNullable ifAbsent: [ 		self visit: node child	]! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitEnd: node	^ node propertyAt: #isNullable ifAbsent: [ 		self visit: node child	]! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitEndOfInput: node	^ false! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitEndOfLine: node	^ false! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitEpsilon: node	^ true! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitFailing: node	^ false! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitFlatten: node	^ self visitDelegate: node! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitLiteralObject: node	^ false! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitLiteralSequence: node	^ node literal isEmpty! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitMapping: node	^ self visitDelegate: node! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitMatch: node	^ self visitDelegate: node! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitNewLine: node	^ false! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitNonEpsilon: node	^ false! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitNot: node	^ node propertyAt: #isNullable ifAbsent: [ 		false	]! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitOptional: node	^ true! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitPP2Node: node	self error: 'should provide specific implementation'! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitPluggable: node	^ node propertyAt: #isNullable ifAbsent: [ 		"Be conservative, we dont know for sure, so it is safer to report true"		false	]! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitPop: node	^ self visitDelegate: node! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitPossesiveRepeating: node	^ node propertyAt: #isNullable ifAbsent: [ 		(node min == 0) ifTrue: [			true		] ifFalse: [ 			self visit: node child		]	]! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitPredicateObject: node	^ false! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitPredicateSequence: node	^ node propertyAt: #isNullable ifAbsent: [ 		node size = 0	]! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitPush: node	^ self visitDelegate: node! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitSea: node	^ self visit: node island! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitSequence: node	^ node propertyAt: #isNullable ifAbsent: [ 		node children allSatisfy: [ :child | self visit: child  ]	]! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitStartOfLine: node	^ false! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitToken: node	^ self visitDelegate: node! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitTrimming: node	^ self visitDelegate: node! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitWater: node	^ self visit: node boundary! !!PP2IsNullableVisitor methodsFor: 'visiting'!visitWrapping: node	^ node propertyAt: #isNullable ifAbsent: [ 		"Be conservative, we don't know for sure, so it is safer to report false"		node doesFunctionalChanges ifTrue: [ false ] ifFalse: [ 			self visit: node child.		]	]! !!PP2NextSetsVisitor methodsFor: 'accessing'!add: aPP2Node to: node	| nextSet |	nextSet := nextSets at: node ifAbsentPut: [ IdentitySet new ].	(nextSets at: node) add: aPP2Node! !!PP2NextSetsVisitor methodsFor: 'accessing'!addAll: aCollection to: node	| nextSet |	nextSet := nextSets at: node ifAbsentPut: [ IdentitySet new ].	(nextSets at: node) addAll: aCollection! !!PP2NextSetsVisitor methodsFor: 'caching'!context: node	^ PP2NextSetsContext new		node: node;		currentNext: currentNext;		yourself! !!PP2NextSetsVisitor methodsFor: 'initialization'!initialize	super initialize.		eoi := PP2EndOfInputNode new.	nextSets := IdentityDictionary new.		"make sure the current next is immutable, otherwise you will have a non-deterministic behaviour"	currentNext := IdentitySet with: eoi.! !!PP2NextSetsVisitor methodsFor: 'accessing'!nextSetFor: node	^ nextSets at: node ifAbsentPut: [ IdentitySet new ]! !!PP2NextSetsVisitor methodsFor: 'accessing'!nextSets	^ nextSets! !!PP2NextSetsVisitor methodsFor: 'accessing'!parentNextSet	self isRoot ifTrue: [  		^ IdentitySet with: eoi	].	^ nextSets at: self parentContext node! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitAction: node	self visitDelegate: node! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitAdaptable: node	self addAll: currentNext to: node.	"should I visit children or not?"	! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitAnd: node	self visitDelegate: node! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitChildrenOf: node	node children do: [ :child | self visit: child ]! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitChoice: node	self visitDelegate: node! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitComposite: node	self visitDelegate: node! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitDelegate: node	self addAll: currentNext to: node.	self visitChildrenOf: node! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitEnd: node	self addAll: currentNext to: node.	"TODO JK: not sure if to add #eoi asPParser"	self visitChildrenOf: node! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitEndOfInput: node	self addAll: currentNext to: node! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitEndOfLine: node	self addAll: currentNext to: node! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitEpsilon: node	self addAll: currentNext to: node! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitFailing: node	self addAll: currentNext to: node! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitFlatten: node	self visitDelegate: node! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitLiteralObject: node	self addAll: currentNext to: node! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitLiteralSequence: node	self addAll: currentNext to: node! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitMapping: node	self visitDelegate: node! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitMatch: node	^ self visitDelegate: node! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitNewLine: node	self addAll: currentNext to: node! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitNonEpsilon: node	self visitDelegate: node! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitNot: node	self visitDelegate: node! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitOptional: node	self visitDelegate: node! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitPP2Node: node	self error: 'should provide specific implementation'! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitPop: node	^ self visitDelegate: node! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitPossesiveRepeating: node	| oldNext |	self addAll: currentNext to: node.	oldNext := currentNext.	currentNext := IdentitySet with: node.	currentNext addAll: oldNext.		self visitChildrenOf: node.		currentNext := oldNext! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitPredicateObject: node	self addAll: currentNext to: node! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitPush: node	^ self visitDelegate: node! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitSea: node	self visitDelegate: node! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitSequence: node	| oldNext |	self addAll: currentNext to: node.	oldNext := currentNext.			node children reversed do: [ :child |		self visit: child.		child isNullable ifFalse: [ currentNext := IdentitySet new ].		currentNext := currentNext copy add: child; yourself	].	currentNext := oldNext! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitStartOfLine: node	self addAll: currentNext to: node! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitToken: node	self visitDelegate: node! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitTrimming: node	self addAll: currentNext to: node.	self visit: node child! !!PP2NextSetsVisitor methodsFor: 'visiting'!visitWater: node	self addAll: currentNext to: node.	self visitChildrenOf: node! !!PP2NoopVisitor methodsFor: 'hooks'!afterAccept: context result: result! !!PP2NoopVisitor methodsFor: 'hooks'!beforeAccept: context! !!PP2NoopVisitor methodsFor: 'caching'!cacheResult: anObject for: context	cache at: context ifPresent: [ self error: 'already cached' ].		cache at: context put: anObject! !!PP2NoopVisitor methodsFor: 'caching'!cachedResultFor: context	^ cache at: context ! !!PP2NoopVisitor methodsFor: 'visiting - utilities'!close: context	self assert: (self isOpened: context).	self assert: (self isClosed: context) not.	self assert: (openStack top == context).		openSet remove: context.	openStack pop.	closeSet add: context.! !!PP2NoopVisitor methodsFor: 'accessing'!closedSet	^ closeSet ! !!PP2NoopVisitor methodsFor: 'caching'!context: node	^ PP2NoopContext new		node: node;		yourself! !!PP2NoopVisitor methodsFor: 'accessing'!currentContext	^ openStack top! !!PP2NoopVisitor methodsFor: 'initialization'!initialize	cache := Dictionary new.	openSet := Set new.	closeSet := Set new.		"to manage parents"	openStack := Stack with: self rootContext.! !!PP2NoopVisitor methodsFor: 'visiting - utilities'!isClosed: context	^ closeSet includes: context ! !!PP2NoopVisitor methodsFor: 'visiting - utilities'!isOpened: context	^ openSet includes: context ! !!PP2NoopVisitor methodsFor: 'accessing'!isRoot	"(rootContext : currentContext)"	^ openStack size = 2! !!PP2NoopVisitor methodsFor: 'visiting - utilities'!nodeClosed: aPP2Parser	"nothing to do"! !!PP2NoopVisitor methodsFor: 'visiting - utilities'!nodeOpened: aPP2Parser	"nothing to do"! !!PP2NoopVisitor methodsFor: 'visiting - utilities'!open: context	self assert: (self isOpened: context) not.	openSet add: context.	openStack push: context! !!PP2NoopVisitor methodsFor: 'accessing'!openSet	^ openSet! !!PP2NoopVisitor methodsFor: 'loop control'!openedResultFor: context	^ #()! !!PP2NoopVisitor methodsFor: 'accessing'!parentContext			"(rootContext : ... : parentContext : currentContext)"	^ openStack at: 2! !!PP2NoopVisitor methodsFor: 'caching'!rootContext	^ PP2NoopContext new		node: nil;		yourself! !!PP2NoopVisitor methodsFor: 'visiting'!visit: node	| result context |	context := self context: node.		(self isClosed: context) ifTrue: [ 		self nodeClosed: node.		^ self cachedResultFor: context	].	(self isOpened: context) ifTrue: [		self nodeOpened: node.		^ self openedResultFor: context	].	self open: context.	self beforeAccept: context.	result := node accept: self.	self afterAccept: context result: result.	self cacheResult: result for: context.	self close: context.	^ result! !!PP2NoopVisitor methodsFor: 'visiting'!visitPP2Node: node	node children do: [ :child | self visit: child ]	! !!PP2PackratVisitor methodsFor: 'as yet unclassified'!doPass: node	^ self visit: node	! !!PP2PackratVisitor methodsFor: 'visiting'!visitPP2Node: node	(node shouldMemoize) ifTrue: [  		(node contextChanges isContextChange) ifTrue: [  			node addWarning: 'cannot memoize a node that changes context!!'		] ifFalse: [ 			node strategy: node strategy memoize		]	].	^ super visitPP2Node: node! !!PP2ParentAnalysisVisitor methodsFor: 'optimizations'!doPass: node	^ self visit: node	! !!PP2ParentAnalysisVisitor methodsFor: 'visiting - utilities'!nodeClosed: node	self assert: parent isNil not.		node addParent: parent! !!PP2ParentAnalysisVisitor methodsFor: 'visiting - utilities'!nodeOpened: node	self assert: parent isNil not.		node addParent: parent! !!PP2ParentAnalysisVisitor methodsFor: 'visiting'!visitPP2Node: node	| tmpParent |	parent isNil ifFalse: [ node addParent: parent ].	tmpParent := parent.	parent := node.	super visitPP2Node: node.	parent := tmpParent.! !!PP2RecognizerVisitor methodsFor: 'support'!changeStrategies: node	node allNodesDo: [ :child | 		self assert: (child hasProperty: #recognizer).		child recognizer ifTrue: [  			child strategy: child strategy recognizer		]	]! !!PP2RecognizerVisitor methodsFor: 'caching'!context: node	^ PP2RecognizerContext new		node: node;		inToken: self inToken;		parent: self currentContext node;		yourself! !!PP2RecognizerVisitor methodsFor: 'optimizations'!doPass: node	self visit: node.	self changeStrategies: node	! !!PP2RecognizerVisitor methodsFor: 'initialization'!inToken	^ inToken top! !!PP2RecognizerVisitor methodsFor: 'initialization'!initialize	super initialize.		inToken := Stack with: false! !!PP2RecognizerVisitor methodsFor: 'visiting'!markNode: node	self inToken ifTrue: [  		node markRecognizer.	] ifFalse: [ 		node markNoRecognizer.	]! !!PP2RecognizerVisitor methodsFor: 'accessing'!parentsFor: node	^ parents at: node ifAbsentPut: [ IdentitySet new ]! !!PP2RecognizerVisitor methodsFor: 'caching'!rootContext	^ PP2RecognizerContext new! !!PP2RecognizerVisitor methodsFor: 'visiting'!visitAction: node	self inToken ifTrue: [  		node warnActionInToken.		inToken push: false.		super visitAction: node.		inToken pop.	] ifFalse: [ 		super visitAction: node	]! !!PP2RecognizerVisitor methodsFor: 'visiting'!visitFlatten: node	self markNode: node.	self visitRecognizer: node child! !!PP2RecognizerVisitor methodsFor: 'visiting'!visitPP2Node: node	self markNode: node.		super visitPP2Node: node! !!PP2RecognizerVisitor methodsFor: 'visiting'!visitRecognizer: node	inToken push: true.	self visit: node.	inToken pop! !!PP2RecognizerVisitor methodsFor: 'visiting'!visitToken: node	self markNode: node.	self visitRecognizer: node child! !!PP2RecognizerVisitor methodsFor: 'visiting'!visitTrimming: node	self markNode: node.	self visitRecognizer: node trimmer.	self visit: node child.! !!PP2SeaOptimizationVisitor methodsFor: 'visiting'!beforeAccept: context	self isRoot ifTrue: [ rootNode := context node ].! !!PP2SeaOptimizationVisitor methodsFor: 'optimizations'!doPass: node	^ self visit: node	! !!PP2SeaOptimizationVisitor methodsFor: 'seas optimizations'!nextSet: node	^ rootNode nextSets at: node! !!PP2SeaOptimizationVisitor methodsFor: 'seas optimizations'!optimizedNextSet: node	| nextSet |	nextSet := self nextSet: node.	nextSet := self removeSeas: nextSet.	nextSet := self removeRepetitions: nextSet.	nextSet := Set withAll: nextSet.		^ nextSet! !!PP2SeaOptimizationVisitor methodsFor: 'seas optimizations'!removeRepetitions: nextSet	"		finds standalne seas and replaces them with islands.		This helps the performance, because seas are not nested	"	| newNextSet |	newNextSet := IdentitySet new.		nextSet do: [ :node | 		(node isRepeating and: [ node min <= 1 ]) ifTrue: [ 			newNextSet add: node child 		] ifFalse: [  			newNextSet add: node		]	].	^ newNextSet! !!PP2SeaOptimizationVisitor methodsFor: 'seas optimizations'!removeSeas: nextSet	"		finds standalne seas and replaces them with islands.		This helps the performance, because seas are not nested	"	| newNextSet |	newNextSet := IdentitySet new.		nextSet do: [ :node | 		| firstSet |		firstSet := node firstSeasOrTerminalsSet.		self seaCanBeRemoved: firstSet ifTrue:  [ :sea |			newNextSet add: sea island		] ifFalse: [  			newNextSet add: node		]	].	^ newNextSet! !!PP2SeaOptimizationVisitor methodsFor: 'seas optimizations'!seaCanBeRemoved: firstSet ifTrue: oneArgBlock ifFalse: aBlock	"Single sea"	(( firstSet size = 1) and: [ 		firstSet anyOne isSea 	]) ifTrue: [ ^ oneArgBlock value: firstSet anyOne ].		"sea / epsilon"	(((firstSet size = 2) and: [ 		firstSet contains: [ :n | n isSea ] ]) and: [ 		firstSet contains: [ :n | n isEpsilon 	]]) ifTrue: [ ^ oneArgBlock value: (firstSet detect: [ :n | n isSea ]) ].	"sea / #eoi"	(((firstSet size = 2) and: [ 		firstSet contains: [ :n | n isSea ] ]) and: [ 		firstSet contains: [ :n | n isEOI	]]) ifTrue: [ ^ oneArgBlock value: (firstSet detect: [ :n | n isSea ]) ].		^ aBlock value! !!PP2SeaOptimizationVisitor methodsFor: 'seas optimizations'!updateNode: node	| nextSet |	nextSet := self optimizedNextSet: node.		node beforeWater boundaryElements: ((OrderedCollection with: node island) addAll: nextSet; yourself).	node afterWater boundaryElements: (OrderedCollection withAll: nextSet).	node root: rootNode.! !!PP2SeaOptimizationVisitor methodsFor: 'visiting'!visitSea: node	super visitSea: node.	self updateNode: node.			"memoize, if there are seas in water"	node afterWater allNodes select: [ :n | n isSea ] thenDo: [ :sea |		sea isContextFree ifTrue: [ 			sea strategy: sea strategy memoize		]	].	^ node! !!PP2SpecializingVisitor methodsFor: 'optimizations'!doPass: node	^ self visit: node	! !!PP2SpecializingVisitor methodsFor: 'testing'!isAndLiteralObject: node 	self assert: (node isKindOf: PP2AndNode).	^ (node child isKindOf: PP2LiteralObjectNode) ! !!PP2SpecializingVisitor methodsFor: 'testing'!isAndPredicateObject: node 	self assert: (node isKindOf: PP2AndNode).	^ (node child isKindOf: PP2PredicateObjectNode) ! !!PP2SpecializingVisitor methodsFor: 'testing'!isAny: node	(node isKindOf: PP2PredicateNode) ifFalse: [ ^ false ].		(node predicate classification allSatisfy: [ :e | e ]) ifFalse: [ ^ false ].		self assert: node predicateMessage = 'input expected'.	^ true! !!PP2SpecializingVisitor methodsFor: 'testing'!isAnyStarLazyLiteralObject: node 	(self isAnyStarLazyObject: node) ifFalse: [ ^ false ].			((node child afterWater boundaryElements anyOne) isKindOf: PP2LiteralObjectNode) ifFalse: [ ^false ].	^ true! !!PP2SpecializingVisitor methodsFor: 'testing'!isAnyStarLazyObject: node 	| sea |	node class = PP2MappingNode ifFalse: [ ^ false ].	node child class = PP2SeaNode ifFalse: [ ^ false ].		sea := node child.		sea island isEpsilon ifFalse: [ ^ false ].	(self isAny: sea waterToken) ifFalse: [ ^ false ].	(sea beforeWater boundaryElements size = 2) ifFalse: [ ^ false ].	(sea afterWater boundaryElements size = 1) ifFalse: [ ^ false ].		^ true! !!PP2SpecializingVisitor methodsFor: 'testing'!isAnyStarLazyPredicateObject: node 	(self isAnyStarLazyObject: node) ifFalse: [ ^ false ].		((node child afterWater boundaryElements anyOne) isKindOf: PP2PredicateObjectNode) ifFalse: [ ^false ].	^ true! !!PP2SpecializingVisitor methodsFor: 'testing'!isMappingOfThree: node 	self assert: (node isKindOf: PP2MappingNode).	^ (node child children size = 3) ! !!PP2SpecializingVisitor methodsFor: 'testing'!isMappingOfTwo: node 	self assert: (node isKindOf: PP2MappingNode).	^ (node child children size = 2) ! !!PP2SpecializingVisitor methodsFor: 'testing'!isNotLiteralObject: node 	self assert: (node isKindOf: PP2NotNode).	^ (node child isKindOf: PP2LiteralObjectNode) ! !!PP2SpecializingVisitor methodsFor: 'testing'!isNotPredicateObject: node 	self assert: (node isKindOf: PP2NotNode).	^ (node child isKindOf: PP2PredicateObjectNode) ! !!PP2SpecializingVisitor methodsFor: 'testing'!isOptionalCharacter: node 	^ (node child isKindOf: PP2LiteralObjectNode) ! !!PP2SpecializingVisitor methodsFor: 'testing'!isPlus: node 	^ node min = 1 and: [ node max = Float infinity ] ! !!PP2SpecializingVisitor methodsFor: 'testing'!isPlusPredicateObject: node 	^ (node min = 1) and: [ 	  (node max = Float infinity) and: [ 	  node child isKindOf: PP2PredicateObjectNode 	]]! !!PP2SpecializingVisitor methodsFor: 'testing'!isStar: node 	^ node min = 0 and: [ node max = Float infinity ]! !!PP2SpecializingVisitor methodsFor: 'testing'!isStarPredicateObject: node 	^ (node min = 0) and: [ 	  (node max = Float infinity) and: [ 	  node child isKindOf: PP2PredicateObjectNode 	]]! !!PP2SpecializingVisitor methodsFor: 'testing'!isTrimmingLiteralObjectToken: node 	self assert: (node isKindOf: PP2TrimmingNode).		(node child isKindOf: PP2CreateTokenNode) ifFalse: [ ^ false ].	^ (node child childSkipDelegate isKindOf: PP2LiteralObjectNode) 		"		self new isTrimmingLiteralObjectToken: $a asPParser token trim.	"! !!PP2SpecializingVisitor methodsFor: 'testing'!isTrimmingToken: node 	self assert: (node isKindOf: PP2TrimmingNode).	^ node child isKindOf: PP2CreateTokenNode		"		self new isTrimmingToken: 'foo' asPParser token trim.	"! !!PP2SpecializingVisitor methodsFor: 'visiting'!visitAdaptable: node	"do not visit beyond this point"! !!PP2SpecializingVisitor methodsFor: 'visiting'!visitAnd: node	(self isAndLiteralObject: node) ifTrue: [  		node strategy: (PP2AndLiteralObject on: node)	].	(self isAndPredicateObject: node) ifTrue: [  		node strategy: (PP2AndPredicateObject on: node)	].	^ super visitOptional: node! !!PP2SpecializingVisitor methodsFor: 'visiting'!visitMapping: node	super visitMapping: node.		(self isAnyStarLazyPredicateObject: node) ifTrue: [  		node strategy: (PP2AnyStarLazyPredicateObject on: node 			predicate: node child afterWater boundaryElements anyOne predicate).		^ self.	].	(self isAnyStarLazyLiteralObject: node) ifTrue: [  		node strategy: (PP2AnyStarLazyLiteralObject on: node 			literal: node child afterWater boundaryElements anyOne literal).		^ self.	].	(self isMappingOfTwo: node) ifTrue: [  		node strategy: (PP2MappingOfTwo on: node).		^ self	].	(self isMappingOfThree: node) ifTrue: [  		node strategy: (PP2MappingOfThree on: node).		^ self	].	^ super visitMapping: node! !!PP2SpecializingVisitor methodsFor: 'visiting'!visitNot: node	(self isNotLiteralObject: node) ifTrue: [  		node strategy: (PP2NotLiteralObject on: node)	].	(self isNotPredicateObject: node) ifTrue: [  		node strategy: (PP2NotPredicateObject on: node)	].	^ super visitOptional: node! !!PP2SpecializingVisitor methodsFor: 'visiting'!visitOptional: node	(self isOptionalCharacter: node) ifTrue: [  		node strategy: (PP2OptionalLiteralObject on: node)	].	^ super visitOptional: node! !!PP2SpecializingVisitor methodsFor: 'visiting'!visitPossesiveRepeating: node	(self isStar: node) ifTrue: [  		node strategy: (PP2Star on: node)	].	(self isStarPredicateObject: node) ifTrue: [  		node strategy: (PP2StarPredicateObject 			on: node 			predicate: node child predicate)	].	(self isPlus: node) ifTrue: [  		node strategy: (PP2Plus on: node)	].	(self isPlusPredicateObject: node) ifTrue: [  		node strategy: (PP2PlusPredicateObject on: node)	].	^ super visitPossesiveRepeating: node! !!PP2SpecializingVisitor methodsFor: 'visiting'!visitSequence: node	(node children size = 2) ifTrue: [  		node strategy: (PP2SequenceOfTwo on: node)	].	(node children size = 3) ifTrue: [  		node strategy: (PP2SequenceOfThree on: node)	].	^ super visitSequence: node! !!PP2SpecializingVisitor methodsFor: 'visiting'!visitTrimming: node	(self isTrimmingToken: node) ifTrue: [  		node strategy: (PP2TrimmingToken on: node)	].	(self isTrimmingLiteralObjectToken: node) ifTrue: [  		node strategy: (PP2TrimmingLiteralObjectToken on: node)	].	^ super visitTrimming: node! !!PP2TransformVisitor methodsFor: 'accessing'!block	^ block! !!PP2TransformVisitor methodsFor: 'accessing'!block: anObject	block := anObject! !!PP2TransformVisitor methodsFor: 'initialization'!initialize	super initialize.	predicate := [ :node | true ].	block := [ :node | node ].		mapping := IdentityDictionary new.! !!PP2TransformVisitor methodsFor: 'visiting'!initializeMapping: rootNode	| transformed |		rootNode allNodesDo: [ :node |		transformed := node copy. 		(predicate value: node) ifTrue: [  			transformed := block value: transformed		].		mapping at: node put: transformed.	]! !!PP2TransformVisitor methodsFor: 'visiting'!openedResultFor: context	"when visiting opened node, return the transformed value"	^ self transformed: context node! !!PP2TransformVisitor methodsFor: 'accessing'!predicate	^ predicate! !!PP2TransformVisitor methodsFor: 'accessing'!predicate: anObject	predicate := anObject! !!PP2TransformVisitor methodsFor: 'visiting'!transformed: node	^ mapping at: node ifAbsent: [ node ].	! !!PP2TransformVisitor methodsFor: 'visiting'!visitPP2Node: node	| transformed transformedChild |	self isRoot ifTrue: [ self initializeMapping: node ].			transformed := self transformed: node.	transformed children do: [ :child |		transformedChild := self visit: child.		transformed replace: child with: transformedChild.	].	^ transformed! !!PP2TrimmingCacheVisitor methodsFor: 'optimizations'!doPass: node	self flag: 'should add a trimming guard for the equivalent trimmers'.	(self usingSameTrimmer: node) ifTrue: [ 		self visit: node.	] ifFalse: [  		node warnDifferentTrimmer.	]! !!PP2TrimmingCacheVisitor methodsFor: 'optimizations'!usingSameTrimmer: node	| trimmings trimmers |	trimmings := node allNodes select: [ :c | c isTrimming ].		trimmers := trimmings collect: [ :e | e trimmer ].	^ (Set withAll: trimmers) size = 1! !!PP2TrimmingCacheVisitor methodsFor: 'visiting'!visitTrimming: node	node trimmer strategy: node trimmer strategy trimmingCache.		super visitTrimming: node! !!PP2NextSetsContext methodsFor: 'comparing'!= anotherContext	super = anotherContext ifFalse: [ ^ false ].		(self currentNext size = anotherContext currentNext size) ifFalse: [ ^ false ].	self currentNext do: [ :value |		(anotherContext currentNext includes: value) ifFalse: [ ^ false ]	].	^ true! !!PP2NextSetsContext methodsFor: 'accessing'!currentNext	^ currentNext! !!PP2NextSetsContext methodsFor: 'accessing'!currentNext: anObject	self assert: [ anObject class == IdentitySet ] description: 'if not, override the #hash and #='.	currentNext := anObject! !!PP2NextSetsContext methodsFor: 'comparing'!hash	| hash |	hash := super hash.	currentNext size <= 10 ifTrue: [  		currentNext do: [ :e | e identityHash ].	].	^ hash bitXor: currentNext size hash! !!PP2NoopContext class methodsFor: 'instance creation'!with: node	^ (self new)		node: node;		yourself! !!PP2NoopContext methodsFor: 'comparing'!= anotherContext	self class == anotherContext class ifFalse: [ ^ false ].	self node == anotherContext node ifFalse: [ ^ false ].		^ self properties = anotherContext properties! !!PP2NoopContext methodsFor: 'comparing'!hash	^ self node identityHash bitXor: (self properties hash)! !!PP2NoopContext methodsFor: 'initialization'!initialize	super initialize! !!PP2NoopContext methodsFor: 'accessing'!node	^ node! !!PP2NoopContext methodsFor: 'accessing'!node: anObject	node := anObject! !!PP2NoopContext methodsFor: 'accessing - properties'!properties	^ properties! !!PP2NoopContext methodsFor: 'accessing - properties'!properties: anObject	^ properties := anObject ! !!PP2RecognizerContext methodsFor: 'comparing'!= anotherContext	super = anotherContext ifFalse: [ ^ false ]	.	(self inToken == anotherContext inToken) ifFalse: [ ^ false ].	(self parent == anotherContext parent) ifFalse: [ ^ false ].		^ true! !!PP2RecognizerContext methodsFor: 'comparing'!hash	^ super hash bitXor: (self inToken hash bitXor: self parent identityHash)! !!PP2RecognizerContext methodsFor: 'accessing'!inToken	^ inToken! !!PP2RecognizerContext methodsFor: 'accessing'!inToken: anObject	inToken := anObject! !!PP2RecognizerContext methodsFor: 'accessing'!parent	^ parent! !!PP2RecognizerContext methodsFor: 'accessing'!parent: anObject	parent := anObject! !!PP2PopMemento methodsFor: 'accessing'!position	^ position! !!PP2PopMemento methodsFor: 'accessing'!position: anObject	position := anObject! !!PP2PopMemento methodsFor: 'accessing'!stackSize	^ stackSize! !!PP2PopMemento methodsFor: 'accessing'!stackSize: anObject	stackSize := anObject! !!PP2PopMemento methodsFor: 'accessing'!stackTop	^ top! !!PP2PopMemento methodsFor: 'accessing'!stackTop: anObject	top := anObject! !!PP2PushMemento methodsFor: 'accessing'!position	^ position! !!PP2PushMemento methodsFor: 'accessing'!position: anObject	position := anObject! !!PP2PushMemento methodsFor: 'accessing'!stackSize	^ stackSize! !!PP2PushMemento methodsFor: 'accessing'!stackSize: anObject	stackSize := anObject! !!PP2Stack class methodsFor: 'accessing'!elementsCollection	^ OrderedCollection new! !!PP2Stack methodsFor: 'comparing'!= anotherStack	(anotherStack isKindOf: PP2Stack) ifFalse: [  		^ false	].	^ anotherStack elements = elements ! !!PP2Stack methodsFor: 'accessing'!elements	^ elements! !!PP2Stack methodsFor: 'comparing'!equals: anotherStack	(anotherStack isKindOf: PP2Stack) ifFalse: [  		^ false	].	^ anotherStack elements = elements ! !!PP2Stack methodsFor: 'initialization'!initialize	super initialize.		elements := PP2Stack elementsCollection.! !!PP2Stack methodsFor: 'removing'!isEmpty	^ elements isEmpty ! !!PP2Stack methodsFor: 'removing'!pop	^ elements removeLast! !!PP2Stack methodsFor: 'copying'!postCopy	"JK: I am not sure, if this works properly for optimized version!!"	super postCopy.		elements := elements copy.! !!PP2Stack methodsFor: 'adding'!push: element	elements addLast: element.	^ element! !!PP2Stack methodsFor: 'adding'!size	^ elements size! !!PP2Stack methodsFor: 'removing'!top	^ elements last! !!PP2Stream class methodsFor: 'instance creation'!new	"for compatibility reasons"	^ self basicNew		initialize! !!PP2Stream class methodsFor: 'instance creation'!on: collection	^ self new		collection: collection;		yourself! !!PP2Stream methodsFor: 'converting'!asPetit2Context	^ PP2InMemoryContext on: self	collection! !!PP2Stream methodsFor: 'converting'!asPetit2Stream	^ self! !!PP2Stream methodsFor: 'context interface'!atEnd: position	^ collection size <= position! !!PP2Stream methodsFor: 'context interface'!atPosition: position	^ collection at: position! !!PP2Stream methodsFor: 'accessing'!collection	^ collection! !!PP2Stream methodsFor: 'accessing'!collection: aCollection	collection := aCollection! !!PP2Stream methodsFor: 'accessing'!contents	^ collection copyFrom: 1 to: collection size! !!PP2Stream methodsFor: 'context interface'!copyFrom: start to: end	"start - end should be in range <1, collection size> "	^ collection copyFrom: start to: end! !!PP2Stream methodsFor: 'initialization'!initialize	super initialize! !!PP2Stream methodsFor: 'testing'!isBuffered	^ false! !!PP2Stream methodsFor: 'tokenization'!newToken: tokenClass from: start to: stop	^ tokenClass 		on: collection 		start:  start		stop: 	stop! !!PP2Stream methodsFor: 'printing'!printOn: writeStream position: position	writeStream		nextPutAll: (collection copyFrom: 1 to: position);		nextPutAll: '·';		nextPutAll: (collection copyFrom: position + 1 to: collection size)! !!PP2Stream methodsFor: 'initialization'!reset	! !!PP2Token class methodsFor: 'instance creation'!on: collection start: start stop: stop	^ self new		collection: collection;		start: start;		stop: stop;		yourself! !!PP2Token methodsFor: 'accessing'!collection	^ collection! !!PP2Token methodsFor: 'accessing'!collection: anObject	collection := anObject! !!PP2Token methodsFor: 'testing'!isToken	^ true! !!PP2Token methodsFor: 'printing'!printOn: aStream	self value printOn: aStream.	aStream nextPut: $[.	start printOn: aStream.	aStream nextPut: $,.	stop printOn: aStream.	aStream nextPut: $].! !!PP2Token methodsFor: 'accessing - properties'!properties	^ properties! !!PP2Token methodsFor: 'accessing - properties'!properties: newProperties	^ properties := newProperties! !!PP2Token methodsFor: 'accessing'!size	"Answer the size of this token in the underlying collection."	^ stop - start + 1! !!PP2Token methodsFor: 'accessing'!start	^ start! !!PP2Token methodsFor: 'accessing'!start: anObject	start := anObject! !!PP2Token methodsFor: 'accessing'!stop	^ stop! !!PP2Token methodsFor: 'accessing'!stop: anObject	stop := anObject! !!PP2Token methodsFor: 'printing'!toString	^ self value, '[', start, ',', stop ,']'! !!PP2Token methodsFor: 'evaluating'!value	^ collection copyFrom: start to: stop! !!PP2UnknownCharSetPredicate class methodsFor: 'as yet unclassified'!instance	instance isNil ifTrue: [ 		instance := PP2UnknownCharSetPredicate new	].	^ instance! !!PP2UnknownCharSetPredicate methodsFor: 'testing'!isUnknown	^ true! !!PP2UnknownCharSetPredicate methodsFor: 'accessing'!value: aCharacter	self error: 'I don''t know, sorry man :('! !!PP2CharacterStream class methodsFor: 'instance creation'!on: stream encoder: encoder	^ (self basicNew initialize)		stream: stream;		encoder: encoder;		yourself! !!PP2CharacterStream methodsFor: 'accessing'!atEnd	^ stream atEnd! !!PP2CharacterStream methodsFor: 'accessing'!encoder	^ encoder! !!PP2CharacterStream methodsFor: 'accessing'!encoder: anObject	encoder := anObject! !!PP2CharacterStream methodsFor: 'accessing'!next	^ (encoder nextCodePointFromStream: stream) asCharacter! !!PP2CharacterStream methodsFor: 'accessing'!stream	^ stream! !!PP2CharacterStream methodsFor: 'accessing'!stream: anObject	stream := anObject! !!Stream methodsFor: '*petitparser2'!asPetit2Context	^ self asPetit2Stream asPetit2Context ! !!Stream methodsFor: '*petitparser2'!asPetit2Stream	^ PP2BufferStream 		on: self 		bufferSize: 4*1024! !!Symbol methodsFor: '*PetitParser2'!asPParser	"Answer a predicate parser named after the receiving symbol. Possible symbols are the method selectors on the class-side of PPPredicateObjectParser."	^ PP2NodeFactory instance perform: self! !!UndefinedObject methodsFor: '*PetitParser2'!asPParser	^ PP2EpsilonNode new! !!UndefinedObject methodsFor: '*PetitParser2'!isSeparator	^ false! !!String methodsFor: '*petitparser2'!asPParser	"Answer a parser that accepts the receiving string."	^ PP2LiteralSequenceNode on: self! !!SequenceableCollection methodsFor: '*petitparser2'!asPetit2Context	^ PP2InMemoryContext on: self position: 0! !!SequenceableCollection methodsFor: '*petitparser2'!asPetit2Stream	^ PP2Stream on: self	"^ PP2BufferStream on: (ReadStream on: self)"! !!ManifestPetitParser class methodsFor: 'code-critics'!ruleRBBadMessageRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#PP2RecordingContext #node #false)) #'2019-12-21T17:44:58.79148+01:00') #(#(#RGMethodDefinition #(#PP2RecordingContext #strategy #false)) #'2019-12-21T17:45:12.398818+01:00') )! !!ManifestPetitParser class methodsFor: 'code-critics'!ruleRBLongMethodsRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#PP2Node #optimize #false)) #'2020-01-05T15:57:22.927177+01:00') )! !!PP2InMemoryContext class methodsFor: 'instance creation'!new	^ self basicNew initialize! !!PP2InMemoryContext class methodsFor: 'instance creation'!on: aCollection position: position	^ (self on: aCollection) 		position: position;		setAsStartState;		yourself.! !!PP2InMemoryContext methodsFor: 'reparsing'!adoptString: newString	collection := newString.	readLimit := newString size.	self assert: readLimit notNil.! !!PP2InMemoryContext methodsFor: 'reparsing'!applyChange: change	change updateContext: self.	change updateTokens: self returnValue.	change updateParser: self parser! !!PP2InMemoryContext methodsFor: 'converting'!asPetit2Context	^ self! !!PP2InMemoryContext methodsFor: 'converting'!asPositionableStream	^ self! !!PP2InMemoryContext methodsFor: 'copying'!copyFrom: start to: end	"start - end should be in range <1, collection size> "	^ collection copyFrom: start to: end! !!PP2InMemoryContext methodsFor: 'debugging'!debugResult	^ self globalAt: #debugResult ifAbsentPut: [ 		| context |		context := self copy.		context restore: self startMemento.		context parser duplicate enableDebug parseWithContext: context.		context currentDebugResult	]! !!PP2InMemoryContext methodsFor: 'accessing-globals'!globals	^ globals! !!PP2InMemoryContext methodsFor: 'accessing-globals'!globals: anObject	^ globals := anObject! !!PP2InMemoryContext methodsFor: 'initialization'!initialize	super initialize.		self setAsStartState! !!PP2InMemoryContext methodsFor: 'testing'!isBuffered	^ false! !!PP2InMemoryContext methodsFor: 'testing'!isPetit2Context	^ true! !!PP2InMemoryContext methodsFor: 'tokenization'!newToken: tokenClass from: start	^ tokenClass 		on: collection		start: start + 1		stop: position! !!PP2InMemoryContext methodsFor: 'accessing'!next: anInteger 	| endPosition |	endPosition := position + anInteger.	^ (endPosition <= readLimit) ifTrue: [ 		collection copyFrom: position+1 to: (position := endPosition).		] ifFalse: [  		nil	]! !!PP2InMemoryContext methodsFor: 'accessing'!nextFor: aCharacter	position == readLimit ifTrue: [ ^ false ].	position := position + 1.	^ (collection at: position) == aCharacter 		ifTrue: [  true] 		ifFalse: [position := position - 1 . false ]! !!PP2InMemoryContext methodsFor: 'accessing'!parser	^ parser! !!PP2InMemoryContext methodsFor: 'accessing'!parser: anObject	parser := anObject! !!PP2InMemoryContext methodsFor: 'accessing'!peek	"An improved version of peek, that is slightly faster than the built in version."	^ self atEnd ifFalse: [ collection at: position + 1 ]! !!PP2InMemoryContext methodsFor: 'accessing'!position	^ position ! !!PP2InMemoryContext methodsFor: 'copying'!postCopy	super postCopy.		globals := globals copy.! !!PP2InMemoryContext methodsFor: 'accessing - properties'!properties	^ properties! !!PP2InMemoryContext methodsFor: 'accessing - properties'!properties: newProperties	^ properties := newProperties! !!PP2InMemoryContext methodsFor: 'accessing'!readLimit	^ readLimit! !!PP2InMemoryContext methodsFor: 'memoization'!remember	^ PP2ContextMemento new		stream: self;		position: position;		properties: self propertiesCopy;		yourself.! !!PP2InMemoryContext methodsFor: 'memoization'!rememberPosition	^ position! !!PP2InMemoryContext methodsFor: 'initialization'!reset	super reset.	globals := nil! !!PP2InMemoryContext methodsFor: 'memoization'!restore: contextMemento	position := contextMemento position.	properties := contextMemento propertiesCopy.! !!PP2InMemoryContext methodsFor: 'memoization'!restorePosition: anInteger	position := anInteger ! !!PP2InMemoryContext methodsFor: 'accessing'!returnValue	^ returnValue! !!PP2InMemoryContext methodsFor: 'accessing'!returnValue: anObject	returnValue := anObject! !!PP2InMemoryContext methodsFor: 'stream extras'!shift	position := position + 1! !!PP2InMemoryContext methodsFor: 'stream extras'!shift: integer	position := position + integer! !!PP2InMemoryContext methodsFor: 'accessing'!startMemento	^ startMemento! !!PP2InMemoryContext methodsFor: 'accessing'!startMemento: anObject	startMemento := anObject! !!PP2InMemoryContext methodsFor: 'accessing'!stream	^ self! !!PP2InMemoryContext methodsFor: 'accessing'!stream: aPP2Stream	collection := aPP2Stream collection.	readLimit := collection size.	position := 0! !!PP2InMemoryContext methodsFor: 'stream extras'!uncheckedNext	position := position + 1.	^ collection at: position! !!PP2InMemoryContext methodsFor: 'stream extras'!uncheckedPeek	^ collection at: position + 1! !!PP2InMemoryContext methodsFor: 'accessing'!upTo: character	"fast version using indexOf:"	| start end |	start := position+1.	end := collection indexOf: character startingAt: start ifAbsent: [ 0 ].	"not present--return rest of the collection"		(end = 0 or: [end > readLimit]) ifTrue: [ ^ self upToEnd ].	"skip to the end and return the data passed over"	position := end.	^ collection copyFrom: start to: end! !!PP2InMemoryContext methodsFor: 'evaluating'!value	^ returnValue! !!PP2RecordingContext methodsFor: 'converting'!asCacheReport	| table |	table := OrderedCollection new. 	parser allCaches do: [ :c | 		table add: (Array with: c with: c hitRatio with: c invocations).	].	^ table! !!PP2RecordingContext methodsFor: 'converting'!asFrequencyTable	| bag total result |	bag := (eventsTrace entriesCollect: #strategy) asBag.	result := OrderedCollection new.	bag isEmpty ifTrue: [ ^ result ].	total := 100.0 / bag size.	bag sortedCounts 		do: [ :each | result addLast: (Array with: each value with: each key with: total * each key) ].	^ result! !!PP2RecordingContext methodsFor: 'converting'!asFrequencyTableForEvent: event	| bag total result filtered |		filtered := OrderedCollection new.	eventsTrace entriesDo: [ :e | 		event == e event ifTrue: [ filtered add: e strategy ]	].		bag := filtered asBag.	result := OrderedCollection new.	bag isEmpty ifTrue: [ ^ result ].	total := 100.0 / bag size.	bag sortedCounts 		do: [ :each | result addLast: (Array with: each value with: each key with: total * each key) ].	^ result! !!PP2RecordingContext methodsFor: 'converting'!asReportTable	| backtrackPerCharacter restoreCount rememberCount table lwRememberCount lwRestoreCount lwBacktrackPerCharacter |	rememberCount := (self countFor: #remember).	restoreCount := (self countFor: #restore).	backtrackPerCharacter := (restoreCount / (totalSize max: 1) asFloat).	lwRememberCount := (self countFor: #rememberPosition).	lwRestoreCount := (self countFor: #restorePosition).	lwBacktrackPerCharacter := (lwRestoreCount / (totalSize max: 1) asFloat).	table := OrderedCollection new. 	table add: (Array with: totalSize with: #'total stream size' with: totalSize).	table add: (Array with: backtrackPerCharacter with: #'backtrack per character' with: backtrackPerCharacter).	table add: (Array with: rememberCount with: #'remember count' with: rememberCount).	table add: (Array with: restoreCount with: #'restore count' with: restoreCount).	table add: (Array with: lwBacktrackPerCharacter with: #'lightweight backtrack per character' with: lwBacktrackPerCharacter).	table add: (Array with: lwRememberCount with: #'lightweight remember count' with: lwRememberCount).	table add: (Array with: lwRestoreCount with: #'lightweight restore count' with: lwRestoreCount).	^ table! !!PP2RecordingContext methodsFor: 'recording'!cacheHit	self event: #cacheHit! !!PP2RecordingContext methodsFor: 'reporting'!countFor: event	| count |	count := 0.	self eventsTrace entriesDo: [ :e |		(e event == event) ifTrue: [ count := count + 1 ].	].	^ count! !!PP2RecordingContext methodsFor: 'accessing'!event: value	| entry |	entry := PP2EventRecord new		position: self position;		strategy: self strategy;		event: value;		yourself.			eventsTrace addLast: entry! !!PP2RecordingContext methodsFor: 'converting'!eventsTable	| trace |	trace := OrderedCollection new.	1 to: (10*1000 min: eventsTrace entriesCount) do: [ :index | 		trace addLast: { 			(eventsTrace entryAt: index) position . 			(eventsTrace entryAt: index) event . 			(eventsTrace entryAt: index) strategy .			(eventsTrace entryAt: index) node 		}	].	^ trace! !!PP2RecordingContext methodsFor: 'accessing'!eventsTrace	^ eventsTrace ! !!PP2RecordingContext methodsFor: 'private'!findContextSuchThat: aBlock	^ thisContext findContextSuchThat: aBlock! !!PP2RecordingContext methodsFor: 'accessing'!furthestPosition	^ furthestPosition max: position! !!PP2RecordingContext methodsFor: 'accessing'!furthestPosition: anObject	furthestPosition := anObject! !!PP2RecordingContext methodsFor: 'initialization'!initialize	super initialize.	self reset.! !!PP2RecordingContext methodsFor: 'reporting'!invocationCount	^  self countFor: #methodInvoked! !!PP2RecordingContext methodsFor: 'events'!invoked	| entry |	entry := PP2InvocationRecord new		position: self position;		strategy: self strategy;		event: #invoked;		yourself.			eventsTrace addLast: entry! !!PP2RecordingContext methodsFor: 'testing'!isRecording	^ true! !!PP2RecordingContext methodsFor: 'accessing'!lastDebugResult	^ (self currentDebugResult children) isEmpty ifTrue: [ 		nil	] ifFalse: [		self currentDebugResult children last	]! !!PP2RecordingContext methodsFor: 'events'!namedInvoked	| entry |	entry := PP2InvocationRecord new		position: self position;		strategy: self strategy;		event: #namedInvoked;		yourself.			eventsTrace addLast: entry! !!PP2RecordingContext methodsFor: 'accessing'!next	self event: #next.	furthestPosition := (furthestPosition max: position + 1).		^ super next! !!PP2RecordingContext methodsFor: 'accessing'!next: number	self event: #next.	furthestPosition := (furthestPosition max: position + number).		^ super next: number! !!PP2RecordingContext methodsFor: 'private'!node	^ (self findContextSuchThat: [ :ctxt | (ctxt receiver isKindOf: PP2AbstractStrategy)])		ifNil: [ nil ]		ifNotNil: [ :aContext |			aContext receiver node		].	! !!PP2RecordingContext methodsFor: 'accessing'!parser: aPP2Node	super parser: aPP2Node.		"Transform to recording strategies"	aPP2Node enableRecording.! !!PP2RecordingContext methodsFor: 'accessing'!position: value	self assert: value isInteger.	super position: value! !!PP2RecordingContext methodsFor: 'events'!remember	self event: #remember.	^ super remember! !!PP2RecordingContext methodsFor: 'memoization'!rememberPosition	self event: #rememberPosition.	^ super rememberPosition! !!PP2RecordingContext methodsFor: 'initialization'!reset	super reset.		eventsTrace := PP2EventsTrace new.	furthestPosition := -1.	totalSize := 0.! !!PP2RecordingContext methodsFor: 'memoization'!restore: whatever	self event: #restore.	furthestPosition := (furthestPosition max: position).	^ super restore: whatever! !!PP2RecordingContext methodsFor: 'memoization'!restorePosition: newPosition	self event: #restorePosition.	furthestPosition := (furthestPosition max: position).		^ super restorePosition: newPosition! !!PP2RecordingContext methodsFor: 'requirements'!setAsStartState	^ self startMemento: super remember! !!PP2RecordingContext methodsFor: 'private'!strategy	^ (self findContextSuchThat: [ :ctxt | (ctxt receiver isKindOf: PP2AbstractStrategy)])		ifNil: [ PP2NilStrategy new ]		ifNotNil: [ :aContext | aContext receiver ].	! !!PP2RecordingContext methodsFor: 'accessing'!stream: aStream	super stream: aStream.	totalSize := totalSize + readLimit.! !!PP2RecordingContext methodsFor: 'accessing'!totalSize	^ totalSize! !!PP2RecordingContext methodsFor: 'events'!uncheckedNext	self event: #uncheckedNext.	^ super uncheckedNext! !!PP2RecordingContext methodsFor: 'events'!uncheckedPeek	self event: #uncheckedPeek.	^ super uncheckedPeek! !!PP2OutOfBoundsException class methodsFor: 'signalling'!signalFor: subscript	^ (self new)		signalFor: subscript;		signal! !!PP2OutOfBoundsException methodsFor: 'signalling'!signalFor: anInteger	subscript := anInteger! !!Character methodsFor: '*petitparser2'!asPParser	"Answer a parser that accepts the receiving character."		^ PP2LiteralObjectNode on: self! !!PositionableStream methodsFor: '*petitparser2'!asPetit2Stream	^ PP2Stream on: self contents! !!Text methodsFor: '*PetitParser2'!asPetit2Stream	^ string asPetit2Stream! !!Array methodsFor: '*PetitParser2'!asMapArgument	^ self! !!BlockClosure methodsFor: '*PetitParser2'!asCharSetPredicate	^ PP2CharSetPredicate on: self! !!BlockClosure methodsFor: '*PetitParser2'!asPParser	"Answer a parser implemented in the receiving one-argument block."	^ PP2PluggableNode on: self! !!Collection methodsFor: '*PetitParser2'!nodesDo: aBlock	self do: aBlock! !"PetitParser2"!!TPP2AdaptableGrammarTest commentStamp: '' prior: 0!TestSuite for PP2AdaptableGrammar!!TPP2ExpressionGrammarTest commentStamp: '' prior: 0!TestSuite for PP2ExpressionGrammar!!PP2MinimalStream commentStamp: '' prior: 0!I provide a bare minimum of methods required by PP2 to be parsed:- atEnd- nextI can be converted to PP2Stream using the #asPetit2Stream!!PP2CompositeNodeExamples commentStamp: '' prior: 0!I am an abstract class that should be used for writing examples about parsers, using GToolkit-Examples.I am supposed to be subclassed in a similar fashion as PP2CompositeNodeTest.!!TPP2AdaptableGrammarTest methodsFor: 'accessing'!parserClass	^ PP2AdaptableGrammar! !!TPP2AdaptableGrammarTest methodsFor: 'tests'!testContent	self parse: '1_2__3___' rule: #content.	self fail: '1_2' rule: #content.! !!TPP2AdaptableGrammarTest methodsFor: 'tests'!testElement	self parse: '1a' rule: #element.	self parse: '2aa' rule: #element.	self fail: '2a' rule: #element.! !!TPP2AdaptableGrammarTest methodsFor: 'tests'!testElementNumberInBody	self parse: '10___4______' rule: #content.	self fail: '1_2' rule: #content.! !!TPP2AdaptableGrammarTest methodsFor: 'tests'!testHead	self parse: '1' rule: #head! !!TPP2CollectionAssertions methodsFor: 'assertions'!assert: aCollection allSatisfy: aBlock	self assert: (aCollection allSatisfy: aBlock)! !!TPP2CollectionAssertions methodsFor: 'assertions'!assert: aCollection anySatisfy: aBlock	self assert: (aCollection anySatisfy: aBlock)! !!TPP2CollectionAssertions methodsFor: 'assertions'!assert: aCollection includes: aBlock	self assert: (aCollection includes: aBlock)! !!TPP2CollectionAssertions methodsFor: 'assertions'!assert: aCollection noneSatisfy: aBlock	self assert: (aCollection noneSatisfy: aBlock)! !!TPP2ContextTest methodsFor: 'requirements'!contextOn: aString	self explicitRequirement! !!TPP2ContextTest methodsFor: 'tests'!testAtEnd	| context |	context := self contextOn: 'foo'.		self deny: context atEnd.	context next: 3.	self assert: context atEnd.! !!TPP2ContextTest methodsFor: 'tests'!testContents	| context |	context := self contextOn: 'foo'.		self assert: (context respondsTo: #contents).	self assert: context contents equals: 'foo'! !!TPP2ContextTest methodsFor: 'tests'!testCopyGlobals	| context contextCopy |	context := self contextOn: 'foo'.	context globals: (IdentityDictionary newFromPairs: { #a . #b }).		contextCopy := context copy.		self assert: context globals equals: contextCopy globals.	self assert: context globals ~~ contextCopy globals.	! !!TPP2ContextTest methodsFor: 'tests'!testMemo	| context memento |	context := self contextOn: 'foobar'.	context propertyAt: #foo put: #bar.	memento := context remember.	context next.	context propertyAt: #bar put: #baz.	context propertyAt: #foo put: #bark.	context restore: memento.	self assert: context position equals: 0.	self deny: (context hasProperty: #bar).	self assert: (context propertyAt: #foo) equals: #bar.! !!TPP2ContextTest methodsFor: 'tests'!testNext	| retval context |	context := self contextOn: 'foo'.		retval := context next: 3.	self assert: retval isPetit2Success.	self assert: retval equals: 'foo'.		retval := context next: 1.	self assert: retval isNil.		context position: 0.	retval := context next: 3.	self assert: retval isPetit2Success.	self assert: retval = 'foo'.! !!TPP2ContextTest methodsFor: 'tests'!testNextAtEnd	| context retval |	context := self contextOn: 'foo'.		context position: 3.		retval := context next.	self assert: retval isNil.		self assert: context position equals: 3.! !!TPP2ContextTest methodsFor: 'tests'!testParser	| context parser |	parser := $a asPParser.		context := (self contextOn: 'bar')		parser: parser;		yourself.		self assert: context parser equals: parser.! !!TPP2ContextTest methodsFor: 'tests'!testPeek	| context |	context := self contextOn: 'foo'.	self assert: context peek equals: $f.		context upToEnd.	self assert: context peek equals: nil.! !!TPP2ContextTest methodsFor: 'tests'!testPeekBack	| context |	context := self contextOn: 'bar'.	self should: [ context peekBack ] raise: Exception.		context upToEnd.		self assert: context peekBack equals: $r.! !!TPP2ContextTest methodsFor: 'tests'!testRemember	| context memento |	context := self contextOn: 'foobar'.	context propertyAt: #foo put: #bar.	memento := context remember.	self assert: memento position equals: context position.	self assert: memento properties equals: context properties.	context propertyAt: #foo put: #baz.	self assert: (memento propertyAt: #foo) equals: #bar.! !!TPP2ContextTest methodsFor: 'tests'!testRestore	| context memento |	context := self contextOn: 'foobar'.	context propertyAt: #foo put: #bar.	memento := context remember.	context next.	context propertyAt: #foo put: #baz.	context propertyAt: #bar put: #baq.	context restore: memento.	self deny: (context hasProperty: #bar).	self assert: (context propertyAt: #foo) equals: #bar.	self assert: context position equals: 0.! !!TPP2ContextTest methodsFor: 'tests'!testSuccess	| context |	context := (self contextOn: 'bar')		position: 1;		returnValue: #foo;		yourself.		self assert: context isPetit2Success.	self assert: context value == #foo.	self assert: context returnValue == #foo.	self assert: context atEnd not.	self assert: context uncheckedPeek == $a.! !!TPP2ContextTest methodsFor: 'tests'!testUncheckedNext	| context retval |	context := self contextOn: 'foo'.		self assert: context position equals: 0.		retval := context uncheckedNext.	self assert: retval isPetit2Success.	self assert: retval equals: $f.	self assert: context position equals: 1.! !!TPP2ContextTest methodsFor: 'tests'!testUncheckedPeek	| context |	context := self contextOn: 'foo'.			self assert: context uncheckedPeek == $f.		context position: 3.	self should: [context uncheckedPeek] raise: Error.	! !!TPP2ContextTest methodsFor: 'tests'!testUpTo	| context retval |	context := self contextOn: 'foobar'.	self assert: context position equals: 0.			retval := context upTo: $f.	self assert: context position equals: 1.	self assert: retval equals: 'f'.	! !!TPP2ContextTest methodsFor: 'tests'!testUpTo2	| context retval |	context := self contextOn: 'foobar'.	self assert: context position equals: 0.			retval := context upTo: $r.	self assert: context position equals: 6.	self assert: retval equals: 'foobar'.! !!TPP2ContextTest methodsFor: 'tests'!testUpTo3	| context retval |	context := self contextOn: 'foobar'.	self assert: context position equals: 0.			retval := context upTo: $x.	self assert: context position equals: 6.	self assert: retval equals: 'foobar'.! !!TPP2ContextTest methodsFor: 'tests'!testUpTo4	| context retval |	context := self contextOn: 'foof'.	context next.	self assert: context position equals: 1.			retval := context upTo: $f.	self assert: context position equals: 4.	self assert: retval equals: 'oof'.	! !!TPP2ContextTest methodsFor: 'tests'!testUpToEnd	| context retval |	context := self contextOn: 'foobar'.	self assert: context position equals: 0.			retval := context upToEnd.	self assert: context position equals: 6.	self assert: retval equals: 'foobar'.	! !!TPP2ExpressionGrammarTest methodsFor: 'accessing'!parserClass	^ PP2ExpressionGrammar ! !!TPP2ExpressionGrammarTest methodsFor: 'testing'!testAddition	self parse: '1 + 2' rule: #addition.	self parse: '1 + (2 + 3)' rule: #addition.		self parse: '1 + (2 * 3)' rule: #addition.					self fail: '1 * 2' rule: #addition.! !!TPP2ExpressionGrammarTest methodsFor: 'testing'!testMultiplication	self parse: '1 * 2' rule: #multiplication.	self parse: '1 * (2 + 3)' rule: #multiplication.		self parse: '1 * (2 * 3)' rule: #multiplication.					self fail: '1 + 2' rule: #multiplication.! !!TPP2ExpressionGrammarTest methodsFor: 'testing'!testNumber	self parse: '1' rule: #number.	self parse: '10' rule: #number.	self parse: '10.3' rule: #number.		self fail: 'foo' rule: #number.! !!TPP2ExpressionGrammarTest methodsFor: 'testing'!testParentheses	self parse: '(1)' rule: #parentheses.	self parse: '(1.2)' rule: #parentheses.! !!TPP2ExpressionGrammarTest methodsFor: 'testing'!testPrimary	self parse: '10.3' rule: #primary.	self parse: '(10.3)' rule: #primary.	self parse: '(1 * 2 + 3)' rule: #primary.! !!TPP2ExpressionGrammarTest methodsFor: 'testing'!testTerms	self parse: '1' rule: #terms.	self parse: '1 + 1' rule: #terms.	self parse: '1 * 1' rule: #terms.	self parse: '((1) * (2 + (3 + 4)))' rule: #terms.		self fail: '1 ^ 1' rule: #terms.! !!TPP2ExpressionParserTest methodsFor: 'tests'!testNumber	self parse: '1' rule: #number to: 1.! !!TPP2ParseTest methodsFor: 'test'!testAction	| parser |	parser := #any asPParser ==> [:e | e asUppercase ].	self assert: parser parse: 'a' to: $A.	self assert: parser parse: 'b' to: $B! !!TPP2ParseTest methodsFor: 'test'!testAnd	| parser |	parser := 'foo' asPParser, 'bar' asPParser and.	self		assert: parser		parse: 'foobar'		to: #('foo' 'bar')		end: 3.	self assert: parser fail: 'foobaz' end: 3.! !!TPP2ParseTest methodsFor: 'test'!testBlock	| parser |	parser := [ :ctx | 		self assert: (ctx isPetit2Context).		ctx next 	] asPParser.		self assert: parser parse: 'ab' to: $a end: 1.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: '' to: nil! !!TPP2ParseTest methodsFor: 'test'!testChoice	| parser |	parser := $a asPParser / $b asPParser.		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: 'ab' to: $a end: 1.	self assert: parser parse: 'ba' to: $b end: 1.	self assert: parser fail: ''.	self assert: parser fail: 'c'.	self assert: parser fail: 'ca'! !!TPP2ParseTest methodsFor: 'test'!testDelegateWithEndOfInput	| parser |	parser := ($a asPParser / #eoi asPParser) wrapped.		self assert: parser parse: 'a' to: $a.	self assert: parser parse: '' to: nil.	self assert: parser fail: 'b'.! !!TPP2ParseTest methodsFor: 'test - operators'!testDelimitedBy	| parser |	parser := $a asPParser delimitedBy: $b asPParser.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aba' to: #($a $b $a).	self assert: parser parse: 'ababa' to: #($a $b $a $b $a).	self assert: parser parse: 'ab' to: #($a $b).	self assert: parser parse: 'abab' to: #($a $b $a $b).	self assert: parser parse: 'ababab' to: #($a $b $a $b $a $b).		self assert: parser parse: 'ac' to: #($a) end: 1.	self assert: parser parse: 'abc' to: #($a $b) end: 2.	self assert: parser parse: 'abac' to: #($a $b $a) end: 3.	self assert: parser parse: 'ababc' to: #($a $b $a $b) end: 4.		self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'c'! !!TPP2ParseTest methodsFor: 'test'!testEnd	| parser |	parser := $a asPParser end.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: ''.	self assert: parser fail: 'aa' end: 1.! !!TPP2ParseTest methodsFor: 'test'!testEndLiteral	| parser |	parser := 'stuff' asPParser end.	self assert: parser parse: 'stuff' to: 'stuff'.	self assert: parser fail: 'stufff' end: 5.	self assert: parser fail: 'fluff'! !!TPP2ParseTest methodsFor: 'test'!testEndOfInput	| parser |	parser := #endOfInput asPParser.	self assert: parser parse: '' to: nil.	self assert: parser fail: 'a'.! !!TPP2ParseTest methodsFor: 'test'!testEndOfLine	| parser |	parser := #endOfLine asPParser.	self assert: parser parse: '' to: nil.	self assert: parser fail: 'a'.	self assert: $a asPParser, parser parse: 'a'.! !!TPP2ParseTest methodsFor: 'test'!testEpsilon	| parser |	parser := nil asPParser.		self assert: parser parse: '' to: nil.		self assert: parser parse: 'a' to: nil end: 0.	self assert: parser parse: 'ab' to: nil end: 0! !!TPP2ParseTest methodsFor: 'test'!testFailing	| parser |	parser := PP2FailingNode message: 'Plonk'.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'aa'.! !!TPP2ParseTest methodsFor: 'test'!testFlattenSequence	| parser |	parser := ($a asPParser, $b asPParser) flatten.		self assert: parser parse: 'ab' to: 'ab'.		self assert: parser fail: 'ac' end: 1.	self assert: parser fail: 'bc'! !!TPP2ParseTest methodsFor: 'test - mapping'!testFoldLeft	| parser |	parser := #any asPParser star 		foldLeft: [ :a :b | Array with: a with: b ].	self assert: parser parse: 'a' to: #a.	self assert: parser parse: 'ab' to: #($a $b).	self assert: parser parse: 'abc' to: #(($a $b) $c).	self assert: parser parse: 'abcd' to: #((($a $b) $c) $d).	self assert: parser parse: 'abcde' to: #(((($a $b) $c) $d) $e)! !!TPP2ParseTest methodsFor: 'test - mapping'!testFoldLeft2	| parser |	parser := #any asPParser star 		foldLeft: [ :a :b :c | Array with: a with: b with: c ]."	self assert: parser parse: #(a) to: #a."	self assert: parser parse: 'a' to: 'a'.	self assert: parser parse: 'abc' to: #($a $b $c).	self assert: parser parse: 'abcde' to: #(($a $b $c) $d $e)! !!TPP2ParseTest methodsFor: 'test - mapping'!testFoldRight	| parser |	parser := #any asPParser star 		foldRight: [ :a :b | Array with: a with: b ].	self assert: parser parse: 'a' to: #a.	self assert: parser parse: 'ab' to: #($a $b).	self assert: parser parse: 'abc' to: #($a ($b $c)).	self assert: parser parse: 'abcd' to: #($a ($b ($c $d))).	self assert: parser parse: 'abcde' to: #($a ($b ($c ($d $e))))! !!TPP2ParseTest methodsFor: 'test - mapping'!testFoldRight2	| parser |	parser := #any asPParser star 		foldRight: [ :a :b :c | Array with: a with: b with: c ].	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'abc' to: #($a $b $c).	self assert: parser parse: 'abcde' to: #($a $b ($c $d $e))! !!TPP2ParseTest methodsFor: 'test'!testFragment	"	| fragment parser result |	fragment := $a asPParser plus fragment.	parser := fragment wrapped.		result := (self assert: parser parse: 'aa') returnValue.	self assert: result isPetit2Context.	self assert: result start equals: 0.	self assert: result stop equals: 2.	self assert: result parsedValue size equals: 2.	self assert: result parsedValue first equals: $a.		self assert: result parsedValue second equals: $a.	self assert: result parser == fragment.			self assert: parser fail: 'b'.	self assert: parser fail: ''.	"! !!TPP2ParseTest methodsFor: 'test'!testLiteralObject	| parser |	parser := $a asPParser.		self assert: parser literal equals: $a.	self assert: parser message equals: 'literal $a expected'.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'! !!TPP2ParseTest methodsFor: 'test'!testLiteralObjectCaseInsensitive	| parser |	parser := $a asPParser caseInsensitive.		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'A' to: $A.	self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'B'	! !!TPP2ParseTest methodsFor: 'test'!testLiteralSequence	| parser |	parser := 'abc' asPParser.		self assert: parser parse: 'abc' to: 'abc'.	self assert: parser parse: 'abcd' to: 'abc' end: 3.	self assert: parser fail: 'ab'.	self assert: parser fail: 'abd'! !!TPP2ParseTest methodsFor: 'test'!testLiteralSequenceCaseInsensitive	| parser |	parser := 'abc' asPParser caseInsensitive.		self assert: parser parse: 'abc' to: 'abc'.	self assert: parser parse: 'ABC' to: 'ABC'.	self assert: parser parse: 'abC' to: 'abC'.	self assert: parser parse: 'AbC' to: 'AbC'.		self assert: parser fail: 'ab'.	self assert: parser fail: 'abd'! !!TPP2ParseTest methodsFor: 'test'!testMap	| parser |	parser := #any asPParser		map: [ :a | Array with: a ].	self assert: parser parse: 'a' to: #($a).	self assert: parser fail: ''.! !!TPP2ParseTest methodsFor: 'test'!testMapSequence	| parser |	parser := #any asPParser, #any asPParser		map: [ :a :b | Array with: b with: a ].	self assert: parser parse: 'ab' to: #($b $a)! !!TPP2ParseTest methodsFor: 'test'!testMapWrappedSequence	| parser |	parser := (#any asPParser, #any asPParser) wrapped		map: [ :a :b | Array with: b with: a ].	self assert: parser parse: 'ab' to: #($b $a)! !!TPP2ParseTest methodsFor: 'test'!testNewLine	| parser |	parser := #newline asPParser.	self assert: parser parse: '' to: Character cr.	self assert: parser fail: ''! !!TPP2ParseTest methodsFor: 'test'!testNot	| parser |	parser := 'foo' asPParser, 'bar' asPParser  not.		self assert: parser parse: 'foobaz' to: #('foo' nil) end: 3.	self assert: parser fail: 'foobar' end: 3! !!TPP2ParseTest methodsFor: 'test'!testOptional	| parser |	parser := $a asPParser optional.		self assert: parser parse: '' to: nil.	self assert: parser parse: 'a' to: $a.		self assert: parser parse: 'aa' to: $a end: 1.	self assert: parser parse: 'ab' to: $a end: 1.	self assert: parser parse: 'b' to: nil end: 0.	self assert: parser parse: 'bb' to: nil end: 0.	self assert: parser parse: 'ba' to: nil end: 0! !!TPP2ParseTest methodsFor: 'test'!testPlus	| parser |	parser := $a asPParser plus.	self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).	self assert: parser parse: 'ab' to: #($a) end: 1.	self assert: parser parse: 'aab' to: #($a $a) end: 2.	self assert: parser parse: 'aaab' to: #($a $a $a) end: 3.			self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'ba'! !!TPP2ParseTest methodsFor: 'test'!testPlus2	| parser |	parser := ($a asPParser, $b asPParser) plus.		self assert: parser parse: 'ab' to: #(#($a $b)).	self assert: parser fail: 'a' end: 1.! !!TPP2ParseTest methodsFor: 'test'!testPossesiveRepeatingNode	|  parser |		parser := $a asPParser min: 1 max: 2.	self assert: parser fail: ''.	self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a) end: 2.! !!TPP2ParseTest methodsFor: 'test'!testPredicateAny	|  parser |		parser := #any asPParser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: Character null asString to: Character null.		self assert: parser fail: ''.! !!TPP2ParseTest methodsFor: 'test'!testPredicateDigit	|  parser |		parser := #digit asPParser.	self assert: parser parse: '1' to: $1.	self assert: parser parse: '0' to: $0.	self assert: parser parse: '9' to: $9.	self assert: parser fail: 'a'.! !!TPP2ParseTest methodsFor: 'test'!testPredicateLetter	|  parser |		parser := #letter asPParser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: 'z' to: $z.	self assert: parser fail: ''.! !!TPP2ParseTest methodsFor: 'test'!testRepetitions	| parser result |	parser := ('foo' asPParser, ':=' asPParser) plus.		result := (self assert: parser parse: 'foo:=').		self assert: result value size equals: 1.	self assert: result value first equals: #('foo' ':=').		self assert: parser fail: 'foo' end: 3.! !!TPP2ParseTest methodsFor: 'test - operators'!testSeparatedBy	| parser |	parser := $a asPParser separatedBy: $b asPParser.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aba' to: #($a $b $a).	self assert: parser parse: 'ababa' to: #($a $b $a $b $a).		self assert: parser parse: 'ab' to: #($a) end: 1.	self assert: parser parse: 'abab' to: #($a $b $a) end: 3.	self assert: parser parse: 'ac' to: #($a) end: 1.	self assert: parser parse: 'abac' to: #($a $b $a) end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'c'! !!TPP2ParseTest methodsFor: 'test'!testSequence	| parser |	parser := $a asPParser , $b asPParser.		self assert: parser parse: 'ab' to: #($a $b).		self assert: parser parse: 'aba' to: #($a $b) end: 2.	self assert: parser parse: 'abb' to: #($a $b) end: 2.		self assert: parser fail: ''.	self assert: parser fail: 'a' end: 1.	self assert: parser fail: 'aa' end: 1.	self assert: parser fail: 'ba' end: 0.	self assert: parser fail: 'bab' end: 0! !!TPP2ParseTest methodsFor: 'test'!testSequence2	| parser |	parser := ($a asPParser , $b asPParser) star, $a asPParser.	self assert: parser parse: 'a' to: (Array with: OrderedCollection new with: $a).	self assert: parser fail: 'ab' end: 2.	self assert: parser fail: ''.! !!TPP2ParseTest methodsFor: 'test'!testSequenceOfThree	| parser |	parser := $a asPParser , $b asPParser, $c asPParser.		self assert: parser parse: 'abc' to: #($a $b $c).	self assert: parser fail: 'ab' end: 2.! !!TPP2ParseTest methodsFor: 'test'!testStar	| parser |	parser := $a asPParser star.	self assert: parser parse: '' to: #().	self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).	self		assert: parser		parse: 'b'		to: #()		end: 0.	self		assert: parser		parse: 'ab'		to: #($a)		end: 1.	self		assert: parser		parse: 'aab'		to: #($a $a)		end: 2.	self		assert: parser		parse: 'aaab'		to: #($a $a $a)		end: 3! !!TPP2ParseTest methodsFor: 'test'!testStarInToken	| parser |	parser := ($a asPParser / $b asPParser) star token.	self assert: parser parse: '' toTokenValue: ''.	self assert: parser parse: 'a' toTokenValue: 'a'.	self assert: parser parse: 'b' toTokenValue: 'b'.	self assert: parser parse: 'ab' toTokenValue: 'ab'.		! !!TPP2ParseTest methodsFor: 'test'!testStartOfLine	| parser |	parser := #startOfLine asPParser.	self assert: parser parse: '' to: nil.	self assert: parser parse: 'a' to: nil end: 0.	self assert: $a asPParser, parser fail: 'ab' end: 1.! !!TPP2ParseTest methodsFor: 'test'!testTimes	| parser |	parser := $a asPParser times: 2.		self assert: parser fail: ''.	self assert: parser fail: 'a' end: 1.	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a) end: 2! !!TPP2ParseTest methodsFor: 'test'!testToken	| parser |	parser := $a asPParser token.	self assert: parser parse: 'a'	toTokenValue: 'a'.			self assert: parser fail: 'b'.	self assert: parser fail: ''.! !!TPP2ParseTest methodsFor: 'test'!testTokenLiteral	| parser |	parser := 'foo' asPParser token.	self assert: parser parse: 'foo' toTokenValue: 'foo'.			self assert: parser fail: 'bar'.	self assert: parser fail: ''.! !!TPP2ParseTest methodsFor: 'test'!testTokenTrim	| parser |	parser := $a asPParser token trim.		self assert: parser parse: 'a' toTokenValue: 'a'.	self assert: parser parse: ' a' toTokenValue: 'a'.	self assert: parser parse: 'a ' toTokenValue: 'a' end: 2.	self assert: parser parse: ' a ' toTokenValue: 'a' end: 3.	self assert: parser parse: '  a  ' toTokenValue: 'a' end: 5.	self assert: parser fail: 'b'.! !!TPP2ParseTest methodsFor: 'test'!testTrim	| parser |	parser := 'a' asPParser trim.		self assert: parser parse: 'a' to: 'a'.	self assert: parser parse: ' a' to: 'a'.	self assert: parser parse: 'a ' to: 'a' end: 2.	self assert: parser parse: ' a ' to: 'a' end: 3.	self assert: parser parse: '  a  ' to: 'a' end: 5.	self assert: parser fail: 'b'.! !!TPP2ParseTest methodsFor: 'test'!testWrapped	| parser |	parser := $a asPParser wrapped.		self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'.! !!TPP2ParseTest methodsFor: 'test'!testWrappedSequence	| parser |	parser := (($a asPParser , $b asPParser ) wrapped , $c asPParser).	self assert: parser parse: 'abc' to: #(#($a $b) $c)! !!TPP2ParseTest methodsFor: 'test'!testWrapping	| parser |	parser := $a asPParser >=> [:c :cc | cc value].		self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'.! !!TPP2SeaParserTest methodsFor: 'parse support'!emptySea	| nilSea |	nilSea := self seaInstance.	nilSea island: nil asPParser.	nilSea name: 'nil sea'.	^ nilSea! !!TPP2SeaParserTest methodsFor: 'parse support'!nestedBlock	| blockSea block nilIsland |	blockSea := self seaInstance.	nilIsland := (self emptySea ==> #first).		block := PP2DelegateNode new.	block child: (${ asPParser,  (blockSea plus / nilIsland), $} asPParser).	block name: 'block'.		blockSea island: block.	blockSea name: 'block island'.	^ block! !!TPP2SeaParserTest methodsFor: 'parse support'!result	self explicitRequirement! !!TPP2SeaParserTest methodsFor: 'parse support'!seaInstance	^ self explicitRequirement! !!TPP2SeaParserTest methodsFor: 'tests'!testEOFBoundary	| sea |	sea := self seaInstance island: $a asPParser.		self assert: sea parse: '..a..'.	self assert: self result second equals: $a.	self assert: sea fail: '..'! !!TPP2SeaParserTest methodsFor: 'tests'!testNestedBlockDeepNested	| block |	block := self nestedBlock.		self assert: block parse: '{ {} { {  } } }'.	self assert: self result size equals: 3.	self assert: self result first equals: ${.	self assert: self result second size equals: 2.	self assert: self result second first size equals: 3.	self assert: self result second second size equals: 3.	self assert: self result third equals: $}.! !!TPP2SeaParserTest methodsFor: 'tests'!testNestedBlockEmpty	| block |	block := self nestedBlock.		self assert: block parse: '{}'.	self assert: self result size equals: 3.	self assert: self result first equals: ${.	self assert: self result second equals: #() asOrderedCollection.	self assert: self result third equals: $}.! !!TPP2SeaParserTest methodsFor: 'tests'!testNestedBlockNested	| block |	block := self nestedBlock.		self assert: block parse: '{ {} }'.	self assert: self result size equals: 3.	self assert: self result first equals: ${.	self assert: self result second size equals: 1.	self assert: self result second first size equals: 3.	self assert: self result third equals: $}.! !!TPP2SeaParserTest methodsFor: 'tests'!testNestedBlockSpace	| block |	block := self nestedBlock.		self assert: block parse: '{ }'.	self assert: self result size equals: 3.	self assert: self result first equals: ${.	self assert: self result second equals: #( $ ) asOrderedCollection.	self assert: self result third equals: $}.! !!TPP2SeaParserTest methodsFor: 'tests'!testNilSea	| parser |	parser := self emptySea.		self assert: parser parse: ''.	self assert: self result first equals: #() asOrderedCollection.		self assert: parser parse: '...'.	self assert: self result first equals: #($. $. $.) asOrderedCollection.! !!TPP2SeaParserTest methodsFor: 'tests'!testNilSeaPlus	| sea parser |	sea := self seaInstance island: nil asPParser.	parser := sea flatten nonEpsilon plus.		self assert: parser fail: ''.	self assert: parser parse: '...'.	self assert: self result size equals: 1.	self assert: self result first equals: '...'.! !!TPP2SeaParserTest methodsFor: 'tests'!testNilSeaSequence	| sea sea2 parser |	sea := self seaInstance island: nil asPParser.	sea2 := self seaInstance island: nil asPParser.	parser := sea flatten, sea2 flatten.		self assert: parser parse: ''.	self assert: self result first equals: ''.		self assert: self result second equals: ''.		self assert: parser parse: '...'.	self assert: self result first equals: '...'.	self assert: self result second equals: ''.	! !!TPP2SeaParserTest methodsFor: 'tests'!testNilSeaStar	| sea parser |	sea := self seaInstance island: #epsilon asPParser.	parser := sea flatten nonEpsilon star.		self assert: parser parse: ''.	self assert: self result isEmpty.	self assert: parser parse: '...'.	self assert: self result size equals: 1.	self assert: self result first equals: '...'.! !!TPP2SeaParserTest methodsFor: 'tests'!testNullableBoundary	| parser sea |	sea := self seaInstance island: $a asPParser.	parser := sea, $b asPParser optional.		self assert: parser parse: '..a..'.	self assert: self result first second equals: $a.	self assert: parser parse: '..a..b'.	self assert: self result first second equals: $a.	self assert: parser fail: '..b'.	self assert: parser fail: '..'	.! !!TPP2SeaParserTest methodsFor: 'tests'!testNullableIsland	| parser sea |	sea := self seaInstance island: nil asPParser.	parser := sea.		self assert: parser parse: '..'.	self assert: self result first equals: #($. $.) asOrderedCollection.	self assert: self result second equals: nil.	self assert: self result third equals: #() asOrderedCollection.	self assert: parser parse: ''.! !!TPP2SeaParserTest methodsFor: 'tests'!testOverlappingSeas	| seas seaOne seaTwo |	seaOne := self seaInstance island: $a asPParser.	seaTwo := self seaInstance island: $b asPParser.		seas := seaOne, seaTwo.		self assert: seas parse: '..a..b..'.	self assert: self result first second equals: $a.	self assert: self result second second equals: $b.		self assert: seas fail: '..b..a..b..'.	self assert: seas fail: '..a..'! !!TPP2SeaParserTest methodsFor: 'tests'!testSeaPlus	| sea parser |	sea := self seaInstance island: $a asPParser.	parser := sea plus.	self assert: parser parse: '..a..a..a...'.	self assert: self result size equals: 3.		self assert: parser fail: '...'.! !!TPP2SeaParserTest methodsFor: 'tests'!testSeaStar	| sea parser |	sea := self seaInstance island: $a asPParser.	parser := sea star.		self assert: parser parse: '..a..a..a...'.	self assert: self result size equals: 3.		self assert: parser parse: ''.	self assert: self result size equals: 0.	! !!TPP2StreamContextInterface methodsFor: 'tests - context interface'!testAtEnd	| stream |	stream := self streamOn: ''. 	self assert: (stream atEnd: 0).	self assert: (stream atEnd: 1).	stream := self streamOn: 'f'. 	self assert: (stream atEnd: 0) not.	self assert: (stream atEnd: 1).	self assert: (stream atEnd: 2).! !!TPP2StreamContextInterface methodsFor: 'tests - context interface'!testAtPosition	| stream |	stream := self streamOn: 'bar'. 		self assert: (stream atPosition: 1) = $b.	self assert: (stream atPosition: 2) = $a.	self assert: (stream atPosition: 3) = $r.! !!TPP2StreamContextInterface methodsFor: 'tests - context interface'!testAtPositionReversedOrder	| stream |	stream := self streamOn: 'bar'. 		self assert: (stream atPosition: 3) = $r.	self assert: (stream atPosition: 2) = $a.	self assert: (stream atPosition: 1) = $b.! !!TPP2StreamContextInterface methodsFor: 'tests - context interface'!testCopyFromTo	| stream |	stream := self streamOn: 'bar'.	self assert: (stream copyFrom: 1 to: 1) = 'b'.	self assert: (stream copyFrom: 1 to: 3) = 'bar'.! !!TPP2StreamContextInterface methodsFor: 'tests - context interface'!testNewTokenFromTo	| stream |	stream := self streamOn: 'foo'. 		self assert: (stream newToken: PP2Token from: 1 to: 3) value equals: 'foo'.! !!TPP2TypeAssertions methodsFor: 'assertions'!assert: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass)! !!TPP2TypeAssertions methodsFor: 'assertions'!deny: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass) not! !!PP2AbstractParserTest class methodsFor: 'testing'!isAbstract	^ self name = #PP2AbstractParserTest! !!PP2AbstractParserTest class methodsFor: 'accessing'!packageNamesUnderTest  ^ #('PetitParser2' 'PetitParser2-Tests')! !!PP2AbstractParserTest methodsFor: 'utilities'!assert: aParser fail: aCollection	^ self assert: aParser fail: aCollection end: 0! !!PP2AbstractParserTest methodsFor: 'utilities'!assert: aParser fail: aCollection end: anInteger	| stream result context |	self 		assert: aParser isPetit2Parser		description: 'Parser invalid'.	stream := aCollection asPetit2Stream.	context := self context.			result := self parse: stream withParser: aParser withContext: context.		self 		assert: result isPetit2Failure		description: 'Parser did not fail'.	self		assert: result position = anInteger		description: 'Parser failed at wrong position'.	^ result! !!PP2AbstractParserTest methodsFor: 'utilities'!assert: string1 includesSubstring: string2	"Support portability by using ANSI search method"	self assert: (string1 notEmpty and: [string2 notEmpty and: [0 < (string1 indexOfSubCollection: string2 startingAt: 1)]])! !!PP2AbstractParserTest methodsFor: 'utilities'!assert: aParser parse: aCollection	^ self assert: aParser parse: aCollection to: nil end: aCollection size ! !!PP2AbstractParserTest methodsFor: 'utilities'!assert: aParser parse: aCollection end: anInteger	^ self assert: aParser parse: aCollection to: nil end: anInteger! !!PP2AbstractParserTest methodsFor: 'utilities'!assert: aParser parse: aCollection to: anObject	^ self assert: aParser parse: aCollection to: anObject end: aCollection size ! !!PP2AbstractParserTest methodsFor: 'utilities'!assert: aParser parse: aCollection to: aTargetObject end: anInteger	| stream result ctx |	self assert: aParser isPetit2Parser description: 'Parser invalid'.	stream := aCollection asPetit2Stream.	ctx := self context.		result := self parse: stream withParser: aParser withContext: ctx.		aTargetObject isNil		ifTrue: [ self deny: result isPetit2Failure ]		ifFalse: [ self assert: result value asArray equals: aTargetObject asArray ].	self assert: result position = anInteger description: 'Parser accepted at wrong position'.	^ result! !!PP2AbstractParserTest methodsFor: 'utilities'!assert: aParser parse: aCollection toTokenValue: value	^ self assert: aParser parse: aCollection toTokenValue: value end: aCollection size! !!PP2AbstractParserTest methodsFor: 'utilities'!assert: aParser parse: aCollection toTokenValue: value end: end	| result |	result := self		assert: aParser		parse: aCollection		to: nil		end: end.	self assert: (result value isKindOf: PP2Token).	self assert: result value value equals: value.	^ result! !!PP2AbstractParserTest methodsFor: 'context'!context	^ PP2Context new! !!PP2AbstractParserTest methodsFor: 'initialization'!initialize	super initialize.! !!PP2AbstractParserTest methodsFor: 'accessing'!parse: aStream withParser: aParser withContext: aContext	self subclassResponsibility! !!PP2BufferStreamIntegrationTest methodsFor: 'tests'!parse: aStream withParser: aParser withContext: aContext	^ aParser parse: aStream withContext: aContext! !!PP2BufferStreamIntegrationTest methodsFor: 'tests'!streamOn: aString	^ PP2BufferStream on: (PP2MinimalStream on: aString)! !!PP2BufferStreamIntegrationTest methodsFor: 'tests'!streamOn: aString bufferSize: size	^ PP2BufferStream on: (PP2MinimalStream on: aString) bufferSize: size! !!PP2BufferStreamIntegrationTest methodsFor: 'tests'!testIdentifier	"Test with stream that provides only atEnd and next:"	parser := (#letter asPParser, #word asPParser plus) flatten.	stream := self streamOn: 'hi123'.		self assert: parser parse: 'hi123' to: 'hi123' end: 5.! !!PP2BufferStreamIntegrationTest methodsFor: 'tests'!testIdentifierSmallBuffer	"Test with stream that provides only atEnd and next:"	parser := #letter asPParser, #word asPParser plus.	stream := self streamOn: 'hi123' bufferSize: 1.		self assert: parser parse: stream to: nil end: 5! !!PP2BufferStreamIntegrationTest methodsFor: 'tests'!testIdentifierSmallBufferError	"Test with stream that provides only atEnd and next:"	parser := (#letter asPParser, #word asPParser plus) flatten.	stream := self streamOn: 'hi123' bufferSize: 1.		self should: [ self assert: parser parse: stream to: 'hi123' end: 5 ] raise: PP2OutOfBoundsException ! !!PP2BufferStreamIntegrationTest methodsFor: 'tests'!testPredicate	"Test with stream that provides only atEnd and next:"	parser := #letter asPParser.	stream := self streamOn: 'a'.		self assert: parser parse: stream to: $a end: 1.! !!PP2BufferStreamIntegrationTest methodsFor: 'tests'!testSequence	"Test with stream that provides only atEnd and next:"	parser := $a asPParser, $a asPParser.	stream := self streamOn: 'aa'.		self assert: parser parse: stream to: #($a $a) end: 2! !!PP2BufferStreamIntegrationTest methodsFor: 'tests'!testStreamBacktrack	parser := ('aa' asPParser, 'a' asPParser) / 'aa' asPParser.	stream := self streamOn: 'aa'.		self assert: parser parse: stream to: 'aa' end: 2.	! !!PP2BufferStreamIntegrationTest methodsFor: 'tests'!testStreamBacktrackBufferSmall	parser := 'aa' asPParser.	stream := self streamOn: 'aa' bufferSize: 2.		parser := ('aa' asPParser, 'aa' asPParser) / 'aa' asPParser.		self assert: parser parse: stream to: 'aa' end: 2.	! !!PP2BufferStreamIntegrationTest methodsFor: 'tests'!testStreamBacktrackBufferTooSmall	parser := 'aa' asPParser.	stream := self streamOn: 'aa' bufferSize: 1.		parser := ('aa' asPParser, 'aa' asPParser) / 'aa' asPParser.		self should: [ self assert: parser parse: stream to: 'aa' end: 2 ] raise: PP2OutOfBoundsException  	! !!PP2BufferStreamIntegrationTest methodsFor: 'tests'!testStreamBufferTooSmall	parser := 'aa' asPParser.	stream := self streamOn: 'aa' bufferSize: 1.	self should: [ self assert: parser parse: stream to: 'aa' end: 2 ] raise: PP2OutOfBoundsException	! !!PP2BufferStreamIntegrationTest methodsFor: 'tests'!testToken	parser := 'aa' asPParser token.	stream := self streamOn: 'aa'.		self assert: parser parse: stream toTokenValue: 'aa' end: 2! !!PP2CompositeNodeTest class methodsFor: 'testing'!isAbstract	^ self name = #PP2CompositeNodeTest! !!PP2CompositeNodeTest class methodsFor: 'accessing'!resources	^ Array with: PP2ParserResource! !!PP2CompositeNodeTest methodsFor: 'utilities'!assert: aCollection is: anObject	self parse: aCollection.	self		assert: result = anObject		description: 'Got: ' , result printString , '; Expected: ' , anObject printString		resumable: true! !!PP2CompositeNodeTest methodsFor: 'parsing'!fail: aString rule: aSymbol 	| production context |	production := self parserInstanceFor: aSymbol.	context := self context.		result := production parse: aString withContext: context.		self		assert: (result isPetit2Failure or: [context atEnd not])		description: 'Able to parse ' , aString printString.	^ result! !!PP2CompositeNodeTest methodsFor: 'parsing'!parse: aString 	^ self parse: aString rule: #start! !!PP2CompositeNodeTest methodsFor: 'parsing'!parse: aString production: production to: expectedResult end: end checkResult: aBoolean	| ctx |	ctx := self context.	resultContext := self parse: aString withParser: production withContext: ctx.	result := resultContext value.		self		deny: resultContext isPetit2Failure		description: 'Unable to parse ' , aString printString.		self assert: resultContext position equals: end.	aBoolean ifTrue: [ self assert: expectedResult equals: result ].	^ result! !!PP2CompositeNodeTest methodsFor: 'parsing'!parse: aString rule: aSymbol	^ self parse: aString rule: aSymbol end: aString size! !!PP2CompositeNodeTest methodsFor: 'parsing'!parse: aString rule: aSymbol end: end	^ self parse: aString rule: aSymbol to: nil end: end checkResult: false! !!PP2CompositeNodeTest methodsFor: 'parsing'!parse: aString rule: aSymbol to: expectedResult	^ self parse: aString rule: aSymbol to: expectedResult end: aString size checkResult: true! !!PP2CompositeNodeTest methodsFor: 'parsing'!parse: aString rule: aSymbol to: expectedResult end: end	^ self parse: aString rule: aSymbol  to:  expectedResult  end: end checkResult:  true! !!PP2CompositeNodeTest methodsFor: 'parsing'!parse: aString rule: aSymbol to: expectedResult end: end checkResult: aBoolean	| production |	production := self parserInstanceFor: aSymbol.	^ self parse: aString production: production to: expectedResult end: end checkResult: aBoolean 	! !!PP2CompositeNodeTest methodsFor: 'accessing'!parse: aStream withParser: aParser withContext: aContext	^ aParser parse: aStream withContext: aContext! !!PP2CompositeNodeTest methodsFor: 'accessing'!parserClass	self subclassResponsibility! !!PP2CompositeNodeTest methodsFor: 'accessing'!parserInstance	^ PP2ParserResource current parserAt: self parserClass! !!PP2CompositeNodeTest methodsFor: 'accessing'!parserInstanceFor: aSymbol	^ aSymbol = #start		ifTrue: [ self parserInstance ]		ifFalse: [			self parserInstance				productionAt: aSymbol 				ifAbsent: [ self error: 'Production ' , self parserClass name , '>>' , aSymbol printString , ' not found.' ] ]! !!PP2CompositeNodeTest methodsFor: 'running'!setUp	super setUp.	parser := self parserInstance! !!PP2CompositeNodeTest methodsFor: 'running'!tearDown	super tearDown.	parser := result := nil! !!PP2ExpressionGrammarTest class methodsFor: 'testing'!shouldInheritSelectors	^ true! !!PP2ExpressionGrammarTest methodsFor: 'accessing'!parse: aStream withParser: aParser withContext: aContext	^ aParser parse: aStream withContext: aContext! !!PP2ExpressionParserTest methodsFor: 'as yet unclassified'!parserClass	^ PP2ExpressionParser! !!PP2ExpressionGrammarTest_Optimized methodsFor: 'context'!context	^ PP2InMemoryContext new! !!PP2ExpressionGrammarTest_Optimized methodsFor: 'accessing'!parserInstance	^ super parserInstance optimize! !!PP2HtmlHeaderGrammarTest methodsFor: 'accessing'!parserClass	^ PP2HtmlHeaderGrammar ! !!PP2HtmlHeaderGrammarTest methodsFor: 'tests'!testHeader	self parse: '<head>foobar</head>' rule: #header to: 'foobar'! !!PP2HtmlHeaderGrammarTest methodsFor: 'tests'!testHtmlFragment	self parse: '<html><head>foobar</head></html>' rule: #htmlFragment to: 'foobar' end: 25! !!PP2HtmlHeaderGrammarTest methodsFor: 'tests'!testHtmlFragmentNoHeader	self fail: '<html><body>foobar</body></html>' rule: #htmlFragment! !!PP2HtmlHeaderGrammarTest methodsFor: 'tests-integration'!testZincClientIntegration	| byteStream stream |	byteStream := ZnClient new 		url: 'http://pharo.org';  		streaming: true;  		get.	stream := PP2CharacterStream on: byteStream encoder: ZnUTF8Encoder new.	result := PP2HtmlHeaderGrammar new parse: stream.		self assert: stream atEnd not.	self assert: (result includesSubstring: 'Pharo')! !!PP2CsNodeTest methodsFor: 'accessing'!context	context isNil ifTrue: [ 		context := super context	].	^ context! !!PP2CsNodeTest methodsFor: 'accessing'!parse: aStream withParser: aParser withContext: aContext	^ context := aParser parse: aStream withContext: aContext! !!PP2CsNodeTest methodsFor: 'tests'!testStackId	self assert: $a asPParser push stackId equals: #defaultStack.	self assert: $a asPParser pop stackId equals: #defaultStack.		self assert: $a asPParser match stackId equals: #defaultStack.! !!PP2OptimizationParserTest methodsFor: 'accessing'!context	context isNil ifTrue: [		context := PP2RecordingContext new	].	^ context! !!PP2OptimizationParserTest methodsFor: 'accessing'!parse: aStream withParser: aParser withContext: aContext	^ aParser parseAdaptable: aStream withContext: aContext! !!PP2OptimizationParserTest methodsFor: 'tests'!testAndLiteralObject	self assert: $a asPParser and parse: 'a' to: $a end: 0.! !!PP2OptimizationParserTest methodsFor: 'tests'!testAndPop	| parser |	self context defaultStack push: $a.	parser := $a asPParser pop and.	parser optimize.		self assert: parser parse: 'a' to: $a end: 0.	self assert: self context defaultStack top equals: $a.	self assert: self context defaultStack size equals: 1.	self assert: (self context countFor: #remember) equals: 1.! !!PP2OptimizationParserTest methodsFor: 'tests'!testAndPopFailure	| parser |	self context defaultStack push: $a.	parser := $a asPParser pop and.	parser optimize.		self assert: parser fail: 'b'.	self assert: self context defaultStack top equals: $a.	self assert: self context defaultStack size equals: 1.	self assert: (self context countFor: #remember) equals: 1.! !!PP2OptimizationParserTest methodsFor: 'tests'!testAndPredicateObject	self assert: #letter asPParser and parse: 'a' to: $a end: 0.	self assert: #letter asPParser and parse: 'z' to: $z end: 0.		self assert: #letter asPParser and fail: '1' end: 0.! !!PP2OptimizationParserTest methodsFor: 'tests'!testAndPush	| parser |	self context defaultStack push: $b.	parser := $a asPParser push and.	parser optimize.		self assert: parser parse: 'a' to: $a end: 0.	self assert: self context defaultStack top equals: $b.	self assert: self context defaultStack size equals: 1.	self assert: (self context countFor: #remember) equals: 1.! !!PP2OptimizationParserTest methodsFor: 'tests'!testAndPushFailure	| parser |	self context defaultStack push: $b.	parser := $a asPParser push and.	parser optimize.		self assert: parser fail: 'b'.	self assert: self context defaultStack top equals: $b.	self assert: self context defaultStack size equals: 1.	self assert: (self context countFor: #remember) equals: 1.! !!PP2OptimizationParserTest methodsFor: 'tests - seas'!testAnyStarLazyLiteralObject	| parser ctx |	parser := #any asPParser starLazy, $x asPParser.	parser optimize.	parser enableDebug.	ctx := self assert: parser parse: '..x'.	self assert: ctx returnValue first asArray equals: #($. $.).	self assert: ctx debugResult steps equals: 4.		ctx := self assert: parser parse: 'x'.	self assert: ctx returnValue first isEmpty.		self assert: parser fail: '...'.	self assert: parser fail: '..a'! !!PP2OptimizationParserTest methodsFor: 'tests - seas'!testAnyStarLazyPredicateObject	| parser ctx |	parser := #any asPParser starLazy, #letter asPParser.	parser optimize.	parser enableDebug.		ctx := self assert: parser parse: '..a'.	self assert: ctx returnValue first asArray equals: #($. $.).	self assert: ctx debugResult steps equals: 4.	ctx := self assert: parser parse: 'a'.	self assert: ctx returnValue first isEmpty.	self assert: parser fail: '...'.	self assert: parser fail: '...1'! !!PP2OptimizationParserTest methodsFor: 'tests'!testCache	| counter parser contextOne contextTwo |	counter := 0.	parser := [ :ctx | counter := counter + 1. #foo ] asPParser.	parser strategy: parser strategy cache.	parser setOptimized.	contextOne := 'foo' asPetit2Context.	contextTwo := 'bar' asPetit2Context.		parser parseAdaptableWithContext: contextOne.	self assert: counter equals: 1.		parser parseAdaptableWithContext: contextOne.	self assert: counter equals: 2.		contextOne next.	parser parseAdaptableWithContext: contextOne.	self assert: counter equals: 3.	parser parseAdaptableWithContext: contextTwo.	self assert: counter equals: 4.	! !!PP2OptimizationParserTest methodsFor: 'tests'!testCache2	| parser ctx result |	parser := $a asPParser star.	parser strategy: parser strategy cache.	parser setOptimized.		ctx := 'aaa' asPetit2Context.	result := parser parseAdaptableWithContext: ctx.	self assert: result position equals: 3.		ctx := 'aabb' asPetit2Context.	result := parser parseAdaptableWithContext: ctx.	self assert: result position equals: 2.! !!PP2OptimizationParserTest methodsFor: 'tests - guards'!testGuardChoiceFailure	| parserOne parserTwo wrappedOne wrappedTwo result parser |	parserOne := $a asPParser.	parserTwo := $b asPParser.	wrappedOne := parserOne wrapped trim flatten. 	wrappedTwo := parserTwo wrapped trim flatten.	parser := wrappedOne / wrappedTwo.	parser optimize.	parser enableDebug.			result := self assert: parser fail: 'c'.	self assert: result debugResult steps equals: 4! !!PP2OptimizationParserTest methodsFor: 'tests - guards'!testGuardChoiceOptionOne	| parserOne parserTwo wrappedOne wrappedTwo parser result |	parserOne := $a asPParser.	parserTwo := $b asPParser.	wrappedOne := parserOne wrapped trim flatten. 	wrappedTwo := parserTwo wrapped trim flatten.	parser := wrappedOne / wrappedTwo.	parser optimize.	parser enableDebug.	result := self assert: parser parse: 'a ' to: 'a '.	self assert: result debugResult steps equals: 8! !!PP2OptimizationParserTest methodsFor: 'tests - guards'!testGuardChoiceOptionTwo	| parserOne parserTwo wrappedOne wrappedTwo parser result |	parserOne := $a asPParser.	parserTwo := $b asPParser.	wrappedOne := parserOne wrapped trim flatten. 	wrappedTwo := parserTwo wrapped trim flatten.	parser := wrappedOne / wrappedTwo.	parser optimize.	parser enableDebug.		result := self assert: parser parse: 'b ' to: 'b '.	self assert: result debugResult steps equals: 9! !!PP2OptimizationParserTest methodsFor: 'tests - guards'!testGuardOptional	|  wrappedOne parser result |	wrappedOne := $a asPParser wrapped trim flatten.	parser := wrappedOne optional.	parser optimize.	parser enableDebug.	result := self assert: parser parse: 'a' to: 'a' end: 1.	self assert: result debugResult steps equals: 8! !!PP2OptimizationParserTest methodsFor: 'tests - guards'!testGuardOptionalFailure	|  wrappedOne parser result |	wrappedOne := $a asPParser wrapped trim flatten.	parser := wrappedOne optional.	parser optimize.	parser enableDebug.	result := self assert: parser parse: 'c' to: nil end: 0.	self assert: result debugResult steps equals: 2! !!PP2OptimizationParserTest methodsFor: 'tests - guards'!testGuardPlus	| parserOne wrappedOne result parser |	parserOne := $a asPParser.	wrappedOne := parserOne wrapped trim flatten. 	parser := wrappedOne plus.	parser optimize.	parser enableDebug.	result := self assert: parser parse: 'a' to: #('a') end: 1.	self assert: result debugResult steps equals: 13! !!PP2OptimizationParserTest methodsFor: 'tests - guards'!testGuardPlusFailure	| result parser parserOne wrappedOne |	parserOne := $a asPParser.	wrappedOne := parserOne wrapped trim flatten. 	parser := wrappedOne plus.	parser optimize.	parser enableDebug.	result := self assert: parser fail: 'c'.	self assert: result debugResult steps equals: 2! !!PP2OptimizationParserTest methodsFor: 'tests - guards'!testGuardPlusTwo	| parserOne wrappedOne parser result |	parserOne := $a asPParser.	wrappedOne := parserOne wrapped trim flatten. 	parser := wrappedOne plus.	parser optimize.	parser enableDebug.	result := self assert: parser parse: 'aa' to: #('a' 'a') end: 2.	self assert: result debugResult steps equals: 19! !!PP2OptimizationParserTest methodsFor: 'tests - guards'!testGuardStar	| parser wrappedOne result |	wrappedOne := $a asPParser wrapped trim flatten. 	parser := wrappedOne star.	parser optimize.	parser enableDebug.	result := self assert: parser parse: 'a' to: #('a') end: 1.	self assert: result debugResult steps equals: 13.! !!PP2OptimizationParserTest methodsFor: 'tests - guards'!testGuardStarEmpty	| parser wrappedOne result |	wrappedOne := $a asPParser wrapped trim flatten. 	parser := wrappedOne star.	parser optimize.	parser enableDebug.	result := self assert: parser parse: 'c' to: #() end: 0.	self assert: result debugResult steps equals: 2.! !!PP2OptimizationParserTest methodsFor: 'tests'!testLiteralObject		self assert: $a asPParser flatten parse: 'a'.! !!PP2OptimizationParserTest methodsFor: 'tests'!testLiteralObjectTrimmingToken		self assert: $a asPParser wrapped token trim parse: '   a   ' toTokenValue: 'a'.! !!PP2OptimizationParserTest methodsFor: 'tests'!testNotLiteral	self assert: $a asPParser not parse: 'b' to: nil end: 0.! !!PP2OptimizationParserTest methodsFor: 'tests'!testNotPredicateObject	self assert: #letter asPParser not parse: '0' to: nil end: 0.	self assert: #letter asPParser not parse: '_' to: nil end: 0.		self assert: #letter asPParser not fail: 'a' end: 0.! !!PP2OptimizationParserTest methodsFor: 'tests - packrat'!testPackrat	| packrat parser result |	packrat := $a asPParser trim memoize.	parser := packrat and, packrat.		parser optimize.	parser enableDebug.		result := self assert: parser parse: ' a'.	self assert: result debugResult steps equals: 8.! !!PP2OptimizationParserTest methodsFor: 'tests - packrat'!testPackratContextSensitive	| packrat parser result |	packrat := #letter asPParser match memoize.	parser := (#letter asPParser push, packrat) and, #letter asPParser push, packrat.		parser optimize.	parser enableDebug.		result := self assert: parser parse: 'aa'.	self assert: result debugResult steps equals: 11! !!PP2OptimizationParserTest methodsFor: 'tests - packrat'!testPackratContextSensitiveFailure	| packrat parser result |	packrat := #letter asPParser match memoize.	parser := (#letter asPParser push, packrat) and, #letter asPParser, packrat.		parser optimize.	parser enableDebug.		result := self assert: parser fail: 'aa' end: 1! !!PP2OptimizationParserTest methodsFor: 'tests'!testSea	|  parser island result |		island := $a asPParser plus flatten.	parser := island sea.	parser optimize.	result := parser debug: '..aa..'.	self assert: result debugResult steps equals: 33.	! !!PP2OptimizationParserTest methodsFor: 'tests'!testSequenceWithPush	| parser |	self context defaultStack push: $x.	parser := $a asPParser, $b asPParser push, $c asPParser.	parser optimize.		self assert: parser parse: 'abc'.	self assert: self context defaultStack top equals: $b.	self assert: self context defaultStack size equals: 2.	self assert: (self context countFor: #remember) equals: 1.! !!PP2OptimizationParserTest methodsFor: 'tests'!testSequenceWithPushFailureFirst	| parser |	self context defaultStack push: $x.	parser := $a asPParser, $b asPParser push, $c asPParser.	parser optimize.		self assert: parser fail: 'xbc'.	self assert: self context defaultStack top equals: $x.	self assert: self context defaultStack size equals: 1.	self assert: (self context countFor: #remember) equals: 1.! !!PP2OptimizationParserTest methodsFor: 'tests'!testSequenceWithPushFailureLast	| parser |	self context defaultStack push: $x.	parser := $a asPParser, $b asPParser push, $c asPParser.	parser optimize.		self assert: parser fail: 'abx' end: 2.	self assert: self context defaultStack top equals: $x.	self assert: self context defaultStack size equals: 1.	self assert: (self context countFor: #remember) equals: 1.! !!PP2OptimizationParserTest methodsFor: 'tests'!testTrimming		self assert: $a asPParser trim parse: '   a   '.! !!PP2ParseOptimizedTest methodsFor: 'parsing'!parse: aStream withParser: aParser withContext: aContext	^ aParser optimize parseAdaptable: aStream withContext: aContext! !!PP2ParseTest methodsFor: 'accessing'!context	context isNil ifTrue: [ 		context := super context	].	^ context! !!PP2ParseTest methodsFor: 'accessing'!parse: aStream withParser: aParser withContext: aContext	^ aParser parseAdaptable: aStream withContext: aContext! !!PP2ParseTest methodsFor: 'test - context'!testMatch	| node |	node := $a asPParser match.		self context defaultStack push: $a.	self assert: node parse: 'a'.! !!PP2ParseTest methodsFor: 'test - context'!testMatchEmpty	| node |	node := $a asPParser match.		self assert: node fail: 'a'.! !!PP2ParseTest methodsFor: 'test - context'!testMatchFailure	| node |	node := $a asPParser match.		self context defaultStack push: $b.	self assert: node fail: 'b'.! !!PP2ParseTest methodsFor: 'test - context'!testMatchNoMatch	| node |	node := $a asPParser match.		self context defaultStack push: $b.	self assert: node fail: 'a'.! !!PP2ParseTest methodsFor: 'test'!testNonEpsilon	|  parser |	parser := $a asPParser optional nonEpsilon.		self assert: parser fail: ''.	self assert: parser parse: 'a'! !!PP2ParseTest methodsFor: 'test - context'!testPop	| node |	node := nil asPParser pop.		self context defaultStack push: $a.	self assert: node parse: ''.	self assert: context defaultStack isEmpty.! !!PP2ParseTest methodsFor: 'test - context'!testPopStarOne	| node |	node := $a asPParser pop star.		self context defaultStack push: $a.	self assert: node parse: 'a'.	self assert: context defaultStack size equals: 0.! !!PP2ParseTest methodsFor: 'test - context'!testPopStarTwo	| node |	node := $a asPParser pop star.		self context defaultStack push: $a.	self context defaultStack push: $a.	self assert: node parse: 'aa'.	self assert: context defaultStack size equals: 0.! !!PP2ParseTest methodsFor: 'test - context'!testPopStarZero	| node |	node := $a asPParser pop star.		self context defaultStack push: $a.	self assert: node parse: ''.	self assert: context defaultStack size equals: 1.! !!PP2ParseTest methodsFor: 'test - context'!testPush	| node |	node := $a asPParser push.		self assert: node parse: 'a'.	self assert: context defaultStack size equals: 1.	self assert: context defaultStack top equals: $a.! !!PP2ParseTest methodsFor: 'test - context'!testPushStarOne	| node |	node := $a asPParser push star.		self assert: node parse: 'a'.	self assert: context defaultStack size equals: 1.! !!PP2ParseTest methodsFor: 'test - context'!testPushStarTwo	| node |	node := $a asPParser push star.		self assert: node parse: 'aa'.	self assert: self context defaultStack size equals: 2.! !!PP2ParseTest methodsFor: 'test - context'!testPushStarZero	| node |	node := $a asPParser push star.		self assert: node parse: ''.	self assert: self context defaultStack size equals: 0.! !!PP2ParseTest methodsFor: 'test - water'!testWaterBoundary	| water |	water := PP2WaterNode new		boundaryElements: 'foo' asPParser;		yourself.		self assert: water parse: 'foobar' to: '' end: 0.	self assert: water parse: 'barfoo' to: 'bar' end: 3.		self assert: water fail: ''.	self assert: water fail: 'barbar'.	! !!PP2ParseTest methodsFor: 'test - water'!testWaterDefault	| water |	water := PP2WaterNode new.		self assert: water parse: 'foobar' to: 'foobar'.	self assert: water parse: '' to: ''! !!PP2ParseTest methodsFor: 'test - water'!testWaterRecursive	| water |	water := PP2WaterNode new		yourself.	water boundary: water.	self assert: water parse: 'foobar' to: '' end: 0! !!PP2ParseTest methodsFor: 'test - water'!testWaterRecursive2	| water eof |	water := PP2WaterNode new		yourself.	eof := PP2EndOfInputNode new.	water boundary: (water, eof) / eof.	self assert: water parse: 'foobar' to: 'foobar'! !!PP2PredicateTest methodsFor: 'utilities'!assertCharacterSets: aParser	"Assert the character set of aParser does not overlap with the character set with the negated parser, and that they both cover the complete character space."	| positives negatives |	positives := self parsedCharacterSet: aParser.	negatives := self parsedCharacterSet: aParser negate.	self charactersDo: [ :char | 		| positive negative |		positive := positives includes: char.		negative := negatives includes: char.		self 			assert: ((positive and: [ negative not ])				or: [ positive not and: [ negative ] ])			description: char printString , ' should be in exactly one set' ]! !!PP2PredicateTest methodsFor: 'private'!charactersDo: aBlock	1 to: 256 do: [ :index | aBlock value: (Character codePoint: index) ]! !!PP2PredicateTest methodsFor: 'accessing'!parse: aStream withParser: aParser withContext: aContext	^ aParser parse: aStream withContext: aContext! !!PP2PredicateTest methodsFor: 'utilities'!parsedCharacterSet: aParser	| result |	result := WriteStream on: String new.	self charactersDo: [ :char |		(aParser matches: (char asString))			ifTrue: [ result nextPut: char ] ].	^ result contents! !!PP2PredicateTest methodsFor: 'testing-objects'!testAny	| parser |	parser := #any asPParser.	self assertCharacterSets: parser.	self assert: parser parse: ' ' to: $ .	self assert: parser parse: '1' to: $1.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: ''! !!PP2PredicateTest methodsFor: 'testing-objects'!testAnyExceptAnyOf	| parser |	parser := PP2PredicateObjectNode noneOf: #($: $,).	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'z' to: $z.	self assert: parser fail: ':'.	self assert: parser fail: ','! !!PP2PredicateTest methodsFor: 'testing-objects'!testAnyOf	| parser |	parser := PP2PredicateObjectNode anyOf: #($a $z).	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'z' to: $z.	self assert: parser fail: 'x'! !!PP2PredicateTest methodsFor: 'testing-chars'!testBlank	| parser |	parser := #blank asPParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character space) to: Character space.	self assert: parser parse: (String with: Character tab) to: Character tab.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: (String with: Character cr)! !!PP2PredicateTest methodsFor: 'testing-chars'!testChar	| parser |	parser := $* asPParser.	self assertCharacterSets: parser.	self assert: parser parse: '*' to: $*.	self assert: parser parse: '**' to: $* end: 1.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: 'a'! !!PP2PredicateTest methodsFor: 'testing-chars'!testDigit	| parser |	parser := #digit asPParser.	self assertCharacterSets: parser.	self assert: parser parse: '0' to: $0.	self assert: parser parse: '9' to: $9.	self assert: parser fail: ''.	self assert: parser fail: 'a'! !!PP2PredicateTest methodsFor: 'testing-objects'!testExpect	| parser |	parser := PP2PredicateObjectNode expect: $a message: '$a expected'.	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'.	self assert: parser fail: ''! !!PP2PredicateTest methodsFor: 'testing-chars'!testHex	| parser |	parser := #hex asPParser.	self assertCharacterSets: parser.	self assert: parser parse: '0' to: $0.	self assert: parser parse: '5' to: $5.	self assert: parser parse: '9' to: $9.	self assert: parser parse: 'A' to: $A.	self assert: parser parse: 'D' to: $D.	self assert: parser parse: 'F' to: $F.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'e' to: $e.	self assert: parser parse: 'f' to: $f.	self assert: parser fail: ''.	self assert: parser fail: 'g'! !!PP2PredicateTest methodsFor: 'testing-chars'!testLetter	| parser |	parser := #letter asPParser.	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'Z' to: $Z.	self assert: parser fail: ''.	self assert: parser fail: '0'! !!PP2PredicateTest methodsFor: 'testing-chars'!testNewline	| parser |	parser := #newline asPParser.	self assert: parser parse: String cr to: String cr.	self assert: parser parse: String lf to: String lf.	self assert: parser parse: String crlf to: String  crlf.	self assert: parser fail: ' '! !!PP2PredicateTest methodsFor: 'testing-sequence'!testSequenceParser	| parser |	parser := PP2PredicateSequenceNode		on: [ :value | value first isUppercase ]		message: 'uppercase 3 letter words'		size: 3.	self assert: parser size equals: 3.	self assert: parser parse: 'Abc'.	self assert: parser parse: 'ABc'.	self assert: parser parse: 'ABC'.	self assert: parser fail: 'abc'.	self assert: parser fail: 'aBC'.	self assert: parser fail: 'Ab'.	parser := parser negate.	self assert: parser size equals: 3.	self assert: parser fail: 'Abc'.	self assert: parser fail: 'ABc'.	self assert: parser fail: 'ABC'.	self assert: parser parse: 'abc'.	self assert: parser parse: 'aBC'.	self assert: parser fail: 'Ab'! !!PP2PredicateTest methodsFor: 'testing-chars'!testSpace	| parser |	parser := #space asPParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character tab) to: Character tab.	self assert: parser parse: ' ' to: Character space.	self assert: parser fail: ''.	self assert: parser fail: 'a'! !!PP2PredicateTest methodsFor: 'testing-chars'!testWord	| parser |	parser := #word asPParser.	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'A' to: $A.	self assert: parser parse: '0' to: $0.	self assert: parser fail: ''.	self assert: parser fail: '-'! !!PP2SeaOptimizationParserTest methodsFor: 'parse support'!assert: parser parse: input	parser optimize.	result := (super assert: parser parse: input) value! !!PP2SeaOptimizationParserTest methodsFor: 'parsing'!parse: aStream withParser: aParser withContext: aContext	^ aParser parseAdaptable: aStream withContext: aContext! !!PP2SeaOptimizationParserTest methodsFor: 'parse support'!result	^ result! !!PP2SeaOptimizationParserTest methodsFor: 'parse support'!seaInstance	^ PP2SeaNode new! !!PP2SeaParserTest methodsFor: 'utilities'!assert: parser parse: input	result := (super assert: parser parse: input) value! !!PP2SeaParserTest methodsFor: 'accessing'!parse: aStream withParser: aParser withContext: aContext	^ aParser parseAdaptable: aStream withContext: aContext! !!PP2SeaParserTest methodsFor: 'parse support'!result	^ result! !!PP2SeaParserTest methodsFor: 'parse support'!seaInstance	^ PP2SeaNode new! !!PP2SeaParserTest methodsFor: 'tests'!testNestedBlockDeepNested	| block |	block := self nestedBlock.		self assert: block parse: '{ {} { {  } } }'.	self assert: self result size equals: 3.	self assert: self result first equals: ${.	self assert: self result second size equals: 2.	self assert: self result second first size equals: 3.	self assert: self result second second size equals: 3.	self assert: self result third equals: $}.! !!PP2WaterNodeTest methodsFor: 'tests'!testBoundaryElements	| water boundary |	water := PP2WaterNode new.	boundary := $a asPParser.		water boundaryElements: boundary asOrderedCollection.		self assert: water boundary isKindOf: PP2ChoiceNode.	self assert: water boundary firstChild isKindOf: PP2AndNode.	self assert: water boundaryElements first  == boundary! !!PP2AllNodesCacheTest methodsFor: 'tests'!assert: node hasProperty: propertyName withValue: propertyValue	self assert: (node propertyAt: propertyName) equals: propertyValue! !!PP2AllNodesCacheTest methodsFor: 'tests'!testSanity	| parser |	parser := PP2ExpressionGrammar new.	PP2AllNodesCache new doPass: parser.		parser allNodesDo: [ :child | 		self assert: (child hasProperty: #allNodesSize).	].	self assert: (parser productionAt: #number) hasProperty: #allNodesSize withValue: 12.	self assert: parser hasProperty: #allNodesSize withValue: parser allNodes size.	! !!PP2AllNodesVisitorTest methodsFor: 'running'!setUp	visitor := PP2AllNodesVisitor new! !!PP2AllNodesVisitorTest methodsFor: 'tests'!testChoice	parser := $a asPParser / $b asPParser.	children := self visit: parser.		self assert: children isCollection.	self assert: children size = 3.	self assert: (children includes: parser).	self assert: (children includes: parser firstChild).	self assert: (children includes: parser secondChild).! !!PP2AllNodesVisitorTest methodsFor: 'tests'!testCycle	| delegate |	delegate := PP2DelegateNode new.	parser := delegate, delegate.	delegate child: parser.	children := self visit: parser.		self assert: children isCollection.	self assert: children size equals: 2.	self assert: (children includes: parser).	self assert: (children includes: delegate).	! !!PP2AllNodesVisitorTest methodsFor: 'tests'!testLiteral	parser := $a asPParser.	children := self visit: parser.		self assert: children isCollection.	self assert: children size = 1.	self assert: children anyOne = parser.! !!PP2AllNodesVisitorTest methodsFor: 'tests'!testSequence	parser := $a asPParser, $b asPParser.	children := self visit: parser.		self assert: children isCollection.	self assert: children size = 3.	self assert: (children includes: parser).	self assert: (children includes: parser firstChild).	self assert: (children includes: parser secondChild).! !!PP2AllNodesVisitorTest methodsFor: 'tests'!testTokenParser	parser := $a asPParser token.	children := self visit: parser.		self assert: children isCollection.	self assert: children size = 2.	self assert: (children includes: parser child).	self assert: (children includes: parser).	! !!PP2AllNodesVisitorTest methodsFor: 'tests'!testTrimParser	| trimmer |	trimmer := PP2FailingNode instance.	parser := $a asPParser trim: trimmer.		children := self visit: parser.		self assert: children isCollection.	self assert: children size = 3.	self assert: (children includes: parser child).	self assert: (children includes: parser).	self assert: (children includes: trimmer).	! !!PP2AllNodesVisitorTest methodsFor: 'tests'!testWrapping	parser := $a asPParser wrapped.	children := self visit: parser.		self assert: children isCollection.	self assert: children size = 2.	self assert: (children includes: parser child).	self assert: (children includes: parser).	! !!PP2AllNodesVisitorTest methodsFor: 'running'!visit: node	^ visitor visit: node.! !!PP2BufferStreamTest methodsFor: 'running'!setUp	super setUp! !!PP2BufferStreamTest methodsFor: 'running'!streamOn: collection	^ PP2BufferStream on: (PP2MinimalStream on: collection)! !!PP2BufferStreamTest methodsFor: 'running'!streamOn: collection bufferSize: size	^ PP2BufferStream on: (PP2MinimalStream on: collection) bufferSize: size! !!PP2BufferStreamTest methodsFor: 'tests - context interface'!testAtEndDifferentPosition	| stream |	stream := self streamOn: 'f'.	stream upToPosition: 1.	self assert: (stream atEnd: 0) not.	self assert: (stream atEnd: 1).		self assert: (stream atEnd: 2).! !!PP2BufferStreamTest methodsFor: 'tests'!testContents	| stream |	stream := self streamOn: 'bar'. 		self assert: (stream contents) equals: ''.! !!PP2BufferStreamTest methodsFor: 'tests'!testContentsAfterRead	| stream |	stream := self streamOn: 'bar'. 	stream upToPosition: 3.		self assert: (stream contents) equals: 'bar'.! !!PP2BufferStreamTest methodsFor: 'tests - context interface'!testCopyFromToBufferOverflow	| stream |	stream := self streamOn: 'bar' bufferSize:2.	self assert: (stream copyFrom: 2 to: 3) equals: 'ar'! !!PP2BufferStreamTest methodsFor: 'tests'!testCopyFromToOOB	| stream |	stream := self streamOn: 'bar'.	self should: [ stream copyFrom: 4 to: 4 ] raise: PP2OutOfBoundsException.	self should: [ stream copyFrom: 1 to: 4 ] raise: PP2OutOfBoundsException.! !!PP2BufferStreamTest methodsFor: 'tests'!testCopyFromToSmallBuffer	| stream |	stream :=  self streamOn: 'foobar' bufferSize: 3. 	self assert: (stream copyFrom: 1 to: 3) = 'foo'.	self assert: (stream copyFrom: 2 to: 4) = 'oob'.	self should: [ stream copyFrom: 1 to: 3 ] raise: Exception description: 'too much backtrack'.	self should: [ stream copyFrom: 2 to: 5 ] raise: Exception description: 'range too big'.! !!PP2BufferStreamTest methodsFor: 'tests'!testInstanceCreation	| stream |	stream := self streamOn: ''.	self assert: (stream buffer isKindOf: String).	self assert: (stream buffer size = stream bufferSize).! !!PP2BufferStreamTest methodsFor: 'tests'!testInstanceCreationSize	| stream |	stream := self streamOn: '' bufferSize: 2. 	self assert: (stream buffer isKindOf: String).	self assert: (stream buffer size = stream bufferSize).	self assert: (stream bufferSize = 2).! !!PP2BufferStreamTest methodsFor: 'tests - context interface'!testRandomAccessTooMuchBacktrack	| stream |	stream := self streamOn: 'bar' bufferSize: 2. 		self assert: (stream atPosition: 3) equals: $r.		self assert: (stream atPosition: 2) equals: $a.	self should: [ stream atPosition: 1 ] raise: PP2OutOfBoundsException description: 'too much backtrack'.! !!PP2BufferStreamTest methodsFor: 'tests - context interface'!testRandomAccessTwoPasses	| stream |	stream := self streamOn: 'foobar' bufferSize: 2. 		self assert: (stream atPosition: 1) = $f.		self assert: (stream atPosition: 2) = $o.	self assert: (stream atPosition: 3) = $o.		self assert: (stream atPosition: 4) = $b.	self assert: (stream atPosition: 5) = $a.	self assert: (stream atPosition: 6) = $r.		self should: [(stream atPosition: 1) ] raise: Exception.	self should: [(stream atPosition: 2) ] raise: Exception.	self should: [(stream atPosition: 3) ] raise: Exception.	self should: [(stream atPosition: 4) ] raise: Exception.	self assert: (stream atPosition: 5) = $a.	self assert: (stream atPosition: 6) = $r.! !!PP2BufferStreamTest methodsFor: 'tests'!testUncheckedNext	| stream |	stream := self streamOn: 'foo'. 		self assert: stream uncheckedNext = $f.	self assert: stream uncheckedNext = $o.	self assert: stream uncheckedNext = $o.	self should: [ stream uncheckedNext ] raise: Exception.! !!PP2BypassVisitorTest methodsFor: 'as yet unclassified'!assert: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass)! !!PP2BypassVisitorTest methodsFor: 'as yet unclassified'!setUp	visitor := PP2BypassVisitor new! !!PP2BypassVisitorTest methodsFor: 'as yet unclassified'!testBypassCache	| cache |	cache := $a asPParser wrapped.	cache strategy: cache strategy cache.		parser := cache plus.	parser strategy: (PP2Plus on: parser).		self visit: parser.		self assert: parser strategy child isKindOf: PP2DelegateNode.! !!PP2BypassVisitorTest methodsFor: 'as yet unclassified'!testPlus	parser := $a asPParser wrapped plus.	parser strategy: (PP2Plus on: parser).		self visit: parser.		self assert: parser strategy child isKindOf: PP2LiteralObjectNode.! !!PP2BypassVisitorTest methodsFor: 'as yet unclassified'!testSequenceOfTwo	parser := $a asPParser wrapped, $b asPParser wrapped.	parser strategy: (PP2SequenceOfTwo on: parser).		self visit: parser.		self assert: parser strategy firstChild isKindOf: PP2LiteralObjectNode.	self assert: parser strategy secondChild isKindOf: PP2LiteralObjectNode.	! !!PP2BypassVisitorTest methodsFor: 'as yet unclassified'!testSequenceOfTwoRecognizer	parser := $a asPParser wrapped, $b asPParser wrapped.	parser strategy: (PP2SequenceOfTwoRecognizer on: parser).		self visit: parser.		self assert: parser strategy firstChild isKindOf: PP2LiteralObjectNode.	self assert: parser strategy secondChild isKindOf: PP2LiteralObjectNode.	! !!PP2BypassVisitorTest methodsFor: 'as yet unclassified'!testStar	parser := $a asPParser wrapped star.	parser strategy: (PP2Star on: parser).		self visit: parser.		self assert: parser strategy child isKindOf: PP2LiteralObjectNode.! !!PP2BypassVisitorTest methodsFor: 'as yet unclassified'!visit: node	visitor visit: node! !!PP2CommonPrefixVisitorTest methodsFor: 'running'!setUp	super setUp.		visitor := PP2CommonPrefixVisitor new! !!PP2CommonPrefixVisitorTest methodsFor: 'tests'!testChoice	| production |	production := 'foo' asPParser plus wrapped trim ==> [ :foo | foo ]		name: 'production';		yourself.		parser := production / ($a asPParser optional, production wrapped).		self visit: parser.		self assert: production strategy isKindOf: PP2Cache.! !!PP2CommonPrefixVisitorTest methodsFor: 'tests'!testChoiceNonIdentical	| productionOne productionTwo |	productionOne := 'foo' asPParser plus wrapped trim ==> [ :foo | foo ]		name: 'production';		yourself.	productionTwo := 'foo' asPParser plus wrapped trim ==> [ :foo | foo ]		name: 'production';		yourself.		parser := productionOne / ($a asPParser optional, productionTwo wrapped).		self visit: parser.		self assert: productionOne strategy isKindOf: PP2Cache.	self assert: productionOne strategy isKindOf: PP2Cache.	self assert: productionOne strategy == productionTwo strategy.	! !!PP2CommonPrefixVisitorTest methodsFor: 'tests'!testSea	| island |	island := 'foo' asPParser plus wrapped trim ==> [ :foo | foo ]		name: 'production';		yourself.		parser := island sea.		self visit: parser.		self assert: island strategy isKindOf: PP2Cache.! !!PP2CommonPrefixVisitorTest methodsFor: 'tests'!testSeaBoundary	| sea |	sea := $a asPParser star trim flatten wrapped sea.		parser := $b asPParser plus trim wrapped flatten.	sea beforeWater boundaryElements: parser.	sea afterWater boundary: parser.		self visit: sea.	self assert: sea beforeWater boundaryElements allSatisfy: [:e | e strategy isKindOf: PP2Cache ].	self assert: sea afterWater boundaryElements allSatisfy: [:e | e strategy isKindOf: PP2Cache ].	! !!PP2CommonPrefixVisitorTest methodsFor: 'tests'!testSeaNested	| sea |	sea := $a asPParser sea.		parser := (sea ==> #second) sea.	sea beforeWater boundary: $b asPParser plus flatten trim.	sea afterWater boundary: $c asPParser plus flatten trim.	self visit: parser.		self assert: sea beforeWater boundaryElements allSatisfy: [ :e | e strategy isKindOf: PP2Cache ].	self assert: sea afterWater boundaryElements allSatisfy: [ :e | e strategy isKindOf: PP2Cache ].	! !!PP2CommonPrefixVisitorTest methodsFor: 'tests'!testSequence	| production |	production := 'foo' asPParser plus wrapped trim ==> [ :foo | foo ]		name: 'production';		yourself.		parser := (production, $a asPParser) star, production wrapped.		self visit: parser.		self assert: production strategy isKindOf: PP2Cache.! !!PP2CommonPrefixVisitorTest methodsFor: 'visiting'!visit: node	visitor visit: node! !!PP2ContextChangesVisitorTest methodsFor: 'asserting'!assertChangesContext: node	self assert: (visitor visit: node) isContextChange! !!PP2ContextChangesVisitorTest methodsFor: 'asserting'!assertPop: node	self assert: (visitor visit: node) isContextPop! !!PP2ContextChangesVisitorTest methodsFor: 'asserting'!assertPush: node	self assert: (visitor visit: node) isContextPush! !!PP2ContextChangesVisitorTest methodsFor: 'asserting'!denyChangesContext: node	self deny: (visitor visit: node) isContextChange! !!PP2ContextChangesVisitorTest methodsFor: 'asserting'!denyPop: node	self deny: (visitor visit: node) isContextPop! !!PP2ContextChangesVisitorTest methodsFor: 'asserting'!denyPush: node	self deny: (visitor visit: node) isContextPush! !!PP2ContextChangesVisitorTest methodsFor: 'running'!setUp	visitor := PP2ContextChangesVisitor new! !!PP2ContextChangesVisitorTest methodsFor: 'tests'!testAnd	parser := $a asPParser and.		self denyChangesContext: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests'!testAndPush	parser := $a asPParser push and.		self denyChangesContext: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests'!testChoice	parser := $a asPParser / $b asPParser.		self denyChangesContext: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests'!testChoicePopPop	parser := $a asPParser pop / $b asPParser pop.		self assertChangesContext: parser.	self assertPop: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests'!testChoicePushPop	parser := $a asPParser push / $b asPParser pop.		self assertChangesContext: parser.	self denyPush: parser.	self denyPop: parser.! !!PP2ContextChangesVisitorTest methodsFor: 'tests'!testChoicePushPush	parser := $a asPParser push / $b asPParser push.		self assertChangesContext: parser.	self assertPush: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests'!testChoiceWithPop	parser := $a asPParser / $b asPParser pop.		self assertChangesContext: parser.	self denyPop: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests'!testDelegate	parser := $a asPParser wrapped.		self denyChangesContext: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests'!testDelegatePop	parser := $a asPParser pop wrapped.		self assertPop: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests'!testDelegatePush	parser := $a asPParser push wrapped.		self assertPush: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests'!testEpsilon	parser := #epsilon asPParser.		self denyChangesContext: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests'!testLiteralObject	parser := $a asPParser.		self denyChangesContext: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests'!testMatch	parser := $a asPParser match.		self denyChangesContext: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests'!testOptional	parser := $a asPParser optional.		self denyChangesContext: parser.! !!PP2ContextChangesVisitorTest methodsFor: 'tests'!testOptionalPop	parser := $a asPParser pop optional.		self assertChangesContext: parser.	self denyPop: parser.! !!PP2ContextChangesVisitorTest methodsFor: 'tests'!testOptionalPush	parser := $a asPParser push optional.		self assertChangesContext: parser.	self denyPush: parser.! !!PP2ContextChangesVisitorTest methodsFor: 'tests'!testPop	parser := $a asPParser pop.		self assertChangesContext: parser.	self assertPop: parser.! !!PP2ContextChangesVisitorTest methodsFor: 'tests'!testPopOfPop	parser := $a asPParser pop pop.		self assertChangesContext: parser.	self denyPop: parser.! !!PP2ContextChangesVisitorTest methodsFor: 'tests'!testPush	parser := $a asPParser push.		self assertChangesContext: parser.	self assertPush: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests'!testPushOfPush	parser := $a asPParser push push.		self assertChangesContext: parser.	self denyPush: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests'!testRepetition	parser := $a asPParser star.		self denyChangesContext: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests'!testRepetitionPop	parser := $a asPParser pop star.		self assertChangesContext: parser.	self denyPush: parser.! !!PP2ContextChangesVisitorTest methodsFor: 'tests'!testRepetitionPush	parser := $a asPParser push star.		self assertChangesContext: parser.	self denyPush: parser.! !!PP2ContextChangesVisitorTest methodsFor: 'tests'!testSequence	parser := $a asPParser, $b asPParser.		self denyChangesContext: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests'!testSequenceWithPop	parser := $a asPParser, ($b asPParser pop).		self assertChangesContext: parser.	self assertPop: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests'!testSequenceWithPopPush	parser := $a asPParser pop, $b asPParser push.		self assertChangesContext: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests'!testSequenceWithPush	parser := $a asPParser, $b asPParser push.		self assertChangesContext: parser.	self assertPush: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests'!testSequenceWithPushPop	parser := $a asPParser push, $b asPParser pop.		self denyChangesContext: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests'!testWrapping	parser := $a asPParser >=> [ :ctx :cc | cc value ].		self assertChangesContext: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests'!testWrappingSetProperty	parser := $a asPParser >=> [ :ctx :cc | cc value ]		contextChanges: PP2CcChange noChange;		yourself.		 self denyChangesContext: parser! !!PP2ContextMementoTest methodsFor: 'tests'!testEquals	| anotherMemento |	memento := PP2ContextMemento new.	memento position: 1.	memento propertyAt: #foo put: #bar.	anotherMemento := PP2ContextMemento new.	anotherMemento position: 1.	anotherMemento propertyAt: #foo put: #bar.		self assert: memento ~~ anotherMemento.	self assert: memento = anotherMemento.! !!PP2ContextMementoTest methodsFor: 'tests'!testEqualsWithStack	| anotherMemento |	memento := PP2ContextMemento new.	memento position: 1.	memento propertyAt: #foo put: Stack new.	anotherMemento := PP2ContextMemento new.	anotherMemento position: 1.	anotherMemento propertyAt: #foo put: Stack new.		self assert: memento ~~ anotherMemento.	self assert: memento = anotherMemento.! !!PP2ContextMementoTest methodsFor: 'tests'!testHash	| anotherMemento |	memento := PP2ContextMemento new.	memento position: 1.	memento propertyAt: #foo put: #bar.	anotherMemento := PP2ContextMemento new.	anotherMemento position: 1.	anotherMemento propertyAt: #foo put: #bar.		self assert: memento hash = anotherMemento hash.! !!PP2ContextMementoTest methodsFor: 'tests'!testMinus	| anotherMemento |	memento := PP2ContextMemento new.	memento position: 1.		anotherMemento := memento - 1.		self assert: memento ~~ anotherMemento.	self assert: anotherMemento position equals: 0.	self assert: memento position equals: 1.! !!PP2ContextMementoTest methodsFor: 'tests'!testPlus	| anotherMemento |	memento := PP2ContextMemento new.	memento position: 1.		anotherMemento := memento + 1.		self assert: memento ~~ anotherMemento.	self assert: anotherMemento position equals: 2.	self assert: memento position equals: 1.! !!PP2ContextMemoizationVisitorTest methodsFor: 'asserting'!assertCFMemoization: node	visitor visit: node.		self assert: (node memoizationStrategy isKindOf: PP2CFMemoization).! !!PP2ContextMemoizationVisitorTest methodsFor: 'asserting'!assertMemoized: node	visitor visit: node.		self assert: (node isMemoized).! !!PP2ContextMemoizationVisitorTest methodsFor: 'asserting'!assertPopMemoization: node	visitor visit: node.		self assert: (node memoizationStrategy isKindOf: PP2PopMemoization).! !!PP2ContextMemoizationVisitorTest methodsFor: 'asserting'!assertPushMemoization: node	visitor visit: node.		self assert: (node memoizationStrategy isKindOf: PP2PushMemoization).! !!PP2ContextMemoizationVisitorTest methodsFor: 'asserting'!denyCFMemoization: node	visitor visit: node.		self deny: (node memoizationStrategy isKindOf: PP2CFMemoization).! !!PP2ContextMemoizationVisitorTest methodsFor: 'initialization'!setUp	visitor := PP2ContextMemoizationVisitor new! !!PP2ContextMemoizationVisitorTest methodsFor: 'tests'!testAnd	parser := $a asPParser and.		self assertCFMemoization: parser.! !!PP2ContextMemoizationVisitorTest methodsFor: 'tests'!testAndCS	parser := $a asPParser push and.		self denyCFMemoization: parser.! !!PP2ContextMemoizationVisitorTest methodsFor: 'tests'!testAndPop	parser := $a asPParser pop and.		self assertPopMemoization: parser.! !!PP2ContextMemoizationVisitorTest methodsFor: 'tests'!testAndPush	parser := $a asPParser push and.		self assertPushMemoization: parser.! !!PP2ContextMemoizationVisitorTest methodsFor: 'tests'!testNonEpsilon	parser := $a asPParser nonEpsilon.		self assertCFMemoization: parser.! !!PP2ContextMemoizationVisitorTest methodsFor: 'tests'!testNot	parser := $a asPParser not.		self assertCFMemoization: parser.! !!PP2ContextMemoizationVisitorTest methodsFor: 'tests'!testNotCS	parser := $a asPParser push not.		self denyCFMemoization: parser.! !!PP2ContextMemoizationVisitorTest methodsFor: 'tests'!testSequence	parser := $a asPParser, $b asPParser match, $c asPParser.		self assertCFMemoization: parser.! !!PP2ContextMemoizationVisitorTest methodsFor: 'tests'!testSequencePop	parser := $a asPParser, $b asPParser pop, $c asPParser.		self assertPopMemoization: parser.! !!PP2ContextMemoizationVisitorTest methodsFor: 'tests'!testSequencePush	parser := $a asPParser, $b asPParser push, $c asPParser.		self assertPushMemoization: parser.! !!PP2ContextMemoizationVisitorTest methodsFor: 'tests'!testSequencePushPop	parser := $a asPParser push, #letter asPParser match, $a asPParser pop.		self denyCFMemoization: parser.! !!PP2ContextSensitivityVisitorTest methodsFor: 'asserting'!assertIsContextSensitive: node	self assert: (visitor visit: node) description: 'should be context sensitive'! !!PP2ContextSensitivityVisitorTest methodsFor: 'asserting'!denyIsContextSensitive: node	self deny: (visitor visit: node) description: 'should not be context sensitive'! !!PP2ContextSensitivityVisitorTest methodsFor: 'running'!setUp	visitor := PP2ContextSensitivityVisitor new! !!PP2ContextSensitivityVisitorTest methodsFor: 'tests'!testAndMatch	parser := $a asPParser match and.		self assertIsContextSensitive: parser.! !!PP2ContextSensitivityVisitorTest methodsFor: 'tests'!testLiteralObject	parser := $a asPParser.		self denyIsContextSensitive: parser.! !!PP2ContextSensitivityVisitorTest methodsFor: 'tests'!testMatch	parser := $a asPParser match.		self assertIsContextSensitive: parser.! !!PP2ContextSensitivityVisitorTest methodsFor: 'tests'!testSea	parser := $a asPParser sea.		self denyIsContextSensitive: parser.! !!PP2ContextSensitivityVisitorTest methodsFor: 'tests'!testSeaWithCSIsland	parser := $a asPParser match sea.		self assertIsContextSensitive: parser.! !!PP2ContextSensitivityVisitorTest methodsFor: 'tests'!testSequence	parser := $a asPParser, $b asPParser.		self denyIsContextSensitive: parser.! !!PP2ContextSensitivityVisitorTest methodsFor: 'tests'!testSequenceWithMatch	parser := $a asPParser, $b asPParser match.		self assertIsContextSensitive: parser.! !!PP2ContextSensitivityVisitorTest methodsFor: 'tests'!testSequenceWithPush	parser := #letter asPParser, #letter asPParser push.		self denyIsContextSensitive: parser.! !!PP2ContextSensitivityVisitorTest methodsFor: 'tests'!testSequenceWithPushMatch	parser := (#letter asPParser push), (#letter asPParser match).		self denyIsContextSensitive: parser.! !!PP2ContextSensitivityVisitorTest methodsFor: 'tests'!testSequenceWithPushMatchPop	parser := (#letter asPParser push), (#letter asPParser match), (#letter asPParser pop).		self denyIsContextSensitive: parser.! !!PP2ContextTest methodsFor: 'requirements'!contextOn: aString	^ PP2Context on: aString asPetit2Stream! !!PP2ContextTest methodsFor: 'tests'!testAsPetit2Context	| context |	context := (PP2MinimalStream on: 'foo') asPetit2Stream asPetit2Context.		self assert: (context isKindOf: PP2Context).	self assert: context isPetit2Success.! !!PP2ContextTest methodsFor: 'tests'!testAsPositionableStream	| context |	context := (PP2MinimalStream on: 'foo') asPetit2Stream asPetit2Context.	context position: 2.	self should: [ context asPositionableStream ] raise: Exception! !!PP2ContextTest methodsFor: 'tests'!testCopy	| newContext context |	context := PP2Context new 		position: #postion;		stream: #stream;		parser: #parser;		startMemento: #startMemento;		yourself.			newContext := context copy.		self deny: context == newContext.	self assert: context position = newContext position.	self assert: context stream = newContext stream.		self assert: context parser = newContext parser.	self assert: context startMemento = newContext startMemento.! !!PP2DebugResultIntegrationTest methodsFor: 'tests'!testArithmetic	| parser result |	parser := PP2ExpressionParser new.	result := parser debug: '1 + 2'.	self assert: result debugResult children size equals: 1.	self assert: result debugResult children first result equals: #(1 $+ 2)! !!PP2DebugResultIntegrationTest methodsFor: 'tests'!testArithmeticCache	| parser result number links |	parser := PP2ExpressionParser new.	number := (parser productionAt: #number).	number strategy: number strategy cache.		result := parser debug: '1'.	links := result debugResult allResults select: [ :e | 		e children isEmpty not and: [ e children first isKindOf: PP2DebugResultLink ]	] thenCollect: [ :e | e children first ].	self assert: links size equals: 2.	self assert: links allSatisfy: [ :l | l reference parser name = #number ].! !!PP2DebugResultIntegrationTest methodsFor: 'tests'!testArithmeticFailure	| parser result |	parser := PP2ExpressionParser new.	result := parser debug: '1 / 2'.	self assert: result debugResult children size equals: 1.	self assert: result debugResult children first result isPetit2Failure! !!PP2DebugResultIntegrationTest methodsFor: 'tests'!testNumberParser	| parser result |	parser := PP2ExpressionParser new productionAt: #number.	result := parser debug: '1'.	self assert: result debugResult children size equals: 1.	self assert: result debugResult children first result equals: 1! !!PP2DebugResultIntegrationTest methodsFor: 'tests'!testProfilingContext	| parser result |	parser := PP2ExpressionParser new productionAt: #number.	result := parser debug: '1'.	self assert: result isKindOf: PP2RecordingContext.! !!PP2DebugResultTest methodsFor: 'tests'!testContents	| result |	result := PP2DebugResult new.	result context: 'a' asPetit2Context.		self assert: result contents equals: 'a'! !!PP2DebugResultTest methodsFor: 'tests'!testStartStopInterval	| result |	result := PP2DebugResult new.		self assert: result startStopInterval notNil.! !!PP2DebuggingStrategyTest methodsFor: 'initialization'!setUp	node := $a asPParser.	strategy := node strategy.! !!PP2DebuggingStrategyTest methodsFor: 'tests'!testCache	| debugStrategy |	debugStrategy := strategy debug.		self assert: debugStrategy cache == debugStrategy.	self assert: debugStrategy strategy isKindOf: PP2Cache	! !!PP2DebuggingStrategyTest methodsFor: 'tests'!testDebug	| debugStrategy |	debugStrategy := strategy debug.		self assert: debugStrategy debug == debugStrategy.	! !!PP2DebuggingStrategyTest methodsFor: 'tests'!testParsingGuard	| classification debugStrategy |	debugStrategy := strategy debug.	classification := Array new: 255 withAll: false.		self assert: (debugStrategy parsingGuard: classification) == debugStrategy.	self assert: debugStrategy strategy isKindOf: PP2ParsingGuard.		self assert: debugStrategy strategy retval isPetit2Failure.! !!PP2DebuggingStrategyTest methodsFor: 'tests'!testParsingGuardOptional	| classification debugStrategy optional |	optional := $a asPParser optional.		debugStrategy := optional strategy debug.	classification := Array new: 255 withAll: false.		self assert: (debugStrategy parsingGuard: classification) == debugStrategy.	self assert: debugStrategy strategy isKindOf: PP2ParsingGuard.		self assert: debugStrategy strategy retval isNil.! !!PP2DebuggingStrategyTest methodsFor: 'tests'!testRecognizer	| debugStrategy |	node := #letter asPParser.	strategy := node strategy.	debugStrategy := strategy debug.	self assert: debugStrategy strategy isKindOf: PP2PredicateObject.		self assert: debugStrategy recognizer == debugStrategy.	self assert: debugStrategy strategy isKindOf: PP2PredicateObjectRecognizer.	! !!PP2FirstCharSetTest methodsFor: 'support'!assert: aPP2CharSetPredicate value: anInteger	self assert: (aPP2CharSetPredicate value: anInteger) ! !!PP2FirstCharSetTest methodsFor: 'support'!reject: aPP2CharSetPredicate value: anInteger	self assert: (aPP2CharSetPredicate value: anInteger) not! !!PP2FirstCharSetTest methodsFor: 'tests'!testEmptyLiteralSequence	firstCharSet := '' asPParser firstCharSet.	1 to: 255 do: [ :index |		self assert: firstCharSet value: (Character codePoint: index).	].	self assert: firstCharSet value: (Character codePoint: 0).	self assert: firstCharSet value: (Character codePoint: 1234).! !!PP2FirstCharSetTest methodsFor: 'tests'!testEpsilon	firstCharSet := nil asPParser firstCharSet.	1 to: 255 do: [ :index |		self assert: firstCharSet value: (Character codePoint: index).	].	self assert: firstCharSet value: (Character codePoint: 0).	self assert: firstCharSet value: (Character codePoint: 1234).! !!PP2FirstCharSetTest methodsFor: 'tests'!testLiteralObject	firstCharSet := $b asPParser firstCharSet.	self assert: firstCharSet value: $b.	self reject: firstCharSet value: $a.	self reject: firstCharSet value: $c.		self reject: firstCharSet value: (Character codePoint: 1024).	! !!PP2FirstCharSetTest methodsFor: 'tests'!testLiteralSequence	firstCharSet := 'foobar' asPParser firstCharSet.	self assert: firstCharSet value: $f.	self reject: firstCharSet value: $e.	self reject: firstCharSet value: $o.	self reject: firstCharSet value: $b.		self reject: firstCharSet value: 1024.	! !!PP2FirstCharSetTest methodsFor: 'tests'!testNot	firstCharSet := #digit asPParser not firstCharSet.	self should: [ firstCharSet value: $1 ] raise: Error! !!PP2FirstCharSetTest methodsFor: 'tests'!testPluggable	firstCharSet := ([ :c | c next ] asPParser) firstCharSet.	self assert: firstCharSet isUnknown.! !!PP2FirstCharSetTest methodsFor: 'tests'!testPredicateObject	firstCharSet := #digit asPParser firstCharSet.	self assert: firstCharSet value: $0.	self assert: firstCharSet value: $1.	self assert: firstCharSet value: $2.	self assert: firstCharSet value: $3.	self assert: firstCharSet value: $4.	self assert: firstCharSet value: $5.	self assert: firstCharSet value: $6.	self assert: firstCharSet value: $7.	self assert: firstCharSet value: $8.	self assert: firstCharSet value: $9.	self reject: firstCharSet value: $/.	self reject: firstCharSet value: $:.		self reject: firstCharSet value: (Character codePoint: 1024).	self reject: firstCharSet value: (Character codePoint: 0).	! !!PP2FirstCharSetTest methodsFor: 'tests'!testStartOfLine	firstCharSet := #startOfLine asPParser firstCharSet.	self should: [ firstCharSet value: $1 ] raise: Error! !!PP2FirstCharSetTest methodsFor: 'tests'!testWrapping	firstCharSet := ($a asPParser >=> [ :c :cc | cc value ]) firstCharSet.	self assert: firstCharSet isUnknown.! !!PP2FirstCharSetTest methodsFor: 'tests'!testWrappingNonFunctional	firstCharSet := ($b asPParser >==> [ :c :cc | cc value ]) firstCharSet.	self assert: firstCharSet value: $b.	self reject: firstCharSet value: $a.	self reject: firstCharSet value: $c.! !!PP2FirstProductionSetCacheTest methodsFor: 'tests'!testSanity	| parser |	parser := PP2ExpressionGrammar new.	PP2FirstProductionSetCache new doPass: parser.		parser allNodesDo: [ :child | 		self assert: (child hasProperty: #firstProductionSet).		self assert: (child firstProductionSet allSatisfy: [ :e | e isProduction  ])	]! !!PP2FirstSetCacheTest methodsFor: 'tests'!testSanity	| parser |	parser := ((($f asPParser, 'oo' asPParser) wrapped not ==> [ :e | e ]) star / 				   (nil asPParser, '' asPParser)) end.	PP2FirstSetCache new doPass: parser.		self assert: (parser allNodes allSatisfy: [ :child | child hasProperty: #firstSet ])! !!PP2FirstSetVisitorTest methodsFor: 'converting'!assert: aSet anySatisfy: anObject	self assert: (aSet anySatisfy: anObject)! !!PP2FirstSetVisitorTest methodsFor: 'converting'!assert: aSet includes: anObject	self assert: (aSet includes: anObject)! !!PP2FirstSetVisitorTest methodsFor: 'accessing'!firstSet: aPP2Node	^ PP2FirstSetVisitor firstSet visit: aPP2Node! !!PP2FirstSetVisitorTest methodsFor: 'accessing'!firstSetWithProduction: aPP2Node	^ PP2FirstSetVisitor productionSet visit: aPP2Node! !!PP2FirstSetVisitorTest methodsFor: 'tests - seas or terminals'!firstSetWithSeasOrTerminals: node	^ PP2FirstSetVisitor seasOrTerminalsSet visit: node! !!PP2FirstSetVisitorTest methodsFor: 'accessing'!firstSetWithTokens: aPP2Node	^ PP2FirstSetVisitor tokenSet visit: aPP2Node! !!PP2FirstSetVisitorTest methodsFor: 'accessing'!firstSetWithoutDuplicates: aPP2Node	^ self withoutDuplicates: (PP2FirstSetVisitor firstSet visit: aPP2Node)! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testAdaptable	parser := PP2AdaptableNode new.	parser changeChild: $a asPParser.	firstSet := self firstSet: parser.	self assert: firstSet size equals: 2.	self assert: firstSet includes: PP2EpsilonNode instance.		1 to: 255 do: [ :index | 		self assert: firstSet anySatisfy: [ :e | 			(e parse: (Character codePoint: index) asString) isPetit2Success 		]	]	! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testAnd	| sequence |	parser := #letter asPParser.	sequence := parser and, $b asPParser.	firstSet := self firstSet: sequence.	self assert: firstSet size equals: 1.	self assert: firstSet includes: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testChoice	| parserOne parserTwo |	parserOne := $a asPParser.	parserTwo := $b asPParser.			firstSet := self firstSet: parserOne / parserTwo.	self assert: firstSet size equals: 2.	self assert: firstSet includes: parserOne.	self assert: firstSet includes: parserTwo.! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testCycle	| delegateOne delegateTwo sequence |	delegateOne := PP2DelegateNode new.	delegateTwo := PP2DelegateNode new.	sequence := nil asPParser, delegateTwo.		delegateOne child: delegateTwo.	delegateTwo child: delegateOne.		self should: [ firstSet := self firstSet: sequence ] raise: Error."	self assert: firstSet isEmpty"! !!PP2FirstSetVisitorTest methodsFor: 'tests - productions'!testDeepProductions	| productionTop productionOne productionTwo |	productionOne := 'foo' asPParser name: 'bar'.	productionTwo := 'bar' asPParser name: 'baz'.	productionTop := (productionOne / productionTwo) wrapped name: 'bark'.	parser := productionTop plus.		firstSet := self firstSetWithProduction: parser.	self assert: firstSet size equals: 3.	self assert: (firstSet includes: productionOne).	self assert: (firstSet includes: productionTwo).		self assert: (firstSet includes: productionTop).		! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testDelegate	| delegate  |	parser := $a asPParser. 	delegate := parser wrapped.		firstSet := self firstSet: delegate.	self assert: firstSet size equals: 1.	self assert: firstSet includes: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testEndOfInput	parser := PP2EndOfInputNode new.		firstSet := self firstSet: parser.	self assert: firstSet size equals: 1.	self assert: firstSet includes: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests - tokens'!testFirstWithTokensOneToken	| token  |	token := $a asPParser token.	parser := $b asPParser.		firstSet := self firstSetWithTokens: token / parser.		self assert: firstSet size equals: 2.	self assert: firstSet includes: token.	self assert: firstSet includes: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests - tokens'!testFirstWithTokensTwoTokens	| tokenOne tokenTwo trimmer |	trimmer := $c asPParser.	tokenOne := $a asPParser token.	tokenTwo := $b asPParser token trim: trimmer.		firstSet := self firstSetWithTokens: tokenOne / tokenTwo.		self assert: firstSet size equals: 3.	self assert: firstSet includes: tokenOne.	self assert: firstSet includes: tokenTwo child.	self assert: firstSet includes: tokenTwo trimmer.! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testFlatten	| flattened |	parser := #letter asPParser.	flattened := parser, #word asPParser star.	firstSet := self firstSet: flattened.	self assert: firstSet size equals: 1.	self assert: firstSet includes: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests - seas or terminals'!testJustSeaSoT	parser := $a asPParser sea.		firstSet := self firstSetWithSeasOrTerminals: parser.		self assert: firstSet size equals: 1.	self assert: firstSet includes: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testLiteralObject	parser := $a asPParser.	firstSet := self firstSet: parser.	self assert: firstSet size equals: 1.	self assert: firstSet includes: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testLiteralSequence	parser := 'foo' asPParser.	firstSet := self firstSet: parser.	self assert: firstSet size equals: 1.	self assert: firstSet includes: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testNonEpsilon	| terminal |	terminal := $b asPParser.	parser := terminal optional nonEpsilon.		firstSet := self firstSet: parser.		self assert: firstSet size equals: 1.	self assert: firstSet includes: terminal.! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testNonEpsilonWithoutEpsilon	| terminal |	terminal := $b asPParser.	parser := terminal nonEpsilon.		firstSet := self firstSet: parser.		self assert: firstSet size equals: 1.	self assert: firstSet includes: terminal.! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testNot	| sequence |	parser := $a asPParser not.	sequence := parser, $b asPParser.	firstSet := self firstSet: sequence.	self assert: firstSet size equals: 1.	self assert: firstSet includes: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testOptional	| optional |	parser := $a asPParser.	optional := parser optional.	firstSet := self firstSet: optional.	self assert: firstSet size equals: 2.	self assert: firstSet includes: PP2EpsilonNode instance.	self assert: firstSet includes: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests - seas or terminals'!testOptionalSeaSoT	| sea |	sea := $a asPParser sea.	parser := sea optional wrapped.		firstSet := self firstSetWithSeasOrTerminals: parser.		self assert: firstSet size equals: 2.	self assert: firstSet includes: sea! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testPluggable	parser := [:ctx | ctx next] asPParser.	firstSet := self firstSet: parser.	"JK: Not sure if it should contain epsilon or not"	self assert: firstSet size equals: 1.	self assert: firstSet includes: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testPlus	| plus |	parser := $a asPParser.	plus := parser plus.	firstSet := self firstSet: plus.	self assert: firstSet size equals: 1.	self assert: firstSet includes: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testPlusOptional	| plus |	parser := $a asPParser.	"JK: This should actually throw warning somewhere"	plus := parser optional plus.	firstSet := self firstSet: plus.	self assert: firstSet size equals: 2.	self assert: firstSet includes: PP2EpsilonNode instance.	self assert: firstSet includes: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests - seas or terminals'!testPossibleSeaSoT	| sea before |	sea := $a asPParser sea.	before := $b asPParser.	parser := before optional, sea.		firstSet := self firstSetWithSeasOrTerminals: parser.		self assert: firstSet size equals: 2.	self assert: firstSet includes: sea.	self assert: firstSet includes: before.! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testPredicateObject	parser := #letter asPParser.	firstSet := self firstSet: parser.	self assert: firstSet size equals: 1.	self assert: firstSet anyOne equals: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests - productions'!testProductions	| productionOne productionTwo |	productionOne := 'foo' asPParser name: 'bar'.	productionTwo := 'bar' asPParser name: 'baz'.	parser := productionOne / productionTwo.		firstSet := self firstSetWithProduction: parser.	self assert: firstSet size equals: 2.	self assert: (firstSet includes: productionOne).	self assert: (firstSet includes: productionTwo).	! !!PP2FirstSetVisitorTest methodsFor: 'tests - productions'!testProductionsSelf	parser := 'foo' asPParser name: 'bar'.		firstSet := self firstSetWithProduction: parser.	self assert: firstSet size equals: 1.	self assert: (firstSet includes: parser)! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testSea	| sea |	parser := $a asPParser.	sea := parser sea.	firstSet := self firstSetWithoutDuplicates: sea.		self assert: firstSet size equals: 2.	self assert: firstSet includes: parser.	self assert: firstSet includes: #any asPParser. ! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testSeaNullable	| sea |	parser := $a asPParser.	sea := parser optional sea.	firstSet := self firstSetWithoutDuplicates: sea.	self assert: firstSet size equals: 3.	self assert: firstSet includes: parser.	self assert: firstSet includes: #any asPParser.	self assert: firstSet includes: #eoi asPParser.	! !!PP2FirstSetVisitorTest methodsFor: 'tests - seas or terminals'!testSeaRepetitionSoT	| sea |	sea := $a asPParser sea.	parser := sea plus.		firstSet := self firstSetWithSeasOrTerminals: parser.		self assert: firstSet size equals: 1.	self assert: firstSet includes: sea.! !!PP2FirstSetVisitorTest methodsFor: 'tests - seas or terminals'!testSeaSoT	| sea |	sea := $a asPParser sea.	parser := sea wrapped.		firstSet := self firstSetWithSeasOrTerminals: parser.		self assert: firstSet size equals: 1.	self assert: firstSet includes: sea.! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testSeaWaterTokens	| sea waterToken tokenOne tokenTwo |	parser := $a asPParser.	tokenOne := $b asPParser.	tokenTwo := $c asPParser.	waterToken := tokenOne / tokenTwo.		sea := parser sea: waterToken.	firstSet := self firstSetWithoutDuplicates: sea.	self assert: firstSet size equals: 3.	self assert: firstSet includes: parser.	self assert: firstSet includes: tokenOne.	self assert: firstSet includes: tokenTwo.! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testSequence	| sequence |	parser := $a asPParser.	sequence := parser, $b asPParser.	 	firstSet := self firstSet: sequence.	self assert: firstSet size equals: 1.	self assert: firstSet includes: parser! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testSequenceTwoEpsilons	| sequence parserOne parserTwo |	parserOne := $a asPParser.	parserTwo := nil asPParser.	sequence := parserOne star, parserTwo.	 	firstSet := self firstSet: sequence.	self assert: firstSet size equals: 2.	self assert: firstSet includes: parserOne.	self assert: firstSet includes: parserTwo! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testSequenceTwoStars	| sequence parserOne parserTwo |	parserOne := $a asPParser.	parserTwo := $b asPParser.	sequence := parserOne star, parserTwo star.	 	firstSet := self firstSet: sequence.	self assert: firstSet size equals: 3.	self assert: firstSet includes: parserOne.	self assert: firstSet includes: parserTwo.	self assert: firstSet includes: PP2EpsilonNode instance! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testSequenceWithNil	| sequence parserOne parserTwo |	parserOne := nil asPParser.	parserTwo := $b asPParser.	sequence := parserOne, parserTwo.	 	firstSet := self firstSet: sequence.	self assert: firstSet size equals: 1.	self assert: firstSet includes: parserTwo! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testSequenceWithStar	| sequence parserOne parserTwo |	parserOne := $a asPParser.	parserTwo := $b asPParser.	sequence := parserOne star, parserTwo.	 	firstSet := self firstSet: sequence.	self assert: firstSet size equals: 2.	self assert: firstSet includes: parserOne.	self assert: firstSet includes: parserTwo! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testStar	| star |	parser := $a asPParser.	star := parser star.	firstSet := self firstSet: star.	self assert: firstSet size equals: 2.	self assert: firstSet includes: parser.	self assert: firstSet includes: PP2EpsilonNode instance! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testStartOfLine	parser := #startOfLine asPParser.	firstSet := self firstSet: parser.	self assert: firstSet size equals: 1.	self assert: firstSet includes: parser! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testToken	| token |	parser := 'foo' asPParser.	token := parser token.	firstSet := self firstSet: token.	self assert: firstSet size equals: 1.	self assert: firstSet anyOne equals: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testTrimming	| trimming |	parser := 'foo' asPParser.	trimming := parser trim.	firstSet := self firstSet: trimming.	self assert: firstSet size equals: 2.	self assert: firstSet includes: parser.	self assert: firstSet includes: trimming trimmer child.	! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testTrimmingWithEpsilon	| trimming |	parser := 'foo' asPParser.	trimming := parser optional trim.	firstSet := self firstSet: trimming.	self assert: firstSet size equals: 3.	self assert: firstSet includes: parser.	self assert: firstSet includes: trimming trimmer child.		self assert: firstSet includes: PP2EpsilonNode instance.		! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testTwoParents	| sequence |	parser := $a asPParser.	sequence := parser star, parser star.		firstSet := self firstSet: sequence.		self assert: firstSet size equals: 2.	self assert: firstSet includes: PP2EpsilonNode instance.	self assert: firstSet includes: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testWaterFirstSet	| boundary waterToken |	boundary := $b asPParser.	waterToken := $a asPParser.	parser := PP2WaterNode new boundary: boundary; waterToken: waterToken.		firstSet := self firstSet: parser.		self assert: firstSet size equals: 2.	self assert: firstSet includes: boundary.	self assert: firstSet includes: waterToken.! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testWrapping	parser := $a asPParser >=> [:c :cc | cc value].	firstSet := self firstSet: parser.	"JK: Not sure if it should contain epsilon or not"	self assert: firstSet size equals: 1.	self assert: firstSet includes: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests'!testWrappingNonFunctional	| literal |	literal := $a asPParser.	parser := literal >==> [:c :cc | cc value].	firstSet := self firstSet: parser.	"JK: Not sure if it should contain epsilon or not"	self assert: firstSet size equals: 1.	self assert: firstSet includes: literal.! !!PP2FirstSetVisitorTest methodsFor: 'accessing'!withoutDuplicates: set	| newSet |	newSet := Set new.	newSet addAll: set.	^ newSet! !!PP2GuardVisitorTest methodsFor: 'support'!assert: booleanArray at: position	self assert: (booleanArray at: position)! !!PP2GuardVisitorTest methodsFor: 'support'!deny: booleanArray at: position	self assert: (booleanArray at: position) not! !!PP2GuardVisitorTest methodsFor: 'support'!optimize: node	PP2IsNullableCache new doPass: node.	PP2FirstSetCache new doPass: node.	PP2GuardVisitor new doPass: node! !!PP2GuardVisitorTest methodsFor: 'running'!setUp	super setUp.		visitor := PP2GuardVisitor new! !!PP2GuardVisitorTest methodsFor: 'tests'!testChoice	| parserOne parserTwo |	parserOne := 'foo' asPParser token trim wrapped.	parserTwo := 'bar' asPParser token trim wrapped.		self optimize: parserOne / parserTwo.		self assert: parserOne strategy isKindOf: PP2ParsingGuard.	self assert: parserOne strategy classification notNil.		self assert: parserTwo strategy isKindOf: PP2ParsingGuard.	self assert: parserTwo strategy classification notNil.! !!PP2GuardVisitorTest methodsFor: 'tests'!testClassificationFor	| classification |	parser := $a asPParser / $b asPParser.		classification := visitor classificationFor: parser.		self assert: classification at: $a codePoint.	self assert: classification at: $b codePoint.	self deny: classification at: $" codePoint.	self deny: classification at: $c codePoint.	! !!PP2GuardVisitorTest methodsFor: 'tests'!testClassificationFor2	| classification |	parser := #letter asPParser / #digit asPParser.		classification := visitor classificationFor: parser.		1 to: 255 do: [ :index | 		self assert: (classification at: index) equals: ((Character codePoint: index )isAlphaNumeric).	]! !!PP2GuardVisitorTest methodsFor: 'tests'!testClassificationFor3	| classification |	parser := #letter asPParser / #eoi asPParser.		classification := visitor classificationFor: parser.		self assert: classification equals: (Array new: 255 withAll: true).! !!PP2GuardVisitorTest methodsFor: 'tests'!testDelegate	parser := 'foo' asPParser plus flatten wrapped.		self optimize: parser.		self assert: parser strategy isKindOf: PP2ParsingGuard.	self assert: parser strategy classification notNil.! !!PP2GuardVisitorTest methodsFor: 'tests'!testDelegateWithOptional	parser := ('foo' asPParser / 'bar' asPParser optional) wrapped.		self optimize: parser.		self assert: parser strategy isKindOf: PP2Delegate.! !!PP2GuardVisitorTest methodsFor: 'tests'!testGuardedChoice	| parserOne parserTwo parserThree choiceOne |	parserOne := 'foo' asPParser token trim wrapped.	parserTwo := 'bar' asPParser token trim wrapped.	parserThree := 'baz' asPParser token trim wrapped.		choiceOne := (parserOne / parserTwo) wrapped.		self optimize: choiceOne / parserThree.		self assert: choiceOne strategy isKindOf: PP2ParsingGuard.	self assert: choiceOne strategy classification notNil.		self assert: parserThree strategy isKindOf: PP2ParsingGuard.	self assert: parserThree strategy classification notNil.		self assert: parserOne strategy isKindOf: PP2ParsingGuard.	self assert: parserTwo strategy isKindOf: PP2ParsingGuard.! !!PP2GuardVisitorTest methodsFor: 'tests'!testGuardedChoice2	| parserOne parserTwo parserThree choiceOne |	parserOne := 'baz' asPParser token trim wrapped.	parserTwo := 'bar' asPParser token trim wrapped.	parserThree := 'foo' asPParser token trim wrapped.		choiceOne := (parserOne / parserTwo) wrapped.	parser := choiceOne / parserThree.	self optimize: parser.		self assert: choiceOne strategy isKindOf: PP2ParsingGuard.	self assert: choiceOne strategy classification notNil.		self assert: parserThree strategy isKindOf: PP2ParsingGuard.	self assert: parserThree strategy classification notNil.		"already guarded by a parent!!"	self deny: parserOne strategy isKindOf: PP2ParsingGuard.	self deny: parserTwo strategy isKindOf: PP2ParsingGuard.! !!PP2GuardVisitorTest methodsFor: 'tests'!testOptional	parser := 'foo' asPParser token trim optional.		self optimize: parser.		self assert: parser strategy isKindOf: PP2ParsingGuard.	self assert: parser strategy retval isNil.! !!PP2GuardVisitorTest methodsFor: 'tests'!testPlus	parser := 'foo' asPParser token trim plus.	parser strategy: (PP2Plus on: parser).		self optimize: parser.		self assert: parser strategy isKindOf: PP2ParsingGuard.	self assert: parser strategy retval isPetit2Failure.! !!PP2GuardVisitorTest methodsFor: 'tests'!testStar	parser := 'foo' asPParser token trim star.	parser strategy: (PP2Star on: parser).		self optimize: parser.		self assert: parser strategy isKindOf: PP2ParsingGuard.	self assert: parser strategy retval equals: #().! !!PP2GuardVisitorTest methodsFor: 'tests'!testTimes	parser := 'foo' asPParser token trim times: 3.		self optimize: parser.		self assert: parser strategy isKindOf: PP2ParsingGuard.	self assert: parser strategy classification notNil.	self assert: parser strategy retval isPetit2Failure! !!PP2InMemoryContextTest methodsFor: 'requirements'!contextOn: aString	^ PP2InMemoryContext on: aString! !!PP2InMemoryContextTest methodsFor: 'tests - converting'!testAsPetit2Context	| context |	context := 'foo' asPetit2Stream asPetit2Context.		self assert: (context isKindOf: PP2InMemoryContext).	self assert: context isPetit2Success.! !!PP2InMemoryContextTest methodsFor: 'tests - converting'!testAsPetit2ContextDirect	| context |	context := 'foo' asPetit2Context.	self assert: context isKindOf: PP2InMemoryContext.	self assert: context start equals: 0.	self assert: context readLimit equals: 3! !!PP2InMemoryContextTest methodsFor: 'tests - converting'!testAsPositionableStream	| stream context |		context := 'bar' asPetit2Stream asPetit2Context.	context position: 2.	stream := context asPositionableStream.		self assert: (stream isKindOf: PositionableStream).	self assert: stream position equals: 2.	self assert: stream peek equals: $r.! !!PP2InMemoryContextTest methodsFor: 'tests'!testCopy	| stream newContext context |	stream := 'foo' asPetit2Stream.		context := PP2InMemoryContext new		stream: stream; 		position: 1;		parser: #parser;		startMemento: #startMemento;		yourself.			newContext := context copy.		self deny: context == newContext.	self assert: context position = newContext position.	self assert: context contents = newContext contents.		self assert: context parser = newContext parser.	self assert: context startMemento = newContext startMemento.! !!PP2IsNullableCacheTest methodsFor: 'tests'!testSanity	| parser |	parser := ((($f asPParser, 'oo' asPParser) wrapped not ==> [ :e | e ]) star / 				   (nil asPParser, '' asPParser)) end.	PP2IsNullableCache new doPass: parser.		self assert: (parser allNodes allSatisfy: [ :child | child hasProperty: #isNullable ])! !!PP2IsNullableVisitorTest methodsFor: 'support'!assertIsNullable: node	| retval |	retval := visitor visit: node.	self assert: retval! !!PP2IsNullableVisitorTest methodsFor: 'support'!denyIsNullable: node	| retval |	retval := visitor visit: node.	self assert: retval not! !!PP2IsNullableVisitorTest methodsFor: 'running'!setUp	super setUp.		visitor := PP2IsNullableVisitor new! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testAction	self denyIsNullable: #letter asPParser ==> [ :foo | foo ].! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testActionEmpty	self assertIsNullable: nil asPParser ==> [ :foo | foo ].	! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testAdaptable	parser := PP2AdaptableNode new.	parser changeChild: $a asPParser.	self denyIsNullable: parser! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testAdaptableEpsilon	parser := PP2AdaptableNode new.	parser changeChild: nil asPParser.	self denyIsNullable: parser! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testAnd	self denyIsNullable: #letter asPParser and! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testBlock	| block |	block := [ :context | context next ] asPParser.	self denyIsNullable: block.! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testBlockAcceptsEpsilon	| block |	block := [ :context | context next ] asPParser					isNullable: true;					yourself.	self assertIsNullable: block.! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testCycle	| delegateOne delegateTwo sequence |	delegateOne := PP2DelegateNode new.	delegateTwo := PP2DelegateNode new.	sequence := nil asPParser, delegateTwo.		delegateOne child: delegateTwo.	delegateTwo child: delegateOne.		self should: [ self assertIsNullable: sequence ] raise: Error! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testCycleNoRecursion	| delegateOne delegateTwo sequence |	delegateOne := PP2DelegateNode new.	delegateTwo := PP2DelegateNode new.	sequence := $a asPParser, delegateTwo.		delegateOne child: delegateTwo.	delegateTwo child: delegateOne.		self denyIsNullable: sequence! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testEmptyLiteral	self assertIsNullable: '' asPParser! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testEnd	self denyIsNullable: 'foo' asPParser end! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testEndEmpty	self assertIsNullable: nil asPParser end! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testEndOfInput	self denyIsNullable: PP2EndOfInputNode new! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testLiteral	self denyIsNullable: 'foo' asPParser! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testLiteralObject	self denyIsNullable: $a asPParser.! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testNil	self assertIsNullable: nil asPParser optional.! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testNot	self denyIsNullable: #letter asPParser not! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testOptional	self assertIsNullable: #letter asPParser optional.! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testPluggable	self denyIsNullable: [:ctx | ctx] asPParser.! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testPlus	self denyIsNullable: #letter asPParser plus.! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testPlusEplsilon	self assertIsNullable: nil asPParser plus.! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testPredicate	self denyIsNullable: #letter asPParser.! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testPredicateObject	self denyIsNullable: #letter asPParser.! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testPredicateObjectAny	self denyIsNullable: #any asPParser.! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testSequence	self denyIsNullable: #letter asPParser, #word asPParser! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testSequenceEmpty	self assertIsNullable: #letter asPParser optional, nil asPParser! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testSequenceFirstEpsilon	self denyIsNullable: #letter asPParser optional, #word asPParser! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testStar	self assertIsNullable: #letter asPParser star.! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testStartOfLine	self denyIsNullable: #startOfLine asPParser! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testWater	self denyIsNullable: (PP2WaterNode new boundary: nil asPParser).	self denyIsNullable: (PP2WaterNode new boundary: $a asPParser).! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testWrapping	parser := $a asPParser >=> [ :c :cc | cc value ].	self denyIsNullable: parser! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testWrappingAcceptsEpsilon	| wrapped |	wrapped := $a asPParser >=> [ :context :cc |  ]		isNullable: true;		yourself.		self assertIsNullable: wrapped! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testWrappingNonFunctional	parser := $a asPParser >==> [:c :cc | cc value].	self denyIsNullable: parser! !!PP2IsNullableVisitorTest methodsFor: 'tests'!testWrappingNonFunctionalEpsilon	parser := nil asPParser >==> [:c :cc | cc value].	self assertIsNullable: parser! !!PP2NextSetsContextTest methodsFor: 'as yet unclassified'!setUp	o1 := Object new.	o2 := Object new.	o3 := Object new.		context1 := PP2NextSetsContext new.	context2 := PP2NextSetsContext new.! !!PP2NextSetsContextTest methodsFor: 'as yet unclassified'!testEqual	context1 currentNext: (IdentitySet with: o1 with: o2).	context2 currentNext: (IdentitySet with: o2 with: o1).		self deny: context1 == context2.	self assert: context1 = context2.! !!PP2NextSetsContextTest methodsFor: 'as yet unclassified'!testEqualNot	context1 currentNext: (IdentitySet with: o1 with: o2).	context2 currentNext: (IdentitySet with: o2 with: o3).		self deny: context1 == context2.	self deny: context1 = context2.! !!PP2NextSetsContextTest methodsFor: 'as yet unclassified'!testHash	context1 currentNext: (IdentitySet with: o1 with: o2).	context2 currentNext: (IdentitySet with: o2 with: o1).		self assert: context1 hash equals: context2 hash. ! !!PP2NextSetsContextTest methodsFor: 'as yet unclassified'!testHashNotEqual	context1 currentNext: (IdentitySet with: o1 with: o2).	context2 currentNext: (IdentitySet with: o2 with: o1 with: o3).		self deny: context1 hash = context2 hash. ! !!PP2NextSetsVisitorTest methodsFor: 'accessing'!assert: aSet includes: anObject	self assert: (aSet includes: anObject)! !!PP2NextSetsVisitorTest methodsFor: 'accessing'!nextSet: node in: root	visitor visit: root.	^ nextSet := visitor nextSets at: node! !!PP2NextSetsVisitorTest methodsFor: 'accessing'!setUp	visitor := PP2NextSetsVisitor new.	eoi := visitor instVarNamed: #eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing'!testAction	| action |	parser := $a asPParser.	action := parser ==> [:e | e].		self nextSet: parser in: action.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.		self nextSet: action in: action.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing'!testChoice	| choice |	parser := $a asPParser.	choice := parser / parser wrapped.		self nextSet: parser in: choice.		self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing'!testDelegate	| delegate |	parser := $a asPParser.	delegate := parser wrapped.		self nextSet: parser in: delegate.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.		self nextSet: delegate in: delegate.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing'!testEpsilon	parser := nil asPParser.		self nextSet: parser in: parser.		self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing'!testFlatten	| flatten |	parser := $a asPParser.	flatten := parser flatten.		self nextSet: parser in: flatten.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.		self nextSet: flatten in: flatten.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing'!testLiteralObject	parser := $a asPParser.		self nextSet: parser in: parser.		self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing'!testLiteralSequence	parser := 'foo' asPParser.		self nextSet: parser in: parser.		self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing'!testOptional	| optional |	parser := $a asPParser.	optional := parser optional.		self nextSet: parser in: optional.		self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing'!testPossesiveRepeating	| plus |	parser := $a asPParser.	plus := parser plus.		self nextSet: parser in: plus.	self assert: nextSet size equals: 2.	self assert: nextSet includes: eoi.		self nextSet: plus in: plus.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing'!testRoot	parser := $a asPParser.		self nextSet: parser in: parser.		self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing'!testSequence	| sequence |	parser := $a asPParser.	nextParser := $b asPParser.		sequence := parser, nextParser.		self nextSet: parser in: sequence.	self assert: nextSet size equals: 1.	self assert: nextSet includes: nextParser.	self nextSet: nextParser in: sequence.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.			self nextSet: sequence in: sequence.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing'!testSequenceOfDelegates	| sequence |	parser := $a asPParser.	nextParser := $b asPParser wrapped.		sequence := parser wrapped, nextParser.		self nextSet: parser in: sequence.	self assert: nextSet size equals: 1.	self assert: nextSet includes: nextParser.		self nextSet: nextParser in: sequence.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.		self nextSet: sequence in: sequence.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing'!testSequenceOfThree	| sequence nextNextParser |	parser := $a asPParser.	nextParser := $b asPParser.	nextNextParser := $c asPParser.		sequence := parser, nextParser, nextNextParser.		self nextSet: parser in: sequence.	self assert: nextSet size equals: 1.	self assert: nextSet includes: nextParser.		self nextSet: nextParser in: sequence.	self assert: nextSet size equals: 1.	self assert: nextSet includes: nextNextParser.		self nextSet: nextNextParser in: sequence.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.		self nextSet: sequence in: sequence.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing'!testSequenceOfThreeWithNullable	| sequence nextNextParser |	parser := $a asPParser.	nextParser := $b asPParser optional.	nextNextParser := $c asPParser.		sequence := parser, nextParser, nextNextParser.		self nextSet: parser in: sequence.	self assert: nextSet size equals: 2.	self assert: nextSet includes: nextParser.	self assert: nextSet includes: nextNextParser.		self nextSet: nextParser in: sequence.	self assert: nextSet size equals: 1.	self assert: nextSet includes: nextNextParser.		self nextSet: nextNextParser in: sequence.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.		self nextSet: sequence in: sequence.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing'!testSequenceOptional	| sequence |	parser := $a asPParser.	nextParser := $b asPParser optional.		sequence := parser, nextParser.		self nextSet: parser in: sequence.		self assert: nextSet size equals: 2.	self assert: nextSet includes: nextParser.	self assert: nextSet includes: eoi.			self nextSet: sequence in: sequence.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing'!testToken	| token |	parser := $a asPParser.	token := parser token.		self nextSet: parser in: token.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.		self nextSet: token in: token.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing'!testTrim	| trim |	parser := $a asPParser.	trim := parser trim.		self nextSet: parser in: trim.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.		self nextSet: trim in: trim.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing'!testTrimmingToken	| token |	parser := $a asPParser.	token := parser token trim.		self nextSet: parser in: token.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.		self nextSet: token in: token.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NodeCopyTest methodsFor: 'tests'!testCopy	| node nodeCopy |	node := $a asPParser.		nodeCopy := node copy.		self assert: node equals: nodeCopy.	self assert: node ~~ nodeCopy.		self assert: node strategy node == node.	self assert: nodeCopy strategy node == nodeCopy.! !!PP2NodeCopyTest methodsFor: 'tests'!testCopyDelegate	| node nodeCopy |	node := $a asPParser wrapped.		nodeCopy := node copy.		self assert: node equals: nodeCopy.	self assert: node ~~ nodeCopy.		self assert: node child == nodeCopy child.! !!PP2NodeCopyTest methodsFor: 'tests'!testCopyProperties	| node nodeCopy |	node := $a asPParser.	node propertyAt: #foo put: #bar.		nodeCopy := node copy.		self assert: node equals: nodeCopy.	self assert: node properties equals: nodeCopy properties.	self assert: node properties ~~ nodeCopy properties.! !!PP2NodeCopyTest methodsFor: 'tests'!testDuplicateDelegate	| node nodeCopy |	node := $a asPParser wrapped.		nodeCopy := node duplicate.		self assert: node equals: nodeCopy.	self assert: node ~~ nodeCopy.		self assert: node child equals: nodeCopy child.	self assert: node child ~~ nodeCopy child.	! !!PP2NodeCopyTest methodsFor: 'tests'!testDuplicateSequence	| node nodeCopy |	node := $a asPParser, $b asPParser.		nodeCopy := node duplicate.		self assert: node equals: nodeCopy.	self assert: node ~~ nodeCopy.		self assert: node firstChild ~~ nodeCopy firstChild.	self assert: node secondChild ~~ nodeCopy secondChild.	! !!PP2NodeDebugTest methodsFor: 'tests'!testEnableDebug	parser := PP2ExpressionGrammar new.	parser enableDebug.		self assert: parser allNodes allSatisfy: [ :node | node strategies size = 2 ].	self assert: parser allNodes allSatisfy: [ :node |  node strategies first isDebugging ].	self assert: parser allNodes noneSatisfy: [ :node |  node strategies second isDebugging ]	! !!PP2NodeDebugTest methodsFor: 'tests'!testEnableDebugAndRecordingTwice	parser := PP2ExpressionGrammar new.	parser enableDebug.	parser enableRecording.	parser enableDebug.	parser enableRecording.		self assert: parser allNodes allSatisfy: [ :node | node strategies size = 2 ].	self assert: parser allNodes allSatisfy: [ :node |  node strategies first isDebugging ].	self assert: parser allNodes allSatisfy: [ :node |  node strategies first isRecording ].	self assert: parser allNodes noneSatisfy: [ :node |  node strategies second isDebugging ]	.! !!PP2NodeDebugTest methodsFor: 'tests'!testEnableDebugAndRecordingTwiceOptimized	| strategies |	parser := PP2ExpressionGrammar new.	parser optimize.	parser enableDebug.	parser enableRecording.		strategies := IdentityDictionary new.	parser allNodesDo: [ :node | strategies at: node put: node strategies ].		parser enableDebug.	parser enableRecording.		parser allNodesDo: [ :node | 		self assert: (strategies at: node) equals: node strategies.	]! !!PP2NodeDebugTest methodsFor: 'tests'!testEnableDebugTwice	parser := PP2ExpressionGrammar new.	parser enableDebug.	parser enableDebug.		self assert: parser allNodes allSatisfy: [ :node | node strategies size = 2 ].	self assert: parser allNodes allSatisfy: [ :node |  node strategies first isDebugging ].	self assert: parser allNodes noneSatisfy: [ :node |  node strategies second isDebugging ]	! !!PP2NodeDebugTest methodsFor: 'tests'!testEnableRecordingCaches	parser := PP2ExpressionGrammar new.	parser optimize.		parser enableRecording.		self deny: parser collectCaches isEmpty.	self assert: parser collectCaches allSatisfy: [ :c | c isRecording ].! !!PP2NodeDebugTest methodsFor: 'tests'!testEnableRecordingDebugInvocations	parser := PP2ExpressionGrammar new.	parser optimize.		parser enableDebug.	parser enableRecording.		self assert: parser allNodes allSatisfy: [ :n | n strategy isRecording ].! !!PP2NodeDebugTest methodsFor: 'tests'!testEnableRecordingInvocations	parser := PP2ExpressionGrammar new.	parser optimize.		parser enableRecording.		self flag: 'JK: Does not work right now, should implement?'"	self assert: parser allNodes allSatisfy: [ :n | n strategy isRecording ]."! !!PP2NodeDebugTest methodsFor: 'tests'!testEnableRecordingRefreshCaches	parser := PP2ExpressionGrammar new.	parser optimize.		parser enableRecording.		self deny: parser collectCaches isEmpty.	self assert: parser allCaches equals: parser collectCaches.! !!PP2NodeEqualityTest methodsFor: 'support'!deny: anObject equals: anotherObject	self assert: (anObject = anotherObject) not! !!PP2NodeEqualityTest methodsFor: 'tests'!testCycle	parserOne := PP2DelegateNode new.	parserTwo := PP2DelegateNode new.		parserOne child: parserTwo.	parserTwo child: parserOne.		self deny:  parserOne == parserTwo.	self assert: parserOne equals: parserTwo.		self assert: parserOne hash equals: parserTwo hash.! !!PP2NodeEqualityTest methodsFor: 'tests'!testPossesiveRepeating	parserOne := #space asPParser star.	parserTwo := #space asPParser star.		self deny:  	 parserOne == parserTwo.	self assert: parserOne equals: parserTwo.		self assert: parserOne hash equals: parserTwo hash.! !!PP2NodeEqualityTest methodsFor: 'tests'!testPossesiveRepeatingDifferent	parserOne := #space asPParser star.	parserTwo := #space asPParser plus.		self deny: parserOne == parserTwo.	self deny: parserOne equals: parserTwo.		self deny: parserOne hash equals: parserTwo hash.! !!PP2NodeEqualityTest methodsFor: 'tests'!testPossesiveRepeatingDifferent2	parserOne := #space asPParser star.	parserTwo := #blank asPParser star.		self deny: parserOne == parserTwo.	self deny: parserOne equals: parserTwo.		self deny: parserOne hash equals: parserTwo hash.! !!PP2NodeEqualityTest methodsFor: 'tests'!testPredicateObject	parserOne := #space asPParser.	parserTwo := #space asPParser.		self deny:   parserOne == parserTwo.	self assert: parserOne equals: parserTwo.		self assert: parserOne hash equals: parserTwo hash.! !!PP2NodeEqualityTest methodsFor: 'tests'!testSequence	parserOne := $a asPParser, #word asPParser.	parserTwo := $a asPParser, #word asPParser.		self deny:   parserOne == parserTwo.	self assert: parserOne equals: parserTwo.		self assert: parserOne hash equals: parserTwo hash.! !!PP2NodeTransformationTest methodsFor: 'tests'!testDelegateReplace	| one other delegate |	one := $a asPParser.	other := $b asPParser.		delegate := one token.	self assert: delegate children first == one.	self deny: delegate children first == other.		delegate replace: other with: one.	self assert: delegate children first == one.	self deny: delegate children first == other.		delegate replace: one with: other.	self deny: delegate children first == one.	self assert: delegate children first == other! !!PP2NodeTransformationTest methodsFor: 'tests'!testListReplace	| one other another list |	one := $a asPParser.	other := $b asPParser.	another := $c asPParser.	list := one , another , one.	self assert: list children first == one.	self assert: list children second == another.	self assert: list children last == one.		list replace: other with: one.	self assert: list children first == one.	self assert: list children second == another.	self assert: list children last == one.		list replace: one with: other.	self assert: list children first == other.	self assert: list children second == another.	self assert: list children last == other.		list replace: another with: one.	self assert: list children first == other.	self assert: list children second == one.	self assert: list children last == other! !!PP2NodeTransformationTest methodsFor: 'tests'!testSeaReplace	| island sea beforeWater afterWater otherIsland otherBeforeWater otherAfterWater |	island := $a asPParser.	sea := island sea.	beforeWater := sea beforeWater.	afterWater := sea afterWater.		otherIsland := $b asPParser.	otherBeforeWater := $c asPParser.	otherAfterWater := $d asPParser.			self assert: sea children first == beforeWater.	self assert: sea children second == island.	self assert: sea children third == afterWater.		sea replace: island with: otherIsland.	self assert: sea children second == otherIsland.	self assert: sea children first == beforeWater.	self assert: sea children third == afterWater.		sea replace: beforeWater  with: otherBeforeWater.	self assert: sea children first == otherBeforeWater.		sea replace: afterWater  with: otherAfterWater.	self assert: sea children third == otherAfterWater.! !!PP2NodeTransformationTest methodsFor: 'tests'!testTrimmingReplace	| one trimmer trimming other otherTrimmer |	one := $a asPParser.	trimmer := $b asPParser.		other := $c asPParser.	otherTrimmer := $d asPParser.		trimming := one trim: trimmer.	self assert: trimming children first == trimmer.	self assert: trimming children second == one.	self deny: trimming children first == otherTrimmer.	self deny: trimming children second == other.		trimming replace: trimmer with: otherTrimmer.	self assert: trimming children first == otherTrimmer.	self assert: trimming children second == one.		trimming replace: one with: other.	self assert: trimming children second == other! !!PP2NoopVisitorTest methodsFor: 'as yet unclassified'!setUp	super setUp.		visitor := PP2MockNoopVisitor new! !!PP2NoopVisitorTest methodsFor: 'tests'!testVisitCharacter	parser := $a asPParser.	result := visitor visit: parser.		self assert: result equals: visitor! !!PP2NoopVisitorTest methodsFor: 'as yet unclassified'!testVisitCycle	| delegate |	delegate := PP2DelegateNode new.	parser := delegate, delegate.	delegate child: parser.		result := visitor visit: parser.		self assert: result equals: visitor.		self assert: (visitor closedSet includes: (PP2NoopContext with: parser)). 	self assert: (visitor closedSet includes: (PP2NoopContext with: delegate)). 	self assert: (visitor openSet isEmpty). 			self assert: visitor visitOrder size equals: 2.	self assert: visitor visitOrder first equals: parser.	self assert: visitor visitOrder second equals: delegate.! !!PP2NoopVisitorTest methodsFor: 'as yet unclassified'!testVisitDelegate	parser := $a asPParser wrapped.	result := visitor visit: parser.		self assert: result equals: visitor! !!PP2NoopVisitorTest methodsFor: 'as yet unclassified'!testVisitSequence	parser := $a asPParser, $b asPParser.	result := visitor visit: parser.		self assert: result equals: visitor! !!PP2OptimizationIntegrationTest methodsFor: 'tests'!testAnyStarLazyLiteralObject	parser := #any asPParser starLazy, $a asPParser.		parser optimize.		self assert: parser firstChild strategy isKindOf: PP2AnyStarLazyLiteralObject.! !!PP2OptimizationIntegrationTest methodsFor: 'tests'!testAnyStarLazyPredicateObject	parser := #any asPParser starLazy, #word asPParser.		parser optimize.		self assert: parser firstChild strategy isKindOf: PP2AnyStarLazyPredicateObject.! !!PP2OptimizationIntegrationTest methodsFor: 'tests'!testBypass	parser := #letter asPParser wrapped star optimize.		self assert: parser strategy child isKindOf: PP2PredicateObjectNode! !!PP2OptimizationIntegrationTest methodsFor: 'tests'!testCommonPrefix	| prefixOne prefixTwo |	prefixOne := #letter asPParser star wrapped flatten name: 'id'.	prefixTwo := #letter asPParser star wrapped flatten name: 'id'.		parser := (prefixOne token trim) / ((prefixTwo, $a asPParser) token trim).		parser optimize.		self assert: prefixOne strategy isKindOf: PP2Cache.	self assert: prefixTwo strategy isKindOf: PP2Cache.		self assert: prefixOne strategy == prefixTwo strategy.! !!PP2OptimizationIntegrationTest methodsFor: 'tests'!testIdentifier	parser := #letter asPParser, #word asPParser star.		parser optimize.		self assert: parser strategy isKindOf: PP2SequenceOfTwo.	self assert: parser secondChild strategy isKindOf: PP2StarPredicateObject.! !!PP2OptimizationIntegrationTest methodsFor: 'tests'!testIdentifierToken	parser := (#letter asPParser, #word asPParser star) token.		parser optimize.		self assert: parser child strategy isKindOf: PP2SequenceOfTwoRecognizer.	self assert: parser child secondChild strategy isKindOf: PP2StarPredicateObjectRecognizer.! !!PP2OptimizationIntegrationTest methodsFor: 'tests'!testIdentifierTrimmingToken	parser := (#letter asPParser, #word asPParser star) token trim.		parser optimize.		self assert: parser strategy isKindOf: PP2TrimmingToken.	self assert: parser strategy tokenChild strategy isKindOf: PP2SequenceOfTwoRecognizer.	self assert: parser strategy tokenChild firstChild strategy isKindOf: PP2PredicateObjectRecognizer.	self assert: parser strategy tokenChild secondChild strategy isKindOf: PP2StarPredicateObjectRecognizer.! !!PP2OptimizationIntegrationTest methodsFor: 'tests'!testMemoization	| id |	id := #any asPParser, #word asPParser star.	id memoize.		parser := id / id optional.	parser optimize.		self assert: id strategy isKindOf: PP2Packrat.! !!PP2OptimizationIntegrationTest methodsFor: 'tests'!testStarInToken	parser := 'ab' asPParser star token.		parser optimize.		self assert: parser child strategy isKindOf: PP2StarRecognizer.! !!PP2OptimizationIntegrationTest methodsFor: 'tests'!testTrimming	parser := #letter asPParser trim optimize.		self assert: parser trimmer strategy isKindOf: PP2TrimmingCache.	self assert: parser trimmer strategy strategy isKindOf: PP2StarPredicateObjectRecognizer.! !!PP2OptimizationIntegrationTest methodsFor: 'tests'!testTrimmingToken	parser := #letter asPParser trim optimize.		self assert: parser trimmer strategy isKindOf: PP2TrimmingCache.	self assert: parser trimmer strategy strategy isKindOf: PP2StarPredicateObjectRecognizer.! !!PP2PackratVisitorTest methodsFor: 'asserting'!assertMemoized: node	visitor visit: node.		self assert: (node isMemoized).! !!PP2PackratVisitorTest methodsFor: 'asserting'!denyMemoized: node	visitor visit: node.		self deny: (node isMemoized).! !!PP2PackratVisitorTest methodsFor: 'running'!setUp	visitor := PP2PackratVisitor new! !!PP2PackratVisitorTest methodsFor: 'tests'!testMemoize	parser := $a asPParser memoize.		self assertMemoized: parser.! !!PP2PackratVisitorTest methodsFor: 'tests'!testMemoizeMatch	parser := $a asPParser match memoize.		self assertMemoized: parser.! !!PP2PackratVisitorTest methodsFor: 'tests'!testMemoizeMemoized	parser := $a asPParser memoize memoize.		self assertMemoized: parser.	self assert: parser strategies size equals: 2.! !!PP2PackratVisitorTest methodsFor: 'tests'!testMemoizePop	parser := $a asPParser pop memoize.		self denyMemoized: parser.	self assert: parser warnings size equals: 1.! !!PP2PackratVisitorTest methodsFor: 'tests'!testMemoizePush	parser := $a asPParser push memoize.		self denyMemoized: parser.	self assert: parser warnings size equals: 1.! !!PP2ParentAnalysisVisitorTest methodsFor: 'support'!assert: aCollection includes: anObject	self assert: (aCollection includes: anObject) ! !!PP2ParentAnalysisVisitorTest methodsFor: 'running'!setUp	visitor := PP2ParentAnalysisVisitor new! !!PP2ParentAnalysisVisitorTest methodsFor: 'tests'!testCycle	|  delegateOne delegateTwo |	delegateOne := PP2DelegateNode new.	delegateTwo := PP2DelegateNode new.	delegateOne child: delegateTwo.	delegateTwo child: delegateOne.		visitor visit: delegateOne.		self assert: delegateOne parents size equals: 1.	self assert: delegateOne parents includes: delegateTwo.	self assert: delegateTwo parents size equals: 1.	self assert: delegateTwo parents includes: delegateOne.		! !!PP2ParentAnalysisVisitorTest methodsFor: 'tests'!testDeepParent	| superParent |	parser := $a asPParser.	parent := parser wrapped.	superParent := parent wrapped.		visitor visit: superParent.		self assert: parser parents anyOne equals: parent.	self assert: parent parents anyOne equals: superParent.	self assert: superParent parents isEmpty.! !!PP2ParentAnalysisVisitorTest methodsFor: 'tests'!testMultipleParents	| parentOne parentTwo superParent |	parser := $a asPParser.	parentOne := parser wrapped.	parentTwo := parser star.	superParent := parentOne, parentTwo.		visitor visit: superParent.		self assert: parser parents size equals: 2.	self assert: parser parents includes: parentOne.	self assert: parser parents includes: parentTwo.		! !!PP2ParentAnalysisVisitorTest methodsFor: 'tests'!testNoParent	parser := $a asPParser.		visitor visit: parser.		self assert: parser parents isEmpty.! !!PP2ParentAnalysisVisitorTest methodsFor: 'tests'!testParent	parser := $a asPParser.	parent := parser wrapped.		visitor visit: parent.		self assert: parser parents size equals: 1.	self assert: parent parents isEmpty.	self assert: parser parents includes: parent.! !!PP2ParentAnalysisVisitorTest methodsFor: 'tests'!testParentOfSequence	| parserOne parserTwo |	parserOne := $a asPParser.	parserTwo := $b asPParser.	parent := parserOne, parserTwo.		visitor visit: parent.		self assert: parserOne parents size equals: 1.	self assert: parserOne parents includes: parent.	self assert: parserTwo parents size equals: 1.	self assert: parserTwo parents includes: parent.	self assert: parent parents isEmpty.! !!PP2ParsingGuardTest methodsFor: 'as yet unclassified'!guardOn: parser	| guard |	guard := PP2ParsingGuard on: parser.	guard classification: (Array new: 255 withAll: true).	guard retval: (PP2Failure message: 'ooups').	^ guard! !!PP2ParsingGuardTest methodsFor: 'as yet unclassified'!testParseOn	| parser context guard |	parser := #letter asPParser.	guard := self guardOn: parser.	context := 'a' asPetit2Stream asPetit2Context.			self assert: (guard parseOn: context) isPetit2Success! !!PP2ParsingGuardTest methodsFor: 'as yet unclassified'!testParseOnFailure	| parser context guard |	parser := #letter asPParser.	guard := self guardOn: parser.	context := '1' asPetit2Stream asPetit2Context.		self assert: (guard parseOn: context) isPetit2Failure! !!PP2ParsingGuardTest methodsFor: 'as yet unclassified'!testParseOnUnicode	| parser context guard |	parser := #letter asPParser.	guard := self guardOn: parser.	context := 'α' asPetit2Stream asPetit2Context.		self assert: (guard parseOn: context) isPetit2Success.! !!PP2RecognizerVisitorTest methodsFor: 'running'!setUp	visitor := PP2RecognizerVisitor new! !!PP2RecognizerVisitorTest methodsFor: 'tests'!testFlatten	| flattened |	parser := #letter asPParser star.	parser strategy: (PP2StarPredicateObject on: parser).	flattened := parser flatten.		self visit: flattened.		self assert: parser strategy isKindOf: PP2StarPredicateObjectRecognizer ! !!PP2RecognizerVisitorTest methodsFor: 'tests'!testPlus	parser := #letter asPParser plus.	parser strategy: (PP2Plus on: parser).	token := parser token.		self visit: token.		self assert: parser strategy isKindOf: PP2PlusRecognizer   ! !!PP2RecognizerVisitorTest methodsFor: 'tests'!testPredicateObject	parser := #letter asPParser.	token := parser token.		self visit: token.		self assert: parser strategy isKindOf: PP2PredicateObjectRecognizer  ! !!PP2RecognizerVisitorTest methodsFor: 'tests'!testSequenceOfTwo	parser := $a asPParser, $b asPParser.	parser strategy: (PP2SequenceOfTwo on: parser).	token := parser token.		self visit: token.		self assert: parser strategy isKindOf: PP2SequenceOfTwoRecognizer ! !!PP2RecognizerVisitorTest methodsFor: 'tests'!testStar	parser := #letter asPParser star.	parser strategy: (PP2Star on: parser).	token := parser token.		self visit: token.		self assert: parser strategy isKindOf: PP2StarRecognizer    ! !!PP2RecognizerVisitorTest methodsFor: 'tests'!testToken	parser := #letter asPParser star.	parser strategy: (PP2StarPredicateObject on: parser).	token := parser token.		self visit: token.		self assert: parser strategy isKindOf: PP2StarPredicateObjectRecognizer ! !!PP2RecognizerVisitorTest methodsFor: 'tests'!testTwoParents	parser := #letter asPParser star.	parser strategy: (PP2StarPredicateObject on: parser).	token := parser token.	sequence := token, parser.		self visit: sequence.		self assert: parser warnings size equals: 1.	self assert: parser strategy isKindOf: PP2StarPredicateObject.! !!PP2RecognizerVisitorTest methodsFor: 'tests'!testTwoParentsDifferentContext	| wrapped |	parser := #letter asPParser star.	parser strategy: (PP2StarPredicateObject on: parser).	wrapped := parser wrapped.	token := wrapped token.	sequence := wrapped, token.		self visit: sequence.		self assert: parser warnings size equals: 1.	self assert: parser strategy isKindOf: PP2StarPredicateObject.! !!PP2RecognizerVisitorTest methodsFor: 'tests'!testTwoParentsNoWarning	| tokenOne tokenTwo |	parser := #letter asPParser star.	parser strategy: (PP2StarPredicateObject on: parser).	tokenOne := parser token.	tokenTwo := parser token.	sequence := tokenOne, tokenTwo.		self visit: sequence.		self assert: parser warnings isEmpty.	self assert: parser strategy isKindOf: PP2StarPredicateObjectRecognizer.! !!PP2RecognizerVisitorTest methodsFor: 'support'!visit: node	visitor doPass: node! !!PP2RecordingCacheTest methodsFor: 'tests'!testInvocations	| cachedParser parser result |	cachedParser := $a asPParser star.	cachedParser strategy: cachedParser strategy cache recording.		parser := cachedParser and, cachedParser.		result := parser parse: 'aaa' withContext: PP2RecordingContext new.		self assert: result isPetit2Success.	self assert: cachedParser strategy invocations equals: 2.	self assert: cachedParser strategy hits equals: 1.	! !!PP2RecordingContextTest methodsFor: 'requirements'!contextOn: aString	^ PP2RecordingContext on: aString! !!PP2RecordingContextTest methodsFor: 'tests - profiling'!testAsFrequencyTable	| parser context table |	parser := PP2ExpressionParser new optimize enableDebug.	context := self contextOn: '1+2'.		parser parseWithContext: context.		table := context asFrequencyTable.	self assert: (table collect: #first) noneSatisfy: [ :e | e isNil ].	self assert: (table collect: #second) allSatisfy: [ :e | e isNumber ].	self assert: (table collect: #third) allSatisfy: [ :e | e isNumber ].		"This comes from the parseAdaptableWithContext, when remember is called"	self assert: (context eventsTrace strategies) anySatisfy: [ :e | e isKindOf: PP2NilStrategy  ]! !!PP2RecordingContextTest methodsFor: 'tests - debugging'!testDebugResultDebug	| context parser resultContext |	context := PP2RecordingContext new.		parser := 'foo' asPParser star.	resultContext := parser debug: 'foofoofoo' withContext: context.		self assert: resultContext returnValue isPetit2Success.	self assert: context debugResult isNil not.	self assert: context debugResult children size equals: 1.! !!PP2RecordingContextTest methodsFor: 'tests - debugging'!testDebugResultNoDebug	| context parser resultContext |	context := PP2RecordingContext new.		parser := 'foo' asPParser star.	resultContext := parser parse: 'foofoofoo' withContext: context.		self assert: resultContext returnValue isPetit2Success.	self assert: context debugResult isNil not.	self assert: context debugResult children size equals: 1.! !!PP2RecordingContextTest methodsFor: 'tests - profiling'!testMultipleProfilingStrategies	| cache parser context debugging |	parser := #letter asPParser.	cache := parser strategy cache.	debugging := PP2DebuggingStrategy on: cache.	parser strategy: debugging.		context := self contextOn: ''.	context parser: parser.		self assert: parser strategies size equals: 3.	self assert: (parser strategies first isKindOf: PP2RecordingDebuggingStrategy).	self assert: (parser strategies second isKindOf: PP2RecordingCache).	! !!PP2RecordingContextTest methodsFor: 'tests - profiling'!testParserRefreshCache	| parser context |	parser := (#letter asPParser plus token trim, #word asPParser star token trim) flatten.	parser optimize.	self assert:( parser allCaches noneSatisfy: [:c | c isRecording ]).		context := self contextOn: ''.	context parser: parser.	self assert: parser allCaches size equals: 2.	self assert:( parser allCaches allSatisfy: [:c | c isRecording ]).	! !!PP2RecordingContextTest methodsFor: 'tests - profiling'!testRecordingCache	| parser context |	parser := #letter asPParser.	parser strategy: parser strategy cache.		context := self contextOn: ''.	context parser: parser.	self assert: parser strategies size equals: 2.	self assert: (parser strategy isKindOf: PP2RecordingCache).	! !!PP2RecordingContextTest methodsFor: 'tests - debugging'!testSwitchToDebugging	| parser context |	parser := (#letter asPParser plus token trim, #word asPParser star token trim) flatten.	parser optimize.	self assert:( parser allCaches noneSatisfy: [:c | c isRecording ]).		context := self contextOn: ''.	context parser: parser.	self assert: parser allCaches size equals: 2.	self assert:( parser allCaches allSatisfy: [:c | c isRecording ]).	! !!PP2SeaNodeTest methodsFor: 'tests'!testAfterWater	sea := PP2SeaNode new		island: $a asPParser;		yourself.	self assert: sea afterWater isKindOf: PP2WaterNode.! !!PP2SeaNodeTest methodsFor: 'tests'!testBeforeWater	sea := PP2SeaNode new		island: $a asPParser;		yourself.	self assert: sea beforeWater isKindOf: PP2WaterNode.! !!PP2SeaNodeTest methodsFor: 'tests'!testChildren	| waterToken island |	waterToken := #space asPParser.	island := $a asPParser optional.	sea := PP2SeaNode new		island: island;		waterToken: waterToken;		yourself.	self assert: sea children size equals: 3.	self assert: sea children first isKindOf: PP2Node.	self assert: sea children second == island.	self assert: sea children third isKindOf: PP2Node.! !!PP2SeaNodeTest methodsFor: 'tests'!testNonNullableIsland	| waterToken island beforeWater boundary elements |	waterToken := #space asPParser.	island := $a asPParser optional.	sea := PP2SeaNode new		island: island;		waterToken: waterToken;		yourself.	boundary := $b asPParser.			parser := sea, boundary.		sea updateBeforeWater: parser.	beforeWater := sea beforeWater.				elements := beforeWater boundaryElements.	self assert: elements size equals: 2.		self assert: elements noneSatisfy: [ :e | e isNullable  ].! !!PP2SeaNodeTest methodsFor: 'tests'!testUpdateAfterWater	| waterToken island afterWater boundary elements nextBoundary |	waterToken := #space asPParser.	island := $a asPParser.	sea := PP2SeaNode new		island: island;		waterToken: waterToken;		yourself.	boundary := $b asPParser optional.	nextBoundary := $c asPParser.			parser := sea, boundary, nextBoundary.		sea updateAfterWater: parser.	afterWater := sea afterWater.		self assert: afterWater isKindOf: PP2WaterNode.	self assert: afterWater waterToken equals: waterToken.	self assert: afterWater boundary isKindOf: PP2ChoiceNode.	self assert: afterWater boundary children allSatisfy: [ :child | child isKindOf: PP2AndNode].				elements := afterWater boundaryElements.	self assert: elements size equals: 2.		self assert: elements noneSatisfy: [ :n | n isNullable ].	self assert: elements includes: nextBoundary.	! !!PP2SeaNodeTest methodsFor: 'tests'!testUpdateBeforeWater	| waterToken island beforeWater boundary elements |	waterToken := #space asPParser.	island := $a asPParser.	sea := PP2SeaNode new		island: island;		waterToken: waterToken;		yourself.	boundary := $b asPParser.			parser := sea, boundary.		sea updateBeforeWater: parser.	beforeWater := sea beforeWater.		self assert: beforeWater isKindOf: PP2WaterNode.	self assert: beforeWater waterToken equals: waterToken.	self assert: beforeWater boundary isKindOf: PP2ChoiceNode.	self assert: beforeWater boundary children allSatisfy: [ :child | child isKindOf: PP2AndNode ].				elements := beforeWater boundaryElements.	self assert: elements size equals: 2.		self assert: elements includes: island.	self assert: elements includes: boundary.! !!PP2SeaOptimizationVisitorTest methodsFor: 'asserting'!assert: set anySatisfy: aBlock	self assert: (set anySatisfy: aBlock)	! !!PP2SeaOptimizationVisitorTest methodsFor: 'asserting'!assert: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass)! !!PP2SeaOptimizationVisitorTest methodsFor: 'asserting'!assert: set noneSatisfy: aBlock	self assert: (set noneSatisfy: aBlock)	! !!PP2SeaOptimizationVisitorTest methodsFor: 'tests'!testJustSea	parser := $a asPParser sea.		self visit: parser.	self assert: parser strategy isKindOf: PP2Sea! !!PP2SeaOptimizationVisitorTest methodsFor: 'tests'!testMemoizedSea	sea := $a asPParser sea.		parser := sea, ($a asPParser / sea).		self visit: parser.	self assert: sea strategy isKindOf: PP2MemoizedSea.	self assert: sea afterWater allNodes anySatisfy: [ :n | n isSea ]! !!PP2SeaOptimizationVisitorTest methodsFor: 'tests'!testNestedSea	sea := $a asPParser sea.		parser := sea star sea.	self visit: parser.	self assert: sea strategy isKindOf: PP2Sea.	self assert: sea afterWater boundaryElements noneSatisfy: [ :e | e isSea ].	self assert: sea afterWater boundaryElements anySatisfy: [ :e | e == sea island ]! !!PP2SeaOptimizationVisitorTest methodsFor: 'tests'!testOverlappingSeas	| seaOne seaTwo |	seaOne := $a asPParser sea.	seaTwo := $b asPParser sea.		parser := seaOne, seaTwo.		self visit: parser.	self assert: seaOne strategy isKindOf: PP2Sea.	self assert: seaTwo strategy isKindOf: PP2Sea.	self assert: seaOne afterWater allNodes noneSatisfy: [ :n | n isSea ]! !!PP2SeaOptimizationVisitorTest methodsFor: 'tests'!testRepetitionInBoundary	sea := $a asPParser sea.	parser := sea, $b asPParser plus.		self visit: parser.	self assert: sea beforeWater boundaryElements noneSatisfy: [ :e | e isRepeating ].		self assert: sea afterWater boundaryElements noneSatisfy: [ :e | e isRepeating ].! !!PP2SeaOptimizationVisitorTest methodsFor: 'tests'!testSeaInBoundary	parser := $a asPParser sea.		self visit: parser.	self assert: parser strategy isKindOf: PP2Sea.	self assert: parser beforeWater boundaryElements noneSatisfy: [ :e | e isSea ].! !!PP2SeaOptimizationVisitorTest methodsFor: 'tests'!testSeaOptimizations	| bw aw |	sea := $a asPParser sea.		parser := sea star.	self visit: parser.	bw := sea beforeWater boundary.	aw := sea afterWater boundary.	parser parse: '..a..'.		self assert: sea beforeWater boundary == bw.	self assert: sea afterWater boundary == aw.! !!PP2SeaOptimizationVisitorTest methodsFor: 'tests'!testSeaOptimizationsReset	| bw aw |	sea := $a asPParser sea.		parser := sea star.	self visit: parser.	bw := sea beforeWater boundary.	aw := sea afterWater boundary.	sea parse: '..a..'.		self assert: sea beforeWater boundary ~= bw.	self assert: sea afterWater boundary ~= aw.! !!PP2SeaOptimizationVisitorTest methodsFor: 'tests'!testSeaPlus	sea := $a asPParser sea.		parser := sea plus.		self visit: parser.	self assert: sea strategy isKindOf: PP2Sea.	self assert: sea afterWater allNodes noneSatisfy: [ :n | n isSea ]! !!PP2SeaOptimizationVisitorTest methodsFor: 'tests'!testSeaStar	sea := $a asPParser sea.		parser := sea star.		self visit: parser.	self assert: sea strategy isKindOf: PP2Sea.	self assert: sea afterWater allNodes noneSatisfy: [ :n | n isSea ]! !!PP2SeaOptimizationVisitorTest methodsFor: 'visiting'!visit: node	PP2SeaOptimizationVisitor new visit: node! !!PP2SpecializingVisitorTest methodsFor: 'running'!setUp	visitor := PP2SpecializingVisitor new! !!PP2SpecializingVisitorTest methodsFor: 'tests'!testAndLiteraObject	parser := $a asPParser and.		visitor visit: parser.		self assert: parser strategy isKindOf: PP2AndLiteralObject.! !!PP2SpecializingVisitorTest methodsFor: 'tests'!testAndPredicateObject	parser := #letter asPParser and.		visitor visit: parser.		self assert: parser strategy isKindOf: PP2AndPredicateObject! !!PP2SpecializingVisitorTest methodsFor: 'tests'!testAnyStarLazyLiteralObject	| starLazy literal |	starLazy := #any asPParser starLazy.	literal := $a asPParser.	parser := starLazy, literal.		starLazy child updateAfterWater: parser.	starLazy child updateBeforeWater: parser.			visitor visit: parser.	self assert: starLazy strategy isKindOf: PP2AnyStarLazyLiteralObject.	self assert: starLazy strategy literal equals: literal literal.! !!PP2SpecializingVisitorTest methodsFor: 'tests'!testAnyStarLazyPredicateObject	| starLazy predicate |	starLazy := #any asPParser starLazy.	predicate := #letter asPParser.	parser := starLazy, predicate.		starLazy child updateAfterWater: parser.	starLazy child updateBeforeWater: parser.			visitor visit: parser.	self assert: starLazy strategy isKindOf: PP2AnyStarLazyPredicateObject.	self assert: starLazy strategy predicate equals: predicate predicate.! !!PP2SpecializingVisitorTest methodsFor: 'tests'!testIsAny	parser := #any asPParser.		self assert: (visitor isAny: parser).! !!PP2SpecializingVisitorTest methodsFor: 'tests'!testMappingOfThree	parser := ($a asPParser, $b asPParser, $c asPParser) map: [ :a :b :c | $d ].		visitor visit: parser.		self assert: parser strategy isKindOf: PP2MappingOfThree.! !!PP2SpecializingVisitorTest methodsFor: 'tests'!testMappingOfTwo	parser := ($a asPParser, $b asPParser) map: [ :a :b | $c ].		visitor visit: parser.		self assert: parser strategy isKindOf: PP2MappingOfTwo.! !!PP2SpecializingVisitorTest methodsFor: 'tests'!testNotLiteraObject	parser := $a asPParser not.		visitor visit: parser.		self assert: parser strategy isKindOf: PP2NotLiteralObject.! !!PP2SpecializingVisitorTest methodsFor: 'tests'!testOptionalLiteraObject	parser := $a asPParser optional.		visitor visit: parser.		self assert: parser strategy isKindOf: PP2OptionalLiteralObject.! !!PP2SpecializingVisitorTest methodsFor: 'tests'!testPlus	parser := $a asPParser plus.		visitor visit: parser.		self assert: parser strategy isKindOf: PP2Plus.! !!PP2SpecializingVisitorTest methodsFor: 'tests'!testPlusPredicateObject	parser := #letter asPParser plus.		visitor visit: parser.		self assert: parser strategy isKindOf: PP2PlusPredicateObject.! !!PP2SpecializingVisitorTest methodsFor: 'tests'!testPlusPredicateObject2	parser := #letter asPParser plus.	parser max: 20.		visitor visit: parser.	self deny: parser strategy isKindOf: PP2PlusPredicateObject.! !!PP2SpecializingVisitorTest methodsFor: 'tests'!testSequenceOfThree	parser := $a asPParser, $b asPParser, $c asPParser.		visitor visit: parser.		self assert: parser strategy isKindOf: PP2SequenceOfThree.! !!PP2SpecializingVisitorTest methodsFor: 'tests'!testSequenceOfTwo	parser := $a asPParser, $b asPParser.		visitor visit: parser.		self assert: parser strategy isKindOf: PP2SequenceOfTwo.! !!PP2SpecializingVisitorTest methodsFor: 'tests'!testStar	parser := $a asPParser star.		visitor visit: parser.		self assert: parser strategy isKindOf: PP2Star.! !!PP2SpecializingVisitorTest methodsFor: 'tests'!testStarPredicateObject	parser := #letter asPParser star.		visitor visit: parser.		self assert: parser strategy isKindOf: PP2StarPredicateObject.! !!PP2SpecializingVisitorTest methodsFor: 'tests'!testStarPredicateObject2	parser := #letter asPParser star.	parser max: 2.		visitor visit: parser.	self deny: parser strategy isKindOf: PP2StarPredicateObject.! !!PP2SpecializingVisitorTest methodsFor: 'tests'!testTrimmingLiteralObjectToken	parser := $a asPParser token trim.		visitor visit: parser.		self assert: parser strategy isKindOf: PP2TrimmingLiteralObjectToken.	self assert: parser strategy literal equals: $a.	! !!PP2SpecializingVisitorTest methodsFor: 'tests'!testTrimmingLiteralObjectTokenWrapped	parser := $a asPParser wrapped token trim.		visitor visit: parser.		self assert: parser strategy isKindOf: PP2TrimmingLiteralObjectToken.	self assert: parser strategy literal equals: $a.! !!PP2SpecializingVisitorTest methodsFor: 'tests'!testTrimmingToken	parser := $a asPParser plus token trim.		visitor visit: parser.		self assert: parser strategy isKindOf: PP2TrimmingToken.	self assert: parser strategy trimmer equals: parser trimmer.	self assert: parser strategy tokenClass equals: parser child tokenClass.! !!PP2StreamTest methodsFor: 'running'!setUp	super setUp! !!PP2StreamTest methodsFor: 'running'!streamOn: collection	^ PP2Stream on: collection! !!PP2StreamTest methodsFor: 'tests - context interface'!testContents	| stream |	stream := self streamOn: 'bar'. 		self assert: stream contents equals: 'bar'.! !!PP2TransformVisitorTest methodsFor: 'grammars'!grammarA	"A highly recrusive grammar."	| grammar |	grammar := PP2UnresolvedNode new.	grammar def: (grammar , $+ asPParser , grammar) / $1 asPParser.	^grammar! !!PP2TransformVisitorTest methodsFor: 'grammars'!grammarB	"The most stupid parser, it just references itself and never consumes anything. All algorithms should survive such an attack."	| parser |	parser := PP2DelegateNode new.	parser child: parser.	^ parser! !!PP2TransformVisitorTest methodsFor: 'tests'!testTransformIdentityGrammarA	| orig tran |	orig := self grammarA.	tran := orig transform: [ :each | each ].	self deny: orig == tran.	self deny: orig children first == tran children first.	self deny: orig children first children first == tran children first children first.	self deny: orig children first children last == tran children first children last.	self deny: orig children last == tran children last.		self assert: orig class == PP2ChoiceNode.	self assert: orig children first class == PP2SequenceNode.	self assert: orig children first children first == orig.	self assert: orig children first children last == orig.	self assert: orig children last class == PP2LiteralObjectNode.	self assert: tran class == PP2ChoiceNode.	self assert: tran children first class == PP2SequenceNode.	self assert: tran children first children first == tran.	self assert: tran children first children last == tran.	self assert: tran children last class == PP2LiteralObjectNode! !!PP2TransformVisitorTest methodsFor: 'tests'!testTransformIdentityGrammarB	| orig tran |	orig := self grammarB.	tran := orig transform: [ :each | each ].	self deny: orig == tran.	self deny: orig children first == tran children first.		self assert: orig class == PP2DelegateNode.	self assert: orig children first == orig.		self assert: tran class == PP2DelegateNode.	self assert: tran children first == tran! !!PP2TransformVisitorTest methodsFor: 'tests'!testTransformWrapGrammarA	| orig tran |	orig := self grammarA.	tran := orig transform: [ :each | each wrapped ].	self assert: orig class == PP2ChoiceNode.	self assert: orig children first class == PP2SequenceNode.	self assert: orig children first children first == orig.	self assert: orig children first children last == orig.	self assert: orig children last class == PP2LiteralObjectNode.		self assert: tran class == PP2DelegateNode.	self assert: tran children first class == PP2ChoiceNode.	self assert: tran children first children first class == PP2DelegateNode.	self assert: tran children first children first children first class == PP2SequenceNode.	self assert: tran children first children first children first children first == tran.	self assert: tran children first children first children first children last == tran.	self assert: tran children first children last class == PP2DelegateNode.	self assert: tran children first children last children first class == PP2LiteralObjectNode! !!PP2TransformVisitorTest methodsFor: 'tests'!testTransformWrapGrammarB	| orig tran |	orig := self grammarB.	tran := orig transform: [ :each | each wrapped ].		self assert: orig class == PP2DelegateNode.	self assert: orig child == orig.		self assert: tran class == PP2DelegateNode.	self assert: tran child class == PP2DelegateNode.	self assert: tran child child == tran! !!PP2TrimmingCacheVisitorTest methodsFor: 'support'!assert: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass)! !!PP2TrimmingCacheVisitorTest methodsFor: 'as yet unclassified'!setUp	super setUp.		visitor := PP2TrimmingCacheVisitor new! !!PP2TrimmingCacheVisitorTest methodsFor: 'as yet unclassified'!testDifferentTrimmers	parser := $a asPParser trimSpaces, $b asPParser trimBlanks.		visitor doPass: parser.	self assert: parser firstChild trimmer strategy isKindOf: PP2PossesiveRepeating.	self assert: parser secondChild trimmer strategy isKindOf: PP2PossesiveRepeating	! !!PP2TrimmingCacheVisitorTest methodsFor: 'as yet unclassified'!testSequence	parser := $a asPParser trim, $b asPParser trim.		visitor doPass: parser.	self assert: parser firstChild trimmer strategy isKindOf: PP2TrimmingCache.	self assert: parser secondChild trimmer strategy isKindOf: PP2TrimmingCache	! !!PP2TrimmingCacheVisitorTest methodsFor: 'as yet unclassified'!testSimpleTrimming	parser := $a asPParser trim.		visitor doPass: parser.	self assert: parser trimmer strategy isKindOf: PP2TrimmingCache! !!PP2TrimmingCacheVisitorTest methodsFor: 'as yet unclassified'!testSimpleTrimmingToken	parser := $a asPParser token trim.		visitor doPass: parser.	self assert: parser trimmer strategy isKindOf: PP2TrimmingCache! !!PP2MinimalStream class methodsFor: 'as yet unclassified'!on: values	^ self basicNew 		initialize;		values: values;		yourself! !!PP2MinimalStream methodsFor: 'minimal interface'!atEnd	^ position == values size! !!PP2MinimalStream methodsFor: 'private'!contents	^ values! !!PP2MinimalStream methodsFor: 'initialization'!initialize	position := 0.! !!PP2MinimalStream methodsFor: 'minimal interface'!next	position := position + 1.	^ values at: position! !!PP2MinimalStream methodsFor: 'private'!values: anObject	values := anObject! !!PP2MockNoopVisitor methodsFor: 'initialization'!initialize	super initialize.		visitOrder := OrderedCollection new! !!PP2MockNoopVisitor methodsFor: 'accessing'!visitOrder	^ visitOrder! !!PP2MockNoopVisitor methodsFor: 'visiting'!visitPP2Node: aPP2Node	visitOrder add: aPP2Node.		^ super visitPP2Node: aPP2Node! !!PP2ParserResource methodsFor: 'accessing'!parserAt: aParserClass	"Answer a cached instance of aParserClass."		^ parsers at: aParserClass name ifAbsentPut: [ aParserClass new ]! !!PP2ParserResource methodsFor: 'running'!setUp	super setUp.	parsers := Dictionary new! !!PP2CompositeNodeExamples methodsFor: 'utilities'!assert: aCollection is: anObject	| result |	result := self parse: aCollection.	self		assert: result = anObject		description: 'Got: ' , result printString , '; Expected: ' , anObject printString		resumable: true! !!PP2CompositeNodeExamples methodsFor: 'context'!context	^ PP2Context new! !!PP2CompositeNodeExamples methodsFor: 'parsing'!fail: aString rule: aSymbol 	| production context result |	production := self parserInstanceFor: aSymbol.	context := self context.		result := production parse: aString withContext: context.		self		assert: (result isPetit2Failure or: [context atEnd not])		description: 'Able to parse ' , aString printString.	^ result! !!PP2CompositeNodeExamples methodsFor: 'accessing'!parse: aString 	^ self parse: aString rule: #start! !!PP2CompositeNodeExamples methodsFor: 'accessing'!parse: aString production: production to: expectedResult end: end checkResult: aBoolean	| ctx resultContext result |	ctx := self context.	resultContext := self parse: aString withParser: production withContext: ctx.	result := resultContext value.		self		assert: resultContext isPetit2Failure not		description: 'Unable to parse ' , aString printString.		self assert: resultContext position equals: end.	aBoolean ifTrue: [ self assert: expectedResult equals: result ].	^ result! !!PP2CompositeNodeExamples methodsFor: 'accessing'!parse: aString rule: aSymbol	^ self parse: aString rule: aSymbol end: aString size! !!PP2CompositeNodeExamples methodsFor: 'accessing'!parse: aString rule: aSymbol end: end	^ self parse: aString rule: aSymbol to: nil end: end checkResult: false! !!PP2CompositeNodeExamples methodsFor: 'accessing'!parse: aString rule: aSymbol to: expectedResult end: end checkResult: aBoolean	| production |	production := self parserInstanceFor: aSymbol.	^ self parse: aString production: production to: expectedResult end: end checkResult: aBoolean 	! !!PP2CompositeNodeExamples methodsFor: 'accessing'!parse: aStream withParser: aParser withContext: aContext	^ aParser parse: aStream withContext: aContext! !!PP2CompositeNodeExamples methodsFor: 'accessing'!parserClass	self subclassResponsibility! !!PP2CompositeNodeExamples methodsFor: 'accessing'!parserInstance	^ parserInstance ifNil: [ parserInstance := self parserClass new ]! !!PP2CompositeNodeExamples methodsFor: 'accessing'!parserInstanceFor: aSymbol	^ aSymbol = #start		ifTrue: [ self parserInstance ]		ifFalse: [			self parserInstance				productionAt: aSymbol 				ifAbsent: [ self error: 'Production ' , self parserClass name , '>>' , aSymbol printString , ' not found.' ] ]! !"PetitParser2-Tests"!!PP2Validator commentStamp: '' prior: 0!Validator compares the output of the parser with a reference implementation.It is used to validte optimization features of PP2.!!PP2SkipValidation commentStamp: '' prior: 0!If there is something wrong with the validation, throw this error. The PPValidator will skip validation for this source.!!PP2BufferStreamValidator methodsFor: 'validation'!actualForSource: source	| result |		[		result := parser parse: (PP2BufferStream on: (PP2MinimalStream on: source) bufferSize: 64).	] on: PP2OutOfBoundsException do: [  		(PP2SkipValidation reason: 'To small buffer') signal	].	^ result isPetit2Failure ifFalse: [ 		result value isCollection 			ifTrue: [  result value ] 			ifFalse: [ Array with: result value ]	] ifTrue: [ 		#failure	]! !!PP2BufferStreamValidator methodsFor: 'validation'!expectedForSource: source	| result |	result := parser parse: source.		^ result isPetit2Failure ifFalse: [ 		result value isCollection 			ifTrue: [  result value ] 			ifFalse: [ Array with: result value ]	] ifTrue: [ 		#failure	]! !!PP2BufferStreamValidator methodsFor: 'initialization'!initialize	super initialize.		parser := PP2ExpressionParser new! !!PP2BufferStreamValidator methodsFor: 'accessing'!name	^ 'PP2BufferStream'! !!PP2BufferStreamValidator methodsFor: 'accessing'!sources	^ PP2Sources current inputs: #expressionOfSize: steps: 200 amount: 1 max: 200! !!PP2ExpressionGrammarOptimizaitonsValidator methodsFor: 'validation'!actualForSource: source	| result |	result := optimizedParser parse: source.	^ result isPetit2Failure ifFalse: [ 		result value	] ifTrue: [ 		#failure	]! !!PP2ExpressionGrammarOptimizaitonsValidator methodsFor: 'validation'!expectedForSource: source	| result |	result := parser parse: source.		^ result isPetit2Failure ifFalse: [ 		result value	] ifTrue: [ 		#failure	]! !!PP2ExpressionGrammarOptimizaitonsValidator methodsFor: 'initialization'!initialize	super initialize.		parser := PP2ExpressionGrammar new.	optimizedParser := PP2ExpressionGrammar new optimize! !!PP2ExpressionGrammarOptimizaitonsValidator methodsFor: 'accessing'!name	^ 'PP2ExpressionGrammar(Opt)'! !!PP2ExpressionGrammarOptimizaitonsValidator methodsFor: 'accessing'!optimizedParser	^ optimizedParser! !!PP2ExpressionGrammarOptimizaitonsValidator methodsFor: 'accessing'!parser	^ parser! !!PP2ExpressionGrammarOptimizaitonsValidator methodsFor: 'accessing'!sources	^ PP2Sources current inputs: #expressionOfSize: steps: 200 amount: 1 max: 200! !!PP2Validator methodsFor: 'validation'!actualForSource: source	self subclassResponsibility! !!PP2Validator methodsFor: 'reporting'!compactReportTo: filename	| file |	file := FileStream forceNewFileNamed: filename.	self report printCompactOnStream: file.	file close.! !!PP2Validator methodsFor: 'validation'!expectedForSource: source	self subclassResponsibility! !!PP2Validator methodsFor: 'utilities'!fileContents: filename	^ (FileStream fileNamed: filename) contents! !!PP2Validator methodsFor: 'initialization'!initialize	super initialize.		silent := true! !!PP2Validator methodsFor: 'accessing'!name	self subclassResponsibility! !!PP2Validator methodsFor: 'accessing'!report	^ report! !!PP2Validator methodsFor: 'utilities'!showDiffForSource: source	| actual expected |	actual := self actualForSource: source.	expected := self expectedForSource: source.		(DiffMorph 		from: (actual joinUsing: Character lf) 		to: (expected joinUsing: Character lf)) openInWindow! !!PP2Validator methodsFor: 'accessing'!silent	^ silent! !!PP2Validator methodsFor: 'accessing'!silent: aBoolean	^ silent := aBoolean! !!PP2Validator methodsFor: 'accessing'!sources	self subclassResponsibility! !!PP2Validator methodsFor: 'accessing'!timeout	^ 30 asDuration! !!PP2Validator methodsFor: 'transcript'!transcriptCr	self silent ifTrue: [ ^ self ].		Transcript cr.! !!PP2Validator methodsFor: 'transcript'!transcriptShow: text	self silent ifTrue: [ ^ self ].		Transcript show: text.! !!PP2Validator methodsFor: 'validation'!validate	[ self validateBlocking ] fork! !!PP2Validator methodsFor: 'validation'!validateBlocking	| time sources |	self transcriptCr; transcriptShow: 'Validating: ', self name.			report := PP2ValidatorReport new.	report parserName: self name.		time := [		sources := self sources.		report sources: sources.				self transcriptCr.		sources withIndexDo: [ :source :index | 		[ 			((index \\ ((sources size // 50) max: 1)) = 0) ifTrue: [ self transcriptShow: '-' ].			(self validateSource: source report: report).		] on: Error do: [ :err | 			report error: err forSource: source.			silent ifFalse: [ err signal ]		]	]] timeToRun.	report time: time.	self transcriptShow: report asString! !!PP2Validator methodsFor: 'validation'!validateSource: source report: aPPValidatorReport	| expected actual |	[		[ expected := self expectedForSource: source. ] on: PP2SkipValidation do: [ ^ self ].	] on: NotFound do: [ 		"Dunno why, but expected source not found just skip..."		^ self	].		[		[  actual := self actualForSource: source. ] on: PP2SkipValidation do: [  ^ self ]	] valueWithin: self timeout onTimeout: [ 		actual := #().		report timeout: source.	].	aPPValidatorReport actual: actual vs: expected for: source	! !!PP2ValidatorReport methodsFor: 'events'!actual: actual vs: expected for: source	| entry |	(actual isPetit2Failure and: [ expected isPetit2Failure not ]) ifTrue: [ 		entry := PP2ValidatorReportEntry new.		entry actual: #().		entry expected: expected.		entries at: source put: entry.				^ self failure: actual forSource: source.	].	(actual isPetit2Failure and: [ expected isPetit2Failure ]) ifTrue: [ 		entry := PP2ValidatorReportEntry new.		entry expected: #().		entry actual: #().		entries at: source put: entry.				^ self	].	(actual isPetit2Failure not and: [ expected isPetit2Failure ]) ifTrue: [ 		entry := PP2ValidatorReportEntry new.		entry expected: #().		entry actual: actual.		entries at: source put: entry.				^ self	].	"		both are ok	"	entry := PP2ValidatorReportEntry new.	entry expected: expected.	entry actual: actual.	entries at: source put: entry! !!PP2ValidatorReport methodsFor: 'converting'!asString	| stream |	stream := '' writeStream.	self printOnStream: stream.	^ stream contents! !!PP2ValidatorReport methodsFor: 'events'!error: error forSource: source	errors add: (error -> source).! !!PP2ValidatorReport methodsFor: 'accessing'!errors	^ errors! !!PP2ValidatorReport methodsFor: 'events'!failure: failure forSource: source	failures add: (failure -> source)! !!PP2ValidatorReport methodsFor: 'stats'!failureRate	^ ((timeouts size + failures size) / sources size) asFloat! !!PP2ValidatorReport methodsFor: 'accessing'!failures	^ failures! !!PP2ValidatorReport methodsFor: 'initialization'!initialize	entries := Dictionary new.	failures := OrderedCollection new.	timeouts := OrderedCollection new.	errors := OrderedCollection new.! !!PP2ValidatorReport methodsFor: 'accessing'!parserName	^ parserName! !!PP2ValidatorReport methodsFor: 'accessing'!parserName: aString	parserName := aString! !!PP2ValidatorReport methodsFor: 'stats'!precision	| truePositives falsePositives |	truePositives := entries  inject: 0 into: [ :sum :e | sum + e truePositives size ].	falsePositives := entries values inject: 0 into: [ :sum :e | sum + e falsePositives size ].		^ truePositives / (truePositives + falsePositives) asFloat	! !!PP2ValidatorReport methodsFor: 'printing'!printCompactOnStream: stream	stream nextPutAll: self parserName; tab.	stream nextPutAll: self precision asString; tab.	stream nextPutAll: self recall asString; tab.	stream nextPutAll: self failureRate asString; tab.	stream nextPutAll: self timePerSource asString; tab.		stream nextPutAll: failures size asString; tab.	stream nextPutAll: timeouts size asString; tab.	stream nextPutAll: errors size asString; cr.	stream flush.! !!PP2ValidatorReport methodsFor: 'printing'!printOnStream: stream	stream cr; nextPutAll: 'Validated in: ', time asMilliSeconds asString, 'ms on ', sources  size asString, ' files'.	stream cr; nextPutAll: 'precision: ', (self precision printShowingDecimalPlaces: 3).	stream cr; nextPutAll: 'recall: ', (self recall printShowingDecimalPlaces: 3).	stream cr; nextPutAll: 'total elements: ', (self total asString).	stream cr; nextPutAll: 'failure rate: ', (self failureRate printShowingDecimalPlaces: 3).	stream cr; nextPutAll: 'average time: ', (self timePerSource printShowingDecimalPlaces: 3), 'ms'.		stream cr; nextPutAll: 'failures: ', failures size asString.	stream cr; nextPutAll: 'timeouts: ', timeouts size asString.	stream cr; nextPutAll: 'errors: ', errors size asString.	stream flush.! !!PP2ValidatorReport methodsFor: 'stats'!recall	| truePositives falseNegatives |	truePositives := entries values inject: 0 into: [ :sum :e | sum + e truePositives size ].	falseNegatives := entries values inject: 0 into: [ :sum :e | sum + e falseNegatives size ].	^ truePositives / (truePositives + falseNegatives) asFloat	! !!PP2ValidatorReport methodsFor: 'accessing'!sources	^ sources! !!PP2ValidatorReport methodsFor: 'accessing'!sources: anObject	sources := anObject! !!PP2ValidatorReport methodsFor: 'accessing'!time: aTime	time := aTime! !!PP2ValidatorReport methodsFor: 'stats'!timePerSource	^ (time asMilliSeconds / sources size) asFloat! !!PP2ValidatorReport methodsFor: 'events'!timeout: source	timeouts add: source! !!PP2ValidatorReport methodsFor: 'accessing'!timeouts	^ timeouts! !!PP2ValidatorReport methodsFor: 'stats'!total	^ entries values inject: 0 into: [ :sum :e | sum + e expected size ].	! !!PP2ValidatorReportEntry methodsFor: 'accessing'!actual	^ actual! !!PP2ValidatorReportEntry methodsFor: 'accessing'!actual: anObject	actual := anObject! !!PP2ValidatorReportEntry methodsFor: 'accessing'!expected	^ expected! !!PP2ValidatorReportEntry methodsFor: 'accessing'!expected: anObject	expected := anObject! !!PP2ValidatorReportEntry methodsFor: 'stats'!falseNegatives	^ expected select: [ :e | (actual includes: e) not ].! !!PP2ValidatorReportEntry methodsFor: 'stats'!falsePositives	^ actual select: [ :e | (expected includes: e) not ].! !!PP2ValidatorReportEntry methodsFor: 'testing'!isPerfect	^ self precision = 1 and: [ self recall = 1 ]! !!PP2ValidatorReportEntry methodsFor: 'stats'!precision	( actual isEmpty) ifTrue: [ ^ 1 ].		^ self truePositives size / (self truePositives size + self falsePositives size) asFloat	! !!PP2ValidatorReportEntry methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	aStream nextPutAll: (self precision  printShowingDecimalPlaces: 2).	aStream nextPutAll: ', '.	aStream nextPutAll: (self recall  printShowingDecimalPlaces: 2).	aStream nextPut: $).! !!PP2ValidatorReportEntry methodsFor: 'stats'!recall	(expected isEmpty) ifTrue: [ ^ 1 ].	^ self truePositives size / (self truePositives size + self falseNegatives size) asFloat! !!PP2ValidatorReportEntry methodsFor: 'printing'!showStringDiff	(DiffMorph 		from: (actual joinUsing: Character lf) 		to: (expected joinUsing: Character lf)) openInWindow! !!PP2ValidatorReportEntry methodsFor: 'stats'!truePositives	^ actual select: [ :e | (expected includes: e) ].! !!PP2Sources class methodsFor: 'as yet unclassified'!downloadUrl	^ 'http://scg.unibe.ch/download/jk/sources/'! !!PP2Sources methodsFor: 'seas'!aIslandOfSize: size	| collection |	collection := String new: size.		1 to: size do: [ :index |	 		collection at: index put: $. .		].	collection at: size atRandom put: $a.	^ collection! !!PP2Sources methodsFor: 'seas'!aIslandSourcesBenchmarking	^ self cachedValue: #aIslandSourcesBenchmarking ifAbsentPut: [ 		self inputs: #aIslandOfSize: steps: 30 amount: 1 max: 1*1000*1000	]! !!PP2Sources methodsFor: 'seas'!aIslandSourcesComplexity	^ self cachedValue: #aIslandSourcesComplexity ifAbsentPut: [ 		self inputs: #aIslandOfSize: steps: 30 amount: 1 max: 1*1000*1000	]! !!PP2Sources methodsFor: 'seas'!aIslandSourcesProfiling	^ self cachedValue: #aIslandSourcesProfiling ifAbsentPut: [ 		self inputs: #aIslandOfSize: steps: 30 amount: 1 max: 100*1000	]! !!PP2Sources methodsFor: 'seas'!aIslandsOfSize: size	| collection |	collection := String new: size.		1 to: size do: [ :index |		(10 atRandom == 1) ifTrue: [ 			collection at: index put: $a.		] ifFalse: [ 	 		collection at: index put: $. .			]	].	^ collection! !!PP2Sources methodsFor: 'seas'!aIslandsSourcesBenchmarking	^ self cachedValue: #aIslandsSourcesBenchmarking ifAbsentPut: [ 		self inputs: #aIslandsOfSize: steps: 30 amount: 1 max: 1*1000*1000	]! !!PP2Sources methodsFor: 'seas'!aIslandsSourcesComplexity	^ self cachedValue: #aIslandsSourcesComplexity ifAbsentPut: [ 		self inputs: #aIslandsOfSize: steps: 30 amount: 1 max: 100*1000	]! !!PP2Sources methodsFor: 'seas'!aIslandsSourcesProfiling	^ self cachedValue: #aIslandsSourcesProfiling ifAbsentPut: [ 		self inputs: #aIslandsOfSize: steps: 30 amount: 1 max: 2*1000	]! !!PP2Sources methodsFor: 'seas'!blockIslandsOfSize: size	| stream |	stream := WriteStream on: (String new: size).	self blockIslandsOfSize: size stream: stream.	self assert: (stream size - size) == 0.	^ stream contents! !!PP2Sources methodsFor: 'seas'!blockIslandsOfSize: size stream: stream	| index rand |	index := 0.	rand := Random new.		[index < size] whileTrue: [  		((size - index >= 2) and: [(rand next < 0.1)]) ifTrue: [  			| subSize |			subSize := (0 max: (size - index - 2)).			subSize > 0 ifTrue: [ subSize := rand nextInt: subSize ].			stream nextPut: ${.			self blockIslandsOfSize: subSize stream: stream.			stream nextPut: $}.			index := index + subSize  + 2.		] ifFalse: [ 			stream nextPut: $. .			index := index + 1.		].	]! !!PP2Sources methodsFor: 'seas'!blockIslandsSourcesBenchmarking	^ self cachedValue: #blockIslandsSourcesBenchmarking ifAbsentPut: [ 		self inputs: #blockIslandsOfSize: steps: 30 amount: 1 max: 1*1000*1000	]! !!PP2Sources methodsFor: 'seas'!blockIslandsSourcesComplexity	^ self cachedValue: #blockIslandsSourcesComplexity ifAbsentPut: [ 		self inputs: #blockIslandsOfSize: steps: 30 amount: 1 max: 50*1000	]! !!PP2Sources methodsFor: 'seas'!blockIslandsSourcesProfiling	^ self cachedValue: #blockIslandsSourcesProfiling ifAbsentPut: [ 		self inputs: #blockIslandsOfSize: steps: 30 amount: 3 max: 2*1000	]! !!PP2Sources methodsFor: 'seas'!blockIslandsSourcesTesting	^ self cachedValue: #blockIslandsSourcesTesting ifAbsentPut: [ 		self inputs: #blockIslandsOfSize: steps: 30 amount: 1 max: 1*1000	]! !!PP2Sources methodsFor: 'caching'!cachedValue: key ifAbsentPut: block	^ cache at: key ifAbsentPut: block! !!PP2Sources methodsFor: 'download'!download: zipFile	zipFile asFileReference exists ifFalse: [ 		ZnClient new			url: self class downloadUrl, zipFile;			signalProgress: true;			downloadTo: FileSystem workingDirectory.	].	^  (FileSystem zip: zipFile asFileReference) open workingDirectory! !!PP2Sources methodsFor: 'download'!downloadUI: zipFile	zipFile asFileReference exists ifFalse: [ 		UIManager default informUserDuring: [ :bar |			bar label: 'Downloading ...'.			[ ZnClient new				url: self class downloadUrl, zipFile;				signalProgress: true;				downloadTo: FileSystem workingDirectory ]			on: HTTPProgress 			do: [ :progress |				progress isEmpty ifFalse: [ 					bar current: progress percentage.					progress total ifNotNil: [ :aTotalNumber |						bar label: 'Downloading ' ] ].				progress resume ] 		]		].	^  (FileSystem zip: zipFile asFileReference) open workingDirectory! !!PP2Sources methodsFor: 'expressions'!expressionOfSize: size	| stream |	stream := WriteStream on: (String new: size * 5).	self expressionOfSize: size stream: stream.	^ stream contents! !!PP2Sources methodsFor: 'expressions'!expressionOfSize: size stream: stream	| index rand |	index := 0.	rand := Random new.	[ index < size ] whileTrue: [ 		rand next < 0.1			ifTrue: [ 				| subSize |				subSize := rand nextInteger: size - index - 1 + 1.				stream nextPutAll: ' ('.				self expressionOfSize: subSize stream: stream.				stream nextPutAll: ') '.				index := index + subSize ]			ifFalse: [ 				stream nextPutAll: (rand nextInteger: 100) asString.				index := index + 1 ].		index < size ifTrue: [ 			rand next < 0.5				ifTrue: [ stream nextPutAll: ' + ' ]				ifFalse: [ stream nextPutAll: ' * ' ] ] ]! !!PP2Sources methodsFor: 'expressions'!expressionSourcesBenchmarking	^ self cachedValue: #expressionSourcesBenchmarking ifAbsentPut: [ 		self inputs: #expressionOfSize: steps: 50 amount: 10 max: 200.	].	! !!PP2Sources methodsFor: 'expressions'!expressionSourcesComplexity	^ self cachedValue: #expressionSourcesComplexity ifAbsentPut: [ 		self inputs: #expressionOfSize: steps: 50 amount: 3 max: 2000.	].	! !!PP2Sources methodsFor: 'expressions'!expressionSourcesProfiling	^ self cachedValue: #expressionSourcesProfiling ifAbsentPut: [ 		self inputs: #expressionOfSize: steps: 50 amount: 1 max: 100.	].	! !!PP2Sources methodsFor: 'expressions'!expressionSourcesVerification	^ self cachedValue: #expressionSourcesVerification ifAbsentPut: [ 		self inputs: #expressionOfSize: steps: 500 amount: 1 max: 500.	].	! !!PP2Sources methodsFor: 'utility'!files: files withExtension: extension	^ files select: [ :f | f extension = extension ] ! !!PP2Sources methodsFor: 'micro'!idsSourcesBenchmarking	"		PPValidatorSources current idsSourcesBenchmarking.	"	^ self cachedValue: #idsSourcesBenchmarking ifAbsentPut: [ 		self inputs: #loremIpsum: steps: 50 amount: 1 max: 200*1000	]! !!PP2Sources methodsFor: 'expressions'!indentExpressionOfSize: size	| stream |	stream := WriteStream on: (String new: size * 5).	self indentExpressionOfSize: size stream: stream indent: 0 limit: size.	^ stream contents! !!PP2Sources methodsFor: 'expressions'!indentExpressionOfSize: size stream: stream indent: indent limit: limit	| index rand |	index := 0.	rand := Random new.	[index < size] whileTrue: [  		(index ~= 0 and: [ indent < 500 and: [ rand next < 0.1]] ) ifTrue: [  			| subSize |			subSize := rand nextInt: (size - index - 1) + 1.			stream nextPut: Character cr.			(indent + 1) timesRepeat: [ stream nextPutAll: '    ' ].			self indentExpressionOfSize: subSize stream: stream indent: (indent + 1) limit: limit.			stream nextPut: Character cr.			indent timesRepeat: [ stream nextPutAll: '    ' ].			index := index + subSize.		] ifFalse: [ 			stream nextPutAll: (rand nextInt: 100) asString.			index := index + 1.		].			(index < size) ifTrue: [  			(rand next < 0.5) 				ifTrue: [  stream nextPutAll: '+' ] 				ifFalse: [ stream nextPutAll: '*' ]		]	]! !!PP2Sources methodsFor: 'expressions'!indentExpressionSourcesBenchmarking	^ self cachedValue: #indentExpressionSourcesBenchmarking ifAbsentPut: [ 		self inputs: #indentExpressionOfSize: steps: 50 amount: 3 max: 200.	].	! !!PP2Sources methodsFor: 'expressions'!indentExpressionSourcesComplexity	^ self cachedValue: #indentExpressionSourcesComplexity ifAbsentPut: [ 		self inputs: #indentExpressionOfSize: steps: 50 amount: 3 max: 2000.	].	! !!PP2Sources methodsFor: 'expressions'!indentExpressionSourcesProfiling	^ self cachedValue: #indentExpressionSourcesProfiling ifAbsentPut: [ 		self inputs: #indentExpressionOfSize: steps: 50 amount: 1 max: 50.	].	! !!PP2Sources methodsFor: 'expressions'!indentExpressionSourcesVerification	^ self cachedValue: #indentExpressionSourcesVerification ifAbsentPut: [ 		self inputs: #indentExpressionOfSize: steps: 50 amount: 1 max: 50.	].	! !!PP2Sources methodsFor: 'initialization'!initialize	super initialize.	cache := IdentityDictionary new! !!PP2Sources methodsFor: 'utility'!inputs: selector steps: steps amount: amount max: max	| input size step |	input := OrderedCollection new.	step := max // steps.		1 to: steps do: [ :index |		size := step * index.		amount timesRepeat: [ 			input add: (self perform: selector with: size).		]	].	^ input! !!PP2Sources methodsFor: 'expressions'!ll1expressionSourcesBenchmarking	^ self cachedValue: #ll1expressionSourcesBenchmarking ifAbsentPut: [ 		self inputs: #expressionOfSize: steps: 50 amount: 3 max: 2000.	].	! !!PP2Sources methodsFor: 'expressions'!ll1expressionSourcesComplexity	^ self cachedValue: #ll1expressionSourcesComplexity ifAbsentPut: [ 		self inputs: #expressionOfSize: steps: 200 amount: 1 max: 10*1000.	].	! !!PP2Sources methodsFor: 'expressions'!ll1indentExpressionSourcesBenchmarking	^ self cachedValue: #ll1indentExpressionSourcesBenchmarking ifAbsentPut: [ 		self inputs: #indentExpressionOfSize: steps: 50 amount: 3 max: 500.	].	! !!PP2Sources methodsFor: 'expressions'!ll1indentExpressionSourcesComplexity	^ self cachedValue: #ll1indentExpressionSourcesComplexity ifAbsentPut: [ 		self inputs: #indentExpressionOfSize: steps: 200 amount: 1 max: 5*1000.	].	! !!PP2Sources methodsFor: 'utility'!loremIpsum	^ 'Lorem ipsum dolor sit amet  consectetur adipiscing elit  sed do eiusmod tempor incididunt ut labore et dolore magna aliqua  Ut enim ad minim veniam  quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat  Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur  Excepteur sint occaecat cupidatat non proident  sunt in culpa qui officia deserunt mollit anim id est laborum'! !!PP2Sources methodsFor: 'utility'!loremIpsum: size	"Return a mostly random multi-paragraph filler string of the specified size.	The result is pure ASCII, uses CR for newlines and no dots and newlines."		"	PPValidatorSources new loremIpsum: 2048	"		| words out |	words := (self loremIpsum findTokens: ' ') collect: #asLowercase.	(out := LimitedWriteStream on: (String new: size withAll: Character space))		setLimit: size - 2 		limitBlock: [ 			^ out originalContents 				at: size put: Character cr; 				yourself ].	[ 		out << self loremIpsum; cr; cr.		5 atRandom timesRepeat: [			15 atRandom timesRepeat: [	 			out << words atRandom capitalized.				20 atRandom timesRepeat: [ out space; << words atRandom ].				out space ].			out cr; cr ] ] repeat! !!PP2Sources methodsFor: 'utility'!readDirectory: directory	| file |	( (Smalltalk respondsTo: #isSmalltalkX) and:[ Smalltalk isSmalltalkX ] ) ifTrue:[ 		file := self class dataDirectory asFilename / directory.		file exists ifFalse:[  			self error: 'Directory does not exist'.		].		^ (file recursiveDirectoryContentsAsFilenames select:[:each | each isRegularFile ]) asSortedCollection 	] ifFalse:[ 		"Assuming Pharo..."		ZnClient new			url: 'http://scg.unibe.ch/download/jk/sources/smalltalk-src-selected.zip';			signalProgress: true;			downloadTo: FileSystem workingDirectory.		file := (FileSystem zip: 'smalltalk-src-selected.zip' asFileReference) open workingDirectory."		file := self class dataDirectory download		file := self class dataDirectory asFileReference / directory.		file exists ifFalse: [ 			self error: 'Directory', directory asString, ' does not exist'.		]."		^ file allFiles asSortedCollection 	]	"Modified: / 10-05-2015 / 07:54:14 / Jan Vrany <jan.vrany@fit.cvut.cz>"! !!PP2Sources methodsFor: 'utility'!selectEvenly: n fromFiles: collection	^ self selectEvenly: n fromFiles: collection thatSatisfy: [ :e | true ]! !!PP2Sources methodsFor: 'utility'!selectEvenly: n fromFiles: collection thatSatisfy: aBlock	| set step index size sorted |	set := IdentitySet new.		step := 65537.	index := 0.	size := collection size.	sorted := collection sort.	self assert: collection atRandom isFile.		[set size = n] whileFalse: [ 		| file |		index := ((index + step) \\ size).		file := (sorted at: (index + 1)).		((aBlock value: file) and: [ file exists ] ) ifTrue: [			set add: (sorted at: (index + 1)).		].	].	^ set asOrderedCollection sorted collect: [ :file | file contents ]! !!PP2SkipValidation class methodsFor: 'instance creation'!reason: aString	^ self new		reason: aString;		yourself! !!PP2SkipValidation methodsFor: 'accessing'!reason	^ reason! !!PP2SkipValidation methodsFor: 'accessing'!reason: aString	reason := aString! !"PetitParser2-Validation"!!PP2VerificationTests commentStamp: '' prior: 0!I am aspecial kind of test. I do not test validation  itself, but that that validation returns expected results.!!PP2BufferStreamValidatorTest methodsFor: 'running'!setUp	super setUp.	validator := PP2BufferStreamValidator new.! !!PP2BufferStreamValidatorTest methodsFor: 'tests'!testActualForSource	| result |	result := validator actualForSource: '1+2'.		self assert: result size = 3.	self assert: result first = 1.	self assert: result second = $+.	self assert: result third = 2.! !!PP2BufferStreamValidatorTest methodsFor: 'tests'!testActualForSourceSingleNumber	| result |	result := validator actualForSource: '52'.		self assert: result isCollection.! !!PP2BufferStreamValidatorTest methodsFor: 'tests'!testExpectedForSource	| result |	result := validator expectedForSource: '1+2'.		self assert: result size = 3.	self assert: result first = 1.	self assert: result second = $+.	self assert: result third = 2.! !!PP2BufferStreamValidatorTest methodsFor: 'tests'!testExpectedForSourceSingleNumber	| result |	result := validator expectedForSource: '52'.		self assert: result isCollection.! !!PP2ExpressionGrammarOptimizationsValidator methodsFor: 'initialization'!setUp	super setUp.	validator := PP2ExpressionGrammarOptimizaitonsValidator new.! !!PP2ExpressionGrammarOptimizationsValidator methodsFor: 'tests'!testActualForSource	| result |	result := validator actualForSource: '1+2'.		self assert: result size = 3.	self assert: result first = '1'.	self assert: result second = $+.	self assert: result third = '2'.! !!PP2ExpressionGrammarOptimizationsValidator methodsFor: 'tests'!testExpectedForSource	| result |	result := validator expectedForSource: '1+2'.		self assert: result size = 3.	self assert: result first = '1'.	self assert: result second = $+.	self assert: result third = '2'.! !!PP2ExpressionGrammarOptimizationsValidator methodsFor: 'tests'!testOptimization	self assert: validator optimizedParser isOptimized! !!PP2VerificationTests methodsFor: 'streams'!testPP2BufferStream	| validator |	validator := PP2BufferStreamValidator new.	validator validateBlocking.		self assert: validator report precision equals: 1.	self assert: validator report recall equals: 1.! !!PP2VerificationTests methodsFor: 'optimizations'!testPP2ExpressionGrammarOptimizations	| validator |	validator := PP2ExpressionGrammarOptimizaitonsValidator new.	validator validateBlocking.		self assert: validator report precision equals: 1.	self assert: validator report recall equals: 1.! !"PetitParser2-Validation-Tests"!!PP2BenchmarkTest methodsFor: 'tests'!testExpressionGrammar	| parser bench result input |	bench := PP2Benchmark new setupExpressionGrammar.	parser := bench parser.		self assert: parser class equals: PP2ExpressionGrammar.	self assert: (bench context isKindOf: PP2InMemoryContext).		result := parser end parse: '1 + (2 * 3)'.	self assert: result value size = 3.	self assert: result value first equals: '1'.		input := bench input.	context := bench context.	selector := bench selector.	self assert: (bench parser end perform: selector withArguments: {input first . context }) isPetit2Failure not.! !!PP2BenchmarkTest methodsFor: 'testing - expressions'!testExpressionGrammarNoOpt	| parser bench result input |	bench := PP2Benchmark new setupExpressionGrammarNoOpt.	parser := bench parser.		self assert: parser class equals: PP2ExpressionGrammar.	self assert: (bench context isKindOf: PP2Context).		result := parser end parse: '1 + (2 * 3)'.	self assert: result value size = 3.	self assert: result value first equals: '1'.		input := bench input.	context := bench context.	selector := bench selector.	self assert: (bench parser end perform: selector withArguments: {input first . context }) isPetit2Failure not.! !!PP2BenchmarkTest methodsFor: 'testing - expressions'!testExpressionParser	| parser bench result input |	bench := PP2Benchmark new setupExpressionParser.	parser := bench parser.		self assert: parser class equals: PP2ExpressionParser.		result := parser end parse: '1 + (2 * 3)'.	self assert: result value size = 3.	self assert: result value first equals: 1.	input := bench input.	context := bench context.	selector := bench selector.	self assert: (bench parser end perform: selector withArguments: {input first . context }) isPetit2Failure not.! !!PP2Benchmark class methodsFor: 'examples'!exampleExpressionGrammar	<example>		| b |	b := PP2Benchmark new.	b benchmarkExpressionGrammar.	b benchmarkExpressionGrammarNoOpt.	b showTpcs inspect! !!PP2Benchmark methodsFor: 'benchmarks - expression grammar'!benchmarkExpressionGrammar	self smartSetupAndRun: thisContext method selector.! !!PP2Benchmark methodsFor: 'benchmarks - expression grammar'!benchmarkExpressionGrammarNoOpt	self smartSetupAndRun: thisContext method selector.! !!PP2Benchmark methodsFor: 'benchmarks - expression grammar'!benchmarkExpressionParser	self smartSetupAndRun: thisContext method selector.! !!PP2Benchmark methodsFor: 'accessing'!context	^ contextClass new! !!PP2Benchmark methodsFor: 'accessing'!contextClass: aClass	^ contextClass := aClass! !!PP2Benchmark methodsFor: 'accessing'!createResources	^ PP2Sources current! !!PP2Benchmark methodsFor: 'accessing - properties'!hasProperty: aKey	"Test if the property aKey is present."		^ properties notNil and: [ properties includesKey: aKey ]! !!PP2Benchmark methodsFor: 'initialization'!initialize	super initialize.	resources := self createResources.		contextClass := PP2Context.	preferredRepetitions := 1.	report := PP2BenchmarkReport new.	sourcesSize := 'Benchmarking'.		selector := #'parse:withContext:'! !!PP2Benchmark methodsFor: 'accessing'!input	^ input! !!PP2Benchmark methodsFor: 'accessing'!input: anObject	input := anObject! !!PP2Benchmark methodsFor: 'accessing'!instantiate: aParserClass	^ aParserClass new! !!PP2Benchmark methodsFor: 'accessing'!parser	^ parser! !!PP2Benchmark methodsFor: 'accessing'!parser: anObject	parser := anObject! !!PP2Benchmark methodsFor: 'accessing - properties'!properties	^ properties! !!PP2Benchmark methodsFor: 'accessing - properties'!properties: aDictionary	properties := aDictionary ! !!PP2Benchmark methodsFor: 'accessing - properties'!propertyAt: aKey 	^ self propertyAt: aKey  ifAbsent: [ nil ]! !!PP2Benchmark methodsFor: 'accessing - properties'!propertyAt: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		^ properties isNil		ifTrue: [ aBlock value ]		ifFalse: [ properties at: aKey ifAbsent: aBlock ]! !!PP2Benchmark methodsFor: 'accessing - properties'!propertyAt: aKey ifAbsentPut: aBlock	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]! !!PP2Benchmark methodsFor: 'accessing - properties'!propertyAt: aKey put: anObject	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (properties ifNil: [ properties := Dictionary new: 1 ])		at: aKey put: anObject! !!PP2Benchmark methodsFor: 'accessing'!repetitions	^ repetitions isNil ifTrue: [ preferredRepetitions  ] ifFalse: [ repetitions ]! !!PP2Benchmark methodsFor: 'accessing'!repetitions: anObject	repetitions := anObject! !!PP2Benchmark methodsFor: 'accessing'!repetitionsIfNotSet: value	repetitions := value! !!PP2Benchmark methodsFor: 'accessing'!report	^ report! !!PP2Benchmark methodsFor: 'reporting'!reportInput: anInput time: time gcTime: gcTime name: nameOrNil	| size name |	size := anInput inject: 0 into: [:r :e | r + e size  ].		name := nameOrNil isNil 		ifTrue: [ parser class printString ]		ifFalse: [ nameOrNil ].		report addEntry: name size: size time: time gcTime: gcTime.! !!PP2Benchmark methodsFor: 'reporting'!reportInput: anInput time: time name: nameOrNil	self reportInput: anInput time: time gcTime:  0 name: nameOrNil! !!PP2Benchmark methodsFor: 'accessing'!resources	^ resources! !!PP2Benchmark methodsFor: 'accessing'!resources: newResources	resources := newResources! !!PP2Benchmark methodsFor: 'running'!run	| time gcTime |	self repetitions timesRepeat: [ 		3 timesRepeat: [ Smalltalk garbageCollect ].		gcTime := Smalltalk vm totalGCTime.		time := [ input do: [ :source | 			"parser parse: source withContext: self context"			parser perform: selector withArguments: {  source . self context }.		] ] timeToRun asMilliSeconds.				self reportInput: input time: time gcTime: (Smalltalk vm totalGCTime - gcTime) name: parser name	]! !!PP2Benchmark methodsFor: 'running'!runTimeout: timeout	| time gcTime |	self repetitions timesRepeat: [ 		3 timesRepeat: [ Smalltalk garbageCollect ].		gcTime := Smalltalk vm totalGCTime.		time := [ input do: [ :source | 			[ parser parse: source withContext: self context ]				valueWithin: timeout				onTimeout: [ Transcript show: 'timeout'; cr. #timeout ]		] ] timeToRun asMilliSeconds.		self reportInput: input time: time gcTime: (Smalltalk vm totalGCTime - gcTime) name: parser class asString	]! !!PP2Benchmark methodsFor: 'reporting'!saveReport: filename	report save: filename	! !!PP2Benchmark methodsFor: 'accessing'!selector	^ selector ! !!PP2Benchmark methodsFor: 'setup & teardown'!setup: class sources: name	parser := self instantiate: class.	input := self sourcesFor: name	! !!PP2Benchmark methodsFor: 'benchmarks - expression grammar'!setupExpressionGrammar	self setup: PP2ExpressionGrammar sources: 'expression'.	parser name: 'Arithmetic Expressions'.	self parser optimize.		contextClass := PP2InMemoryContext.	selector := #'parseAdaptable:withContext:'.	preferredRepetitions := 3! !!PP2Benchmark methodsFor: 'benchmarks - expression grammar'!setupExpressionGrammarNoOpt	self setup: PP2ExpressionGrammar sources: 'expression'.	parser name: 'Arithmetic Expressions (NoOpt)'.	preferredRepetitions := 3.		contextClass := PP2Context.	selector := #'parseAdaptable:withContext:'.	preferredRepetitions := 3.! !!PP2Benchmark methodsFor: 'benchmarks - expression grammar'!setupExpressionParser	self setup: PP2ExpressionParser sources: 'expression'.	parser name: 'Arithmetic Expressions Parser'.	preferredRepetitions := 3.		contextClass := PP2Context.! !!PP2Benchmark methodsFor: 'setup & teardown'!setupMock: id	input := OrderedCollection with: 'mock'.	parser := (nil asPParser)		name: id;		yourself! !!PP2Benchmark methodsFor: 'running'!setupSelector: setupSelector	self perform: ('setup', setupSelector) asSymbol.! !!PP2Benchmark methodsFor: 'reporting'!showDetailedReport	report showDetailed! !!PP2Benchmark methodsFor: 'reporting'!showReport	report show! !!PP2Benchmark methodsFor: 'reporting'!showSpeedup	report speedup! !!PP2Benchmark methodsFor: 'setup & teardown'!smartSetupAndRun: benchmarkSelector	^ self testSetupAndRun: (benchmarkSelector withoutPrefix: 'benchmark')! !!PP2Benchmark methodsFor: 'accessing'!sourcesFor: language	| sourcesSelector |	sourcesSelector := (language asString, 'Sources', sourcesSize) asSymbol.		^ resources perform: sourcesSelector! !!PP2Benchmark methodsFor: 'accessing'!sourcesSize: aString	sourcesSize := aString! !!PP2Benchmark methodsFor: 'setup & teardown'!teardownSelector: teardownSelector	| symbol |	symbol := ('teardown', teardownSelector) asSymbol.		(self respondsTo: symbol) ifTrue: [ 		self perform: symbol.	]! !!PP2Benchmark methodsFor: 'accessing'!testClass	^ PP2BenchmarkTest! !!PP2Benchmark methodsFor: 'running'!testSelector: testSelector	self testClass new perform: ('test', testSelector) asSymbol.! !!PP2Benchmark methodsFor: 'running'!testSetupAndRun: runSelector	self testSelector: runSelector.	self setupSelector: runSelector.	self run.	self teardownSelector: runSelector.! !!PP2ComplexityBenchmark methodsFor: 'initialization'!initialize	super initialize.		sourcesSize := 'Complexity'.! !!PP2ComplexityBenchmark methodsFor: 'reporting'!reportInput: anInput time: time gcTime: gcTime name: nameOrNil	| size name |	size := anInput size.		name := nameOrNil isNil 		ifTrue: [ parser class printString ]		ifFalse: [ nameOrNil ].		report addEntry: name size: size time: time gcTime: gcTime.! !!PP2ComplexityBenchmark methodsFor: 'running'!run	^ self runTimeout: 30 asDuration! !!PP2ComplexityBenchmark methodsFor: 'running'!runTimeout: timeout	| time |	self repetitions timesRepeat: [ 				input withIndexDo: [ :source :index | 			time := [[ parser parse: source withContext: self context ]				valueWithin: timeout				onTimeout: [ Transcript cr; show: 'timeout'; cr. #TIMEOUT ] ] timeToRunWithoutGC.			self reportInput: source time: time name: parser name.		].	].	^ report! !!PP2BenchmarkEntry methodsFor: 'accessing'!gcTime	^ gcTime ifNil: [ 0 ]! !!PP2BenchmarkEntry methodsFor: 'accessing'!gcTime: anObject	gcTime := anObject! !!PP2BenchmarkEntry methodsFor: 'accessing'!name	^ name! !!PP2BenchmarkEntry methodsFor: 'accessing'!name: anObject	name := anObject! !!PP2BenchmarkEntry methodsFor: 'accessing'!size	^ size! !!PP2BenchmarkEntry methodsFor: 'accessing'!size: anObject	size := anObject! !!PP2BenchmarkEntry methodsFor: 'accessing'!time	^ time! !!PP2BenchmarkEntry methodsFor: 'accessing'!time: anObject	time := anObject! !!PP2BenchmarkEntry methodsFor: 'accessing'!timestamp	^ timestamp! !!PP2BenchmarkEntry methodsFor: 'accessing'!timestamp: anObject	timestamp := anObject! !!PP2BenchmarkEntry methodsFor: 'stats'!tpc	^ time / size! !!PP2BenchmarkReport methodsFor: 'logging'!addEntry: entry	entries add: entry! !!PP2BenchmarkReport methodsFor: 'logging'!addEntry: parserName size: inputSize time: milliseconds	self addEntry: parserName size: inputSize time: milliseconds gcTime: 0! !!PP2BenchmarkReport methodsFor: 'logging'!addEntry: parserName size: inputSize time: milliseconds gcTime: gcMilliseconds	| entry |	entry := PP2BenchmarkEntry new		name: parserName ;		size: inputSize ;		time: milliseconds ;		gcTime: gcMilliseconds ;		timestamp: DateAndTime current.			self addEntry: entry! !!PP2BenchmarkReport methodsFor: 'converting'!asString	| stream |	stream := WriteStream on: String new.	self show: stream.	^ stream contents! !!PP2BenchmarkReport methodsFor: 'statistics'!fiveNumberSummary: list	| median min max lowerQuartile upperQuartile |	median := self median: list.	min := self min: list.	max := self max: list.	lowerQuartile := self lowerQuartile: list.	upperQuartile := self upperQuartile: list.		^ {  min . lowerQuartile . median . upperQuartile . max } ! !!PP2BenchmarkReport methodsFor: 'summary'!gcTimesFrom: subentries	^ subentries collect: #gcTime! !!PP2BenchmarkReport methodsFor: 'summary'!groupBy: fieldName	| dictionary |	dictionary := OrderedDictionary new.	entries do: [ :e |		| collection |		collection := dictionary at: (e perform: fieldName) ifAbsentPut: [ OrderedCollection new ].		collection add: e.	].	^ dictionary! !!PP2BenchmarkReport methodsFor: 'initialization'!initialize	entries := OrderedCollection new! !!PP2BenchmarkReport methodsFor: 'statistics'!lowerHalf: list	| return mean |	mean := self median: list.	return := list select: [ :e | e < mean ].		return isEmpty ifTrue: [ return add: list anyOne ].	^ return! !!PP2BenchmarkReport methodsFor: 'statistics'!lowerQuartile: list	^ self mean: (self lowerHalf: list)! !!PP2BenchmarkReport methodsFor: 'statistics'!max: list	^ list max! !!PP2BenchmarkReport methodsFor: 'statistics'!mean: list	^ list average! !!PP2BenchmarkReport methodsFor: 'statistics'!median: list	| sorted size |	sorted := list sort.	size := sorted size.	^ (size \\ 2 = 0) ifTrue: [ 		((sorted at: (size // 2)) + (sorted at: ((size // 2) + 1))) / 2	] ifFalse: [ 		sorted at: (size // 2) + 1	]! !!PP2BenchmarkReport methodsFor: 'statistics'!min: list	^ list min! !!PP2BenchmarkReport methodsFor: 'reporting'!printFiveNumberSummary: summary on: stream	"expeted: min, q1 mean q3 max"	^ self printNumberSummary: summary on: stream ! !!PP2BenchmarkReport methodsFor: 'reporting'!printNumberSummary: summary on: stream	"expeted: min, q1 mean q3 max"	summary do: [ :e | 		stream 			nextPut: Character tab;			nextPutAll: (e printShowingDecimalPlaces: 3);			yourself	]! !!PP2BenchmarkReport methodsFor: 'reporting'!save: filename	| file    |	file := FileStream forceNewFileNamed: filename.	self show: file.	file close.! !!PP2BenchmarkReport methodsFor: 'reporting complexity'!saveComplexity: filename	| file    |	file := FileStream forceNewFileNamed: filename.	self saveComplexityStream: file.	file close.! !!PP2BenchmarkReport methodsFor: 'reporting complexity'!saveComplexityEntries: subentries stream: stream	| entry time gcTime |	entry := subentries anyOne.	time := self mean: (subentries collect: #time).	gcTime := self mean: (subentries collect: #gcTime).		stream 		nextPutAll: entry name;		nextPut: Character tab;		nextPutAll: entry size asString;		nextPut: Character tab;		nextPutAll: time asFloat asString;		nextPut: Character tab;		nextPutAll: gcTime asFloat asString;		nextPut: Character lf;		flush! !!PP2BenchmarkReport methodsFor: 'reporting complexity'!saveComplexityStream: stream	(self groupBy: #size) keysAndValuesDo: [ :size :subentries |		self saveComplexityEntries: subentries stream: stream	]! !!PP2BenchmarkReport methodsFor: 'reporting'!saveEntriesNamed: name entries: subentries stream: stream	| size  timeSummary timeWithoutGCSummary gcSummary |	size := (self sizesFrom: subentries) anyOne.	timeSummary := self fiveNumberSummary: (self withoutMax: (self timesFrom: subentries)).	timeWithoutGCSummary := self fiveNumberSummary: (self withoutMax: (self timesWithoutGCFrom: subentries)).	gcSummary := self fiveNumberSummary: (self withoutMax: (self gcTimesFrom: subentries)).			stream			nextPutAll: name;			"With GC"			nextPut: Character tab;			nextPutAll: 'with gc'.	self printFiveNumberSummary: (timeSummary collect: [ :e | e / size * 1000 ]) on: stream.	stream			"Without GC"			nextPut: Character tab;			nextPutAll: 'without gc'.	self printFiveNumberSummary: (timeWithoutGCSummary collect: [ :e | e / size * 1000 ]) on: stream.	stream			"GC TIMES"			nextPut: Character tab;			nextPutAll: 'gc'.	self printFiveNumberSummary: (gcSummary collect: [ :e | e / size * 1000 ]) on: stream.	stream			nextPutAll: String lf;			flush.! !!PP2BenchmarkReport methodsFor: 'reporting'!show	Transcript show: '============'; cr.	self show: Transcript! !!PP2BenchmarkReport methodsFor: 'reporting'!show: stream	(self groupBy: #name) keysAndValuesDo: [ :name :subentries |		self saveEntriesNamed: name entries: subentries stream: stream	].! !!PP2BenchmarkReport methodsFor: 'reporting complexity'!showComplexity	self saveComplexityStream: Transcript! !!PP2BenchmarkReport methodsFor: 'reporting'!showDetailed	(self groupBy: #name) keysAndValuesDo: [ :name :subentries |		self showEntries: subentries	]! !!PP2BenchmarkReport methodsFor: 'reporting'!showEntries: subentries	subentries do: [ :e | 		self showEntry: e	]! !!PP2BenchmarkReport methodsFor: 'reporting'!showEntry: entry	Transcript crShow: 'Size: ', entry size asString.	Transcript crShow: entry name, ' time: ', entry time asString.	Transcript crShow: 'Time per character: ', (entry tpc * 1000.0) asString, ' microseconds'.		Transcript crShow: 'GC time: ', (entry gcTime) asString, 'ms'.! !!PP2BenchmarkReport methodsFor: 'accessing'!size	^ entries size! !!PP2BenchmarkReport methodsFor: 'summary'!sizesFrom: subentries	^ subentries collect: #size! !!PP2BenchmarkReport methodsFor: 'reporting'!speedup	self speedup: Transcript! !!PP2BenchmarkReport methodsFor: 'reporting'!speedup: stream	| grouped firstKey first firstName related relatedName |	grouped := (self groupBy: #name).	firstKey := grouped orderedKeys first.	first := (self fiveNumberSummary: (self timesFrom: (grouped at: firstKey))) first.	firstName := (grouped at: firstKey) anyOne name. 		grouped orderedKeys allButFirstDo: [ :key | 		key isNil ifFalse: [ 			related := (self fiveNumberSummary: (self timesFrom: (grouped at: key))) first.			relatedName := (grouped at: key) anyOne name.					stream nextPutAll: firstName, ' vs ', relatedName, ' speedup: ', ((first / related) asFloat printShowingDecimalPlaces: 3).			stream nextPutAll: String lf.		]	].	stream flush.! !!PP2BenchmarkReport methodsFor: 'statistics'!standardDeviation: data	^ (self variance: data)	sqrt! !!PP2BenchmarkReport methodsFor: 'reporting'!time: timeValue characters: size	^ (timeValue / size * 1000) printShowingDecimalPlaces: 3! !!PP2BenchmarkReport methodsFor: 'summary'!timesFrom: subentries	^ subentries collect: #time! !!PP2BenchmarkReport methodsFor: 'summary'!timesWithoutGCFrom: subentries	^ subentries collect: [:e | e time - e gcTime ]! !!PP2BenchmarkReport methodsFor: 'summary'!tpcsFrom: subentries	| size |	size := (self sizesFrom: subentries) anyOne.	^ (subentries collect: #time) collect: [ :e | e / size * 1000 ]! !!PP2BenchmarkReport methodsFor: 'statistics'!upperHalf: list	| mean |	mean := self median: list.	^ list select: [ :e | e >= mean ]! !!PP2BenchmarkReport methodsFor: 'statistics'!upperQuartile: list	^ self mean: (self upperHalf: list)! !!PP2BenchmarkReport methodsFor: 'statistics'!variance: data	| mean squaredDiffs |	mean := self mean: data.	squaredDiffs := data collect: [ :value | (value - mean) abs squared ].		^ squaredDiffs average! !!PP2BenchmarkReport methodsFor: 'statistics'!withoutMax: list	| max new |	(list size <= 1) ifTrue: [ ^ list ].		max := self max: list.	new := list copy asOrderedCollection.	new remove: max.	^ new! !!PP2BenchmarkReport methodsFor: 'statistics'!withoutWorst: list	^ list sort removeLast! !!RBParser methodsFor: '*PetitParser2-Benchmarks'!name	^ 'RBParser'! !"PetitParser2-Benchmarks"!!PRTParametrizable commentStamp: '' prior: 0!I'm a trait that proposes parameter-related methods.!!PRValidation commentStamp: '' prior: 0!During construction of the parameters, just after parsing there is an obscure validation phase. And I'm the class holding a strategy of our this validation is handled.!!PRBasicObject commentStamp: '' prior: 0!I'm a root of objects that are Pillar objects but not visitable per se. I could be replaced by Object. !!PRObject commentStamp: '' prior: 0!I am a superclass of most objects within Pier. I hold a dictionary of properties, so that users can easily annotate me with new values. I am visitable.!!PRAbstractScriptLanguage commentStamp: '' prior: 0!I represent a programming language that can be referenced from a PRScript to get syntax highlighting.Check the method  visitScript: for example on PRLatexWriter.  ...	(self languageForScript: aScript) isSyntaxHighlightingPossible		ifTrue: [ parameters add: 'language=' , (self languageForScript: aScript) printString ]....!!PRNoScriptLanguage commentStamp: '' prior: 0!I'm here for authors to specify they don't want syntax highlighting in their scripts.!!PRRealScriptLanguage commentStamp: '' prior: 0!Superclass for existing real scripting languages!!PRUnspecifiedScriptLanguage commentStamp: '' prior: 0!An unspecified script language!!PRUnsupportedScriptLanguage commentStamp: '' prior: 0!An unsupported script language!!PRDocumentItem commentStamp: '' prior: 0!I am an abstract superclass for the document hierarchy. My subclasses include all the basic elements to represent a document.!!!! DescriptionMost of the time I will be used by a visitor that will visit me. Each of my subclasses can have its own visitor.I'm usually contained inside a PRDocumentGroup at the exception of PRDocument.!!!! Public API and Key Messages- #parser. This class method returns the default parser for this document model.!!!! Internal Representation and Key Implementation Points.-	counter:		I am a counter used by some document items. Maybe I can be improve because not all items need a counter.!!PRAnchor commentStamp: '' prior: 0!I am an anchor within a document. I am used as a reference point within a large document.!!PRDocumentGroup commentStamp: '' prior: 0!I am an abstract group of document items.!!PRAbstractAnnotation commentStamp: '' prior: 0!I am an abstract class to represent an open-ended syntax for special text. The syntax of the annotation is the following: ```	${note:value=some text|value2="some text"}$```The name at the beginning of each annote is called the tag (e.g., 'index', 'note', 'cite'). The tag is followed by a series of associations (key/value pairs).Each annotation has the possibility to define a default parameter that does not need to be explicitly tagged: `${mock:Foo|number=5}$` means  `${mock:value=Foo|number=5}$` since mock defines defaultParameterName as `'value'`.### DescriptionI allow one to extend easily the syntax of Pillar. I am contained inside a PRDocumentGroup. I am define by a tag and I can have some parameters.### Public API and Key Messages- #tag This class method define the tag of an annotation.- #parameters: aCollection   This class method is the constructor of an annotation. This method takes a dictionary of parameters.### Internal Representation and Key Implementation Points. Instance Variables-	hadAllKeys:	I am a boolean. I  know if all the parameters written by the user had a key or if one didn't had a key. To export the document, this is useless except for the Pillar writer.-	parameters:	I  keep all the parameters of the annotation with a key and a value.!!PREnvironmentAnnotation commentStamp: '' prior: 0!I'm an annotation to represent an environment (as in LaTeX).Here is for example an environment called card. It is composed of a begin and end environment annotations.```${begin:card}$!!!! I'm CoolA paragraph about the card.I will be interpreted as part of the card.${end:card}$ ```See comment of PREnvironment. !!PRBeginEnvironmentAnnotation commentStamp: '' prior: 0!I'm the beginning of annotation to represent an environment (as in LaTeX): typically ${begin:card}$ in the following example.Here is for example an environment called card. It is composed of a begin and end environment annotations.```language=Smalltalk${begin:card}$!!!! I'm CoolA paragraph about the card.I will be interpreted as part of the card.${end:card}$ ```See comment of PREnvironment. !!PREndEnvironmentAnnotation commentStamp: '' prior: 0!I'm theannotation to represent the end of an environment (as in LaTeX): typically `${end:card}$` in the following example.Here is for example an environment called card. It is composed of a begin and end environment annotations.```${begin:card}$## I'm CoolA paragraph about the card.I will be interpreted as part of the card.${end:card}$ ```See comment of `PREnvironment`. !!PRMathInTextAnnotation commentStamp: '' prior: 0!Mockup of the annotation for math in text. We do not have a syntax from the pillar side  but this is for Microdown where I correspond to `$ math here $`.May be this is better to have a subclass of PRFormat.We will have to revisit this.!!PRDocument commentStamp: '' prior: 0!I am the root of a document composite.!!PREnvironment commentStamp: '' prior: 0!I represent an environment (as in LaTeX).I'm a `PRDocumentGroup` with a name. Syntactically I'm delimited by a start and an end annotation. I can be nested inside other environment. ```${begin:card}$!!!! I'm CoolA paragraph about the card.I will be interpreted as part of the card.${end:card}$ ```### Known LimitsFor now the parameters should be tested and available from the syntax and this is probably not the case. !!PRMathEnvironment commentStamp: '' prior: 0!I represent a future features for Math environment. I will have to be defined by an annotation, parsed and converted to my structure. I will have to be tested. Currently I'm just used by Microdown (delimited by `$$`) to make sure that we convert well the datastructures.!!PRFormat commentStamp: '' prior: 0!A styling format !!PRBoldFormat commentStamp: '' prior: 0!In Pillar, text can be shown in bold by wrapping the text around `""`.`""text in bold""` renders as **text in bold**.!!PRItalicFormat commentStamp: '' prior: 0!Format can be nested.`""bold ''italic''bold""` shows **bold_italic_bold**!!PRMonospaceFormat commentStamp: '' prior: 0!In Pillar, text can be shown in bold by wrapping the text around `==`.`==text in bold==` renders as `text in bold`.!!PRStrikethroughFormat commentStamp: '' prior: 0!Strikethrough format!!PRHeader commentStamp: '' prior: 0!I represent a header within a document. My level is a natural number.!!PRList commentStamp: '' prior: 0!I am an abstract list. I represent the abstraction over ordered, unordered HTML or latex list. My children are instances of *PRListItem*. If you need a container of elements better use of PRDocumentGroup.!!PROrderedList commentStamp: '' prior: 0!I am an ordered list. I am typically used for numbered items.!!PRUnorderedList commentStamp: '' prior: 0!I am an unordered list. I am typically used for unnumbered lists!!PRListItem commentStamp: '' prior: 0!I am an item within a *PRList*. It means that my subclass should only be elements having a textual representation within Pillar (- -- #).If you need to extend Pillar to support new kind of item (for example bibitem) which do not havea pillar syntax support do not subclass from this class. !!PRParagraph commentStamp: '' prior: 0!I'm a paragraph of text containing text, line breaks or annotations.I'm close to a latex or HTML paragraph. I do not contain complex structures such as lists, codeblocks. 		!!PRAnnotatedParagraph commentStamp: '' prior: 0!An annotated paragraph is represented by: @@ in pillar syntax.@@foo bar zork!!PREmptyParagraph commentStamp: '' prior: 0!An empty paragraph!!PRParameter commentStamp: '' prior: 0!I represent a key and value pair. My key is instance of PRParameterKey and its associated vaue is an instance of PRParameterValue.!!PRPreformatted commentStamp: '' prior: 0!I am preformatted text or source code. My children are instances of *PRText*.I'm delimited by = bar= fooin Pillar syntax.!!PRReference commentStamp: '' prior: 0!I'm a reference. I can be a Link or a Figure. Later i could be a video for example.!!PRFigure commentStamp: '' prior: 0!I'm a Figure.I can have a label and a caption in parameter. My alias (inherited) represents the figure caption.```+A nice caption for our nice figure.>file://figures/pharo-logo.png|width=50|label=pharoLogo+```!!PRLink commentStamp: '' prior: 0!I am an abstract link built from an alias and a reference. The alias is the string representation that will be displayed to the user, whereas the reference is a string identifying the target. If there is no alias, the reference itself is displayed. Links can try to embed the referenced target into the containing document.!!Examples=*Reference*=+Alias>Embedded Reference*!!PRExternalLink commentStamp: '' prior: 0!I am an external link with an URL (Uniform Resource Locator) as reference.!!PRMailLink commentStamp: '' prior: 0!I am an external link pointing to a mail address. I encode my URL to prevent spam bots collecting the address.!!PRInternalLink commentStamp: '' prior: 0!I am an internal link pointing to a structure within the current kernel. I'm syntactically represented by `*@`, label, and `*` ```# Header1@secheader1	A reference to header *@secheader1*```I reference my owning structure to be able to lookup the referenced structure. The referenced structure is cached in the instance variable `target`.!!PRSection commentStamp: '' prior: 0!I'm a section. I'm here to add a structure to the document.!!PRTable commentStamp: '' prior: 0!I am a table. My children are instances of *PRTableRow*.!!PRTableCell commentStamp: '' prior: 0!I am a cell of a table.!!PRTableRow commentStamp: '' prior: 0!I am a row of a table. My children are instances of *PRTableCell*.!!PRHorizontalRule commentStamp: '' prior: 0!I am a horizontal rule.!!PRLineBreak commentStamp: '' prior: 0!I am a line break. I only show up in the wiki format.!!PRMetadata commentStamp: '' prior: 0!This class is directly used by Microdown and not by the Pillar parser. It will mainly used for migrating documents from Pillar to Microdown because strangely enough meta data in Pillar was not a first class component. It means that when parsing a pillar document probably the pillar parser is not handle metadata. So metadata in Pillar files looks like a hack.!!PRParameterKey commentStamp: '' prior: 0!I'm a key in a environment or tag. For example in ${begin:card|rank=33}$ rank is represented by one of my instance. !!PRParameterValue commentStamp: '' prior: 0!I'm a value of a key in a environment or tag. For example in ${begin:card|rank=33}$ 33 is represented by one of my instance. !!PRText commentStamp: '' prior: 0!I am a plain text. I am the most important leaf node of the document composite.!!PRCodeblock commentStamp: '' prior: 0!I represent a code block whose body is not executed. In Pillar syntax```[[[1 + 3 			]]]```But a block can also have a tag and parameters.```[[[language=smalltalk|caption="addition"|label=whatever1 + 3 			]]]```#### Implementation thoughtsIn pillar is in unclear that the argument values can contain formatting directives.!!PRCommentedLine commentStamp: '' prior: 0!A commented line in Pillar is a line starting with %.A comment does not flows on multiple lines. Each line to be commented should start with %.!!PRRaw commentStamp: '' prior: 0!I represent a text that is not parsed/analyzed at all. I can have a type to limit the kind of output with which I'm associated. For example, an instance of me with type 'html' will only be written to HTML documents.I'm particularly useful when the rest of Pillar can't represent something you *really* want in your output: for example, an equation. In this case, you can describe your equation in latex using an instance of me of type latex and a picture everywhere else.!!PRVisitor commentStamp: '' prior: 0!I am an abstract visitor. I provide a default implementation of all visit messages that does not descend automatically into children of the visited graph. Subclasses should override all my messages in appropriate ways to visit the nodes they need.!!PRCascadingCounter commentStamp: '' prior: 0!I can keep track of the count of nested structures so each structure as its own number. For exemple, 2 sections in Chapter 1 would have a counter of #(1 1) and #(1 2). The first number indicates the top-most structure (here a chapter), while the following numbers represent the nested structures. I can count up to a max level.!!PRNotFoundCounter commentStamp: '' prior: 0!I am a subclass used when a reference is not found.In this case no number can be returned so a Warning is raised, and a ? is displayed!!PRError commentStamp: '' prior: 0!General Pillar error!!PRInputFileError commentStamp: '' prior: 0!An inclusion error during an inclusion of file.!!PRPropertyError commentStamp: '' prior: 0!A Pillar property error!!PRSyntaxError commentStamp: '' prior: 0!An error about syntax!!ManifestPillarCore commentStamp: '' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!PRTParametrizable methodsFor: 'accessing-parameters'!hasParameter: aKey	self		parameters at: aKey		ifAbsent: [ ^ false ].	^ true! !!PRTParametrizable methodsFor: 'accessing-parameters'!hasParameters	^ self parameters isNotEmpty! !!PRTParametrizable methodsFor: 'accessing-parameters'!parameterAt: aKey 	^ self parameters at: aKey! !!PRTParametrizable methodsFor: 'accessing-parameters'!parameterAt: aKey put: aValue	^ self parameters at: aKey put: aValue! !!PRTParametrizable methodsFor: 'accessing-parameters'!parameters	^ self explicitRequirement! !!PRValidation class methodsFor: 'protocol'!beSilentDuring: aBlock	^ self 			value: PRValidationStrategy silent			during: aBlock! !!PRValidation class methodsFor: 'accessing'!defaultStrategy	^ PRValidationStrategy shouting! !!PRValidation class methodsFor: 'accessing'!strategy	^ PRValidation value ifNil: [ self defaultStrategy ]! !!PRBasicObject class methodsFor: 'error handling'!defaultErrorClass	^ PRError! !!PRAbstractScriptLanguage class methodsFor: 'protected'!acceptLanguage: aLanguageName	^ aLanguageName matchesRegexIgnoringCase: self acceptedLanguagesRegex ! !!PRAbstractScriptLanguage class methodsFor: 'requirement'!acceptedLanguagesRegex 	^ self standardName! !!PRAbstractScriptLanguage class methodsFor: 'private'!concreteClassFor: aLanguageName	aLanguageName ifNil: [ ^ PRUnspecifiedScriptLanguage ].	^ (self withAllConcreteClasses copyWithout: PRUnsupportedScriptLanguage)		detect: [ :cl | cl acceptLanguage: aLanguageName ]		ifNone: [ PRUnsupportedScriptLanguage ]! !!PRAbstractScriptLanguage class methodsFor: 'instance creation'!default	^ self new		originalName: self standardName;		yourself! !!PRAbstractScriptLanguage class methodsFor: 'instance creation'!for: aLanguageName	^ (self concreteClassFor: aLanguageName) new		originalName: aLanguageName;		yourself! !!PRAbstractScriptLanguage class methodsFor: 'protected'!standardName	"Pay attention standardName is used in LaTeX for displaycode as follows	standardName		[[[language=bash	...	]]]		\begin{displaycode}{bash)}	"	^ self subclassResponsibility! !!PRAbstractScriptLanguage methodsFor: 'comparing'!= anObject	^ self originalName = anObject originalName! !!PRAbstractScriptLanguage methodsFor: 'comparing'!hash	^ self originalName hash! !!PRAbstractScriptLanguage methodsFor: 'initialize'!initialize	super initialize.	self originalName: self class standardName! !!PRAbstractScriptLanguage methodsFor: 'testing'!isSpecified	^ self subclassResponsibility! !!PRAbstractScriptLanguage methodsFor: 'accessing'!originalName	^ originalName! !!PRAbstractScriptLanguage methodsFor: 'accessing'!originalName: aLanguageName	originalName := aLanguageName! !!PRAbstractScriptLanguage methodsFor: 'printing'!printOn: aStream	"super printOn: aStream.	aStream nextPutAll: ' ('."	"do not change this printOn: method because it is used (yes this is not a good idea) for the 	latex code generation directly...."	aStream nextPutAll: self originalName.	"aStream nextPutAll: ')'."! !!PRNoScriptLanguage class methodsFor: 'requirement'!acceptedLanguagesRegex	^ '^$|', self standardName! !!PRNoScriptLanguage class methodsFor: 'testing'!isAbstract	^ false! !!PRNoScriptLanguage class methodsFor: 'protected'!standardName	^ 'no language'! !!PRNoScriptLanguage methodsFor: 'testing'!isSpecified	^ true! !!PRRealScriptLanguage methodsFor: 'testing'!isSpecified	^ true! !!PRUnspecifiedScriptLanguage class methodsFor: 'protected'!acceptLanguage: aLanguageName	^ aLanguageName isNil or: [ super acceptLanguage: aLanguageName ]! !!PRUnspecifiedScriptLanguage class methodsFor: 'testing'!isAbstract	^ false! !!PRUnspecifiedScriptLanguage class methodsFor: 'protected'!standardName	^ 'unspecified language'! !!PRUnspecifiedScriptLanguage methodsFor: 'testing'!isSpecified	^ false! !!PRUnspecifiedScriptLanguage methodsFor: 'accessing'!originalName	^ ''! !!PRUnsupportedScriptLanguage class methodsFor: 'instance creation'!default	<ignoreForCoverage>	^ self shouldNotImplement! !!PRUnsupportedScriptLanguage class methodsFor: 'testing'!isAbstract	^ false! !!PRUnsupportedScriptLanguage class methodsFor: 'protected'!standardName	^ 'unsupported language'! !!PRUnsupportedScriptLanguage methodsFor: 'testing'!isSpecified	^ false! !!PRAnchor class methodsFor: 'testing'!isAbstract	^ false! !!PRAnchor class methodsFor: 'instance creation'!named: aString	^ self new name: aString! !!PRAnchor methodsFor: 'comparing'!= anObject	^ super = anObject		and: [ self name = anObject name ]! !!PRAnchor methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitAnchor: self! !!PRAnchor methodsFor: 'comparing'!hash	^ super hash bitXor: self name hash! !!PRAnchor methodsFor: 'accessing'!name	^ name! !!PRAnchor methodsFor: 'accessing'!name: aString	name := aString trimBoth	"We do trimBoth to avoid to have unexpected space before or after an anchor."! !!PRAbstractAnnotation class methodsFor: 'protected'!acceptName: aTag 	^ aTag asSymbol = self tag! !!PRAbstractAnnotation class methodsFor: 'constant'!closingAnnotationString	^ '}$'					! !!PRAbstractAnnotation class methodsFor: 'accessing'!defaultParameterName	"Each annotation can have some parameters. A parameter has a key and a value. We allow for each annotation to have 1 parameter without key inside the pillar document. I return the key of this parameter."	^ self possibleParameters first! !!PRAbstractAnnotation class methodsFor: 'protected'!findClassAcceptingTag: aTag ifNone: aBlock	^ self withAllConcreteClasses		detect: [ :class | class acceptName: aTag ]		ifNone: aBlock! !!PRAbstractAnnotation class methodsFor: 'accessing'!hasParameters	"Subclasses should override this method when they do not require parameters."	^ true! !!PRAbstractAnnotation class methodsFor: 'testing'!isAbstract	^ self = PRAbstractAnnotation! !!PRAbstractAnnotation class methodsFor: 'constant'!keyValueSeparator	^ $=					! !!PRAbstractAnnotation class methodsFor: 'constant'!markupParameterSeparator	^ $:! !!PRAbstractAnnotation class methodsFor: 'constant'!openingAnnotationString	^ '${'					! !!PRAbstractAnnotation class methodsFor: 'constant'!parameterSeparator	^ $|! !!PRAbstractAnnotation class methodsFor: 'accessing'!possibleParameters	^ #( value )! !!PRAbstractAnnotation class methodsFor: 'protected'!tag	^ self possibleParameters first! !!PRAbstractAnnotation class methodsFor: 'protected'!validateParameters: parameters	| usedKeys |	usedKeys := parameters keys.	usedKeys isEmpty		and: [ self hasParameters				ifTrue: [ PRSyntaxError signal: 'The annotation ' , self tag , 'expect parameters from' , self possibleParameters printString , 'and none where given.' ] ].	(usedKeys allSatisfy: [ :each | self possibleParameters includes: each asSymbol ])		ifFalse:			[ PRSyntaxError signal: 'The key(s) ' , (usedKeys difference: self possibleParameters) printString , '  is not valid for the annotation ' , self tag ].	self hasParameters not and: [ usedKeys ifNotEmpty: [ PRSyntaxError signal: 'The annotation ' , self tag , ' does not expect parameter' ] ]! !!PRAbstractAnnotation class methodsFor: 'protected'!validateParameters: aPRParameters dictionary: parametersDictionary in: anAnnotation	| usedKeys |	usedKeys := parametersDictionary keys.	usedKeys isEmpty and: [ self hasParameters ifTrue: [ PRValidation strategy missingAnnotationParametersIn: anAnnotation ] ].	(usedKeys allSatisfy: [ :each | self possibleParameters includes: each asSymbol ])		ifFalse:			[ PRValidation strategy invalidParameterNames: (usedKeys difference: self possibleParameters) forAnnotation: anAnnotation withParameters: aPRParameters ].	self hasParameters not and: [ usedKeys ifNotEmpty: [ PRValidation strategy unexpectedParameterIn: anAnnotation ] ]! !!PRAbstractAnnotation methodsFor: 'comparing'!= anObject	^ super = anObject and: [ 		self parameters = anObject parameters and: [ 			self hadAllKeys = anObject hadAllKeys and: [ 				self isValid = anObject isValid ] ] ]! !!PRAbstractAnnotation methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitAnnotation: self! !!PRAbstractAnnotation methodsFor: 'rendering'!asPillar	"Return a representation similar to the one used to create the annotation the assumption here is that the parameter dictionary only hold strings."	^ String		streamContents: [ :s | 			s				nextPutAll: self openingAnnotationString;				nextPutAll: self tag.			self hasParameters				ifTrue: [ s nextPut: self markupParameterSeparator.					self asPillarParametersOn: s ].			s nextPutAll: self closingAnnotationString ]! !!PRAbstractAnnotation methodsFor: 'rendering'!asPillarKey: key value: aValue on: aStream	"Output on aStream key = aValue."	aStream		nextPutAll: key;		nextPut: self keyValueSeparator;		nextPutAll: aValue! !!PRAbstractAnnotation methodsFor: 'rendering'!asPillarParametersOn: aStream	| nonDefaultParameters |	nonDefaultParameters := self parameters keys asOrderedCollection.	"nonDefaultParameters remove: self defaultParameterName ifAbsent: [  ]."	"first handle the case of the defaultParameter (which btw can be absent)"	"self parameters		at: self defaultParameterName		ifPresent: [ :v | 			aStream nextPutAll: v asString.			aStream nextPut: self parameterSeparator ]."	"Then the rest"	nonDefaultParameters		do: [ :each | self asPillarKey: each value: ((self parameters at: each) asString) on: aStream ]		separatedBy: [ aStream nextPut: self parameterSeparator ]! !!PRAbstractAnnotation methodsFor: 'initialization'!beInvalid	isValid := false.! !!PRAbstractAnnotation methodsFor: 'rendering'!closingAnnotationString	^ self class closingAnnotationString! !!PRAbstractAnnotation methodsFor: 'rendering'!defaultParameterName	^ self class defaultParameterName	! !!PRAbstractAnnotation methodsFor: 'accessing'!hadAllKeys	^ hadAllKeys ifNil: [ hadAllKeys := true ]! !!PRAbstractAnnotation methodsFor: 'accessing'!hadAllKeys: anObject	hadAllKeys := anObject! !!PRAbstractAnnotation methodsFor: 'comparing'!hash	^ ((super hash 		bitXor: self parameters hash)		bitXor: self hadAllKeys hash)		bitXor: self isValid hash! !!PRAbstractAnnotation methodsFor: 'initialization'!initialize	super initialize.	parameters := OrderedDictionary new.	isValid := true.! !!PRAbstractAnnotation methodsFor: 'testing'!isValid	^ isValid! !!PRAbstractAnnotation methodsFor: 'rendering'!keyValueSeparator	^  self class keyValueSeparator! !!PRAbstractAnnotation methodsFor: 'rendering'!markupParameterSeparator	^ self class markupParameterSeparator! !!PRAbstractAnnotation methodsFor: 'rendering'!openingAnnotationString	^ self class openingAnnotationString! !!PRAbstractAnnotation methodsFor: 'rendering'!parameterSeparator	^  self class parameterSeparator ! !!PRAbstractAnnotation methodsFor: 'accessing'!parameters	^ parameters! !!PRAbstractAnnotation methodsFor: 'accessing'!parameters: aCollection	parameters := aCollection! !!PRAbstractAnnotation methodsFor: 'accessing'!possibleParameters	^ self class possibleParameters! !!PRAbstractAnnotation methodsFor: 'copying'!postCopy	super postCopy.	parameters := parameters copy.	hadAllKeys := hadAllKeys copy! !!PRAbstractAnnotation methodsFor: 'rendering'!tag	^ self class tag! !!PRBeginEnvironmentAnnotation class methodsFor: 'protected'!tag	^ #begin! !!PRBeginEnvironmentAnnotation methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitBeginEnvironmentAnnotation: self! !!PREndEnvironmentAnnotation class methodsFor: 'protected'!tag 	^ #end! !!PREndEnvironmentAnnotation methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitEndEnvironmentAnnotation: self! !!PREnvironmentAnnotation class methodsFor: 'instance creation'!named: aString 		^ self new name: aString; yourself! !!PREnvironmentAnnotation class methodsFor: 'testing'!possibleParameters	^ #(name)! !!PREnvironmentAnnotation class methodsFor: 'testing'!validateParameters: aPRParameters dictionary: parameters in: anInstance	"I do not do any validations.	I allow arbitrary parameters that will be used by my transformers."! !!PREnvironmentAnnotation methodsFor: 'accessing'!name	^ self parameters at: 'name' ifAbsent: [ PREnvironmentMissedNamed signal ]! !!PREnvironmentAnnotation methodsFor: 'accessing'!name: aString 		self parameters at: 'name' put: aString! !!PRMathInTextAnnotation class methodsFor: 'protected'!tag	"For now this is unclear how we will manage it. This is just to make sure that microdown mathInText is converted"	^ #math! !!PRMathInTextAnnotation methodsFor: 'visiting'!accept: aVisitor		^ aVisitor visitMathInTextAnnotation: self! !!PRUndefinedAnnotation class methodsFor: 'visiting'!acceptName: aTag 	^ false! !!PRUndefinedAnnotation class methodsFor: 'protected'!tag	^ 'undefined'! !!PRUndefinedAnnotation class methodsFor: 'instance creation'!withParameters: aPRParameters	^ self new withParameters: aPRParameters! !!PRUndefinedAnnotation methodsFor: 'comparing'!= anObject	^ super = anObject and: [		self tag = anObject tag ]! !!PRUndefinedAnnotation methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitUndefinedAnnotation: self! !!PRUndefinedAnnotation methodsFor: 'comparing'!hash	^ super hash bitXor: self tag hash! !!PRUndefinedAnnotation methodsFor: 'initialization'!initialize	super initialize.	hadAllKeys := true.	tag := self class tag.! !!PRUndefinedAnnotation methodsFor: 'accessing'!tag	^ tag! !!PRUndefinedAnnotation methodsFor: 'accessing'!tag: anObject	tag := anObject! !!PRUndefinedAnnotation methodsFor: 'initialization'!withParameters: aPRParameters 	self add: aPRParameters.	self parameters: aPRParameters asDictionary! !!PRDocument methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitDocument: self! !!PRDocument methodsFor: 'common-properties'!authors	^ self propertyAt: 'authors' ifAbsent: [ self defaultAuthors ]! !!PRDocument methodsFor: 'common-properties'!date	^ (self propertyAt: 'date' ifAbsent: [ self defaultDate ]) asDate! !!PRDocument methodsFor: 'common-defaults'!defaultAuthors	^ ''! !!PRDocument methodsFor: 'common-defaults'!defaultDate	^ Date today! !!PRDocument methodsFor: 'common-defaults'!defaultNext	^ nil! !!PRDocument methodsFor: 'pillar integration'!includeFor: aFile	| inclusionVisitor |	inclusionVisitor := PRFileInclusion new.	inclusionVisitor topFile: aFile file.	^ inclusionVisitor start: (PRCleanAnnotationInParagraphTransformer new start: self).! !!PRDocument methodsFor: 'common-properties'!next	^ self propertyAt: 'next' ifAbsent: [ self defaultNext ]! !!PRDocument methodsFor: 'common-properties'!next: aDocument	^ self propertyAt: 'next' put: aDocument! !!PRDocument methodsFor: 'pillar integration'!transformDocumentFor: aPRPDFDocument	"This is a hook to be able to have framework specific transformation hooks.	see PRAbstractOutputDocument>>#buildOn:"		^ aPRPDFDocument transformDocument: self! !!PRDocumentGroup class methodsFor: 'testing'!isAbstract 	^ false! !!PRDocumentGroup class methodsFor: 'instance creation'!with: aDocumentItem	^ self new		add: aDocumentItem;		yourself! !!PRDocumentGroup class methodsFor: 'instance creation'!withAll: aCollection	^ self new		addAll: aCollection;		yourself! !!PRDocumentGroup methodsFor: 'comparing'!= anObject	^ super = anObject		and: [ self children = anObject children ]! !!PRDocumentGroup methodsFor: 'visiting'!accept: aVisitor	<ignoreForCoverage "This method is ignored for test coverage because it is overriden in all subclasses and these subclasses don't need to do a super-send.">	^ aVisitor visitDocumentGroup: self! !!PRDocumentGroup methodsFor: 'adding'!add: aDocumentItem	aDocumentItem parent: self. 	self setChildren: (self children copyWith: aDocumentItem)! !!PRDocumentGroup methodsFor: 'adding'!addAll: aCollection	self setChildren: self children , aCollection! !!PRDocumentGroup methodsFor: 'accessing'!children	"Answer the children of the receiver."	^ children! !!PRDocumentGroup methodsFor: 'testing'!hasChildren	^ self children isNotEmpty! !!PRDocumentGroup methodsFor: 'comparing'!hash	^ super hash bitXor: self children hash! !!PRDocumentGroup methodsFor: 'initialization'!initialize	super initialize.	self setChildren: #()! !!PRDocumentGroup methodsFor: 'testing'!isGroup	^true! !!PRDocumentGroup methodsFor: 'copying'!postCopy	super postCopy.	self setChildren: (self children		collect: [ :each | each copy ])! !!PRDocumentGroup methodsFor: 'initialization'!setChildren: aCollection	children := aCollection! !!PRDocumentGroup methodsFor: 'accessing-dynamic'!size	^ self children size! !!PRDocumentGroup methodsFor: 'accessing-dynamic'!text	^ String streamContents: [ :stream |		self children do: [ :each |			stream nextPutAll: each text ] ]! !!PREnvironment class methodsFor: 'instance creation'!named: aString 		^ self new name: aString; yourself! !!PREnvironment methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitEnvironment: self! !!PREnvironment methodsFor: 'initialization'!initialize	super initialize.	parameters := OrderedDictionary new! !!PREnvironment methodsFor: 'accessing'!name	^ name! !!PREnvironment methodsFor: 'accessing'!name: aString 		name := aString! !!PREnvironment methodsFor: 'accessing-parameters'!parameters	^ parameters! !!PREnvironment methodsFor: 'accessing-parameters'!parameters: anOrderedDictionary	parameters := anOrderedDictionary! !!PREnvironment methodsFor: 'visiting'!printOn: aStream		super printOn: aStream.	aStream nextPut: $(; print: self name; nextPut: $)! !!PRMathEnvironment methodsFor: 'accessing-parameters'!accept: aVisitor	^ aVisitor visitMathEnvironment: self! !!PRMathEnvironment methodsFor: 'visiting'!caption 	^ self parameters at: 'caption'! !!PRMathEnvironment methodsFor: 'accessing-parameters'!text 	^ self children first text! !!PRBoldFormat methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitBoldFormat: self! !!PRFormat methodsFor: 'visiting'!accept: aVisitor	<ignoreForCoverage "This method is ignored for test coverage because it is overriden in all subclasses and these subclasses don't need to do a super-send.">	^ aVisitor visitFormat: self! !!PRItalicFormat methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitItalicFormat: self! !!PRMonospaceFormat methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitMonospaceFormat: self! !!PRStrikethroughFormat methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitStrikethroughFormat: self! !!PRHeader class methodsFor: 'instance creation'!withAll: aCollection level: anInteger	^ (self withAll: aCollection)		level: anInteger;		yourself! !!PRHeader methodsFor: 'comparing'!= anObject	^ super = anObject		and: [ self level = anObject level ]! !!PRHeader methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitHeader: self! !!PRHeader methodsFor: 'comparing'!hash	^ super hash bitXor: self level hash! !!PRHeader methodsFor: 'accessing'!headerText	^ self children first text! !!PRHeader methodsFor: 'testing'!isHeader	^ true! !!PRHeader methodsFor: 'accessing'!level	^ level! !!PRHeader methodsFor: 'accessing'!level: anInteger	level := anInteger! !!PRList methodsFor: 'visiting'!accept: aVisitor	<ignoreForCoverage "This method is ignored for test coverage because it is overriden in all subclasses and these subclasses don't need to do a super-send.">	^ aVisitor visitList: self! !!PROrderedList methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitOrderedList: self! !!PRUnorderedList methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitUnorderedList: self! !!PRListItem methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitListItem: self! !!PRAnnotatedParagraph class methodsFor: 'instance creation'!withAll: aCollection annotation: aString	^ (self withAll: aCollection)		annotation: aString;		yourself! !!PRAnnotatedParagraph methodsFor: 'comparing'!= anObject	^ super = anObject and: [ self annotation = anObject annotation ]! !!PRAnnotatedParagraph methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitAnnotatedParagraph: self! !!PRAnnotatedParagraph methodsFor: 'accessing'!annotation	^ annotation! !!PRAnnotatedParagraph methodsFor: 'accessing'!annotation: aString	annotation := aString! !!PRAnnotatedParagraph methodsFor: 'comparing'!hash	^ super hash bitXor: self annotation hash! !!PREmptyParagraph methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitEmptyParagraph: self! !!PRParagraph methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitParagraph: self! !!PRParameter class methodsFor: 'instance creation'!keyNode: aParameterKey valueNode: aParameterValue 	| anInstance |	anInstance := self new.	anInstance add: aParameterKey.	anInstance add: aParameterValue.	^ anInstance ! !!PRParameter methodsFor: 'comparing'!= anObject	^ super = anObject and: [ self isValid = anObject isValid ]! !!PRParameter methodsFor: 'visitor'!accept: aVisitor	^ aVisitor visitParameter: self! !!PRParameter methodsFor: 'initialization'!beInvalid	isValid := false! !!PRParameter methodsFor: 'initialization'!initialize	super initialize.	isValid := true.! !!PRParameter methodsFor: 'testing'!isValid	^ isValid! !!PRParameter methodsFor: 'accessing'!key	^ self keyNode name! !!PRParameter methodsFor: 'accessing'!keyNode	^ self children first! !!PRParameter methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' key: '; print: self key! !!PRParameter methodsFor: 'accessing'!value	^ self valueNode value! !!PRParameter methodsFor: 'accessing'!valueNode	^ self children second! !!PRParameters class methodsFor: 'as yet unclassified'!with: aPRParameter withAll: aCollection 	| anInstance |	anInstance := self new.	aPRParameter ifNotNil: [ anInstance add: aPRParameter ].	aCollection ifNotNil: [ anInstance addAll: aCollection ].	^ anInstance! !!PRParameters methodsFor: 'visitor'!accept: aVisitor	^ aVisitor visitParameters: self! !!PRParameters methodsFor: 'converting'!asDictionary	| dict |	dict := OrderedDictionary new.	self children do: [ :each | dict at: each key put: each value ].	^ dict! !!PRParameters methodsFor: 'accessing'!parameters 	^ children! !!PRPreformatted methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitPreformatted: self! !!PRPreformatted methodsFor: 'accessing-dynamic'!text	"the text of a preformatted should not be the concatenation of children."		^ String streamContents: [ :stream |		self children 			do: [ :each | stream nextPutAll: each text ] 			separatedBy: [ stream cr ] ]! !!PRFigure class methodsFor: 'testing'!extensionOf: aString isOneOf: extensions	| extension |	extension := (aString splitOn: $.) last asLowercase.	^ extensions includes: extension! !!PRFigure class methodsFor: 'testing'!isValidReference: aString	^ (self extensionOf: aString isOneOf: self pictureExtensions)		and: [ aString includesSubstring: '://' caseSensitive: true ]! !!PRFigure class methodsFor: 'private'!pictureExtensions	^ #('png' 'jpg' 'jpeg' 'pdf')! !!PRFigure methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitFigure: self! !!PRFigure methodsFor: 'testing'!hasCaption	^ self hasChildren! !!PRFigure methodsFor: 'testing'!hasFigureExtension	^ self class pictureExtensions includes: self reference asFileReference extension! !!PRFigure methodsFor: 'testing'!hasLabel	^ self label isNotNil! !!PRFigure methodsFor: 'accessing'!label	^ self parameters at: 'label' ifAbsent: [ nil ]! !!PRFigure methodsFor: 'accessing'!label: aString	self parameters at: 'label' put: aString! !!PRFigure methodsFor: 'as yet unclassified'!pathInternFile	| path |	path := self reference.	(path beginsWith: 'file://') ifTrue: [ path := path allButFirst: 7 ].	^ path! !!PRExternalLink class methodsFor: 'testing'!isAbstract	^ false! !!PRExternalLink class methodsFor: 'testing'!isValidReference: aString	^ aString includesSubstring: '://' caseSensitive: true! !!PRExternalLink class methodsFor: 'accessing'!priority	^ 25! !!PRExternalLink methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitExternalLink: self! !!PRExternalLink methodsFor: 'testing'!isExternal	^ true! !!PRExternalLink methodsFor: 'accessing'!localFileOrExternalReference	^ self class localFileOrExternalReference: self url! !!PRExternalLink methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream space ; nextPut: $* ; nextPutAll: self url; nextPut: $*! !!PRExternalLink methodsFor: 'accessing'!url	"Answer the URL the receiver is pointing to."	^ self urlPrefix , self urlEntry , self urlPostfix! !!PRExternalLink methodsFor: 'accessing-dynamic'!urlEntry	^ self reference! !!PRExternalLink methodsFor: 'accessing-dynamic'!urlPostfix	^ ''! !!PRExternalLink methodsFor: 'accessing-dynamic'!urlPrefix	^ ''! !!PRMailLink class methodsFor: 'testing'!isValidReference: aString	| index |	index := aString indexOf: $@ ifAbsent: [ ^ false ].	index := aString indexOf: $. startingAt: index ifAbsent: [ ^ false ].	^ aString allSatisfy: [ :each | each isAlphaNumeric or: [ '@-.' includes: each ] ]! !!PRMailLink class methodsFor: 'accessing'!priority	^ 50! !!PRMailLink methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitMailLink: self! !!PRMailLink methodsFor: 'accessing-dynamic'!scrambledUrl	^ self url! !!PRMailLink methodsFor: 'accessing-dynamic'!unscrambledUrl	^ self urlPrefix, super urlEntry, self urlPostfix! !!PRMailLink methodsFor: 'accessing-dynamic'!urlEntry	^ String streamContents: [ :stream |		super urlEntry do: [ :each |			(1 to: 2) atRandom = 1				ifTrue: [ stream nextPut: each ]				ifFalse: [ stream nextPut: $%; nextPutAll: ((each codePoint printStringBase: 16)		padLeftTo: 2 with: $0) ] ] ]! !!PRMailLink methodsFor: 'accessing-dynamic'!urlPrefix	^ 'mailto:'! !!PRInternalLink class methodsFor: 'testing'!isAbstract	^ false! !!PRInternalLink class methodsFor: 'testing'!isValidReference: aString	^ true! !!PRInternalLink class methodsFor: 'accessing'!priority	^ 100! !!PRInternalLink class methodsFor: 'instance creation'!reference: aString	| index |	^ (index := aString indexOf: $@) isZero		ifTrue: [ super reference: aString ]		ifFalse: [ 			index = 1				ifTrue: [ self new anchor: (aString copyFrom: index + 1 to: aString size) ]				ifFalse: [ 					self new						reference: (aString copyFrom: 1 to: index - 1);						anchor: (aString copyFrom: index + 1 to: aString size);						yourself ] ]! !!PRInternalLink methodsFor: 'comparing'!= anObject	^ super = anObject		and: [ self anchor = anObject anchor ]! !!PRInternalLink methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitInternalLink: self! !!PRInternalLink methodsFor: 'accessing'!anchor	"Answer an anchor string the receiver is pointing to."	^ anchor! !!PRInternalLink methodsFor: 'accessing'!anchor: aString	anchor := aString trimBoth! !!PRInternalLink methodsFor: 'testing'!hasAnchor	^ self anchor isNotNil! !!PRInternalLink methodsFor: 'testing'!hasReference	^ self reference isNotNil! !!PRInternalLink methodsFor: 'comparing'!hash	^ super hash bitXor: self anchor hash! !!PRInternalLink methodsFor: 'testing'!isInternal	^ true! !!PRInternalLink methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream space ; nextPutAll: '*@'; nextPutAll: anchor; nextPut: $*! !!PRInternalLink methodsFor: 'accessing'!renderAsText	| text |	text := String new writeStream.	self reference ifNotNil: [ :ref | text nextPutAll: ref ].	self hasAnchor		ifTrue: [ text				nextPutAll: '@';				nextPutAll: self anchor ].	^ text contents! !!PRLink class methodsFor: 'instance creation'!fromReference: aReference	| classes  |	classes := PRLink withAllConcreteClasses select: [ :each | each isValidReference: aReference ].	classes sort: [ :a :b | a priority < b priority ].	^ classes first reference: aReference! !!PRLink class methodsFor: 'testing'!isAbstract 	^ true! !!PRLink class methodsFor: 'accessing'!priority	^ 0! !!PRLink methodsFor: 'visiting'!accept: aVisitor	<ignoreForCoverage "This method is ignored for test coverage because it is overriden in all subclasses and these subclasses don't need to do a super-send.">	^ aVisitor visitLink: self! !!PRLink methodsFor: 'testing'!isBroken	"Answer ==true== if the receiver is broken."	^ false! !!PRLink methodsFor: 'testing'!isExternal	^ false! !!PRLink methodsFor: 'testing'!isInternal	^ false! !!PRLink methodsFor: 'testing'!isLink	^ true! !!PRLink methodsFor: 'accessing'!renderAsText	^ self reference! !!PRLink methodsFor: 'accessing'!title	^ self renderAsText ifEmpty: [ nil ] ifNotEmpty: #yourself! !!PRReference class methodsFor: 'testing'!isValidReference: aString	self subclassResponsibility! !!PRReference class methodsFor: 'private'!localFileOrExternalReference: aString	| localFileIndicator |	localFileIndicator := 'file://'.	^ (aString beginsWith: localFileIndicator)			ifTrue: [ aString allButFirst: localFileIndicator size ]			ifFalse: [ aString ]! !!PRReference class methodsFor: 'instance creation'!reference: aString	^ self new		reference: aString;		yourself! !!PRReference methodsFor: 'comparing'!= anObject	^ super = anObject and: [ self reference = anObject reference and: [ self parameters = anObject parameters ] ]! !!PRReference methodsFor: 'visiting'!accept: aVisitor	<ignoreForCoverage "This method is ignored for test coverage because it is overriden in all subclasses and these subclasses don't need to do a super-send.">	^ aVisitor visitReference: self! !!PRReference methodsFor: 'accessing-dynamic'!alias	"Answer the alias of the receiver or an empty string if none."	^ self text! !!PRReference methodsFor: 'testing'!hasAlias	^ self hasChildren! !!PRReference methodsFor: 'testing'!hasAnchor	^ false! !!PRReference methodsFor: 'comparing'!hash	^ super hash bitXor: self reference hash! !!PRReference methodsFor: 'initialization'!initialize	super initialize.	self parameters: OrderedDictionary new! !!PRReference methodsFor: 'accessing'!localFileOrExternalReference	^ self class localFileOrExternalReference: self reference! !!PRReference methodsFor: 'accessing-parameters'!parameters	"Answer an array of parameters."	^ parameters! !!PRReference methodsFor: 'accessing'!parameters: aCollection	parameters := aCollection! !!PRReference methodsFor: 'copying'!postCopy	super postCopy.	self parameters: (self parameters		collect: [ :each | each copy ])! !!PRReference methodsFor: 'accessing'!reference	"Answer the reference of the receiver."	^ reference! !!PRReference methodsFor: 'accessing'!reference: aString	reference := aString! !!PRReference methodsFor: 'accessing-dynamic'!text	^ super text ifEmpty: [ self reference asString ] ifNotEmpty: #yourself! !!PRReference methodsFor: 'accessing'!title	"Answer a title of the reference, this is should never be nil."	^ self reference! !!PRSection methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitSection: self! !!PRTable methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitTable: self! !!PRTable methodsFor: 'accessing'!columnCount	^ self children inject: 0 into: [ :max :row | max max: row columnCount ]! !!PRTable methodsFor: 'accessing'!rowCount	^ self children size! !!PRTableCell class methodsFor: 'instance creation'!align: aSymbolePosition heading: aBoolean withAll: aCollection	^ (self withAll: aCollection)		align: aSymbolePosition;		heading: aBoolean;		yourself! !!PRTableCell methodsFor: 'comparing'!= anObject	^ super = anObject		and: [ self align = anObject align		and: [ self heading = anObject heading ] ]! !!PRTableCell methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitTableCell: self! !!PRTableCell methodsFor: 'accessing'!align	^ align! !!PRTableCell methodsFor: 'accessing'!align: aSymbol	align := aSymbol! !!PRTableCell methodsFor: 'actions'!beAlignedCenter	self align: #center! !!PRTableCell methodsFor: 'actions'!beAlignedLeft	self align: #left! !!PRTableCell methodsFor: 'actions'!beAlignedRight	self align: #right! !!PRTableCell methodsFor: 'actions'!beHeading	self heading: true! !!PRTableCell methodsFor: 'comparing'!hash	^ super hash bitXor: self align hash! !!PRTableCell methodsFor: 'accessing'!heading	^ heading! !!PRTableCell methodsFor: 'accessing'!heading: aBoolean	heading := aBoolean! !!PRTableCell methodsFor: 'initialization'!initialize	super initialize.	heading := false! !!PRTableCell methodsFor: 'testing'!isAligned	^ self align isNotNil! !!PRTableCell methodsFor: 'testing'!isAlignedCenter	^ self align = #center! !!PRTableCell methodsFor: 'testing'!isAlignedLeft	^ self align = #left! !!PRTableCell methodsFor: 'testing'!isAlignedRight	^ self align = #right! !!PRTableCell methodsFor: 'testing'!isHeading	^ self heading! !!PRTableRow methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitTableRow: self! !!PRTableRow methodsFor: 'accessing'!columnCount	^ self children size! !!PRTableRow methodsFor: 'testing'!isHeading	"For a row to be considered a heading row, all cells must be either heading or empty. A totally empty row is not considered a heading row."	^ (self children anySatisfy: [ :cell | cell hasChildren ])		and: [ self children allSatisfy: [ :cell | cell isHeading or: [ cell hasChildren not ] ] ]! !!PRDocumentItem methodsFor: 'comparing'!= anObject	^ self species = anObject species! !!PRDocumentItem methodsFor: 'visiting'!accept: aVisitor	<ignoreForCoverage "This method is ignored for test coverage because it is overriden in all subclasses and these subclasses don't need to do a super-send.">	^ aVisitor visitDocumentItem: self! !!PRDocumentItem methodsFor: 'accessing'!counter	^ counter! !!PRDocumentItem methodsFor: 'accessing'!counter: anObject	counter := anObject! !!PRDocumentItem methodsFor: 'gt-inspection'!gtInspectPillarModel: composite	<gtInspectorPresentationOrder: 50>		composite tree		shouldValidate: false;		title: 'Model';		display: [ :each | each hasChildren ifTrue: [ each children ] ifFalse: [ #() ] ];		children: [ :each | each hasChildren ifTrue: [ each children ] ifFalse: [ #() ] ];		format: [ :each | (each class name withoutPrefix: 'PR'), ' - ', (each text contractTo: 50)] ! !!PRDocumentItem methodsFor: 'testing'!hasChildren	^ false! !!PRDocumentItem methodsFor: 'comparing'!hash	^ self species hash! !!PRDocumentItem methodsFor: 'initialization'!initialize	super initialize.	counter := PRNotFoundCounter maxLevel: 5! !!PRDocumentItem methodsFor: 'testing'!isDocument	^self class = PRDocument! !!PRDocumentItem methodsFor: 'testing'!isGroup	^false! !!PRDocumentItem methodsFor: 'testing'!isHeader	^ false! !!PRDocumentItem methodsFor: 'testing'!isLink	^ false! !!PRDocumentItem methodsFor: 'accessing'!parent	^ parent! !!PRDocumentItem methodsFor: 'accessing'!parent: aDocumentGroup	parent := aDocumentGroup! !!PRDocumentItem methodsFor: 'helpers'!parser  ^ self class parser! !!PRDocumentItem methodsFor: 'accessing'!start	^ start! !!PRDocumentItem methodsFor: 'accessing'!start: anObject	start := anObject! !!PRDocumentItem methodsFor: 'accessing'!stop	^ stop! !!PRDocumentItem methodsFor: 'accessing'!stop: anObject	stop := anObject! !!PRDocumentItem methodsFor: 'accessing-dynamic'!text	"Answer a string representation of the receiver."	^ String new! !!PRHorizontalRule class methodsFor: 'testing'!isAbstract	^ false! !!PRHorizontalRule methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitHorizontalRule: self! !!PRLineBreak class methodsFor: 'testing'!isAbstract	^ false! !!PRLineBreak methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitLineBreak: self! !!PRMetadata class methodsFor: 'testing'!isAbstract	^ false! !!PRMetadata methodsFor: 'initialization'!accept: aVisitor	^ aVisitor visitMetadata: self! !!PRMetadata methodsFor: 'initialization'!initialize 	super initialize.	metadata := Dictionary new! !!PRMetadata methodsFor: 'as yet unclassified'!metaData	^ metadata! !!PRMetadata methodsFor: 'initialization'!metadata: aDictionary	metadata := aDictionary! !!PRParameterKey class methodsFor: 'testing'!isAbstract	^ false! !!PRParameterKey class methodsFor: 'instance creation'!named: aString 	^ self new name: aString asSymbol! !!PRParameterKey methodsFor: 'comparing'!= anObject	^ super = anObject and: [ 		self name = anObject name ]! !!PRParameterKey methodsFor: 'visitor'!accept: aVisitor	^ aVisitor visitParameterKey: self! !!PRParameterKey methodsFor: 'comparing'!hash	^ super hash bitXor: self name hash! !!PRParameterKey methodsFor: 'accessing'!name	^ name! !!PRParameterKey methodsFor: 'accessing'!name: anObject	name := anObject! !!PRParameterValue class methodsFor: 'testing'!isAbstract	^ false! !!PRParameterValue class methodsFor: 'instance creation'!value: aString 	^ self new value: aString! !!PRParameterValue methodsFor: 'comparing'!= anObject	^ super = anObject and: [ 		self value = anObject value ]! !!PRParameterValue methodsFor: 'visitor'!accept: aVisitor	^ aVisitor visitParameterValue: self! !!PRParameterValue methodsFor: 'comparing'!hash	^ super hash bitXor: self value hash! !!PRParameterValue methodsFor: 'accessing'!value	^ value! !!PRParameterValue methodsFor: 'accessing'!value: anObject	value := anObject! !!PRCodeblock class methodsFor: 'instance creation'!content: aString parameters: parameterDictionary	"The pillar parser is sending us bogus parameters in the form of an orderedDictionary containing ('' -> true)	Since we do not know how to fix the parser we block the propagation of bogus parameters here."		| param | 	param := parameterDictionary.	parameterDictionary isNotEmpty 		and: [ parameterDictionary at: '' ifPresent: [ param := OrderedDictionary new ] ].			^ (self content: aString)		parameters: param;		yourself! !!PRCodeblock methodsFor: 'comparing'!= anObject	"We use the method language to be sure that the language is a PRAbstractScriptLanguage and not a string."		^ super = anObject		and: [ 			self language.			anObject language.			self parameters = anObject parameters ]! !!PRCodeblock methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitCodeblock: self! !!PRCodeblock methodsFor: 'accessing-delegated'!caption	"This method should be named: setAndReturnCaption"	self flag: #fixme. 	^ caption		ifNil: [ 			self setCaption: (self						parameters 							at: 'caption'							ifPresent: [ :string | (PRDocument parser parse: string) children first ]							ifAbsent: [ self defaultCaptionWhenEmpty ]).			caption ]! !!PRCodeblock methodsFor: 'accessing-delegated'!caption: aString	"this method should be named: updateCaptionInParameters"	self flag: #fixme.	parameters := self parameters copyWith: 'caption' -> aString! !!PRCodeblock methodsFor: 'accessing-delegated'!defaultCaptionWhenEmpty	"When there is no caption and still we asked for it, the class sets the defaultCaptionWhenEmpty as caption.	"	^ PRParagraph with: (PRText content: '')! !!PRCodeblock methodsFor: 'accessing-delegated'!eval: aString	parameters := parameters copyWith: 'eval' -> aString! !!PRCodeblock methodsFor: 'accessing'!firstLine: aString	parameters := parameters copyWith: 'firstLine' -> aString! !!PRCodeblock methodsFor: 'accessing'!fromFile: aString	parameters := parameters copyWith: 'fromFile' -> aString! !!PRCodeblock methodsFor: 'testing'!hasCaption	^ self parameters at: 'caption' ifPresent: [ :param | param isEmptyOrNil not ] ifAbsent: [ false ]! !!PRCodeblock methodsFor: 'testing'!hasLabel	| label |	label := self parameters at: 'label' ifAbsent: [ ^ false ].	^ label isEmptyOrNil not! !!PRCodeblock methodsFor: 'testing'!hasNoCode	^ (self text copyWithout: Character tab) isEmpty! !!PRCodeblock methodsFor: 'testing'!hasShortCaption	^ self parameters at: 'shortCaption'		ifPresent: [ :param | param isEmptyOrNil not ]		ifAbsent: [ false ]! !!PRCodeblock methodsFor: 'comparing'!hash	^ super hash bitXor: self properties hash! !!PRCodeblock methodsFor: 'accessing-delegated'!hideable: aString	parameters := parameters copyWith: 'hideable' -> aString! !!PRCodeblock methodsFor: 'initialization'!initialize	super initialize.	parameters := OrderedDictionary new! !!PRCodeblock methodsFor: 'testing'!isEvaluated	^ self parameters at: 'eval' ifAbsent: [ false ]! !!PRCodeblock methodsFor: 'testing'!isHideable	^ self parameters at: 'hideable' ifPresent: [ :hideable | hideable = 'true' or: [ hideable = true ] ] ifAbsent: [ false ]! !!PRCodeblock methodsFor: 'testing'!isStructure	^ self parameters includesKey: 'structure'! !!PRCodeblock methodsFor: 'accessing-delegated'!label	^ self parameters at: 'label' ifAbsent: ['']! !!PRCodeblock methodsFor: 'accessing-delegated'!label: aString	parameters := parameters copyWith: 'label' -> aString! !!PRCodeblock methodsFor: 'accessing-delegated'!language	^ self		parameters at: 'language'		ifPresent: [ :language | 			language isString				ifTrue: [ 					| realObject |					realObject := PRAbstractScriptLanguage for: language.					self language: realObject.					realObject ]				ifFalse: [ language ] ]		ifAbsent: [ PRUnspecifiedScriptLanguage default ]! !!PRCodeblock methodsFor: 'accessing-delegated'!language: aLanguage	self parameters at: 'language' put: aLanguage! !!PRCodeblock methodsFor: 'accessing'!lastLine: aString	parameters := parameters copyWith: 'lastLine' -> aString! !!PRCodeblock methodsFor: 'accessing'!lineNumber: aString	parameters := parameters copyWith: 'lineNumber' -> aString! !!PRCodeblock methodsFor: 'accessing-parameters'!parameters	^ parameters! !!PRCodeblock methodsFor: 'accessing-parameters'!parameters: aCollection	parameters := aCollection! !!PRCodeblock methodsFor: 'operations'!removePossibleParagraph: content	^ content first class = PRParagraph		ifTrue:[ content first children ] 		ifFalse: [ content ]! !!PRCodeblock methodsFor: 'accessing-delegated'!setCaption: aParagraph	"pay attention this is the not the same than the setter"		caption := aParagraph! !!PRCodeblock methodsFor: 'accessing-delegated'!shortCaption	^ self parameters at: 'shortCaption' ifAbsent: ['']! !!PRCodeblock methodsFor: 'accessing-delegated'!shortCaption: aString 	parameters := parameters copyWith: 'shortCaption' -> aString! !!PRCodeblock methodsFor: 'testing'!structureName	^ self parameters at: 'structure'! !!PRCodeblock methodsFor: 'testing'!structureName: aName	^ self parameters at: 'structure' put: aName! !!PRCodeblock methodsFor: 'accessing'!text: aString	super text: aString withoutTrailingNewlines! !!PRCommentedLine methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitCommentedLine: self! !!PRRaw class methodsFor: 'instance creation'!content: aString type: aTypeString	^ (self content: aString)		type: aTypeString;		yourself! !!PRRaw class methodsFor: 'accessing'!verbatimTypeSeparator	^ ':'! !!PRRaw class methodsFor: 'accessing'!verbatimTypes	"The verbatim types to be recognized, for now this is hardcoded."		^ #('text' 'html' 'latex' 'markdown')! !!PRRaw methodsFor: 'comparing'!= anObject	^ super = anObject and: [ self type = anObject type ]! !!PRRaw methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitRaw: self! !!PRRaw methodsFor: 'comparing'!hash	^ super hash bitXor: self type hash! !!PRRaw methodsFor: 'testing'!isForType: aSymbol	^ self type isNil or: [ self type = aSymbol ]! !!PRRaw methodsFor: 'accessing'!type	^ type! !!PRRaw methodsFor: 'accessing'!type: aString	type := aString! !!PRText class methodsFor: 'instance creation'!content: aString	^ self new text: aString! !!PRText class methodsFor: 'testing'!isAbstract	^ false! !!PRText methodsFor: 'comparing'!= anObject	^ super = anObject		and: [ self text = anObject text ]! !!PRText methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitText: self! !!PRText methodsFor: 'comparing'!hash	^ super hash bitXor: self text hash! !!PRText methodsFor: 'testing'!isText	^ self class name = #PRText! !!PRText methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' text: '; print: self text! !!PRText methodsFor: 'accessing'!text	"Answer the string the receiver is representing."	^ text! !!PRText methodsFor: 'accessing'!text: aString	text := aString! !!PRObject class methodsFor: 'testing'!isAbstract	^ true! !!PRObject class methodsFor: 'instance creation'!new	"Create a new instance of this class and checks if it isn't abstract."	self isAbstract		ifTrue: [ self error: self name , ' is abstract.' ].	^ super new! !!PRObject class methodsFor: 'reflection'!withAllConcreteClasses	^ Array streamContents: [ :stream |		self withAllConcreteClassesDo: [ :each |			stream nextPut: each ] ]! !!PRObject class methodsFor: 'reflection'!withAllConcreteClassesDo: aBlock	self		withAllSubclassesDo: [ :each | 			each isAbstract				ifFalse: [ aBlock value: each ] ]! !!PRObject methodsFor: 'visiting'!accept: aVisitor	<ignoreForCoverage>	"Dispatch to ==aVisitor== depending on the receiver."! !!PRObject methodsFor: 'accessing'!children	^ #()! !!PRObject methodsFor: 'private'!errorPropertyNotFound: aSelector	PRPropertyError signal: 'Property ' , aSelector , ' not found.'! !!PRObject methodsFor: 'testing'!hasProperty: aKey	"Test if the property ==aKey== is defined within the receiver."	^ self properties includesKey: aKey! !!PRObject methodsFor: 'copying'!postCopy	super postCopy.	properties := properties copy! !!PRObject methodsFor: 'printing'!printOn: aStream	<ignoreForCoverage>	super printOn: aStream.	aStream nextPut: $[; print: self identityHash; nextPut: $]! !!PRObject methodsFor: 'accessing-properties'!properties	"Answer the property dictionary of the receiver."	^ properties ifNil: [ properties := Dictionary new ]! !!PRObject methodsFor: 'accessing-properties'!properties: aDictionary		properties := aDictionary! !!PRObject methodsFor: 'accessing-properties'!propertyAt: aKey	"Answer the value of the property ==aKey==, raises an error if the property doesn't exist."	^ self propertyAt: aKey ifAbsent: [ self errorPropertyNotFound: aKey ]! !!PRObject methodsFor: 'accessing-properties'!propertyAt: aKey ifAbsent: aBlock	"Answer the value of the property ==aKey==, or the result of ==aBlock== if the property doesn't exist."	^ self properties at: aKey ifAbsent: aBlock! !!PRObject methodsFor: 'accessing-properties'!propertyAt: aKey ifAbsentPut: aBlock	"Answer the value of the property ==aKey==, or if the property doesn't exist adds and answers the result of evaluating ==aBlock==."	^ self properties at: aKey ifAbsentPut: aBlock! !!PRObject methodsFor: 'accessing-properties'!propertyAt: aKey put: aValue	"Adds or replaces the property ==aKey== with ==aValue==."	^ self properties at: aKey put: aValue! !!PRVisitor methodsFor: 'visiting'!start: anObject	^ self visit: anObject! !!PRVisitor methodsFor: 'visiting'!visit: anObject	^ anObject acceptDecorated: self! !!PRVisitor methodsFor: 'visiting'!visitAll: aCollection	^aCollection collect: [ :each | self visit: each ]! !!PRVisitor methodsFor: 'visiting'!visitAll: aCollection separatedBy: aBlock	aCollection do: [ :each | self visit: each ] separatedBy: aBlock! !!PRVisitor methodsFor: 'visiting-document'!visitAnchor: anObject	^ self visitDocumentItem: anObject! !!PRVisitor methodsFor: 'visiting-document'!visitAnnotatedParagraph: aDocument	^ self visitParagraph: aDocument! !!PRVisitor methodsFor: 'visiting-annotations'!visitAnnotation: anAnnotation	"Visiting an annotation means that we visit the textual representation of an annotation. Such annotations will be transformed into annotation object. The corresponding visit method will be invoked on such object : visitCitationAnnotation vs visitCitation."	^ self visitDocumentGroup: anAnnotation! !!PRVisitor methodsFor: 'visiting-annotations'!visitBeginEnvironmentAnnotation: aBeginEnvironmentAnnotation	"Visiting an annotation means that we visit the textual representation of an annotation. Such annotations will be transformed into annotation object. The corresponding visit method will be invoked on such object : visitBeginEnvironmentAnnotation vs visitBeginEnvironment."	^ self visitAnnotation: aBeginEnvironmentAnnotation! !!PRVisitor methodsFor: 'visiting-document'!visitBoldFormat: anObject	^ self visitFormat: anObject! !!PRVisitor methodsFor: 'visiting-document'!visitCodeblock: aCodeBlock 	^ self visitText: aCodeBlock! !!PRVisitor methodsFor: 'visiting-document'!visitCommentedLine: aCommentedLine! !!PRVisitor methodsFor: 'visiting-document'!visitDataItem: anObject	^ self visitListItem: anObject! !!PRVisitor methodsFor: 'visiting-document'!visitDefinitionList: anObject	^ self visitList: anObject! !!PRVisitor methodsFor: 'visiting-document'!visitDocument: anObject	^ self visitDocumentGroup: anObject! !!PRVisitor methodsFor: 'visiting-document'!visitDocumentGroup: anObject	^ self visitAll: anObject children! !!PRVisitor methodsFor: 'visiting-document'!visitDocumentItem: anObject! !!PRVisitor methodsFor: 'visiting-document'!visitEmptyParagraph: anObject	<ignoreForCoverage "This method is ignored for coverage because visiting an empty paragraph is typically very much different from visiting a paragraph.">		^ self visitParagraph: anObject! !!PRVisitor methodsFor: 'visiting-document'!visitEnvironment: anEnvironment	"An environment object has been created based on the begin and end annotations.	My subclasses may want to introduce a preAction and postAction triggering. By default just visit all children."	self visitParameters: anEnvironment parameters.	^ self visitDocumentGroup: anEnvironment! !!PRVisitor methodsFor: 'visiting-document'!visitExternalLink: anObject	^ self visitLink: anObject! !!PRVisitor methodsFor: 'visiting-document'!visitFigure: anObject	^ self visitReference: anObject! !!PRVisitor methodsFor: 'visiting-document'!visitFormat: anObject	^ self visitDocumentGroup: anObject! !!PRVisitor methodsFor: 'visiting-document'!visitHeader: anObject	^ self visitDocumentGroup: anObject! !!PRVisitor methodsFor: 'visiting-document'!visitHorizontalRule: anObject	^ self visitDocumentItem: anObject! !!PRVisitor methodsFor: 'visiting-document'!visitInternalLink: anObject	^ self visitLink: anObject! !!PRVisitor methodsFor: 'visiting-document'!visitItalicFormat: anObject	^ self visitFormat: anObject! !!PRVisitor methodsFor: 'visiting-document'!visitLineBreak: anObject	<ignoreForCoverage "This method is ignored for coverage because visiting a line break is typically very much different from visiting a standard document item.">	^ self visitDocumentItem: anObject! !!PRVisitor methodsFor: 'visiting-document'!visitLink: anObject	^ self visitReference: anObject! !!PRVisitor methodsFor: 'visiting-document'!visitList: anObject	^ self visitDocumentGroup: anObject! !!PRVisitor methodsFor: 'visiting-document'!visitListItem: anObject	^ self visitDocumentGroup: anObject! !!PRVisitor methodsFor: 'visiting-document'!visitMailLink: anObject	^ self visitExternalLink: anObject! !!PRVisitor methodsFor: 'visiting-document'!visitMathEnvironment: aMathEnvironment		self visitParameters: aMathEnvironment parameters.	^ self visitDocumentGroup: aMathEnvironment! !!PRVisitor methodsFor: 'visiting-document'!visitMonospaceFormat: anObject	^ self visitFormat: anObject! !!PRVisitor methodsFor: 'visiting-document'!visitOrderedList: anObject	^ self visitList: anObject! !!PRVisitor methodsFor: 'visiting-document'!visitParagraph: anObject	^ self visitDocumentGroup: anObject! !!PRVisitor methodsFor: 'visiting-parameters'!visitParameter: anObject	^ self visitDocumentGroup: anObject ! !!PRVisitor methodsFor: 'visiting-parameters'!visitParameterKey: anObject	^ self visitDocumentItem: anObject ! !!PRVisitor methodsFor: 'visiting-parameters'!visitParameterValue: anObject	^ self visitDocumentItem: anObject ! !!PRVisitor methodsFor: 'visiting-parameters'!visitParameters: anObject	"To me this cannot work since an object is a dictionary and not a document group	I let it for now because I do not have all pillar loaded but I'm suspicious."	^ self visitDocumentGroup: anObject ! !!PRVisitor methodsFor: 'visiting-document'!visitPreformatted: anObject	^ self visitDocumentGroup: anObject! !!PRVisitor methodsFor: 'visiting-document'!visitRaw: aRaw	^ self visitText: aRaw! !!PRVisitor methodsFor: 'visiting-document'!visitReference: anObject	^ self visitDocumentGroup: anObject! !!PRVisitor methodsFor: 'visiting-document'!visitRoot: anObject	"Microdown compatibility"		^ self visitDocumentGroup: anObject! !!PRVisitor methodsFor: 'visiting-document'!visitSection: aSection	^ self visitDocumentGroup: aSection! !!PRVisitor methodsFor: 'visiting-document'!visitStrikethroughFormat: anObject	^ self visitFormat: anObject! !!PRVisitor methodsFor: 'visiting-document'!visitSubscriptFormat: anObject	^ self visitFormat: anObject! !!PRVisitor methodsFor: 'visiting-document'!visitSuperscriptFormat: anObject	^ self visitFormat: anObject! !!PRVisitor methodsFor: 'visiting-document'!visitTermItem: anObject	^ self visitListItem: anObject! !!PRVisitor methodsFor: 'visiting-document'!visitText: anObject	^ self visitDocumentItem: anObject! !!PRVisitor methodsFor: 'visiting-annotations'!visitUndefinedAnnotation: aUndefinedAnnotation	"Visiting an annotation means that we visit the textual representation of an annotation. Such annotations will be transformed into annotation object. The corresponding visit method will be invoked on such object : visitFootnoteAnnotation vs visitFootnote."	^ self visitAnnotation: aUndefinedAnnotation! !!PRVisitor methodsFor: 'visiting-document'!visitUnderlineFormat: anObject	^ self visitFormat: anObject! !!PRVisitor methodsFor: 'visiting-document'!visitUnorderedList: anObject	^ self visitList: anObject! !!PRCascadingCounter class methodsFor: 'instance creation'!maxLevel: anInteger	^ self new 		setMaxLevel: anInteger;		yourself! !!PRCascadingCounter methodsFor: 'accessing'!current	^ self deepCopy! !!PRCascadingCounter methodsFor: 'action'!dontIncrementAt: level 	counters at: level put: -1! !!PRCascadingCounter methodsFor: 'accessing'!elements	^ counters first: self indexOfLastNonZero! !!PRCascadingCounter methodsFor: 'action'!incrementAt: level 	counters at: level put: (counters at: level) + 1.	level + 1 to: counters size		do: [ :i | counters at: i put: 0 ]! !!PRCascadingCounter methodsFor: 'accessing'!indexOfLastNonZero	counters size to: 1 by: -1 do: [ :index | 		(counters at: index) strictlyPositive			ifTrue: [ ^ index ] ].	^ 1! !!PRCascadingCounter methodsFor: 'testing'!isValidCounter	^ true! !!PRCascadingCounter methodsFor: 'printing'!printOn: aStream	self elements do: [ :each | aStream nextPutAll: each printString ] separatedBy: [ aStream nextPut: $. ]! !!PRCascadingCounter methodsFor: 'initialization'!setMaxLevel: anInteger	counters := Array new: anInteger withAll: 0.! !!PRNotFoundCounter methodsFor: 'accessing'!elements	^ { '¿?' }! !!PRNotFoundCounter methodsFor: 'testing'!isValidCounter	^ false! !!PRShoutingValidationStrategy methodsFor: 'error handling'!invalidParameterNames: aMissingKeys forAnnotation: anAnnotation withParameters: aPRParameters	PRSyntaxError signal: 'The key(s) ' , aMissingKeys printString , 		'  is not valid for the annotation ' , anAnnotation tag ! !!PRShoutingValidationStrategy methodsFor: 'error handling'!missingAnnotationParametersIn: anAnnotation	PRSyntaxError signal: 'The annotation ', anAnnotation tag, 		'expect parameters from', anAnnotation class possibleParameters printString, 		'and none where given.'! !!PRShoutingValidationStrategy methodsFor: 'error handling'!missingAnnotationSupport: aString 	PRSyntaxError signal: 'Pillar doesn''t support this tag : ''' , aString , ''' on his annotations.'! !!PRShoutingValidationStrategy methodsFor: 'error handling'!unexpectedParameterIn: anAnnotation	PRSyntaxError signal: 'The annotation ', anAnnotation tag, ' does not expect parameter'! !!PRSilentValidationStrategy methodsFor: 'error handling'!invalidParameterNames: aMissingKeys forAnnotation: anAnnotationClass withParameters: aPRParameters	aMissingKeys do: [ :eachKey | 		aPRParameters children 			detect: [ :eachParameter | eachParameter key = eachKey ]  			ifFound: [ :aParameter | aParameter beInvalid ]			ifNone: [ "ignore" ] ]! !!PRSilentValidationStrategy methodsFor: 'error handling'!missingAnnotationParametersIn: aPRAnnotation 	aPRAnnotation beInvalid! !!PRSilentValidationStrategy methodsFor: 'error handling'!missingAnnotationSupport: aString 	^ PRUndefinedAnnotation new tag: aString! !!PRSilentValidationStrategy methodsFor: 'error handling'!unexpectedParameterIn: anAnnotation	anAnnotation beInvalid! !!PRValidationStrategy class methodsFor: 'cleanup'!cleanUp	self reset! !!PRValidationStrategy class methodsFor: 'accessing'!reset	uniqueInstance := nil! !!PRValidationStrategy class methodsFor: 'accessing'!shouting	^ PRShoutingValidationStrategy uniqueInstance! !!PRValidationStrategy class methodsFor: 'accessing'!silent	^ PRSilentValidationStrategy uniqueInstance! !!PRValidationStrategy class methodsFor: 'accessing'!uniqueInstance	^ uniqueInstance ifNil: [ uniqueInstance := self new ]! !!PRValidationStrategy methodsFor: 'error handling'!invalidParameterNames: aMissingKeys forAnnotation: anAnnotation withParameters: aPRParameters	^ self subclassResponsibility! !!PRValidationStrategy methodsFor: 'error handling'!missingAnnotationParametersIn: anAnnotation	^ self subclassResponsibility! !!PRValidationStrategy methodsFor: 'error handling'!missingAnnotationSupport: aString 	^ self subclassResponsibility! !!PRValidationStrategy methodsFor: 'error handling'!unexpectedParameterIn: anAnnotation	self subclassResponsibility! !"Pillar-Core"!!ManifestPillarMicrodownToPillarConverter commentStamp: '' prior: 0!I'm extending the microdown object model to support the generation of Pillar elements.My main method is `asPillar`.!!MicTextualMicrodownToPillarTest commentStamp: '' prior: 0!This test case uses the microdownSnippetFactory and test that the conversion to Pillar object trees is correct. This is why it is in this packageMicrodown text -> Microdown trees -> Pillar treesTe tests are just checking that object of the correct class is created. Future extensions should handle the details.!!MicMicrodownObjectToPillarObjectConverter commentStamp: '' prior: 0!This visitor is about to disappeared. It was created just to make sure that we can have asPillar expressed as a visitor. Now this visitor is working on non expanded code blocks.!!MicMathInlineBlock methodsFor: '*Pillar-MicrodownToPillarConverter'!associatedPillarClass	^ PRMathInTextAnnotation ! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'parsing'!parse: sample createChildElementOfClass: aClass	| parser micDoc pillarDoc |	parser := self parserClass new. 	micDoc := (parser parse: sample) children first children first.	pillarDoc := micDoc accept: visitor.	self assert: pillarDoc class equals: aClass.	^ pillarDoc! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'parsing'!parse: sample createChildSecondElementOfClass: aClass	| parser micDoc pillarDoc |	parser := self parserClass new. 	micDoc := (parser parse: sample) children first children second.	pillarDoc := micDoc accept: visitor.	self assert: pillarDoc class equals: aClass.	^ pillarDoc! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'parsing'!parse: sample createElementOfClass: aClass	| parser micDoc pillarDoc |	parser := self parserClass new. 	micDoc := (parser parse: sample) children first.	pillarDoc := micDoc accept: visitor.	self assert: pillarDoc class equals: aClass.	^ pillarDoc! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests'!parserClass	^ Microdown! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'running'!setUp 	super setUp. 	visitor := MicMicrodownObjectToPillarObjectConverter new.	factory := MicMicrodownSnippetFactory new.! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests'!testAnchorBlock	self parse: factory anchorSample createElementOfClass: PRAnchor! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests-inline blocks'!testAnchorReference	self parse: factory anchorReferenceSample createChildElementOfClass: PRInternalLink! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests'!testAnnotated	self parse: factory annotatedSample createElementOfClass: PRAnnotatedParagraph! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests-inline blocks'!testAnnotation	self parse: factory annotationSample createChildSecondElementOfClass: PRUndefinedAnnotation! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests-inline blocks'!testBoldFormat	self parse: factory boldFormatSample createChildElementOfClass: PRBoldFormat! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests-inline blocks'!testBoldFormatEmpty	| boldBlock |	self skip.	self flag: #fixme.	"the parser parse '****' and return a HorizontalBlock"	boldBlock := self parse: factory boldFormatEmptySample createChildElementOfClass: PRBoldFormat.	self assert: boldBlock text equals: ''! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests'!testCodeBlock	self parse: (factory codeblock: 'language=pharo' body: '1-2 ') createElementOfClass: PRCodeblock! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests'!testCodeInText	| document |	document := self parserClass new parse: 'The method `foo` is fun'.	pillarDocument := document accept: visitor.	self assert: pillarDocument children first class equals: PRParagraph.	self assert: pillarDocument children first children second class equals: PRMonospaceFormat 		! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests'!testComment	self parse: factory commentSample createElementOfClass: PRCommentedLine! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests'!testEnvironmentBlock	self parse: factory environmentSample createElementOfClass: PREnvironment	! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests-inline blocks'!testFigure	self parse: factory figureSample createChildElementOfClass: PRFigure! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests'!testHeader 	self parse: factory headerLevel3Sample createElementOfClass: PRHeader! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests'!testHorizontalLineBlock	self parse: factory horizontalLineSample createElementOfClass: PRHorizontalRule	! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests-inline blocks'!testItalicFormat	self parse: factory italicFormatSample createChildElementOfClass: PRItalicFormat! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests-inline blocks'!testItalicFormatEmpty	| italicBlock |	italicBlock := self parse: factory italicFormatEmptySample createChildElementOfClass: PRItalicFormat.	self assert: italicBlock text equals: ''! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests-inline blocks'!testLink	self parse: factory linkSample createChildElementOfClass: PRExternalLink! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests'!testListItem	self parse: factory listMultiSample createChildElementOfClass: PRListItem	! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests'!testMathBlock	self parse: factory mathParametersSample createElementOfClass: PRMathEnvironment	! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests-inline blocks'!testMathInline	self parse: factory mathInlineSample createChildElementOfClass: PRMathInTextAnnotation! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests'!testMetaDataBlock	self parse: factory metaDataSample createElementOfClass: PRMetadata	! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests-inline blocks'!testMonospaceFormat	self parse: factory monospaceFormatSample createChildElementOfClass: PRMonospaceFormat! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests-inline blocks'!testMonospaceFormatEmpty	| monospaceBloc |	monospaceBloc := self parse: factory monospaceFormatEmptySample createChildElementOfClass: PRMonospaceFormat.	self assert: monospaceBloc text equals: ''! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests'!testNumberedList	| document |	document := (self parserClass new 		parse: MicMicrodownSnippetFactory new orderedListWithTwoItemsSample).	document := document accept: visitor.	self assert: document children first class equals: PROrderedList.	self		assert: document children first children first class		equals: PRListItem.	self		assert: document children first children second class		equals: PRListItem! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests'!testQuoteBlock	| source root pillarNode |	source := '> text1>    text2'.	root := self parserClass new parse: source.	self assert: root children size equals: 1.	pillarNode := root children first accept: visitor.	self assert: pillarNode class equals: PRPreformatted.	self		assert: pillarNode text		equals:			'text1text2'! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests-inline blocks'!testRawFormat	self skip.	self flag: #fixme.	"PRRaw don't understand setChildren"	self parse: factory rawFormatSample createChildSecondElementOfClass: PRRaw! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests'!testRoot	| source root pillar |	source := '####    Level four## Level 2'.	root := self parserClass new parse: source.	pillar := root accept: visitor.	self assert: pillar class equals: PRDocument.	self assert: pillar children second class equals: PRHeader.	self assert: pillar children first level equals: 4! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests'!testSingleLevelOrderedList2	| source root list |	source := '19. item 1    expanded7.  item 2'.	root := self parserClass new parse: source.	list := root children first accept: visitor.	self assert: list class equals: PROrderedList .	self assert: list children size equals: 2.	self		assert: list children first text		equals:			'item 1expanded'.	self assert: list counter equals: 19! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests'!testSingleLevelUnorderedList2	| source root list item |	source := '- item 1  expanded- item 2'.	root := self parserClass new parse: source.	list := root children first accept: visitor.	self assert: list class equals: PRUnorderedList.	self assert: list children size equals: 2.	item := list children first.	self assert: item class equals: PRListItem.	self		assert: item children first text		equals:			'item 1expanded'! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests'!testSingleParagraphWithIndentedText	| source root expected pillar |	source := 'This is   a paragraph with spaces	and one with tabs'.	expected := 'This isa paragraph with spacesand one with tabs'.	root := self parserClass new parse: source.	pillar := root children first accept: visitor.	self assert: pillar class equals: PRParagraph.	self assert: pillar children first class equals: PRText.	self assert: pillar children first text equals: expected! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests-inline blocks'!testStrikethroughFormat	self parse: factory strikethroughFormatSample createChildElementOfClass: PRStrikethroughFormat! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests-inline blocks'!testStrikethroughFormatEmpty	| strikeBlock |	strikeBlock := self parse: factory strikethroughFormatEmptySample createChildElementOfClass: PRStrikethroughFormat.	self assert: strikeBlock text equals: ''! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests'!testTableBlock	self parse: factory simpleTable createElementOfClass: PRTable! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests'!testTableFormatBlock	self parse: factory simpleTableMoreFormat createElementOfClass: PRTable! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests-inline blocks'!testText	| source root pillar |	source := 'Foo'.	root := (self parserClass new parse: source) children first children first.	pillar := root accept: visitor.	self assert: pillar class equals: PRText! !!MicMicrodownObjectToPillarObjectConverterTest methodsFor: 'tests'!testTwoLevelUnorderedList1	| source root list secondItem subItem |	source := '- item 1  - sublevel- item 2'.	root := self parserClass new parse: source.	list := root children first accept: visitor.	secondItem := list children second.	self assert: secondItem class equals: PRListItem.	self assert: secondItem children first class equals: PRText.	self assert: secondItem children first text equals: 'item 2'.	subItem := list children first children second.	self assert: subItem class equals: PRUnorderedList.	self		assert: subItem children first text		equals: 'sublevel'	"item 1"	"unorded list"	"sub item"! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - anchor'!anchorClass	^ PRAnchor! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - codeblock'!codeBlockClass	^ PRCodeblock! !!MicTextualMicrodownToPillarTest methodsFor: 'accessing'!factory	^ factory! !!MicTextualMicrodownToPillarTest methodsFor: 'accessing'!factory: aFactory	factory := aFactory! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - header'!headerClass	^ PRHeader! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - list'!orderedListClass	^ PROrderedList! !!MicTextualMicrodownToPillarTest methodsFor: 'accessing'!parse: sample createChildElementOfClass: aClass	| parser micDoc pillarDoc |	parser := self parserClass new. 	micDoc := parser parse: sample.	pillarDoc := micDoc asPillar.	self assert: pillarDoc children first children first class equals: aClass.	^ pillarDoc children first children first! !!MicTextualMicrodownToPillarTest methodsFor: 'accessing'!parse: sample createElementOfClass: aClass	| parser micDoc pillarDoc |	parser := self parserClass new. 	micDoc := parser parse: sample.	pillarDoc := micDoc asPillar.	self assert: pillarDoc children first class equals: aClass.! !!MicTextualMicrodownToPillarTest methodsFor: 'accessing'!parseCreateDocument: sample 	| parser micDoc pillarDoc |	parser := self parserClass new. 	micDoc := parser parse: sample.	pillarDoc := micDoc asPillar.	self assert: pillarDoc class equals: PRDocument.! !!MicTextualMicrodownToPillarTest methodsFor: 'accessing'!parserClass	^ Microdown   ! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - document'!rootBlockClass	^ PRDocument! !!MicTextualMicrodownToPillarTest methodsFor: 'running'!setUp 	super setUp.	self factory: MicMicrodownSnippetFactory new.! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - anchor'!testAnchor	self parse: factory anchorSample createElementOfClass: self anchorClass! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - anchor'!testAnchorAreTrimed	self parse: factory anchorAreTrimedSample createElementOfClass: self anchorClass! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - anchor'!testAnchorWithNewLine	self parse: factory anchorWithNewLineSample createElementOfClass:  self anchorClass! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - anchor'!testAnchorWithSpaceInside	self parse: factory anchorWithSpaceInsideSample createElementOfClass:  self anchorClass! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - format'!testBoldFormat	self parse: factory boldFormatSample createChildElementOfClass: PRBoldFormat! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - format'!testBoldFormatEmpty	| boldBlock |	self skip.	"the parser parse '****' and return a HorizontalBlock"	boldBlock := self parse: factory boldFormatEmptySample createChildElementOfClass: PRBoldFormat.	self assert: boldBlock text equals: ''! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - header'!testHeaderEmpty	self parse: factory headerEmptySample createElementOfClass: self headerClass! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - header'!testHeaderLevel1	self parse: factory headerLevel1Sample createElementOfClass: self headerClass! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - header'!testHeaderLevel2	self parse: factory headerLevel2Sample createElementOfClass: self headerClass! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - header'!testHeaderLevel3	self parse: factory headerLevel3Sample createElementOfClass: self headerClass! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - header'!testHeaderLevel4	self parse: factory headerLevel4Sample createElementOfClass: self headerClass! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - header'!testHeaderLevel5	self parse: factory headerLevel5Sample createElementOfClass: self headerClass! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - header'!testHeaderWithFormat	self parse: factory headerWithFormatSample createElementOfClass: self headerClass! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - header'!testHeaderWithNewLine	self parse: factory headerWithNewLineSample createElementOfClass: self headerClass! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - format'!testItalicFormat	self parse: factory italicFormatSample createChildElementOfClass: PRItalicFormat! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - format'!testItalicFormatEmpty	| italicBlock |	italicBlock := self parse: factory italicFormatEmptySample createChildElementOfClass: PRItalicFormat.	self assert: italicBlock text equals: ''! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - document'!testLineEnd	self parseCreateDocument: factory lineEndSample ! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - document'!testLineEndwithNewline	self parseCreateDocument: factory lineEndwithNewlineSample ! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - list'!testListMulti	self parse: factory listMultiSample createElementOfClass: self unorderedListClass! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - list'!testListWithComment	self parse: factory listWithCommentSample createElementOfClass: self orderedListClass ! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - format'!testMonospaceFormat	self parse: factory monospaceFormatSample createChildElementOfClass: PRMonospaceFormat! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - format'!testMonospaceFormatEmpty	| monospaceBloc |	monospaceBloc := self parse: factory monospaceFormatEmptySample createChildElementOfClass: PRMonospaceFormat.	self assert: monospaceBloc text equals: ''! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - document'!testNewline	self parseCreateDocument: factory newlineSample ! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - document'!testNewlineCR	self parseCreateDocument: factory newlineCRSample ! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - document'!testNewlineCRLF	self parseCreateDocument: factory newlineCRLFSample ! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - document'!testNewlineLF	self parseCreateDocument: factory newlineLFSample ! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - list'!testOrderedList	self parse: factory orderedListSample createElementOfClass: self orderedListClass! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - list'!testOrderedListEmpty	self parse: factory orderedListEmptySample createElementOfClass: self orderedListClass! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - list'!testOrderedListWithTwoItems	self		parse: factory orderedListWithTwoItemsSample		createElementOfClass: self orderedListClass! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - codeblock'!testScript	self		parse: factory blockSampleOnMultipleLines		createElementOfClass: self codeBlockClass! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - codeblock'!testScriptParameterTrueByDefault	self 		parse: factory blockWithParameterTrueByDefaultSample 		createElementOfClass: self codeBlockClass ! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - codeblock'!testScriptParameterWithFloat	self parse: factory blockWithParameterWithFloatSample createElementOfClass: self codeBlockClass ! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - codeblock'!testScriptParameterWithNoValues	self parse: factory blockWithParameterWithNoValuesSample createElementOfClass: self codeBlockClass ! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - codeblock'!testScriptWithLanguage	self parse: factory blockWithLanguageSample createElementOfClass: self codeBlockClass ! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - codeblock'!testScriptWithNewLine	self parse: factory blockWithNewLineSample createElementOfClass: self codeBlockClass ! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - codeblock'!testScriptWithSpaceAtTheEnd	self parse: factory blockWithSpaceAtTheEndSample createElementOfClass: self codeBlockClass ! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - codeblock'!testScriptWithSpacedParameters	self parse: factory blockWithSpacedParametersSample createElementOfClass: self codeBlockClass! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - format'!testStrikethroughFormat	self parse: factory strikethroughFormatSample createChildElementOfClass: PRStrikethroughFormat! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - format'!testStrikethroughFormatEmpty	| strikeBlock |	strikeBlock := self parse: factory strikethroughFormatEmptySample createChildElementOfClass: PRStrikethroughFormat.	self assert: strikeBlock text equals: ''! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - list'!testUnorderedList	self parse: factory unorderedListSample createElementOfClass: self unorderedListClass ! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - list'!testUnorderedListEmpty	self parse: factory unorderedListEmptySample createElementOfClass: self unorderedListClass ! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - list'!testUnorderedListWithSubList	self		parse: factory unorderedListWithSubListSample		createElementOfClass: self unorderedListClass ! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - list'!testUnorderedListWithTwoItems	self		parse: factory unorderedListWithTwoItemsSample		createElementOfClass: self unorderedListClass ! !!MicTextualMicrodownToPillarTest methodsFor: 'tests - list'!unorderedListClass	^ PRUnorderedList ! !!MicToPillarBasicTest methodsFor: 'tests'!parserClass	^ Microdown! !!MicToPillarBasicTest methodsFor: 'tests'!testCodeBlock	| document |	document := self parserClass new parse: '```language=pharo	1-2 ```'.	self assert: document asPillar children first class equals: PRCodeblock.	! !!MicToPillarBasicTest methodsFor: 'tests'!testCodeInText	| document |	document := self parserClass new parse: 'The method `foo` is fun'.	pillarDocument := document asPillar.	self assert: pillarDocument children first class equals: PRParagraph.	self assert: pillarDocument children first children second class equals: PRMonospaceFormat 		! !!MicToPillarBasicTest methodsFor: 'tests'!testHeader 	| document |	document := self parserClass new parse: '# Header1	## Header 2	### Header 3'.	pillarDocument := document asPillar.	"we could have use Grammar headerMarkup to build the text but this is clearer like that"	self assert: pillarDocument children first class equals: PRHeader.	self assert: pillarDocument children third class equals: PRHeader.	self assert: pillarDocument children fifth class equals: PRHeader	! !!MicToPillarBasicTest methodsFor: 'tests'!testNumberedList	| document |	document := (self parserClass new 		parse: MicMicrodownSnippetFactory new orderedListWithTwoItemsSample) asPillar.	self assert: document children first class equals: PROrderedList.	self		assert: document children first children first class		equals: PRListItem.	self		assert: document children first children second class		equals: PRListItem! !!MicTextBlock methodsFor: '*Pillar-MicrodownToPillarConverter'!associatedPillarClass	"special case"! !!MicEnvironmentBlockTest methodsFor: '*Pillar-MicrodownToPillarConverter-Tests'!testEnvironmentBlockAsPillar	| source root pillar |	source := '<!!environment|name=aNameHello this is a dull body.!!>'.	root := parser parse: source.	pillar := root children first asPillar.	self assert: pillar class equals: PREnvironment	! !!MicEnvironmentBlockTest methodsFor: '*Pillar-MicrodownToPillarConverter-Tests'!testEnvironmentBlockWithParametersAsPillar	| source root pillar |	source := '<!!environment|toto=22&name=isAlreadyDefinedHello this is a dull body.!!>'.	root := parser parse: source.	pillar := root children first asPillar.	self assert: pillar class equals: PREnvironment.	self assert: (pillar parameterAt: 'toto') equals: '22'.	self assert: (pillar parameterAt: 'name') equals: 'isAlreadyDefined'	! !!MicOrderedListBlockTest methodsFor: '*Pillar-MicrodownToPillarConverter-Tests'!testSingleLevelList2asPillar	| source root list |	source := '19. item 1    expanded7.  item 2'.	root := parser parse: source.	list := root children first asPillar.	self assert: list class equals: PROrderedList .	self assert: list children size equals: 2.	self		assert: list children first text		equals:			'item 1expanded'.	self assert: list counter equals: 19! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'formatting'!formatBlock: aMicFormatBlock	| childrenAsPillar |	childrenAsPillar := aMicFormatBlock isOnlyChild 		ifTrue: [ {(PRText new text: aMicFormatBlock substring )} ] 		ifFalse: [ aMicFormatBlock children collect: [:e | e accept: self ] ].	 ^ aMicFormatBlock associatedPillarClass new				setChildren: childrenAsPillar;				yourself! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'formatting'!urlBlock: aMicUrlBlock		| queries urlString |	queries := aMicUrlBlock reference uri query.	aMicUrlBlock reference uri query: nil.	"UGLY we remove the query dicrtionary just to print."	urlString := aMicUrlBlock reference uri asString.	"the following test is needed as reported in https://github.com/pillar-markup/Microdown/issues/527"	urlString first = $/ ifTrue: [ urlString := urlString allButFirst ].		aMicUrlBlock reference uri query: queries.	^ aMicUrlBlock associatedPillarClass new		  setChildren:			  ((aMicUrlBlock inlineParse: aMicUrlBlock substring) collect: [ :n | 					   n accept: self ]);		  reference: urlString;		  yourself! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'visiting'!visitAnchor: aMicAnchorBlock 	^ PRAnchor new name: aMicAnchorBlock label; yourself! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'visiting inline'!visitAnchorReference: aMicAnchorReference	^ PRInternalLink new anchor: aMicAnchorReference substring; yourself! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'visiting'!visitAnnotated: aMicAnnotatedBlock 	^ PRAnnotatedParagraph new 			annotation: aMicAnnotatedBlock label; 			setChildren: (aMicAnnotatedBlock pillarFrom: aMicAnnotatedBlock textElements);			yourself! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'visiting inline'!visitAnnotation: aMicAnnotation	^ aMicAnnotation associatedPillarClass new parameters: aMicAnnotation arguments! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'visiting inline'!visitBold: aMicBold 	^ self formatBlock: aMicBold! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'visiting'!visitCell: aCell	| cell |	cell := PRTableCell new.	aCell do: [ :each | cell add: (each accept: self)  ].	^ cell! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'visiting'!visitCode: aMicCodeBlock	| prBlock par pillars |	prBlock := PRCodeblock new.	prBlock text: aMicCodeBlock code.	aMicCodeBlock arguments keysAndValuesDo: [ :k :v | 		(aMicCodeBlock arguments includesKey: #language)			ifFalse: [ 				(aMicCodeBlock arguments keys first = k and: v isEmptyOrNil)					ifTrue: [ prBlock parameterAt: 'language' put: k ]					ifFalse: [ prBlock parameterAt: k put: v ] ]			ifTrue: [ prBlock parameterAt: k put: v ] ].	aMicCodeBlock hasCaption		ifTrue: [ 			prBlock parameters removeKey: #caption.			par := PRParagraph new.			pillars := aMicCodeBlock captionElements collect: [ :each | 				           each accept: MicMicrodownObjectToPillarObjectConverter new ].			pillars do: [ :each | par add: each ].			prBlock setCaption: par ]		ifFalse: [ 			prBlock caption "Yes this is not an accessor but something with side effect" ].	^ prBlock! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'visiting'!visitComment: aMicCommentBlock 	^ PRCommentedLine new 			text: aMicCommentBlock text ; 			yourself! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'visiting'!visitEnvironment: aMicEnvironmentBlock		| env |	env := PREnvironment new 			name: aMicEnvironmentBlock environmentName;			parameters: aMicEnvironmentBlock arguments; yourself.	env add: (PRParagraph withAll: (aMicEnvironmentBlock pillarFrom: aMicEnvironmentBlock bodyElements)).	^ env! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'visiting inline'!visitFigure: aMicFigureBlock	| aPRFigure |	aPRFigure := self urlBlock: aMicFigureBlock.	^ aPRFigure		  label: aMicFigureBlock substring;		  parameters: aMicFigureBlock arguments;		  yourself! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'visiting'!visitFormatBlock: aMicFormatBlock 	| childrenAsPillar | 	childrenAsPillar := aMicFormatBlock isOnlyChild  		ifTrue: [ {(PRText new text: aMicFormatBlock substring )} ]  		ifFalse: [ aMicFormatBlock children collect: [:e | e accept: self ] ]. 	 ^ aMicFormatBlock associatedPillarClass new 				setChildren: childrenAsPillar; 				yourself! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'visiting'!visitHeader: aMicHeaderBlock 	^ PRHeader new		level: aMicHeaderBlock level;		setChildren: (aMicHeaderBlock children collect: [:each | each accept: self ]);		yourself! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'visiting'!visitHorizontalLine: anHorizontalLineBlock 	^ PRHorizontalRule new ! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'visiting inline'!visitItalic: aMicItalic 	^ self formatBlock: aMicItalic! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'visiting inline'!visitLink: aMicLink	^ aMicLink associatedPillarClass new		  setChildren:			  ((aMicLink inlineParse: aMicLink substring) collect: [ :n | 					   n accept: self ]);		  reference: aMicLink url asString;		  yourself! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'visiting'!visitListItem: aMicListItemBlock	 	^ PRListItem new		setChildren: "(aMicListItemBlock pillarFrom: aMicListItemBlock textElements)," (aMicListItemBlock children collect: [:child| child accept: self]);		yourself;		yourself! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'visiting'!visitMath: aMicMathBlock 	| captionElements |	captionElements := aMicMathBlock arguments at: 'caption' ifAbsent: [ nil ]. 	captionElements isNotNil 		ifTrue: [ aMicMathBlock arguments at: 'caption' put: (aMicMathBlock pillarFrom: captionElements) ].	^ PRMathEnvironment new 	 	parameters: aMicMathBlock arguments;   		add: (PRText content: aMicMathBlock body);		yourself! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'visiting inline'!visitMathInline: aMicMathInline 	^ self formatBlock: aMicMathInline! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'visiting inline'!visitMetaData: aMicMetaData 	^ PRMetadata new 			metadata: aMicMetaData body; yourself! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'visiting inline'!visitMonospace: aMicMonospace 	^ self formatBlock: aMicMonospace! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'visiting'!visitOrderedList: aMicOrderedListBlock 	^ PROrderedList new		setChildren: (aMicOrderedListBlock children collect: [ :child | child accept: self ]);		counter: aMicOrderedListBlock startIndex;		yourself! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'visiting'!visitParagraph: aMicParagraphBlock 	^ PRParagraph  new		setChildren: (aMicParagraphBlock pillarFromString: aMicParagraphBlock text);		yourself! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'visiting'!visitQuote: aMicQuoteBlock 	^ PRPreformatted new 		setChildren: (aMicQuoteBlock pillarFromString: aMicQuoteBlock text); 		yourself! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'visiting inline'!visitRaw: aMicRaw	^ PRRaw new text: aMicRaw substring ; yourself 	! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'visiting'!visitRoot: aMicRootBlock 	^ PRDocument new 		setChildren: (aMicRootBlock children collect: [ :child | child accept: self ]); 		yourself! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'visiting'!visitRow: aRow in: aTable at: i	| row |	row := PRTableRow new.	i = 1 		ifTrue: [ aRow do: [ :cell | row add: ((self visitCell: cell) heading: true) ] ] 		ifFalse: [ aRow do: [ :cell | row add: (self visitCell: cell) ] ].	^ row! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'visiting inline'!visitStrike: aMicStrike 	^ self formatBlock: aMicStrike! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'visiting'!visitTable: aTable	| table |	table := PRTable new.	aTable rows doWithIndex: [ :row : i | 		table add: (self visitRow: row in: aTable at: i)].	^ table! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'visiting inline'!visitText: aMicTextBlock	 	^ PRText new text: aMicTextBlock substring ; yourself! !!MicMicrodownObjectToPillarObjectConverter methodsFor: 'visiting'!visitUnorderedList: aMicUnorderedListBlock 	^ PRUnorderedList new 		setChildren: (aMicUnorderedListBlock children collect:[:child| child accept: self]); 		yourself! !!MicBoldFormatBlock methodsFor: '*Pillar-MicrodownToPillarConverter'!associatedPillarClass	^ PRBoldFormat! !!Trait methodsFor: '*Pillar-MicrodownToPillarConverter'!buildMicroDownUsing: aBuilder withComment: aString		aBuilder 		header: [	aBuilder text: 'Trait: '.					aBuilder text: self name] withLevel: 1;		horizontalLine;		text: aString! !!MicElement methodsFor: '*Pillar-MicrodownToPillarConverter'!asPillar	^ self accept: MicMicrodownObjectToPillarObjectConverter new! !!MicLinkBlock methodsFor: '*Pillar-MicrodownToPillarConverter'!associatedPillarClass	^ PRExternalLink! !!MicInlineParserTest methodsFor: '*Pillar-MicrodownToPillarConverter-Tests'!testBasicTextAsPillar	| res |	res := self splitter pillarFrom: 'abc'.	self assert: res first text equals: 'abc'.	self assert: res first class equals: PRText.! !!MicInlineParserTest methodsFor: '*Pillar-MicrodownToPillarConverter-Tests'!testBoldAndNestedItalicAsPillar	| res |	res := self splitter pillarFrom: 'abc**x_y_z**cba'.	self assert: res second class equals: PRBoldFormat.	self assert: res second children first text equals: 'x'.	self assert: res second children second class equals: PRItalicFormat.	self assert: res second children second children first text equals: 'y'.	self assert: res second children third text equals: 'z'! !!MicInlineParserTest methodsFor: '*Pillar-MicrodownToPillarConverter-Tests'!testBoldAsPillar	| res |	res := self splitter pillarFrom: 'abc**xyz**cba'.	self assert: res second children first text equals: 'xyz'.	self assert: res second class equals: PRBoldFormat.! !!MicInlineParserTest methodsFor: '*Pillar-MicrodownToPillarConverter-Tests'!testExternalLinkAsPillar	| res |	res := self splitter pillarFrom: 'abc[alias](link)cba'.	self assert: res second children first text equals: 'alias'.	self assert: res second class equals: PRExternalLink.! !!MicInlineParserTest methodsFor: '*Pillar-MicrodownToPillarConverter-Tests'!testFigureAsPillar	| res |	res := self splitter pillarFrom: 'abc!![alias](http://www.pharo.org)cba'.	self assert: res second children first text equals: 'alias'.	self assert: res second class equals: PRFigure! !!MicInlineParserTest methodsFor: '*Pillar-MicrodownToPillarConverter-Tests'!testItalicAsPillar	| res |	res := self splitter pillarFrom: 'abc_xyz_cba'.	self assert: res second children first text equals: 'xyz'.	self assert: res second class equals: PRItalicFormat.		! !!MicInlineParser methodsFor: '*Pillar-MicrodownToPillarConverter'!pillarFrom: aString	"return a collection of pillar nodes which can be used in setChildren: of the owner of aString"	^ (self parse: aString) collect: [ :node | 		  node accept: MicMicrodownObjectToPillarObjectConverter new ]! !!MicHorizontalLineBlockTest methodsFor: '*Pillar-MicrodownToPillarConverter-Tests'!testHorizontalLineBlockAsPillar	| source root pillar |	source := '***	'.	root := parser parse: source.	pillar := root children first asPillar.	self assert: pillar class equals: PRHorizontalRule	! !!MicMonospaceFormatBlock methodsFor: '*Pillar-MicrodownToPillarConverter'!associatedPillarClass	^ PRMonospaceFormat! !!MicFigureBlock methodsFor: '*Pillar-MicrodownToPillarConverter'!associatedPillarClass	^PRFigure! !!MicQuoteBlockTest methodsFor: '*Pillar-MicrodownToPillarConverter-Tests'!testQuoteBlockAsPilar	| source root pillarNode |	source := '> text1>    text2'.	root := parser parse: source.	self assert: root children size equals: 1.	pillarNode := root children first asPillar.	self assert: pillarNode class equals: PRPreformatted.	self		assert: pillarNode text		equals:			'text1text2'! !!MicParagraphBlockTest methodsFor: '*Pillar-MicrodownToPillarConverter-Tests'!testSingleParagraphWithFormat	| source root pillar |	source := 'This **paragraph** with spaces'.	root := parser parse: source.	pillar := root children first asPillar.	self assert: pillar class equals: PRParagraph.	self assert: pillar children first class equals: PRText.	self assert: pillar children first text equals: 'This '.	self assert: pillar children second class equals: PRBoldFormat.	self assert: pillar children third class equals: PRText.	self assert: pillar children third text equals: ' with spaces'.	 	! !!MicParagraphBlockTest methodsFor: '*Pillar-MicrodownToPillarConverter-Tests'!testSingleParagraphWithIndentedTextAsPillar	| source root expected pillar |	source := 'This is   a paragraph with spaces	and one with tabs'.	expected := 'This isa paragraph with spacesand one with tabs'.	root := parser parse: source.	pillar := root children first asPillar.	self assert: pillar class equals: PRParagraph.	self assert: pillar children first class equals: PRText.	self assert: pillar children first text equals: expected! !!MicRootBlockTest methodsFor: '*Pillar-MicrodownToPillarConverter-Tests'!testRootAsPillar	| source root pillar |	source := '####    Level four## Level 2'.	root := parser parse: source.	pillar := root asPillar.	self assert: pillar class equals: PRDocument.	self assert: pillar children second class equals: PRHeader.	self assert: pillar children first level equals: 4! !!MicAnchorBlockTest methodsFor: '*Pillar-MicrodownToPillarConverter-Tests'!testAnchorBlockAsPillar	| source root pillar |	source := '@anchor'.	root := parser parse: source.	pillar := root children first asPillar.	self assert: pillar class equals: PRAnchor.	self assert: root children first label equals: 'anchor'! !!MicHeaderBlockTest methodsFor: '*Pillar-MicrodownToPillarConverter-Tests'!testHeaderLevel4AsPillar	| source root pillar |	source := '####    Level four'.	root := parser parse: source.	pillar := root children first asPillar.	self assert: pillar class equals: PRHeader.	self assert: pillar children first class equals: PRText.	self assert: pillar children first text equals: 'Level four'! !!MicItalicFormatBlock methodsFor: '*Pillar-MicrodownToPillarConverter'!associatedPillarClass	^ PRItalicFormat! !!MicAbstractBlock methodsFor: '*Pillar-MicrodownToPillarConverter'!pillarFrom: aCollectionOfMicElements		^ aCollectionOfMicElements collect: [ :e | e accept: MicMicrodownObjectToPillarObjectConverter new ]! !!MicAbstractBlock methodsFor: '*Pillar-MicrodownToPillarConverter'!pillarFromString: aString		^ MicInlineParser new pillarFrom: aString! !!MicRawBlock methodsFor: '*Pillar-MicrodownToPillarConverter'!associatedPillarClass	^ PRRaw ! !!MicCodeBlockTest methodsFor: '*Pillar-MicrodownToPillarConverter-Tests'!testSingleCodeBlockTwoLinesAsPillar	| source root code textBody argument |	textBody := 'my fancy codeis really cool'.	argument := 'ArgumentGoesHere'.	source := CodeblockMarkup, argument, String cr, textBody, String cr, CodeblockMarkup. 	root := self parser parse: source.	code := root children first asPillar.	self		assert: code text		equals:			'my fancy codeis really cool'.	self assert: code language originalName equals: 'ArgumentGoesHere'! !!MicRawBlockTest methodsFor: '*Pillar-MicrodownToPillarConverter-Tests'!testRawAsBackslash	"backslash should not be expanded in raw"	| source rawBlock pillar |	source := 'bla {{ aRaw\Text }} bla'.	rawBlock := (parser parse: source) children first children second.	pillar := rawBlock asPillar.	self assert: pillar class equals: PRRaw.	self assert: pillar text equals: ' aRaw\Text '! !!MicRawBlockTest methodsFor: '*Pillar-MicrodownToPillarConverter-Tests'!testRawAsPillar	| source rawBlock pillar |	source := 'bla {{ aRawText }} bla'.	rawBlock := (parser parse: source) children first children second.	pillar := rawBlock asPillar.	self assert: pillar class equals: PRRaw.	self assert: pillar text equals: ' aRawText '! !!MicUnorderedListBlockTest methodsFor: '*Pillar-MicrodownToPillarConverter-Tests'!testSingleLevelList2asPillar	| source root list item |	source := '- item 1  expanded- item 2'.	root := parser parse: source.	list := root children first asPillar.	self assert: list class equals: PRUnorderedList.	self assert: list children size equals: 2.	item := list children first.	self assert: item class equals: PRListItem.	self		assert: item children first text		equals:			'item 1expanded'! !!MicUnorderedListBlockTest methodsFor: '*Pillar-MicrodownToPillarConverter-Tests'!testSingleLevelList2asPillarWithFormatting	| source root prlist item |	source := '- **item 1** expanded- item 2'.	root := parser parse: source.	prlist := root children first asPillar.	self assert: prlist class equals: PRUnorderedList.	self assert: prlist children size equals: 2.	item := prlist children first.	self assert: item class equals: PRListItem.	self		assert: item children first text		equals:			'item 1'.				self		assert: item children second text		equals:			' expanded'.! !!MicUnorderedListBlockTest methodsFor: '*Pillar-MicrodownToPillarConverter-Tests'!testTwoLevelList1AsPillar	| source root list secondItem subItem |	source := '- item 1  - sublevel- item 2'.	root := parser parse: source.	list := root children first asPillar.	secondItem := list children second.	self assert: secondItem class equals: PRListItem.	self assert: secondItem children first class equals: PRText.	self assert: secondItem children first text equals: 'item 2'.	subItem := list children first children second.	self assert: subItem class equals: PRUnorderedList.	self		assert: subItem children first text		equals: 'sublevel'	"item 1"	"unorded list"	"sub item"! !!MicUnorderedListBlockTest methodsFor: '*Pillar-MicrodownToPillarConverter-Tests'!testTwoLevelList1AsPillarWithFormatting	| source root list secondItem subItem |	source := '- item 1  - `sublevel`- item 2'.	root := parser parse: source.	list := root children first asPillar.	secondItem := list children second.	self assert: secondItem class equals: PRListItem.	self assert: secondItem children first class equals: PRText.	self assert: secondItem children first text equals: 'item 2'.	subItem := list children first children second.	self assert: subItem class equals: PRUnorderedList.	self		assert: subItem children first children first class		equals: PRMonospaceFormat	"item 1"	"unorded list"	"sub item"! !!MicMathBlockTest methodsFor: '*Pillar-MicrodownToPillarConverter-Tests'!testMathBlockAsPillar	| source root pillar |	source := '',MathOpeningBlockMarkup,'V_i = C_0 - C_3', MathClosingBlockMarkup.root := parser parse: source.	pillar := root children first asPillar.	self assert: pillar class equals: PRMathEnvironment.	self assert: pillar children first class equals: PRText.	! !!MicMathBlockTest methodsFor: '*Pillar-MicrodownToPillarConverter-Tests'!testMathBlockAsPillarWithArgument	| source root pillar |	source := '',MathOpeningBlockMarkup,'toto=22&caption=isAlreadyDefined.V_i = C_0 - C_3', MathClosingBlockMarkup.	root := parser parse: source.	pillar := root children first asPillar.	self assert: pillar class equals: PRMathEnvironment.	self assert: pillar children first class equals: PRText.	self assert: (pillar parameters at: 'toto') equals: '22'.	self assert: pillar caption first text  equals: 'isAlreadyDefined.'.	! !!MicMathBlockTest methodsFor: '*Pillar-MicrodownToPillarConverter-Tests'!testMathBlockAsPillarWithArgumentWithFormatting	| source root pillar |	source := '',MathOpeningBlockMarkup,'toto=22&caption=**is**AlreadyDefined.V_i = C_0 - C_3', MathClosingBlockMarkup.	root := parser parse: source.	pillar := root children first asPillar.	self assert: pillar class equals: PRMathEnvironment.	self assert: pillar children first class equals: PRText.	self assert: (pillar parameters at: 'toto') equals: '22'.	self assert: pillar caption first text equals: 'is'.	self assert: pillar caption first class equals: PRBoldFormat.	! !!MicInlineElement methodsFor: '*Pillar-MicrodownToPillarConverter'!associatedPillarClass	^ self subclassResponsibility! !!MicAnnotationBlock methodsFor: '*Pillar-MicrodownToPillarConverter'!associatedPillarClass 	^  PRAbstractAnnotation findClassAcceptingTag: self name ifNone: [ PRUndefinedAnnotation ]	! !!MicAnchorReferenceBlock methodsFor: '*Pillar-MicrodownToPillarConverter'!associatedPillarClass	^ PRInternalLink! !!MicStrikeFormatBlock methodsFor: '*Pillar-MicrodownToPillarConverter'!associatedPillarClass	^ PRStrikethroughFormat! !"Pillar-MicrodownToPillarConverter"!!PRDataItem commentStamp: '' prior: 0!Data in a list!!PRTermItem commentStamp: '' prior: 0!A term (to be renamed) is the label part into definition list. It is delimited by ; i.e., blue and red below;blue.:color of the sky;red.:color of the firegeneratesblue.color of the skyred.color of the fire!!PRBashScriptLanguage commentStamp: '' prior: 0!Bash scripting language!!PRCSSScriptLanguage commentStamp: '' prior: 0!Cascading stylesheet language!!PRHTMLScriptLanguage commentStamp: '' prior: 0!Hypertext markup language!!PRHTTPScriptLanguage commentStamp: '' prior: 0!General HTTP script language!!PRJSONScriptLanguage commentStamp: '' prior: 0!JSON!!PRJavaScriptScriptLanguage commentStamp: '' prior: 0!JavaScript language!!PRSQLScriptLanguage commentStamp: '' prior: 0!SQL!!PRSTONScriptLanguage commentStamp: '' prior: 0!STON (Smalltalk Object Notation)!!PRShellCommandsScriptLanguage commentStamp: '' prior: 0!A PRBashScriptLanguage is xxxxxxxxx.!!PRSmalltalkScriptLanguage commentStamp: '' prior: 0!Smalltalk !!PRBeginColumnsAnnotation commentStamp: '' prior: 0!I am an annotation that mark the beginning of a columns environement.My tag is: 'columns''.Example: ${columns}$ in${columns}$   ${column:width=60}$      bla   ${column:40}$      bla${endColumns}$!!PRCitationAnnotation commentStamp: '' prior: 0!I am an annotation that represents a bibliographic citation.```	${cite:ref=Duca99a}$```	My tag is: 'cite'.- a ref with the key "ref=" (required takes a reference in the LaTeX bib format)### Examples: 	`${cite:ref=Duca99a}$`!!PRColumnAnnotation commentStamp: '' prior: 0!I am an annotation that mark the beginning of a new column. My tag is: 'column'.[[[			${column:50}$		${column:width=50}$]]]I can have as parameter:- a width with the key "width=" (required, you can write it without the key, take an integer between 0 and 100)!!!! Examples: Here is an example as used in Slides[[[${slide:title=First Exercise!!}$${columns}$${column:width=50}$- Watch the ""original"" Karate Kid first movie- Be geeky- Think about the exercises...${column:width=50}$+>file://figures/KarateKid.png|width=86+${endColumns}$]]]!!PRDocumentListAnnotation commentStamp: '' prior: 0!I am class representing a DocumentListAnnotation. I allow users to get abstracts of files located in a directory and specify a link to access these files.I can choose the number of files to take and the way to sort them.We can also choose they way abstracts will be represented by specifying templates. We ahave the possibility of giving multiple templates.Then abstracts will alternately change templates if you specified mutliple directories.When no template file is specified, abstracts are generated as DocumentGroup containing different files elements.With templates the annotation is remplaced by a Raw document in Html.For templates values, you can not specify directories, only .mustache files. You have to specify complete path starting from the project directory.Also for the path, the complete path from the project directory.${docList:path=blogs|limit=3|sort=date|templates=#('templates/docArticle.mustache' 'templates/template.mustache')}$${docList:path=wrongDirectory|limit=3|sort=date|templates=#('templates/docArticle.mustache' 'templates/template.mustache')}$ should raise an Error!!PREndColumnsAnnotation commentStamp: '' prior: 0!I am an annotation that mark the end of a 'columns' environment.My tag is: 'endColumns'.Example: ${endColumns}$ in${columns}$   ${column:width=60}$      bla   ${column:40}$      bla${endColumns}$!!PRFootnoteAnnotation commentStamp: '' prior: 0!I am an annotation that mark a footnoteMy tag is 'footnote'My parameters are :- note=aString !!PRIndexAnnotation commentStamp: '' prior: 0!Add a word to the document index.!!PRInputFileAnnotation commentStamp: '' prior: 0!I include a reference to a pillar file. With me we can add a transformation to remplace an annotation to a pillar file by his tree.My tag is: 'inputFile''.I can have in parameter:- a path to a file with the key "value=" (required, you can write it without the key)Examples: ${inputFile:myFile.pillar}$${inputFile:value=directory/myFile.pillar}$!!PRSlideTitleAnnotation commentStamp: '' prior: 0!I'm an annotation use to create a new Slide for a Slider exporter. My tag is: 'slide''.I can have as parameter:- a title with the key "title=" (required, you can write it without the key)- a label if you want to create a reference to this slide (optional)!!!! Examples: [[[${slide:Introduction|label=sld:intro}$${slide:title=Presentation}$${slide:title=Conclusion|label=sld:ccl}$]]]!!PRTocAnnotation commentStamp: '' prior: 0!I'm an annotation use to generate some Table of contents. My tag is: 'toc''.I have this form : ${toc:depthLevel=x|level=y|highlight=true}$The depthLevel is use to know the min level of title i need to use. I'll not print title lower than it.The level is use to know what i need to print. I stay on the section x-1 and I stop at the next y title.Highlight allow to highlight the current section (this might be vanish in the futur).Example:${toc:depthLevel=5|level=3|highlight=true}$!!PRDependencies commentStamp: '' prior: 0!I'm a visitor used to compute file and image dependencies using a cache. I should be moved to a separate package. Probably together with the Command Line handlers that expose the functionalities to the command line. !!PRFileDependencies commentStamp: '' prior: 0!I am a vistitor which visit the document and return all file dependencies of this document.!!PRImageDependencies commentStamp: '' prior: 0!I am a vistitor which visit the document and return all image dependencies of this document.!!PRColumn commentStamp: '' prior: 0!I am a column.!!PRColumnEnvironment commentStamp: '' prior: 0!I am a columns environment.!!PRSlide commentStamp: '' prior: 0!I am a slide. I am here to structure a document that will be export as a Slide prensentation. (PRBeamerExporter, PRDeckJSExporter...).title is the title of the slide.the label is a way to create a link to this slinde on the slider.!!PRWarning commentStamp: '' prior: 0!A Pillar warning!!PRLinkWarning commentStamp: '' prior: 0!I am a warning raised when a we have a problem with a link at the export.!!PRReferenceNotFound commentStamp: '' prior: 0!I am a warning raised when a reference is not found during the resolution phase!!PRDefinitionList commentStamp: '' prior: 0!I am an definition list. I am typically used for a keyword and a longer definition string.!!PRSubscriptFormat commentStamp: '' prior: 0!Style as subscript!!PRSuperscriptFormat commentStamp: '' prior: 0!Style as superscript!!PRUnderlineFormat commentStamp: '' prior: 0!Style as underline formatted!!PRCitation commentStamp: '' prior: 0!I am a citation.!!PRFootnote commentStamp: '' prior: 0!I am a footnote, you can create me with :noted: aStringIt create a footnote with note specified in parameter.!!PRToc commentStamp: '' prior: 0!This class represents a toc. A Toc can have children. Then a Title is considered as a Toc without children!!Object methodsFor: '*Pillar-Model-Core-Core'!accept: aVisitor	<ignoreForCoverage>	self error: self printString , ' is missing #accept:'! !!Object methodsFor: '*Pillar-Model-Core-Core'!acceptDecorated: aVisitor	self accept: aVisitor! !!Object methodsFor: '*Pillar-Model'!asMustachableValue	"Return a string that represents the value of an object that mustache will inject in a template.	For example true as MustachableValue should return 'true'	"	"true asMustachableValue >>> 'true'"	"1 asMustachableValue >>> '1'"	"'1' asMustachableValue >>> '1'"	"(Path * 'foo.bib') asMustachableValue >>> 'foo.bib'"		^ self! !!Path methodsFor: '*Pillar-Model'!asMustachableValue	^ self pathString! !!PRDataItem methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitDataItem: self! !!PRTermItem methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitTermItem: self! !!PRBashScriptLanguage class methodsFor: 'testing'!isAbstract	^ false! !!PRBashScriptLanguage class methodsFor: 'requirement'!standardName	^ 'bash'! !!PRCSSScriptLanguage class methodsFor: 'testing'!isAbstract	^ false! !!PRCSSScriptLanguage class methodsFor: 'protected'!standardName	^ 'css'! !!PRHTMLScriptLanguage class methodsFor: 'testing'!isAbstract	^ false! !!PRHTMLScriptLanguage class methodsFor: 'requirement'!standardName	^ 'html'! !!PRHTTPScriptLanguage class methodsFor: 'testing'!isAbstract	^ false! !!PRHTTPScriptLanguage class methodsFor: 'requirement'!standardName	^ 'http'! !!PRJSONScriptLanguage class methodsFor: 'testing'!isAbstract	^ false! !!PRJSONScriptLanguage class methodsFor: 'requirement'!standardName	^ 'json'! !!PRJavaScriptScriptLanguage class methodsFor: 'testing'!isAbstract	^ false! !!PRJavaScriptScriptLanguage class methodsFor: 'protected'!standardName	^ 'javascript'! !!PRPillarLanguage class methodsFor: 'testing'!isAbstract	^ false! !!PRPillarLanguage class methodsFor: 'requirement'!standardName	^ 'pillar'! !!PRSQLScriptLanguage class methodsFor: 'testing'!isAbstract	^ false! !!PRSQLScriptLanguage class methodsFor: 'protected'!standardName	^ 'sql'! !!PRSTONScriptLanguage class methodsFor: 'testing'!isAbstract	^ false! !!PRSTONScriptLanguage class methodsFor: 'requirement'!standardName	^ 'ston'! !!PRShellCommandsScriptLanguage class methodsFor: 'testing'!isAbstract	^ false! !!PRShellCommandsScriptLanguage class methodsFor: 'requirement'!standardName	^ 'shellcommands'! !!PRSmalltalkScriptLanguage class methodsFor: 'testing'!isAbstract	^ false! !!PRSmalltalkScriptLanguage class methodsFor: 'requirement'!standardName	^ 'smalltalk'! !!UndefinedObject methodsFor: '*Pillar-Model-Core'!accept: aVisitor	<ignoreForCoverage>	"do nothing"! !!PRBeginColumnsAnnotation class methodsFor: 'testing'!hasParameters	^ false! !!PRBeginColumnsAnnotation class methodsFor: 'testing'!possibleParameters	^ #()! !!PRBeginColumnsAnnotation class methodsFor: 'protected'!tag	^ #columns! !!PRBeginColumnsAnnotation methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitColumnsAnnotation: self! !!PRCitationAnnotation class methodsFor: 'accessing'!possibleParameters	^ #(ref)! !!PRCitationAnnotation class methodsFor: 'protected'!tag	^ #cite! !!PRCitationAnnotation methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitCitationAnnotation: self! !!PRCitationAnnotation methodsFor: 'printing'!asPillarParametersOn: aStream	self parameters		at: 'ref'		ifPresent: [ :v | self asPillarKey: 'ref' value: v on: aStream ]! !!PRCitationAnnotation methodsFor: 'testing'!isCitation	^true! !!PRColumnAnnotation class methodsFor: 'accessing'!possibleParameters	^ #(width)! !!PRColumnAnnotation class methodsFor: 'protected'!tag	^ #column! !!PRColumnAnnotation methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitColumnAnnotation: self! !!PRColumnAnnotation methodsFor: 'printing'!asPillarParametersOn: aStream	self parameters		at: 'width'		ifPresent: [ :v | self asPillarKey: 'width' value: v asString on: aStream ]! !!PRDocumentListAnnotation class methodsFor: 'protected'!possibleParameters		^ #(path limit sort templates summaryMaxSize)! !!PRDocumentListAnnotation class methodsFor: 'protected'!tag	^ #docList! !!PRDocumentListAnnotation methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitDocListAnnotation: self! !!PRDocumentListAnnotation methodsFor: 'visiting'!limit	^ self parameters at: #limit ifAbsent: [ '3' ]! !!PRDocumentListAnnotation methodsFor: 'visiting'!path	^ self parameters at: #path! !!PRDocumentListAnnotation methodsFor: 'visiting'!sort	^ self parameters at: #sort ifAbsent: [ '' ]! !!PRDocumentListAnnotation methodsFor: 'visiting'!summaryMaxSize	^ self parameters at: #summaryMaxSize		ifPresent: [ :size | size asInteger ]		ifAbsent: [ 500 ]! !!PRDocumentListAnnotation methodsFor: 'visiting'!templates	^ self parameters at: #templates ifAbsent: [ #() ]! !!PREndColumnsAnnotation class methodsFor: 'testing'!hasParameters	^ false! !!PREndColumnsAnnotation class methodsFor: 'protected'!possibleParameters	^ #()! !!PREndColumnsAnnotation class methodsFor: 'protected'!tag 	^ #endColumns! !!PREndColumnsAnnotation methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitEndColumnsAnnotation: self! !!PRFootnoteAnnotation class methodsFor: 'accessing'!possibleParameters	^ #(note)! !!PRFootnoteAnnotation class methodsFor: 'protected'!tag	^ #footnote! !!PRFootnoteAnnotation methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitFootnoteAnnotation: self! !!PRFootnoteAnnotation methodsFor: 'descriptions'!asPillarParametersOn: aStream	self parameters		at: 'note'		ifPresent: [ :v | 			self asPillarKey: 'note' value: v asString on: aStream ]! !!PRIndexAnnotation class methodsFor: 'protected'!tag	^ #index! !!PRInputFileAnnotation class methodsFor: 'protected'!path: aPath	^ self withParameters: (OrderedDictionary new			at: 'path' put: aPath;			yourself)! !!PRInputFileAnnotation class methodsFor: 'protected'!possibleParameters	^ #(path)! !!PRInputFileAnnotation class methodsFor: 'protected'!tag	^ #inputFile! !!PRInputFileAnnotation class methodsFor: 'protected'!value: aValue		self deprecated: 'Please use #path: instead'		  transformWith: '`@receiver value: `@statements1' 						 -> '`@receiver path: `@statements1'.	^ self path: aValue! !!PRInputFileAnnotation methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitInputFileAnnotation: self! !!PRInputFileAnnotation methodsFor: 'printing'!asPillarParametersOn: aStream	self parameters		at: 'path'		ifPresent: [ :v | self asPillarKey: 'path' value: v asString on: aStream ]! !!PRInputFileAnnotation methodsFor: 'private'!errorFileNotFound: aFile	PRInputFileError signal: 'File at: ' , aFile fullName , ' not found.'! !!PRInputFileAnnotation methodsFor: 'accessing'!fileWithConfiguration: aConfiguration	"I search my file."	^ aConfiguration baseDirectory resolve: self path! !!PRInputFileAnnotation methodsFor: 'accessing'!path	^ self parameters at: 'path'! !!PRInputFileAnnotation methodsFor: 'accessing'!value	self deprecated: 'Please use #path instead'		  transformWith: '`@receiver value' 						  -> '`@receiver path'.	^ self path.! !!PRSlideTitleAnnotation class methodsFor: 'accessing'!possibleParameters	^ #(title label)! !!PRSlideTitleAnnotation class methodsFor: 'protected'!tag	^ #slide! !!PRSlideTitleAnnotation methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitSlideTitleAnnotation: self! !!PRTocAnnotation class methodsFor: 'accessing'!possibleParameters	^ #(depthLevel level)! !!PRTocAnnotation class methodsFor: 'protected'!tag	^ #toc! !!PRTocAnnotation methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitTOCAnnotation: self! !!PRDependencies methodsFor: 'accessing'!cachedDependencies	^ cachedDependencies ! !!PRDependencies methodsFor: 'visiting'!start: aDocument	cachedDependencies := Set new.	super start: aDocument.	^ cachedDependencies.! !!PRFileDependencies class methodsFor: 'testing'!isAbstract	^ false! !!PRFileDependencies methodsFor: 'visiting-document'!visitInternalLink: anInternalLink	anInternalLink hasReference		ifTrue: [ self cachedDependencies add: (anInternalLink localFileOrExternalReference) ].	super visitInternalLink: anInternalLink ! !!PRImageDependencies class methodsFor: 'as yet unclassified'!isAbstract	^ false! !!PRImageDependencies methodsFor: 'visiting-document'!visitFigure: anObject 	cachedDependencies add: anObject localFileOrExternalReference.	super visitFigure: anObject.! !!PRVisitor methodsFor: '*Pillar-Model'!visitCitation: aCitation	^ self visitDocumentItem: aCitation! !!PRVisitor methodsFor: '*Pillar-Model'!visitCitationAnnotation: aCitation	"Visiting an annotation means that we visit the textual representation of an annotation. Such annotations will be transformed into annotation object. The corresponding visit method will be invoked on such object : visitCitationAnnotation vs visitCitation."	^ self visitAnnotation: aCitation! !!PRVisitor methodsFor: '*Pillar-Model'!visitColumn: aColumn	^ self visitDocumentGroup: aColumn! !!PRVisitor methodsFor: '*Pillar-Model'!visitColumnAnnotation: aColumnAnnotation	"Visiting an annotation means that we visit the textual representation of an annotation. Such annotations will be transformed into annotation object. The corresponding visit method will be invoked on such object : visitColumnAnnotation vs visitColumn."	^ self visitAnnotation: aColumnAnnotation! !!PRVisitor methodsFor: '*Pillar-Model'!visitColumns: aColumns	^ self visitDocumentGroup: aColumns! !!PRVisitor methodsFor: '*Pillar-Model'!visitColumnsAnnotation: aColumnsAnnotation	"Visiting an annotation means that we visit the textual representation of an annotation. Such annotations will be transformed into annotation object. The corresponding visit method will be invoked on such object : visitColumnsAnnotation vs visitColumns."	^ self visitAnnotation: aColumnsAnnotation! !!PRVisitor methodsFor: '*Pillar-Model'!visitDocListAnnotation: aPRDocListAnnotation 	^ self visitAnnotation: aPRDocListAnnotation! !!PRVisitor methodsFor: '*Pillar-Model'!visitEndColumnsAnnotation: aEndColumnsAnnotation	^ self visitAnnotation: aEndColumnsAnnotation! !!PRVisitor methodsFor: '*Pillar-Model'!visitEndEnvironmentAnnotation: aEndEnvironmentAnnotation	"Visiting an annotation means that we visit the textual representation of an annotation. Such annotations will be transformed into annotation object. The corresponding visit method will be invoked on such object : visitBeginEnvironmentAnnotation vs visitBeginEnvironment."	^ self visitAnnotation: aEndEnvironmentAnnotation! !!PRVisitor methodsFor: '*Pillar-Model'!visitFootnote: aFootnote	^ self visitDocumentItem: aFootnote! !!PRVisitor methodsFor: '*Pillar-Model'!visitFootnoteAnnotation: aFootnoteAnnotation	"Visiting an annotation means that we visit the textual representation of an annotation. Such annotations will be transformed into annotation object. The corresponding visit method will be invoked on such object : visitFootnoteAnnotation vs visitFootnote."	^ self visitAnnotation: aFootnoteAnnotation! !!PRVisitor methodsFor: '*Pillar-Model'!visitInputFileAnnotation: anInputFileAnnotation	^ self visitAnnotation: anInputFileAnnotation! !!PRVisitor methodsFor: '*Pillar-Model'!visitSlide: aSlide	^ self visitDocumentGroup: aSlide! !!PRVisitor methodsFor: '*Pillar-Model'!visitSlideTitleAnnotation: aSlideTitleAnnotation	"Visiting an annotation means that we visit the textual representation of an annotation. Such annotations will be transformed into annotation object. The corresponding visit method will be invoked on such object : visitSlideTitleAnnotation vs visitSlide."	^ self visitAnnotation: aSlideTitleAnnotation! !!PRVisitor methodsFor: '*Pillar-Model'!visitTOCAnnotation: aTOCAnnotation	^ self visitAnnotation: aTOCAnnotation! !!PRVisitor methodsFor: '*Pillar-Model'!visitTable: anObject	^ self visitDocumentGroup: anObject! !!PRVisitor methodsFor: '*Pillar-Model'!visitTableCell: anObject	^ self visitDocumentGroup: anObject! !!PRVisitor methodsFor: '*Pillar-Model'!visitTableRow: anObject	^ self visitDocumentGroup: anObject! !!PRColumn class methodsFor: 'instance creation'!width: aNumber	^ self new		width: aNumber;		yourself! !!PRColumn methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitColumn: self! !!PRColumn methodsFor: 'accessing'!width	^ width! !!PRColumn methodsFor: 'accessing'!width: anObject	width := anObject! !!PRColumnEnvironment methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitColumns: self! !!PRSlide class methodsFor: 'instance creation'!titled: aTitle	^ self new		title: aTitle;		yourself! !!PRSlide methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitSlide: self! !!PRSlide methodsFor: 'testing'!hasLabel	^ label isNotNil! !!PRSlide methodsFor: 'accessing'!label	^ label! !!PRSlide methodsFor: 'accessing'!label: anObject	label := anObject! !!PRSlide methodsFor: 'accessing'!title	^ title ifNil: [ 'New Slide' ]! !!PRSlide methodsFor: 'accessing'!title: anObject	title := anObject! !!PRReferenceNotFound methodsFor: 'accessing'!inputFile: aFile	inputFile := aFile! !!PRReferenceNotFound methodsFor: 'accessing'!messageText	^inputFile ifNil: [ super messageText ] ifNotNil: [ inputFile pathString, ' ', super messageText ]! !!PRDefinitionList methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitDefinitionList: self! !!PRSubscriptFormat methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitSubscriptFormat: self! !!PRSuperscriptFormat methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitSuperscriptFormat: self! !!PRUnderlineFormat methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitUnderlineFormat: self! !!PRCitation class methodsFor: 'as yet unclassified'!defaultRef	^'No Reference'! !!PRCitation class methodsFor: 'as yet unclassified'!isAbstract	^false! !!PRCitation class methodsFor: 'as yet unclassified'!ref: aString	^ self new		ref: aString;		yourself! !!PRCitation methodsFor: 'comparing'!= anObject	^ super = anObject and: [ self ref = anObject ref ]! !!PRCitation methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitCitation: self! !!PRCitation methodsFor: 'initialization'!initialize	super initialize.	ref := self class defaultRef! !!PRCitation methodsFor: 'accessing'!ref	^ ref! !!PRCitation methodsFor: 'accessing'!ref: aString	ref := aString! !!PRFootnote class methodsFor: 'testing'!isAbstract	^ false! !!PRFootnote class methodsFor: 'instance creation'!noted: aString	^ self new note: aString.! !!PRFootnote methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitFootnote: self.! !!PRFootnote methodsFor: 'accessing'!note	^ note! !!PRFootnote methodsFor: 'accessing'!note: aString	note := aString! !!PRToc class methodsFor: 'testing'!isAbstract	^ false! !!PRToc methodsFor: 'comparing'!= anItem	^ self species = anItem species		and: [ self name = anItem name				and: [ self level = anItem level and: [ self fileReference = anItem fileReference ] ] ]! !!PRToc methodsFor: 'adding'!addChildren: aToc	children add: aToc! !!PRToc methodsFor: 'converting'!asCTEnvironmentWithParent: aParent	| dictionary |	dictionary := CTEnvironment new.	dictionary parent: aParent.		dictionary at: #name put: name.	dictionary at: #level put: level.	self hasFileReference ifTrue: [ 		dictionary			at: #href			put: '/', (self changeFileExtension: fileReference) , '#' , self name asLowercase.	].	dictionary at: #hasChildren put: self children isNotEmpty.	dictionary at: #children put: (self children collect: [ :each | 		each asCTEnvironmentWithParent: dictionary ]).	^ dictionary! !!PRToc methodsFor: 'converting'!asDictionary	| dictionary |	dictionary := Dictionary new.	dictionary at: #name put: name.	dictionary at: #level put: level.	self hasFileReference ifTrue: [ 		dictionary			at: #href			put: '/', (self changeFileExtension: fileReference) , '#' , self name asLowercase.	].	dictionary at: #hasChildren put: self children isNotEmpty.	dictionary at: #children put: (self children collect: [ :each | 		each asDictionary			at: #parent put: dictionary;			yourself ]).	^ dictionary! !!PRToc methodsFor: 'converting'!changeFileExtension: aPillarFile	^ ((aPillarFile splitOn: '.') at: 1) , '.html'! !!PRToc methodsFor: 'accessing'!children	^ children! !!PRToc methodsFor: 'accessing'!children: anObject	children := anObject! !!PRToc methodsFor: 'comparing'!compareChildren: anItem	^ (self children with: anItem children collect: [ :elem1 :elem2 | elem1 = elem2 ])		inject: true		into: [ :res :elem | res & elem ]! !!PRToc methodsFor: 'accessing'!fileReference	^ fileReference! !!PRToc methodsFor: 'accessing'!fileReference: anObject	fileReference := anObject! !!PRToc methodsFor: 'testing'!hasFileReference	^ fileReference isNotNil! !!PRToc methodsFor: 'comparing'!hash	^ name hash + level hash + fileReference hash! !!PRToc methodsFor: 'comparing'!hashChildren	^ (self children collect: [ :elem | elem hash ])		inject: 0		into: [ :sum :value | sum + value ]! !!PRToc methodsFor: 'adding'!initialize	super initialize.	children := OrderedCollection new! !!PRToc methodsFor: 'accessing'!level	^ level! !!PRToc methodsFor: 'accessing'!level: anObject	level := anObject! !!PRToc methodsFor: 'accessing'!name	^ name! !!PRToc methodsFor: 'accessing'!name: anObject	name := anObject! !!Collection methodsFor: '*Pillar-Model-Core'!acceptDecorated: aVisitor	<ignoreForCoverage "This method is ignored for test coverage because it exists only as a hook for other frameworks (i.e., Magritte).">	self accept: aVisitor! !"Pillar-Model"!!CodeBlockDefaultLanguageItem commentStamp: '' prior: 0!I'm a specific item for Pillar only configuration. I'm used to manage languages. Used for example this waylanguageForScript: aScript	^ aScript language isSpecified		ifTrue: [ aScript language ]		ifFalse: [ self configuration defaultScriptLanguage ]			scriptLanguages are defined that way in cocoondescriptionDefaultScriptLanguage	<magritteDescription>	^ PRMagritteScriptLanguageDescription new		priority: 100;		accessor: #defaultScriptLanguage;		label: 'Default language for scripts.';		cocoonDocumentation:				'Indicate the language in scripts when none is specified. This language is used for syntax highlighting. The currently supported languages are ', (PRRealScriptLanguage withAllConcreteClasses collect: #standardName) asCommaStringAnd, '.';		default: PRUnspecifiedScriptLanguage default;		cocoonDefaultDocumentation: 'An unspecified language';		yourself			PRRealScriptLanguage withAllConcreteClasses collect: #standardName >>> #('bash' 'css' 'html' 'http' 'json' 'javascript' 'pillar' 'sql' 'ston' 'shellcommands' 'smalltalk')PRUnspecifiedScriptLanguage default >>> ''!!ConfigurationDescriptionForPillar commentStamp: '' prior: 0!I'm just holding some descriptions that are used to generate the configurationForPillar class.ChrysalConfigurationBuilder new 	configurationRootClass: ChrysalPillarishConfiguration;	defineConfigurationClassNamed: #ConfigurationForPillar 	packagedIn: 'Pillar-Chrysal'; 	withDescriptionItems: ConfigurationDescriptionForPillar itemDescriptionForPillar!!CodeBlockDefaultLanguageItem methodsFor: 'accessing'!defaultDomainValueString	"Returns a string representing the default value but as an object once imported in Pharo and not a string used by the writer of a configuration."	^ '(PRRealScriptLanguage for: {1})' format: {self default}! !!CodeBlockDefaultLanguageItem methodsFor: 'accessing'!defaultValue	"Default value is the default value of an item in the domain of the configuration writer and not in the Pharo world."	^ nil  		"so that we get PRRealScriptLanguage for: nil 	returns a PRUnspecificiedScriptLanguage"! !!CodeBlockDefaultLanguageItem methodsFor: 'conversion'!domainValueConversionString	"Returns a string converting a string as written by in the configuration file to a pharo object. 	Note that this method is like the body of a macro that will be expanded in the configuration class: here aValue is the name of the parameter of the generated method.		 Parameter of the item like baseline should be accessed via self nameOfProperty"	^ '^ PRAbstractScriptLanguage for: aValue' ! !!CodeBlockDefaultLanguageItem methodsFor: 'initialization'!initialize	super initialize. 	propertyName := #defaultScriptLanguage.	explanation := 'Indicate the language in scripts when none is specified. This language is used for syntax highlighting. The currently supported languages are ', self possibleValuesString! !!CodeBlockDefaultLanguageItem methodsFor: 'initialization'!possibleValuesString	^(PRRealScriptLanguage withAllConcreteClasses collect: #standardName) asCommaStringAnd.! !!ConfigurationDescriptionForPillar class methodsFor: 'sample'!itemDescriptionForPillar	^ {	(PathConfigurationItem new 		propertyName: #bibFile; 		default: 'book.bib'; 		explanation: 'Identify the file to be taken as input for the bibliography. This is the .bib file used to resolve the ${cite:ref=Key}$ annotation.'; 		yourself)	.	(StringConfigurationItem new		propertyName: #title;		default: 'my super cool book';		yourself).	(StringConfigurationItem new		propertyName: #attribution;		default: 'me, myself and I';		yourself).	(NumberConfigurationItem new		propertyName: #headingLevelOffset;		explanation:			'Indicate how to convert from the level of a Pillar heading to the level of heading in your exported document.	For example, a headingLevelOffset of 3 converts a 1st level Pillar heading to an <h4>in HTML';		default: 0;		yourself).	(StringConfigurationItem new		propertyName: #series;		default: 'Square Bracket Associate Collection';		yourself).	(StringConfigurationItem new		propertyName: #keywords;		default: 'Pharo';		yourself).	(PathConfigurationItem new		propertyName: #outputDirectory;		default: 'build').	(FolderConfigurationItem new		propertyName: #baseDirectory;		default: '.').	(FileConfigurationItem new		propertyName: #outputFile;		default: 'output';		explanation:			'If separateOutputFiles is false, indicate the name of the output file. This can also be a write stream.').	(FileConfigurationItem new		propertyName: #mainDocument;		default: 'book').	(FileConfigurationItem new		propertyName: #inputFile;		default: 'book';		explanation:			'The Pillar file that must be transformed. You can also specify an input file at the end of the command-line interface. Previously there was no default value').	(StringConfigurationItem new		propertyName: #latexTemplate;		default: '_support/templates/main.latex.mustache').	(BooleanConfigurationItem new		propertyName: #scrambledEmailAddresses;		beFalseAsDefault).	(BooleanConfigurationItem new		propertyName: #separateOutputFiles;		explanation:			'If true, each input file is exported to one output file. If false (the default), all input files are exported to outputFile.';		beFalseAsDefault).	(BooleanConfigurationItem new		propertyName: #renderStructureAsSlide;		explanation:			'When true (the default), Pillar will create a dedicated slide for each Pillar header. This parameter is meaningless when generating a written document';		beTrueAsDefault).	(StringConfigurationItem new		propertyName: #latexChapterTemplate;		default: '_support/templates/chapter.latex.mustache').	(StringConfigurationItem new		propertyName: #htmlTemplate;		default: '_support/templates/html.mustache').	(StringConfigurationItem new		propertyName: #htmlChapterTemplate;		default: '_support/templates/html.mustache').	(NewLineConfigurationItem new		propertyName: #newLine;		defaultIsPlatform).	(StringConfigurationItem new		propertyName: #latexWriter;		default: #latex:sbabook;		yourself)			.	(StringConfigurationItem new		propertyName: #htmlWriter;		default: #html;		yourself)			.	(NumberConfigurationItem new		propertyName: #slideInTemplateForDeckJS;		explanation: 'Number of slides in Template: Indicate the number of slides created by the DeckJS template. This is important to create anchors.';		default: 1;		yourself).	(CodeBlockDefaultLanguageItem new)	.	(CompositeConfigurationItem new		propertyName: #levelSpecification;		default: #PRTitlePrinterSpecification;		fields: #(level renderAs capitalization numbering headerSize);		yourself)	.	(ListConfigurationItem new		propertyName: #levels;		default: #OrderedCollection;		element: #levelSpecification;		yourself)	.	(PathConfigurationItem new		propertyName: #tocFile;		explanation: 'Identify the file to be taken as input for the root of the table of contents. When it is not specified, the table of contents will not be computed and displayed';		yourself)	}! !"Pillar-Chrysal-Generator"!!PRBuildStrategy commentStamp: '' prior: 0!I represent ways to identify files to process.My main extension point is the method filesToBuildOn: aProject!!PRBuildAllStrategy commentStamp: '' prior: 0!This strategy will handle all the files in the root. note that for now it does not work.!!PRBuildListStrategy commentStamp: '' prior: 0!On the command line we can pass a list of files to be processed: ```pillar build pdf file1.pillar file2.pillar```Note that there is a bug when using two files.!!PRBuildRootMainStrategy commentStamp: '' prior: 0!I'm a file strategy that identifies the pillar file on the root of the repository: i.e., index.pillar or book.pillar.I (will be) used when the user types 	pillar build pdf!!PRDocumentListSorter commentStamp: '' prior: 0!A class for representing a gloabl sorter for different kind of sorting!!PRDocumentListDateSorter commentStamp: '' prior: 0!I am a class use for sorting files according their modifications dates.By default it is descending sorting.PRDocListDateSorter with: aCollectionOfReferences!!PRDocumentListNameSorter commentStamp: '' prior: 0!I am a class use for sorting files according their basename.By default it is ascending sorting.PRDocListNameSorter with: aCollectionOfReferences!!PRTitlePrinter commentStamp: '' prior: 0!I'm responsible for printing header level.I contain level descriptions.  !!PRTitlePrinterSpecification commentStamp: '' prior: 0!I describe how a level should be printed. - My level is the level of the header I describe.- Numbering is a boolean.	 If numbering is false, the numerator will not take this level of header into account.	If size is at 0, i'll take this level of header into account for the numerator but i'll not render the counter. If my size is at 1 i'll only render the numer of my header level. If my size x i'll render the counter of my level and the counter of x-1 of my parents.- renderAs represents the kind of representation I want for my counter. It can be "number", "roman", "letter" or "upperLetter".If numbering is at false, the size need to be 0.!!PRLevelRomanPrinter commentStamp: '' prior: 0!I'm a configuration that render myself as a Roman number.!!PRTransformersDocumentation commentStamp: '' prior: 0!I am a class that will generate the documentation of the transformers in Pillar.I will use the 'pillarTransformer:key:documentation' pragma. I will display the keyword and the documentation of a transformer. The keyword is use to disable a transformer into a configuration.To use me you can execute :| stream |stream := '' writeStream.PRTransformersDocumentation on: stream.stream contents!!PRCreateSymLink commentStamp: '' prior: 0!I allow to create a symbolic Link!!PRExportBrush commentStamp: '' prior: 0!I'm the superclass of all brushes. A brush is something you can add on a canvas. For example, LaTeX command and environment brushes can be added to a LaTeX canvas; HTML tags can be added to an HTML canvas.!!PRExportCanvas commentStamp: '' prior: 0!I am the place where the visitors will write stuff. I output everything to a stream. Eventhough I have some streaming capabilities (#nextPutAll:, #raw:, ...), my clients should use brushes as much as possible instead. This is because the brushes will take the responsibility to write correct text for the clients.!!PROutputStream commentStamp: '' prior: 0!I represent a very simple interface for writing text to a stream.I'm associated with a configuration which knows some details about the output stream (e.g., the line ending convention)!!PRConfigurationError commentStamp: '' prior: 0!I am the error raised when the configuration provided during the export is invalid.!!PRExportError commentStamp: '' prior: 0!I'm an exception class representing errors that happens while exporting a pillar document.!!PRNoInputFileError commentStamp: '' prior: 0!I am an error raised when no input file is specified while exporting a pier document!!PRCompilationContext commentStamp: '' prior: 0!S. Ducasse comment: It looks like this class is actually doing nothing since it just stores two values and returns value. Most of the time people write(PRCompilationContext 	withDocument: anInput	withConfiguration: 'ljkjlkjkl') input	(PRCompilationContext 	withDocument: 'jkljlkj'	withConfiguration: 'ljkjlkjkl') inputBut PRCheckPhase uses the configuration passed bt the context. executeOn: aPillarContext	self new		configuration: aPillarContext configuration;		start: aPillarContext input.	^ aPillarContext	!!PROutputDocument commentStamp: '' prior: 0!I represent a pillar output document.I contain the already written text (String) and the pillar document (ast) used to generate it. I'm useful in the post-processing steps of a pipeline, where a pipeline can choose to, for example:- apply a template to the already written text (using the document's metadata)- dump the text into a file!!PRPhase commentStamp: '' prior: 0!I am an abstract class to describe a Phase of an export. A Phase takes an input, transforms it and returns an output.A phase holds a configuration. This configuration is a  the configuration of the export.To create a new phase you have to define its prority as a class method then to define the action of the Phase with a method actionOn: anInput. This method will return an output. You can also add some transformations to the output like: transformerInputFileOn: aCollection	<pillarTransformer: 1> "the parameter is the priority of the transformation"	aCollection		do: [ :each | 			PRFileInclusion new				configuration: self configuration;				start: each ]!!PRDocumentChildrenTransformer commentStamp: '' prior: 0!I'm an abstract class. I allows the transformation of a tree. I'll visit the children of a document a remplace them by a collection of newChildren.newChildren is a Collection where we stock the new children of PRDocument during the transformation.!!PRSectionTransformer commentStamp: '' prior: 0!For each header, I add a section structure. This is useful in export formats (such as HTML5 and Docbook) where sub-sections are embedded in their parent section.!!ManifestPillarExporterCore commentStamp: '' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!PRCyclicFileInclusionError commentStamp: '' prior: 0!I am an error announcing cyclic dependencies between pillar files.!!PRDocumentWriter commentStamp: '' prior: 0!I'm the superclass of all classes supposed to output a pillar document to a text file. I have a canvas to which the subclasses can write to using dedicated brushes. I have a configuration which specifies some details about how to write text (e.g., end of line convention).I can either emit the raw text or converted text. By default I convert text. !!PRNodeTransformer commentStamp: '' prior: 0!I'm an abstract class. I allow the transformation of a tree. I'll visit a tree and if a node needs to be transformed I'll replace the node by its transformation. replacement is a Stack with all the nodes of the branch of the node I'm visiting.!!PRAnchorOfSection commentStamp: '' prior: 0!After each title I add an anchor with the title of the section.I'm used with the autoAnchor configuration parameter.!!PRCitationTransformer commentStamp: '' prior: 0!I am a transformer which will replace the citation annotations  by a real citation structure.!!PRCleanAnnotationInParagraphTransformer commentStamp: '' prior: 0!When a paragraph only contains an annotation, I remove the paragraph so the annotation becomes a top-level child of the document.!!PRColumnsTransformer commentStamp: '' prior: 0!I replace each ==columns== annotation with a structure of columns.!!PRFileInclusion commentStamp: '' prior: 0!I replace each ==inputFile== annotation with the content of the referenced file.!!PRFootnoteTransformer commentStamp: '' prior: 0!I replace each ==footnote== annotation with a structure of footnote.!!PRHeadingLevelOffsetTransformer commentStamp: '' prior: 0!Convert from the level of a Pillar heading to the level of heading in the exported document. For example, a ==headingLevelOffset== of 3 converts a 1st level Pillar heading to an ==<h4>== in HTML.!!PRNumeratingLinksVisitor commentStamp: '' prior: 0!I'm created with an anchorsMapping and i give counters at each internal links of the document I visit.!!PRNumeratingVisitor commentStamp: '' prior: 0!I add numbers to all titles, scripts, figures, and internal links.!!PRPrintingTransformer commentStamp: '' prior: 0!I support the use of a printer to print title and sections related transformations.!!PRRemoveHideableScripts commentStamp: '' prior: 0!I visit a document and I hide scripts with ==hideable== parameter at ==true==.!!PRScriptEvaluator commentStamp: '' prior: 0!I replace each script with ==eval=true== with the result of its evaluation.!!PRScriptFromFile commentStamp: '' prior: 0!I replace each script with a ==fromFile== parameter with the content of the referenced file.!!PRScriptLineNumber commentStamp: '' prior: 0!I add line numbers to each script with ==lineNumber=true==.[[[lineNumber=true					]]]S. Ducasse: String new writeStream is no correct because imagine that we are on mac and we want to produce document for windows... We should not output mac end of line. This is why PROutputStream should be used instead. !!PRSlideTransformer commentStamp: '' prior: 0!I replace each slide annotation with a slide structure.!!PRTemplatedWriter commentStamp: '' prior: 0!I am a pillar document writer that wraps a normal wrapper.When writing one element, I first check if there is a file in the current template that overrides the default writing. If so, I use that file to template the contents.Otherwise I simply delegate the writing to the wrapped one.I am carefully designed so if an element X is delegated to the wrapped writer, it should delegate the writing of X's children back to myself.!!PRTocBuilderVisitor commentStamp: '' prior: 0!I am a visitor in charge of extracting table of contents from the files by visiting headers and inputAnnotations.How to !!?PRTocBuilderVisitor new 	documentSource: (FileSystem workingDirectory / 'file.pillar'); 	currentFile: 'file.pillar';  	inProcessFiles: (Array with: (FileSystem workingDirectory  / 'file.pillar' )); 	visit: (PRPillarParser parse: (FileSystem workingDirectory / 'file.pillar') asFileReference readStream)!!PRUpdateFileInclusionReference commentStamp: '' prior: 0!I update all reference of figures and internal links for file inclusion !!PRAbstractOutputDocument methodsFor: 'accessing'!baseDirectory		^ project baseDirectory! !!PRAbstractOutputDocument methodsFor: 'writing'!basicWriter		self subclassResponsibility! !!PRAbstractOutputDocument methodsFor: 'building'!buildOn: aPRProject 		| parsedDocument transformedDocument writtenFile |	parsedDocument := self parseInputFile: file.	parsedDocument properties: (self metadataConfigurationForDocument: parsedDocument).	transformedDocument := parsedDocument transformDocumentFor: self.	writtenFile := self writeDocument: transformedDocument.	self postWriteTransform: writtenFile.	^ PRSuccess new.! !!PRAbstractOutputDocument methodsFor: 'accessing'!configuration		^ project configuration! !!PRAbstractOutputDocument methodsFor: 'accessing'!extension	self subclassResponsibility! !!PRAbstractOutputDocument methodsFor: 'accessing'!file	^ file! !!PRAbstractOutputDocument methodsFor: 'accessing'!file: aFile		file := aFile! !!PRAbstractOutputDocument methodsFor: 'metadata'!getMustacheTemplateValuesFromDocument: aDocument	"aDocument already has a conifguration holding potential metadata. 	We add the text contents to it. This dictionarylike structure will be used by the mustache."	| templates content |	content := self writer write: aDocument.	templates := aDocument properties.	templates at: #content put: content.	^ templates! !!PRAbstractOutputDocument methodsFor: 'accessing'!inputFile		^ file file! !!PRAbstractOutputDocument methodsFor: 'metadata'!metadataConfigurationForDocument: aDocument 	"create an environment with the local document properties as children of the document properties."		| subConfiguration |	subConfiguration := project configuration class newFromDictionary: aDocument properties.	subConfiguration parent: project configuration.	^ subConfiguration! !!PRAbstractOutputDocument methodsFor: 'accessing'!outputDirectory		"pay attention the output directory of an output document is more precise than the one of a project. 	Indeed it will take into account the kind of document and add 'pdf', 'html'.... as subfolder.	See PRPdfOutput >> #documentFor: to see the logic."		^ outputDirectory ifNil: [ project outputDirectory ]! !!PRAbstractOutputDocument methodsFor: 'accessing'!outputDirectory: aFileReference	"pay attention the output directory of a output document is more precise than the one of a project. 	Indeed it will take into account the kind of document and add 'pdf', 'html'.... as subfolder.	See PRPdfOutput >> #documentFor: to see the logic."		outputDirectory := aFileReference ! !!PRAbstractOutputDocument methodsFor: 'building'!parseInputFile: anInputFile		^ anInputFile parsedDocument! !!PRAbstractOutputDocument methodsFor: 'building'!postWriteTransform: aFile	"Nothing. Hook for subclasses"! !!PRAbstractOutputDocument methodsFor: 'accessing'!project		^ project! !!PRAbstractOutputDocument methodsFor: 'accessing'!project: aPRProject 		project := aPRProject! !!PRAbstractOutputDocument methodsFor: 'accessing'!tableOfContents		^ project tableOfContents! !!PRAbstractOutputDocument methodsFor: 'accessing'!target: aTarget 	target := aTarget! !!PRAbstractOutputDocument methodsFor: 'templating'!templateDirectory	^ project baseDirectory / '_support' / 'templates' / self writer folderName! !!PRAbstractOutputDocument methodsFor: 'templating'!templateFile		^ project baseDirectory / (self writer templateForConfiguration: project configuration)! !!PRAbstractOutputDocument methodsFor: 'templating'!templateFile: aDocument	^ self templateDirectory		/ (aDocument propertyAt: 'template' ifAbsent: [ self writer templateForConfiguration: project configuration ])! !!PRAbstractOutputDocument methodsFor: 'building'!transformDocument: aDocument	"Double dispatch hook invoked by document. In addition let the document control the inclusion process and the transformations."		| withInclusions |	withInclusions := aDocument includeFor: file.		^ (self transformationsFor: aDocument)		inject: withInclusions		into: [ :accum :each | each start: accum ]! !!PRAbstractOutputDocument methodsFor: 'accessing'!transformations		^ target transformations! !!PRAbstractOutputDocument methodsFor: 'accessing'!transformationsFor: aDocument		^ target transformations! !!PRAbstractOutputDocument methodsFor: 'building'!writeDocument: aDocument	| environment templatedOutput outputFile |	environment := self getMustacheTemplateValuesFromDocument: aDocument.	templatedOutput := (MustacheTemplate on: (self templateFile: aDocument) readStream contents) value: environment.			self flag: #DuplicatedInSubclass.	outputFile := (self outputDirectory resolve: (file file asAbsolute relativeTo: project baseDirectory asAbsolute)) withoutExtension , self extension.	outputFile ensureDelete.	outputFile parent ensureCreateDirectory.	outputFile writeStreamDo: [ :stream | stream nextPutAll: templatedOutput ].	^ outputFile! !!PRAbstractOutputDocument methodsFor: 'writing'!writer		"If templating is active in the command, use the templated writer"	| writer |	writer := self basicWriter.	project isTemplatable ifTrue: [ 		writer := PRTemplatedWriter new			outputDocument: self;			defaultWriter: writer;			yourself ].	^ writer! !!PRBuildAllStrategy class methodsFor: 'instance-creation'!on: aPRProject 		^ self new		project: aPRProject;		yourself! !!PRBuildAllStrategy methodsFor: 'accessing'!filesToBuildOn: aProject		| children |	children := aProject baseDirectory children reject: [ :maybeExcludedDirectory |		self shouldExcludeDirectory: maybeExcludedDirectory ].	^ children flatCollect: [ :each |		each allChildren			select: [ :file | file isFile and: [ self isSupportedExtension: file extension ] ]			thenCollect: [ :file | 				(PRInputDocument forFile: file)					project: aProject;					yourself ] ]! !!PRBuildAllStrategy methodsFor: 'private - testing'!shouldExcludeDirectory: aFileReference 		^ aFileReference basename beginsWithAnyOf: #( '.' '_' )! !!PRBuildListStrategy class methodsFor: 'instance-creation'!list: aCollection 		^ self new		files: aCollection;		yourself! !!PRBuildListStrategy methodsFor: 'accessing'!files: aCollection 	files := aCollection asSet! !!PRBuildListStrategy methodsFor: 'accessing'!filesToBuildOn: aProject	^ files collect: [ :file | 				(PRInputDocument forFile: (aProject baseDirectory resolve: file))					project: aProject;					yourself ]! !!PRBuildRootMainStrategy methodsFor: 'accessing'!filesToBuildOn: aProject 	"select the only file with pillar extension in current directory ; if there is no OR several pillar files, relative error is raised"	"Now it select a file named index which can be a pillar or a microdown file and if there is no one, relative error is raised"		| pillarFiles|	pillarFiles := aProject baseDirectory children select: [ :each | each isFile and:[ self isSupportedExtension: each  extension ] ].	pillarFiles reject: [ :each | each basename = 'README' ].	pillarFiles ifEmpty: [ self error: 'There is no pillar (md or pillar) file in the repository root.' ].	pillarFiles size = 1 ifTrue: [ ^ { (PRInputDocument forFile: pillarFiles first) 			project: aProject;			yourself } ].	self error: 'There is more than one pillar file in the repository root.'! !!PRBuildStrategy methodsFor: 'accessing'!filesToBuildOn: aProject	self subclassResponsibility! !!PRBuildStrategy methodsFor: 'accessing'!initialize	super initialize.	supportedLanguageExtensions := #('pillar' 'mic' 'md' 'MIC' 'MD')! !!PRBuildStrategy methodsFor: 'accessing'!isSupportedExtension: aString	^ supportedLanguageExtensions includes: aString trimBoth! !!PRCopyPhase class methodsFor: 'instance-creation'!directory: aString 		^ self new		directory: aString;		yourself! !!PRCopyPhase methodsFor: 'accessing'!destinationDirectory	^ destinationDirectory! !!PRCopyPhase methodsFor: 'accessing'!destinationDirectory: anObject	destinationDirectory := anObject! !!PRCopyPhase methodsFor: 'executing'!executeOn: aPRCompilationContext	destinationDirectory exists		ifTrue: [ ^ self ].	destinationDirectory ensureCreateDirectory.	sourceDirectory copyAllTo: destinationDirectory.	^ self! !!PRCopyPhase methodsFor: 'accessing'!sourceDirectory	^ sourceDirectory! !!PRCopyPhase methodsFor: 'accessing'!sourceDirectory: anObject	sourceDirectory := anObject! !!PRDocumentListDateSorter methodsFor: 'accessing'!initialize	super initialize.	files := OrderedCollection new.	direction := -1! !!PRDocumentListDateSorter methodsFor: 'sorting'!sort	^ files sort: [ :a :b | 		direction < 0 ifTrue: [a modificationTime > b modificationTime ]		ifFalse: [a modificationTime < b modificationTime]]! !!PRDocumentListNameSorter methodsFor: 'initialization'!initialize	super initialize.	files := OrderedCollection new.	direction := 1! !!PRDocumentListNameSorter methodsFor: 'initialization'!sort	^ files sort: [ :a :b | 		direction > 0 ifTrue: [a basename < b basename ]		ifFalse: [a basename > b basename]]! !!PRDocumentListSorter class methodsFor: 'instance creation'!with: aCollection	^ self new		files: aCollection;		sort! !!PRDocumentListSorter class methodsFor: 'instance creation'!with: aCollection order: aString	^ self new		files: aCollection;		direction: aString;		sort! !!PRDocumentListSorter methodsFor: 'accessing'!direction	^ direction! !!PRDocumentListSorter methodsFor: 'accessing'!files	^ files! !!PRDocumentListSorter methodsFor: 'accessing'!files: anObject	files := anObject! !!PRDocumentListSorter methodsFor: 'accessing'!sort	^ self subclassResponsibility ! !!PRInputDocument class methodsFor: 'factory'!forFile: aFile		^ (self inputClassForFile: aFile) new file: aFile ; yourself! !!PRInputDocument class methodsFor: 'factory'!inputClassForFile: aFile	"In the future classes should register explicitely and not be based on subclasses or implementator tricks."			"^ self subclasses		detect: [ :each | each doesHandleExtension: aFile extension ]		ifNone: [ PRNoInputDocument  ]			before microdown integration we only looked in the subclasses of PRInputDocument. 	Now MicInputDocument is not a subclass of PRInputDocument for dependency reasons.	It could be fixed with proper packaging."			^ ((SystemNavigation default allImplementorsOf: #doesHandleExtension:) 		collect: [ :each | each methodClass instanceSide ]) 		detect: [ :each | each doesHandleExtension: aFile extension ]		ifNone: [ PRNoInputDocument  ]! !!PRInputDocument methodsFor: 'accessing'!basename		^ file basename! !!PRInputDocument methodsFor: 'building'!contributeToPipelineBuilding: aPRPipelineBuilder 		1halt.	self flag: #maybeToRemove.		aPRPipelineBuilder setInputDocument: file.	aPRPipelineBuilder parser: self parser! !!PRInputDocument methodsFor: 'accessing'!file	^ file! !!PRInputDocument methodsFor: 'accessing'!file: aFileReference 	file := aFileReference! !!PRInputDocument methodsFor: 'accessing'!fullName	^ file fullName! !!PRInputDocument methodsFor: 'accessing'!path		^ file path! !!PRInputDocument methodsFor: 'printing'!printOn: aStream	aStream		nextPutAll: self class name;		nextPutAll: '(';		nextPutAll: file fullName;		nextPutAll: ')'! !!PRInputDocument methodsFor: 'accessing'!project	^ project! !!PRInputDocument methodsFor: 'accessing'!project: aPRProject 	project := aPRProject! !!PRNoInputDocument class methodsFor: 'registration'!doesHandleExtension: anExtension	^ false! !!PRNoInputDocument methodsFor: 'accessing'!parserClass 	"may be the error should not be raised here."		self error: 'Extension file ', file extension, 'not recognized'! !!PRPillarInputDocument class methodsFor: 'registration'!doesHandleExtension: anExtension	^ anExtension = 'pillar'! !!PRPillarInputDocument methodsFor: 'accessing'!parsedDocument	^ self parserClass parse: file contents! !!PRPillarInputDocument methodsFor: 'accessing'!parserClass		^ PRDocument parser ! !!PRFailure methodsFor: 'controlling'!and: aPRStatus		^ self! !!PRFailure methodsFor: 'controlling'!exitProcess	Exit signalFailure! !!PRFailure methodsFor: 'controlling'!isFailure	^ true! !!PRFailure methodsFor: 'controlling'!isSuccess	^ false! !!PRFailure methodsFor: 'controlling'!value	^ 1! !!PRStatus class methodsFor: 'instance creation'!withStatus: aBoolean	^ aBoolean 		ifTrue: [ PRSuccess new ]		ifFalse: [ PRFailure new ]! !!PRStatus methodsFor: 'controlling'!and: aPRStatus	self subclassResponsibility! !!PRStatus methodsFor: 'controlling'!exitProcess	self subclassResponsibility! !!PRStatus methodsFor: 'controlling'!isFailure	self subclassResponsibility ! !!PRStatus methodsFor: 'controlling'!isSuccess	self subclassResponsibility ! !!PRStatus methodsFor: 'controlling'!value	self subclassResponsibility	! !!PRSuccess methodsFor: 'controlling'!and: aPRStatus	^ aPRStatus! !!PRSuccess methodsFor: 'controlling'!exitProcess	Exit signalSuccess! !!PRSuccess methodsFor: 'controlling'!isFailure	^ false! !!PRSuccess methodsFor: 'controlling'!isSuccess	^ true! !!PRSuccess methodsFor: 'controlling'!value		^ 0! !!PRAbsentTarget class methodsFor: 'clap'!buildClapCommandWithId: anId withPositionals: isWithPositionals	^ self 		buildClapCommandWithId: anId 		withPositionals: isWithPositionals 		withDescription: 'Export format not found in pillar.config. Please edit it and add a valid export format at "defaultExport" label'! !!PRAbsentTarget class methodsFor: 'accessing'!builderName		^ #errorAbsentTarget! !!PRErrorTarget class methodsFor: 'clap'!buildClapCommandWithId: anId withPositionals: isWithPositionals withDescription: aDescription	^ (ClapCommand id: anId asSymbol)			description: aDescription asString;			add: ClapFlag forHelp;			meaning: [ :args |				args at: #helpFlag ifPresent: [ :help | help value; exitSuccess].				(ClapDocumenter on: (ZnCharacterWriteStream on: args context stdout))                explain: args specification.				];		yourself.! !!PRErrorTarget class methodsFor: 'accessing'!builderName 	^ #errorTarget! !!PRErrorTarget class methodsFor: 'testing'!isAbstract	^ true! !!PRInvalidTarget class methodsFor: 'clap'!buildClapCommandWithId: anId withPositionals: isWithPositionals	^ self buildClapCommandWithId: anId withPositionals: isWithPositionals withDescription: 'Invalid export format. Please edit your pillar.conf with a valid format at "defaultExport" label'! !!PRInvalidTarget class methodsFor: 'accessing'!builderName		^ #errorInvalidTarget! !!PRTarget class methodsFor: 'clap'!buildClapCommand		^ self buildClapCommandWithId: self clapId withPositionals: true! !!PRTarget class methodsFor: 'clap'!buildClapCommandWithId: anId withPositionals: isWithPositionals		| target project command |	target := self new.	project := self newProject. 	command := (ClapCommand id: anId asSymbol)		description: 'Build your Pillar documents in ', self clapId asString ,' format';		add: ClapFlag forHelp;		add: ((ClapFlag id: #templatable)				description: 'Use a template');				meaning: [project beTemplatable];		add: ((ClapFlag id: #all)				description: 'Build all Pillar documents in repository';				canonicalName: 'a';				meaning: [ PRBuildAllStrategy new ]);		add: ((ClapFlag id: #mainRoot)				description: 'Build index.pillar in root directory';				canonicalName: 'm';				meaning: [ PRBuildRootMainStrategy new ]); yourself.						isWithPositionals ifTrue: [ command := command add: ((ClapPositional id: #requestedFiles)				description: 'Pillar files you want to build';				multiple: true;				meaning: [ :doc | doc word asFileReference ]); yourself ].				command := command meaning: [ :args |			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].			args at: #templatable ifPresent: [(args at: #templatable) value ].			"here, default strategy is mainRoot and the following order give strategies a priority order"			isWithPositionals ifTrue: [ 			(args at: #requestedFiles ) isExplicit ifTrue:[ 				target buildStrategy: (PRBuildListStrategy list: (args occurrencesOf: #requestedFiles collect: #value) )				] ].			args at: #all ifPresent: [ :strat | target buildStrategy: strat value ].			args at: #mainRoot ifPresent: [ :strat | target buildStrategy: strat value].						target buildWithClapArguments: project ]				yourself.				^ command.! !!PRTarget class methodsFor: 'accessing'!builderClassForName: aString 		| builders |	builders := self allSubclasses select: [ :each | 		each isAbstract not and: [ each builderName = aString ] ].	builders size > 1 ifTrue: [ 		self error: 'There is more than one builder class for name: ', aString ].	^ builders anyOne! !!PRTarget class methodsFor: 'accessing'!builderForName: aString 		^ (self builderClassForName: aString) new! !!PRTarget class methodsFor: 'accessing'!builderName		^ self subclassResponsibility! !!PRTarget class methodsFor: 'clap'!clapCommandList	^ self allSubclasses		select: [ :each | each isAbstract not ]		thenCollect: [ :each | each buildClapCommand ]! !!PRTarget class methodsFor: 'clap'!clapId		^ self builderName ! !!PRTarget class methodsFor: 'testing'!isAbstract	^ self == PRTarget! !!PRTarget class methodsFor: 'clap-integration'!newProject	^ PRProject on: FileSystem workingDirectory! !!PRTarget class methodsFor: 'accessing'!targetByFormatName: aFormat	^ self allSubclasses		detect: [ :each | (each isAbstract not) and: [each builderName asString = aFormat asString] ] ifNone: [ ^ PRInvalidTarget ]! !!PRTarget methodsFor: 'accessing'!addPillarDocumentTransformation: aTransformation		transformations add: aTransformation! !!PRTarget methodsFor: 'building'!allFilesStrategy	self buildStrategy: PRBuildAllStrategy new! !!PRTarget methodsFor: 'building'!buildOn: aProject	"Set the pipeline and execute it for each file of the project."	| status |	status := PRSuccess new.		"Set the pipeline"	aProject contributeToPipelineBuilding: self.	"For each file, we execute the pipeline"	(self filesToBuildOn: aProject) do: [ :each |		each file exists ifTrue: [ 			status := status and: ((self documentFor: each) buildOn: aProject) ]		"I do not know how to report if a file does not exist. 		May be producing a failure is not adequate."	].	^ status! !!PRTarget methodsFor: 'accessing'!buildStrategy: aStrategy	buildStrategy := aStrategy! !!PRTarget methodsFor: 'clap-integration'!buildWithClapArguments: project	(project build: self) exitProcess! !!PRTarget methodsFor: 'building'!documentFor: aFile	self subclassResponsibility! !!PRTarget methodsFor: 'building'!explicitFilesStrategyOn: aListOfFileReferences	self buildStrategy: (PRBuildListStrategy list: aListOfFileReferences)! !!PRTarget methodsFor: 'building'!filesToBuildOn: aPRProject 		^ buildStrategy filesToBuildOn: aPRProject! !!PRTarget methodsFor: 'initialization'!initialize	super initialize.	transformations := Set new.	"self buildAll"	buildStrategy := PRBuildRootMainStrategy new.! !!PRTarget methodsFor: 'building'!onlyMainRootStrategy	self buildStrategy: PRBuildRootMainStrategy new! !!PRTarget methodsFor: 'preparation'!prepareForExecutionOn: aPRProject 		self subclassResponsibility! !!PRTarget methodsFor: 'accessing'!transformations		^ transformations! !!PRWritingTarget class methodsFor: 'testing'!isAbstract	^ self == PRWritingTarget! !!PRWritingTarget methodsFor: 'accessing'!createConfigurationFrom: aPRProject	^ aPRProject configuration class new		propertyAt: #_outputFormat put: self;		parent: aPRProject configuration;		yourself! !!PRWritingTarget methodsFor: 'accessing'!extension		^ self subclassResponsibility! !!PRWritingTarget methodsFor: 'accessing'!outputDirectoryName		^ self subclassResponsibility! !!PRWritingTarget methodsFor: 'preparation'!prepareForExecutionOn: aPRProject	| configuration outputDirectory outputFormat target source |	"As a temporary solution, remove the old results folder before building the document.	This should be replaced by a smarter solution replacing only modified files"	aPRProject wipeout.	configuration := self createConfigurationFrom: aPRProject.		outputFormat := configuration propertyAt: #_outputFormat.	target := aPRProject outputDirectory  / outputFormat outputDirectoryName resolve: (Path from: '_support').	source := aPRProject baseDirectory /  '_support'.		PRCopyPhase new		sourceDirectory: source;		destinationDirectory: target;		executeOn: nil "We used a configuration context here that is not needed anymore".			outputDirectory := aPRProject outputDirectory / self outputDirectoryName.	aPRProject baseDirectory children		do: [ :each | 			((each basename beginsWith: '_') or: [ each basename beginsWith: '.' ])				ifFalse: [ each copyAllTo: outputDirectory / each basename ] ]! !!PRWritingTarget methodsFor: 'accessing'!writerFor: aPRPillarConfiguration 		self subclassResponsibility! !!PRWritingTarget methodsFor: 'accessing'!writerFor: aPRPillarConfiguration forConfigurationTag: aTag		"(PRDocumentWriter allSubclasses detect: [ :each | 		each isAbstract not			and: [ each writerName = (aPRPillarConfiguration propertyAt: #latexWriter) ] ])				new"					^ (((SystemNavigation default allImplementorsOf: #writerName) 		collect: [ :each | each methodClass instanceSide ]) 			 detect: [ :each | 	each isAbstract not 						and: [ each writerName asLowercase = (aPRPillarConfiguration propertyAt: aTag) asLowercase ] ]) new! !!PRTitlePrinter class methodsFor: 'accessing'!defaultStrategyMapping	^ Dictionary		with: 'number' -> PRLevelNumberPrinter		with: 'roman' -> PRLevelRomanPrinter		with: 'letter' -> PRLevelLetterPrinter		with: 'upperLetter' -> PRLevelUpperLetterPrinter! !!PRTitlePrinter class methodsFor: 'accessing'!printerSpecFor: aStyle 	^ (self strategyClassMapping at: aStyle) new		! !!PRTitlePrinter class methodsFor: 'accessing'!strategyClassMapping	^ StrategyMapping ifNil: [ StrategyMapping := self defaultStrategyMapping ]! !!PRTitlePrinter methodsFor: 'initialization'!initialize	super initialize.	levels := Array new: self maxLevels.	1 to: self maxLevels do: [ :l | 		levels at: l put:  (PRLevelNumberPrinter new								headerSize: l;								level: l;								printer: self;								yourself) ]! !!PRTitlePrinter methodsFor: 'accessing'!level1	^ levels at: (self levelIndex: 1)! !!PRTitlePrinter methodsFor: 'accessing'!level1: aLevelSpec	self level: aLevelSpec n: 1! !!PRTitlePrinter methodsFor: 'accessing'!level2	^ levels at: (self levelIndex: 2)! !!PRTitlePrinter methodsFor: 'accessing'!level2: aLevelSpec	self level: aLevelSpec n: 2! !!PRTitlePrinter methodsFor: 'accessing'!level3	^ levels at: (self levelIndex: 3)! !!PRTitlePrinter methodsFor: 'accessing'!level3: aLevelSpec	self level: aLevelSpec n: 3! !!PRTitlePrinter methodsFor: 'accessing'!level4	^levels at: (self levelIndex: 4)! !!PRTitlePrinter methodsFor: 'accessing'!level4: aLevelSpec	self level: aLevelSpec n: 4! !!PRTitlePrinter methodsFor: 'accessing'!level5	^ levels at: (self levelIndex: 5)! !!PRTitlePrinter methodsFor: 'accessing'!level5: aLevelSpec	self level: aLevelSpec n: 5! !!PRTitlePrinter methodsFor: 'accessing'!level6	^ levels at: (self levelIndex: 6)! !!PRTitlePrinter methodsFor: 'accessing'!level6: aLevelSpec	self level: aLevelSpec n: 6! !!PRTitlePrinter methodsFor: 'accessing'!level7	^ levels at: (self levelIndex: 7)! !!PRTitlePrinter methodsFor: 'accessing'!level7: aLevelSpec	self level: aLevelSpec n: 7! !!PRTitlePrinter methodsFor: 'accessing'!level: aLevelSpec n: n	levels at: (self levelIndex: n) put: aLevelSpec.	aLevelSpec level: n.	aLevelSpec printer: self.! !!PRTitlePrinter methodsFor: 'accessing'!levelConfigurationFor: aHeader	"to get the associated level spec"		^ self perform: ('level' , aHeader level asString) asSymbol! !!PRTitlePrinter methodsFor: 'accessing'!levelIndex: wishedLevel		^ wishedLevel! !!PRTitlePrinter methodsFor: 'accessing'!leveln: anInteger	^ self perform: ('level', anInteger asString) asSymbol ! !!PRTitlePrinter methodsFor: 'initialization'!maxLevels	^ 7! !!PRTitlePrinter methodsFor: 'builder'!printerSpecFor: aStyle	^ self class printerSpecFor: aStyle! !!PRTitlePrinter methodsFor: 'accessing'!strategyClassFor: aStyle		^ self class strategyClassMapping at: aStyle ifAbsent: [ 'roman' ]! !!PRLevelLetterPrinter methodsFor: 'rendering-element'!renderElement: aNumber on: stream	| alphabet position |	aNumber = 0 ifTrue: [ stream nextPutAll: 'NaN'. ^self  ].	alphabet := Character alphabet.	position := aNumber \\ alphabet size.	position = 0 		ifTrue: [ position := alphabet size ].	stream nextPut: (alphabet at: position).	((aNumber - 1) / alphabet size) asFloat floor timesRepeat: [ stream nextPut: $' ]! !!PRLevelNumberPrinter methodsFor: 'rendering-element'!renderElement: aNumber on: stream	aNumber printOn: stream! !!PRLevelRomanPrinter methodsFor: 'rendering-element'!renderElement: aNumber on: stream	stream nextPutAll: aNumber printStringRoman! !!PRLevelUpperLetterPrinter methodsFor: 'rendering-element'!renderElement: aNumber on: stream	| alphabet position |	aNumber = 0		ifTrue: [ stream nextPutAll: 'NaN'. ^ self ].	alphabet := Character alphabet.	position := aNumber \\ alphabet size.	position = 0		ifTrue: [ position := alphabet size ].	stream nextPut: (alphabet at: position) asUppercase.	((aNumber - 1) / alphabet size) asFloat floor timesRepeat: [ stream nextPut: $' ] ! !!PRTitlePrinterSpecification class methodsFor: 'accessing - defaults'!defaultLevel	^ 1! !!PRTitlePrinterSpecification class methodsFor: 'instance creation'!new	^ self with: Dictionary new! !!PRTitlePrinterSpecification class methodsFor: 'instance creation'!with: aDictionary	"what a ugly API"	| inst |	inst := super new		numbering: (aDictionary at: 'numbering' ifAbsent: [ true ]);		autoAnchor: (aDictionary at: 'autoAnchor' ifAbsent: [ false ]);		capitalization: (aDictionary at: 'capitalization' ifAbsent: [ 'raw' ]);		yourself.	inst numbering		ifTrue: [ inst size: (aDictionary at: 'size' ifAbsent: [ 0 ]) ]		ifFalse: [ inst size: 0 ].	^ inst! !!PRTitlePrinterSpecification methodsFor: 'accessing'!autoAnchor	^ autoAnchor ! !!PRTitlePrinterSpecification methodsFor: 'accessing'!autoAnchor: anObject 	autoAnchor := anObject ! !!PRTitlePrinterSpecification methodsFor: 'accessing'!capitalization	^ capitalization! !!PRTitlePrinterSpecification methodsFor: 'accessing'!capitalization: anObject	capitalization := anObject ! !!PRTitlePrinterSpecification methodsFor: 'rendering'!elementSeparator	"why hardcoding it?"	^ $.! !!PRTitlePrinterSpecification methodsFor: 'initialization'!fillFromAnother: another	"copy all the field from another instance this is used to convert a configuration specification to an instance of one of the subclasses."	"the equivalent of a changeClassToThatOf:"		self autoAnchor: another autoAnchor. 	self capitalization: another capitalization. 	self level: another level. 	self numbering: another numbering. 	self renderAs: another renderAs. 	self size: another size! !!PRTitlePrinterSpecification methodsFor: 'accessing'!headerSize	^ size! !!PRTitlePrinterSpecification methodsFor: 'accessing'!headerSize: anInteger	"Pay attention changing the size only makes sense when numbering is true."	size := numbering		ifTrue: [ anInteger ]		ifFalse: [ 0 ]! !!PRTitlePrinterSpecification methodsFor: 'initialization'!initialize	super initialize.	numbering := true. 	autoAnchor := false.	capitalization := 'raw'.	level := 1. 	renderAs := 'number'! !!PRTitlePrinterSpecification methodsFor: 'accessing'!level	^ level ifNil: [ self class defaultLevel ]! !!PRTitlePrinterSpecification methodsFor: 'accessing'!level: anObject	level := anObject! !!PRTitlePrinterSpecification methodsFor: 'accessing'!numbering	^ numbering! !!PRTitlePrinterSpecification methodsFor: 'accessing'!numbering: anObject	numbering := anObject! !!PRTitlePrinterSpecification methodsFor: 'accessing'!predecessor	^ level = 1			ifTrue: [ nil ]			ifFalse: [ self printer perform: ('level' , (self level - 1) asString) asSymbol ]! !!PRTitlePrinterSpecification methodsFor: 'rendering'!printCounter: aCollection	^ String streamContents: [ :s | self printCounter: aCollection withMaxSize: self size on: s ]! !!PRTitlePrinterSpecification methodsFor: 'rendering'!printCounter: aCollection withMaxSize: aSize on: stream	aSize > 0		ifTrue: [ (self predecessor isNotNil and: [ aSize - 1 > 0 ])				ifTrue: [ self predecessor printCounter: aCollection allButLast withMaxSize: aSize - 1 on: stream.					aCollection allButLast last = -1						ifFalse: [ stream nextPut: self elementSeparator ] ].			self printElement: aCollection last on: stream ]! !!PRTitlePrinterSpecification methodsFor: 'rendering-element'!printElement: aNumber on: stream	aNumber = -1		ifFalse: [ self renderElement: aNumber on: stream ]! !!PRTitlePrinterSpecification methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: 'level:'; 		nextPutAll: self level asString.	aStream nextPutAll: ' autoAnchor:'; 		nextPutAll: self autoAnchor asString.! !!PRTitlePrinterSpecification methodsFor: 'accessing'!printer	^ printer! !!PRTitlePrinterSpecification methodsFor: 'accessing'!printer: aPrinter	printer := aPrinter! !!PRTitlePrinterSpecification methodsFor: 'accessing'!renderAs	"only use during serialisation to serve as an marker to create instance of adequate subclasses"	^ renderAs ! !!PRTitlePrinterSpecification methodsFor: 'accessing'!renderAs: aString	"only use during serialisation"	renderAs := aString! !!PRTitlePrinterSpecification methodsFor: 'rendering-element'!renderElement: aNumber on: stream	^ self subclassResponsibility! !!PRTitlePrinterSpecification methodsFor: 'accessing'!size	^ self headerSize! !!PRTitlePrinterSpecification methodsFor: 'accessing'!size: anInteger	"Pay attention changing the size only makes sense when numbering is true."	self headerSize: anInteger! !!PRTransformersDocumentation class methodsFor: 'instance creation'!on: aStream	"I generate the documentation of the Pillar transformers on a Stream."	^ self new		stream: aStream;		generateDoc;		stream! !!PRTransformersDocumentation methodsFor: 'accessing'!allTransformers		^ PRNodeTransformer withAllConcreteClasses! !!PRTransformersDocumentation methodsFor: 'action'!generateDoc	| transformers |	transformers := self allTransformers.	stream		lf;		lf;		nextPutAll: 'Transformers and keywords to disable them:';		lf;		lf.	self generateDocumentationOf: transformers! !!PRTransformersDocumentation methodsFor: 'action'!generateDocumentationOf: transformers	transformers		do: [ :transformer | 			stream				nextPutAll: ';==';				nextPutAll: transformer class printString;				nextPutAll: '==';				nextPutAll: Smalltalk os lineEnding;				nextPutAll: ':';				nextPutAll: transformer comment;				nextPutAll: Smalltalk os lineEnding ]! !!PRTransformersDocumentation methodsFor: 'accessing'!stream	^ stream! !!PRTransformersDocumentation methodsFor: 'accessing'!stream: anObject	stream := anObject! !!Path methodsFor: '*Pillar-ExporterCore'!lookup: lookupBlock ifNone: noneBlock	"Detect a job that satisfies the lookupBlock, or value noneBlock if none satisfies. 	The lookup starts at myself, following recursevely through my parent."	(lookupBlock value: self) ifTrue: [ ^ self ].			^ self isEmpty 		ifTrue: noneBlock 		ifFalse: [ self parent lookup: lookupBlock ifNone: noneBlock ]! !!RelativePath methodsFor: '*Pillar-ExporterCore'!pillarPrintString	self isEmpty ifTrue: [ ^ '' ].	^ String streamContents: [ :str |		str nextPutAll: (self at: 1) asString.		2 to: self size do: [:i |			str				nextPut: self delimiter;				nextPutAll: (self at: i) ] ]								! !!PRAbstractScriptLanguage methodsFor: '*pillar-exportercore'!isSyntaxHighlightingPossible	^ false! !!PRRealScriptLanguage methodsFor: '*pillar-exportercore'!isSyntaxHighlightingPossible	^ true! !!PRCreateSymLink methodsFor: 'system'!createSymbolic: name to: target	| command |	command :='ln -sf ' , target , ' ' , name.	name asFileReference exists		ifTrue: [ command := 'unlink ', name , '; ' , command ].	self system: command! !!PRCreateSymLink methodsFor: 'system'!system: command	"Perform OS system() call."	^ self ffiCall: #(#int #system #(#char #* #command)) module: LibC! !!PRExportBrush methodsFor: 'initialization'!setStream: aStream	stream := aStream! !!PRExportCanvas class methodsFor: 'instance creation'!on: aStream 	^ self new		setStream: aStream;		yourself! !!PRExportCanvas methodsFor: 'private'!brush: aBrush	self flush.	currentBrush := aBrush.	aBrush setStream: stream.	^ aBrush! !!PRExportCanvas methodsFor: 'accessing'!flush	stream flush! !!PRExportCanvas methodsFor: 'writing text'!line: aString	self		nextPutAll: aString;		newLine! !!PRExportCanvas methodsFor: 'writing text'!lines: aString	"Output aString and take care of line ending within aString."	| str |	str := aString readStream.	[ str atEnd ] whileFalse: [ | line |		line := str nextLine.		str atEnd			ifTrue: [ self nextPutAll: line ]			ifFalse: [ self line: line ]	 ]! !!PRExportCanvas methodsFor: 'writing text'!newLine	stream newLine! !!PRExportCanvas methodsFor: 'writing text'!nextPut: aCharacter	stream nextPut: aCharacter! !!PRExportCanvas methodsFor: 'writing text'!nextPutAll: aString	aString do: [ :char | self nextPut: char ]! !!PRExportCanvas methodsFor: 'writing text'!nextPutAllLines: aString	self withLinesIn: aString do: [ :line | self nextPutAll: line ] separatedBy: [ self newLine ]! !!PRExportCanvas methodsFor: 'writing text'!raw: aString	stream << aString! !!PRExportCanvas methodsFor: 'writing text'!rawLines: aString	"Output aString and take care of line ending within aString."	self withLinesIn: aString do: [ :line | self raw: line ] separatedBy: [ self newLine ]! !!PRExportCanvas methodsFor: 'initialization'!setStream: aStream 	stream := aStream! !!PRExportCanvas methodsFor: 'writing text'!space	stream space! !!PRExportCanvas methodsFor: 'private'!withLinesIn: aString do: aBlock separatedBy: anotherBlock	"this method shows that the PRCommentedLine class is weak because it should encapsulate the way it internally represents lines. Now this is exposed in clients."	| str |	str := aString readStream.	[ str atEnd ]		whileFalse: [ 			| line |			line := str nextLine.			aBlock value: line.			str atEnd				ifFalse: anotherBlock ]! !!PROutputStream class methodsFor: 'instance creation'!on: aWriteStream 	^ self new		setStream: aWriteStream;		yourself! !!PROutputStream methodsFor: 'streaming'!<< anObject	anObject isBlock		ifTrue: anObject		ifFalse: [ stream << anObject ]! !!PROutputStream methodsFor: 'accessing'!configuration	^ configuration ifNil: [ configuration := ConfigurationForPillar new ]! !!PROutputStream methodsFor: 'accessing'!configuration: aConfiguration	^ configuration := aConfiguration! !!PROutputStream methodsFor: 'streaming'!contents	^ stream contents! !!PROutputStream methodsFor: 'accessing'!flush	stream flush! !!PROutputStream methodsFor: 'testing'!isEmpty		^ stream isEmpty! !!PROutputStream methodsFor: 'streaming'!newLine	self << self configuration newLine! !!PROutputStream methodsFor: 'accessing'!nextPut: aCharacter 	stream nextPut: aCharacter! !!PROutputStream methodsFor: 'initialization'!setStream: aWriteStream	stream := aWriteStream! !!PROutputStream methodsFor: 'streaming'!space	stream space! !!PROutputStream methodsFor: 'private'!stream	^ stream! !!PROutputStream methodsFor: 'streaming'!tab	stream tab! !!PROutputStream methodsFor: 'streaming'!trimLastNewLine	| newLine |	newLine := self configuration newLine.	(newLine isEmpty or: [ stream position < newLine size ])		ifTrue: [ ^ self ].	stream position: stream position - newLine size.! !!PRExportError methodsFor: 'accessing'!inputFile: aFile	file := aFile! !!PRExportError methodsFor: 'accessing'!messageText	^ String		streamContents: [ :stream | 			stream << super messageText.			file ifNotNil: [ stream << ' (' << file basename << ')' ] ]! !!PRCompilationContext class methodsFor: 'instance creation'!configuration: aConfiguration	^ self new configuration: aConfiguration! !!PRCompilationContext class methodsFor: 'instance creation'!isAbstract	^ false! !!PRCompilationContext class methodsFor: 'instance creation'!withDocument: aDocument withConfiguration: aConfiguration	^ self new		input: aDocument;		configuration: aConfiguration;		yourself! !!PRCompilationContext methodsFor: 'accessing'!configuration	^ configuration! !!PRCompilationContext methodsFor: 'accessing'!configuration: aConfiguration	configuration := aConfiguration! !!PRCompilationContext methodsFor: 'accessing'!input	^ input! !!PRCompilationContext methodsFor: 'accessing'!input: anObject	input := anObject! !!PROutputDocument class methodsFor: 'testing'!isAbstract	^ false! !!PROutputDocument methodsFor: 'accessing'!outputText	^ outputText! !!PROutputDocument methodsFor: 'accessing'!outputText: anObject	outputText := anObject! !!PROutputDocument methodsFor: 'accessing'!pillarDocument	^ pillarDocument! !!PROutputDocument methodsFor: 'accessing'!pillarDocument: aPRDocument 	pillarDocument := aPRDocument! !!PRDocumentChildrenTransformer class methodsFor: 'testing'!isAbstract	^ self = PRDocumentChildrenTransformer ! !!PRDocumentChildrenTransformer methodsFor: 'actions'!actionOn: anInput	anInput input children		do: [ :documentItem | self manageItem: documentItem ].	self possibleTransformationEnding.	anInput input setChildren: newChildren asArray.	^ anInput! !!PRDocumentChildrenTransformer methodsFor: 'pipeline'!contributeToPipelineBuilding: aPRPipelineBuilder 		aPRPipelineBuilder addPillarDocumentTransformation: self! !!PRDocumentChildrenTransformer methodsFor: 'initialization'!initialize	super initialize.	newChildren := OrderedCollection new! !!PRDocumentChildrenTransformer methodsFor: 'private'!manageItem: documentItem	^ self subclassResponsibility ! !!PRDocumentChildrenTransformer methodsFor: 'private'!possibleTransformationEnding	"Basicly I do nothing. Override me if you need to do an action before the end of the transformation."	! !!PRDocumentChildrenTransformer methodsFor: 'pipeline'!prepareForExecutionOn: aPRProject 		"Nothing"! !!PRSectionTransformer class methodsFor: 'class initialization'!initialize 	" self initialize "	MaxDepthLevel := self maxDepthLevelForSection! !!PRSectionTransformer class methodsFor: 'accessing'!maxDepthLevel: anObject	MaxDepthLevel := anObject! !!PRSectionTransformer class methodsFor: 'protected'!maxDepthLevelForSection	^ 7! !!PRSectionTransformer methodsFor: 'testing'!aSectionIsOpen	sections do: [ :e | e ifNotNil: [ ^ true ] ].	^ false! !!PRSectionTransformer methodsFor: 'private'!cleanSections	self cleanSectionsUnderLevel: 1! !!PRSectionTransformer methodsFor: 'private'!cleanSectionsAndOpenNewWith: documentItem	| newSection |	documentItem level <= MaxDepthLevel		ifTrue: [ self cleanSectionsUnderLevel: documentItem level.			newSection := PRSection with: documentItem.			sections at: documentItem level put: newSection ]		ifFalse: [ self currentSection add: documentItem ].	^ newSection! !!PRSectionTransformer methodsFor: 'private'!cleanSectionsUnderLevel: aNumber	[ self currentSectionIndex >= aNumber ] whileTrue: [ self closeLastSection ]! !!PRSectionTransformer methodsFor: 'private'!closeLastSection	| lastSection |	lastSection := self currentSection.	sections at: self currentSectionIndex put: nil.	self aSectionIsOpen		ifTrue: [ self currentSection add: lastSection ]		ifFalse: [ newChildren add: lastSection ]! !!PRSectionTransformer methodsFor: 'accessing'!currentSection	^ sections at: self currentSectionIndex! !!PRSectionTransformer methodsFor: 'accessing'!currentSectionIndex	"I return the index of deeper section open now. If I don't have any section open I return -1."	| index |	index := MaxDepthLevel.	sections reverse		do: [ :each | 			each ifNotNil: [ ^ index ].			index := index - 1 ].	^ -1! !!PRSectionTransformer methodsFor: 'initialization'!initialize	super initialize.	sections := Array ofSize: MaxDepthLevel! !!PRSectionTransformer methodsFor: 'private'!manageItem: documentItem	^ documentItem isHeader		ifTrue: [ self cleanSectionsAndOpenNewWith: documentItem ]		ifFalse: [ 			self aSectionIsOpen				ifTrue: [ self currentSection add: documentItem ]				ifFalse: [ newChildren add: documentItem ] ]! !!PRSectionTransformer methodsFor: 'private'!possibleTransformationEnding	self cleanSections! !!PRPhase class methodsFor: 'instance-creation'!executeOn: aPillarContext	^ self new		actionOn: aPillarContext! !!PRPhase class methodsFor: 'testing'!isAbstract	^ self = PRPhase! !!PRPhase methodsFor: 'actions'!actionOn: anInput	self subclassResponsibility! !!PRPhase methodsFor: 'accessing'!configuration	^ configuration ifNil: [ ConfigurationForPillar new ]! !!PRPhase methodsFor: 'accessing'!configuration: aConfiguration	configuration := aConfiguration! !!PRPhase methodsFor: 'actions'!executeOn: anInput	^ self actionOn: anInput! !!PRPhase methodsFor: 'testing'!isFileInclusionPhase		^ false! !!PRPhase methodsFor: 'testing'!isOutputFormatterPhase		^ false! !!PRPhase methodsFor: 'testing'!isParsingPhase		^ false! !!PRPhase methodsFor: 'testing'!isSavePhase		^ false! !!PRPhase methodsFor: 'pipeline'!prepareForExecutionOn: aPRProject 		self subclassResponsibility! !!PRCyclicFileInclusionError methodsFor: 'accessing'!files: aCollection 	files := aCollection! !!MicRootBlock methodsFor: '*Pillar-ExporterCore'!pdfTransformationsFor: aDocument	^ #()! !!MicRootBlock methodsFor: '*Pillar-ExporterCore'!transformDocumentFor: aPRPDFDocument 	"This is a hook to be able to have framework specific transformation hooks.	see PRAbstractOutputDocument>>#buildOn:"	"Note that the resolution is made against the currently transformed file and not the base directory of the project else we may lose the fact that a figure is within multiple folders within the base project. 	Compare 		/base and		/base/Chapters/Chapter1/FileContainingAReferenceToFigures.md	When resolving figures/myPng referenced from within FileContainingAReferenceToFigures.md 	we should get /base/Chapters/Chapter1/figures/myPng!!	Using base we lose Chapters/Chapter1 and only get /base/figures/myPng.	"		^ aPRPDFDocument transformDocument: (self resolveFrom: aPRPDFDocument file file asMicResourceReference )! !!PRDocumentWriter class methodsFor: 'accessing'!defaultConfiguration	| defaultConfiguration |	defaultConfiguration := ConfigurationForPillar new.	defaultConfiguration properties at: 'outputType' put: self.	defaultConfiguration properties at: 'configurations' put: Dictionary new.	"we specify an empty collection of sub configurations to avoid infinite recursion : a default configuration would otherwise contain a collection of default configurations, each containing a collection of default configurations..."	^ defaultConfiguration! !!PRDocumentWriter class methodsFor: 'accessing'!defaultConfigurationName	^ self writerName! !!PRDocumentWriter class methodsFor: 'accessing'!fileExtension	^ self subclassResponsibility! !!PRDocumentWriter class methodsFor: 'accessing'!folderName	"This method is for decoupling the writer from its physical representation.	It represents the physical folder name in the archetype, used when this writer is specified.	For example your writerName can be latex:sbabook but the corresponding folderName is latex"	^ self subclassResponsibility! !!PRDocumentWriter class methodsFor: 'testing'!isAbstract	^ self = PRDocumentWriter! !!PRDocumentWriter class methodsFor: 'accessing'!markupType	^ self writerName! !!PRDocumentWriter class methodsFor: 'instance creation'!on: aWriteStream 	^ self new		setStream: aWriteStream;		yourself! !!PRDocumentWriter class methodsFor: 'instance creation'!write: aDocumentItem	^ self new write: aDocumentItem! !!PRDocumentWriter class methodsFor: 'instance creation'!write: aDocument to: aStream	^ self new write: aDocument to: aStream! !!PRDocumentWriter class methodsFor: 'accessing'!writerName	"Each writer define this to know the appropriate files to take for process. This one is different from folderName which corresponds to the physical representation. See folderName"	^ self subclassResponsibility! !!PRDocumentWriter methodsFor: 'accessing'!canvasClass	^ self subclassResponsibility! !!PRDocumentWriter methodsFor: 'accessing'!configuration	^ configuration ifNil: [ configuration := ConfigurationForPillar new ]! !!PRDocumentWriter methodsFor: 'accessing'!configuration: aConfiguration 	configuration := aConfiguration.	stream ifNotNil: [ stream configuration: aConfiguration ]! !!PRDocumentWriter methodsFor: 'streaming'!contents	^ stream contents! !!PRDocumentWriter methodsFor: 'private'!defaultStream	^ WriteStream on: (String new: 1000)! !!PRDocumentWriter methodsFor: 'accessing'!fileExtension	^ self class fileExtension , '.json'! !!PRDocumentWriter methodsFor: 'templating'!folderName	^ self class folderName! !!PRDocumentWriter methodsFor: 'helpers'!getStringFor: anObject	"Visit anObject and exports everything to a new stream. Answer the stream content."	^ self getStringForAll: { anObject }! !!PRDocumentWriter methodsFor: 'helpers'!getStringForAll: aCollection	"Visit each element of aCollection and exports everything to a new stream. Answer the stream content."	^ String streamContents: [ :newStream | | visitor |		visitor := (self class on: newStream)			configuration: self configuration;			yourself.		aCollection do: [ :object | visitor start: object ] ]! !!PRDocumentWriter methodsFor: 'initialization'!initialize	super initialize.	writingRaw := false.	self setStream: self defaultStream.	canvas := self canvasClass on: stream.! !!PRDocumentWriter methodsFor: 'helpers'!languageForScript: aScript	^ aScript language isSpecified		ifTrue: [ aScript language ]		ifFalse: [ self configuration defaultScriptLanguage ]! !!PRDocumentWriter methodsFor: 'accessing'!mainDocumentTemplateName		^ 'template'! !!PRDocumentWriter methodsFor: 'accessing'!markupType	^ self class markupType! !!PRDocumentWriter methodsFor: 'helpers'!noNewLineDuring: aBlock	| oldNewLine |	oldNewLine := self configuration newLine.	self configuration newLine: ''.	aBlock ensure: [ self configuration newLine: oldNewLine ]! !!PRDocumentWriter methodsFor: 'initialization'!setStream: aStream	stream := PROutputStream on: aStream.	configuration ifNotNil: [ stream configuration: configuration ].	canvas ifNotNil: [ canvas setStream: stream ].! !!PRDocumentWriter methodsFor: 'visiting'!start: anObject	super start: anObject.	canvas flush! !!PRDocumentWriter methodsFor: 'templating'!templateForConfiguration: aConfiguration	| inputFile templateName |	configuration := aConfiguration.	inputFile := configuration inputFile.		(configuration hasProperty: #mainDocument)		ifFalse: [ ^ configuration propertyAt: self mainDocumentTemplateName ifAbsent: [ 'main.mustache' ] ].		templateName := inputFile fullName		= ((configuration baseDirectory resolve: configuration mainDocument) , 'pillar') fullName		ifTrue: [ self mainDocumentTemplateName ]		ifFalse: [ self chapterTemplateName ].	^ configuration propertyAt: templateName! !!PRDocumentWriter methodsFor: 'visiting-document'!visitEmptyParagraph: anObject	stream newLine! !!PRDocumentWriter methodsFor: 'visiting-document'!visitLineBreak: aLineBreak	canvas newLine! !!PRDocumentWriter methodsFor: 'visiting-document'!visitRaw: aRaw	(aRaw isForType: self writerName)		ifTrue: [ self writeRawDuring: [ super visitRaw: aRaw ] ]! !!PRDocumentWriter methodsFor: 'visiting-document'!visitText: aText	writingRaw		ifTrue: [ canvas rawLines: aText text ]		ifFalse: [ canvas nextPutAllLines: aText text ]! !!PRDocumentWriter methodsFor: 'visiting'!write: aDocumentItem	^ self start: aDocumentItem; contents! !!PRDocumentWriter methodsFor: 'visiting'!write: aDocumentItem to: aStream	^ self setStream: aStream; start: aDocumentItem! !!PRDocumentWriter methodsFor: 'helpers'!writeCounter: aCounter	"Write on the canvas the string representation of ==aCounter=="	^ aCounter elements do: [ :each | self writeCounterElement: each ] separatedBy: [ self writeCounterElementSeparator ]! !!PRDocumentWriter methodsFor: 'helpers'!writeCounterDefinitionSeparator	canvas nextPutAll: '. '! !!PRDocumentWriter methodsFor: 'helpers'!writeCounterElement: aCounterElement	canvas nextPutAll: aCounterElement asString! !!PRDocumentWriter methodsFor: 'helpers'!writeCounterElementSeparator	canvas nextPut: $.! !!PRDocumentWriter methodsFor: 'helpers'!writeCounterForFigure: aFigure	aFigure counter isValidCounter		ifFalse: [ ^ self ].	self writeCounter: aFigure counter.	self writeCounterDefinitionSeparator! !!PRDocumentWriter methodsFor: 'helpers'!writeCounterForHeader: aHeader	| headerConf |	headerConf := self configuration levelConfigurationFor: aHeader.	(headerConf numbering and: [ aHeader counter isValidCounter and: [ headerConf size > 0 ] ])		ifFalse: [ ^ self ].	canvas nextPutAll: (headerConf printCounter: aHeader counter elements).	self writeCounterDefinitionSeparator! !!PRDocumentWriter methodsFor: 'helpers'!writeCounterForScript: aScript	aScript counter isValidCounter		ifFalse: [ ^ self ].	self writeCounter: aScript counter.	self writeCounterDefinitionSeparator! !!PRDocumentWriter methodsFor: 'writing'!writeParagraphDuring: aBlockClosure 		self subclassResponsibility! !!PRDocumentWriter methodsFor: 'helpers'!writeRawDuring: aBlock	[ 	writingRaw := true.	aBlock value ]		ensure: [ writingRaw := false ]! !!PRDocumentWriter methodsFor: 'compatibility'!writerFor: aPRPillarConfiguration 		^ self! !!PRDocumentWriter methodsFor: 'accessing'!writerName	^ self class writerName! !!PRAnchorOfSection class methodsFor: 'accessing'!charForAnchorOccurence	^ '@'! !!PRAnchorOfSection methodsFor: 'adding'!addAnchorOf: aPRHeader	| anchorText headerText |	headerText := aPRHeader headerText.		occurenceOfHeader at: headerText ifAbsentPut: 0.	occurenceOfHeader at: headerText put: ((occurenceOfHeader at: headerText) + 1).		anchorText := headerText , self class charForAnchorOccurence , (occurenceOfHeader at: headerText) asString .	^ Array with: aPRHeader with: (PRAnchor named: anchorText)! !!PRAnchorOfSection methodsFor: 'private'!initOccurenceOfAnchor: aGroup	occurenceOfHeader := Dictionary new.	aGroup children		do: [ :child | 			child class = PRAnchor				ifTrue: [ self verifyAnchorName: child name ] ].! !!PRAnchorOfSection methodsFor: 'private'!verifyAnchorName: aString	"Verify an anchor name, if it has the form 'anchorName@aNumber', the occurence number on  the dictionary is changed by aNumber if it is greater than the occurence and if anchorName is a key on the dictionary"	| anchorParts anchorLastPart realAnchorName |		anchorParts := (aString substrings: '@') asOrderedCollection.	(anchorParts size > 1)  ifFalse: [ ^ self ].	anchorLastPart := (anchorParts at: (anchorParts size)).		anchorLastPart asNumber isNumber 		ifTrue: [ anchorParts removeAt: (anchorParts size) ].		realAnchorName := anchorParts inject: '' into: [ :substring :next | substring , next ].		((occurenceOfHeader at: realAnchorName ifAbsent: [ true ]) or: [ (occurenceOfHeader at: realAnchorName) > (anchorLastPart asNumber) ])		ifTrue: [ occurenceOfHeader at: realAnchorName put: (anchorLastPart asNumber) ].! !!PRAnchorOfSection methodsFor: 'visiting-document'!visitDocumentGroup: aGroup	occurenceOfHeader ifNil: [ self initOccurenceOfAnchor: aGroup ].		aGroup		setChildren:			(aGroup children				flatCollect: [ :child | 					"if child is a PRHeader and the configuration's parameter autoAnchor is true"					((child class = PRHeader) and: [((self configuration printer levelConfigurationFor: child ) autoAnchor ) ])						ifTrue: [ self addAnchorOf: child ]						ifFalse: [ 							replacement push: {child}.							self visit: child.							replacement pop ] ])! !!PRCitationTransformer methodsFor: 'helper'!createNewCitationWith: aCitationAnnotation	^ PRCitation ref: (aCitationAnnotation parameters at: 'ref' ifAbsent:[ PRCitation defaultRef ])! !!PRCitationTransformer methodsFor: 'visiting-annotations'!visitCitationAnnotation: aCitationAnnotation	self replace: (OrderedCollection with: (self createNewCitationWith: aCitationAnnotation)).	super visitCitationAnnotation: aCitationAnnotation ! !!PRCleanAnnotationInParagraphTransformer methodsFor: 'accessing'!goal: aPRBuildGoal 		goal := aPRBuildGoal! !!PRCleanAnnotationInParagraphTransformer methodsFor: 'testing'!paragraphIsSingleton: aParagraph	^ aParagraph children size = 1		or: [ self paragraphJustContainsALineBreakMore: aParagraph ]! !!PRCleanAnnotationInParagraphTransformer methodsFor: 'testing'!paragraphJustContainsALineBreakMore: aParagraph	^ aParagraph children size = 2		and: [ aParagraph children second isKindOf: PRLineBreak ]! !!PRCleanAnnotationInParagraphTransformer methodsFor: 'testing'!paragraphOnlyContainsAnnotation: aParagraph	^ ((aParagraph children size between: 1 and: 2) and: [ aParagraph children first isKindOf: PRAbstractAnnotation ])		and: [ self paragraphIsSingleton: aParagraph ]! !!PRCleanAnnotationInParagraphTransformer methodsFor: 'visiting-document'!visitParagraph: aParagraph	(self paragraphOnlyContainsAnnotation: aParagraph)		ifTrue: [ self replace: {aParagraph children first} ]! !!PRColumnsTransformer class methodsFor: 'meta-data'!dependencies	^ { PRCleanAnnotationInParagraphTransformer }! !!PRColumnsTransformer methodsFor: 'protected'!add: anObject toCurrentEnvironmentOr: aBlock	currentColumn isNil & currentColumns isNil		ifTrue: [ ^ aBlock value ].	self delete.	currentColumn		ifNotNil: [ currentColumn add: anObject ]		ifNil: [ currentColumns add: anObject ]! !!PRColumnsTransformer methodsFor: 'accessing'!goal: aPRBuildGoal 		goal := aPRBuildGoal! !!PRColumnsTransformer methodsFor: 'visiting'!start: aDocumentItem	| object |	"Execute clean annotation before"	object := super start: (PRCleanAnnotationInParagraphTransformer new start: aDocumentItem).	currentColumns isNotNil | currentColumn isNotNil		ifTrue: [ PRError signal: 'Missing ending columns annotation. Please use ${endColumns}$ at the end of the columns environment.' ].	^ object! !!PRColumnsTransformer methodsFor: 'visiting-annotations'!visitColumnAnnotation: anAnnotation	currentColumns		ifNil:			[ PRError signal: 'You can''t create a new column if you are not inside a column environment. Please use ${columns}$ before the beginning of a column.' ].	currentColumn := PRColumn width: (anAnnotation parameters at: 'width').	currentColumns add: currentColumn.	self delete! !!PRColumnsTransformer methodsFor: 'visiting-annotations'!visitColumnsAnnotation: anAnnotation	currentColumns ifNotNil: [ PRError signal: 'You have to close a columns environment before you open an other. Use the ${endColumns}$ tag please.' ].	currentColumns := PRColumnEnvironment new.	self delete! !!PRColumnsTransformer methodsFor: 'visiting-annotations'!visitDocumentGroup: aGroup	self add: aGroup toCurrentEnvironmentOr: [ super visitDocumentGroup: aGroup ]! !!PRColumnsTransformer methodsFor: 'visiting-annotations'!visitDocumentItem: anItem	self add: anItem toCurrentEnvironmentOr: [ super visitDocumentItem: anItem ]! !!PRColumnsTransformer methodsFor: 'visiting-annotations'!visitEndColumnsAnnotation: anAnnotation	currentColumns ifNil: [ PRError signal: 'Column environement ending encounter out of a column environment.' ].	self replace: {currentColumns}.	currentColumns := nil.	currentColumn := nil! !!PRCustomTagTransformer methodsFor: 'helper'!createNewCitationWith: documentItem	^ PRCitation ref: (documentItem parameters at: 'ref' ifAbsent:[ PRCitation defaultRef ])! !!PRCustomTagTransformer methodsFor: 'visiting-annotations'!visitCitationAnnotation: aCitationAnnotation	self replace: (OrderedCollection with: (self createNewCitationWith: aCitationAnnotation)).	super visitCitationAnnotation: aCitationAnnotation ! !!PREnvironmentTransformer class methodsFor: 'meta-data'!dependencies	^ { PRCleanAnnotationInParagraphTransformer }! !!PREnvironmentTransformer methodsFor: 'protected'!add: anObject toCurrentEnvironmentOr: aBlock	currentColumn isNil & self hasEnvironment not		ifTrue: [ ^ aBlock value ].	self delete.	currentColumn		ifNotNil: [ currentColumn add: anObject ]		ifNil: [ self currentEnvironment add: anObject ]! !!PREnvironmentTransformer methodsFor: 'environment'!currentEnvironment	^ environmentStack first! !!PREnvironmentTransformer methodsFor: 'accessing'!goal: aPRBuildGoal 		goal := aPRBuildGoal! !!PREnvironmentTransformer methodsFor: 'environment'!hasEnvironment	^ environmentStack isNotEmpty! !!PREnvironmentTransformer methodsFor: 'initialization'!initialize	super initialize.	environmentStack := OrderedCollection new.! !!PREnvironmentTransformer methodsFor: 'environment'!popEnvironment	^ environmentStack removeFirst! !!PREnvironmentTransformer methodsFor: 'environment'!pushEnvironment: anEnvironment	"If it is the root environment (i.e., the first environment found in this document's structure)	we replace the annotation with the environment node.		Otherwise add the environment to the current environment and delete the current node.		This is required because environment annotations are in a flat world and we have to translate that to a nester treeish world"	self hasEnvironment		ifFalse: [ self replace: { anEnvironment } ]		ifTrue: [ 			self currentEnvironment add: anEnvironment.			self delete. ].	environmentStack addFirst: anEnvironment.! !!PREnvironmentTransformer methodsFor: 'visiting'!start: aDocumentItem	| object |	"Execute clean annotation before"	object := super start: (PRCleanAnnotationInParagraphTransformer new start: aDocumentItem).	self hasEnvironment | currentColumn isNotNil		ifTrue: [ PRError signal: ('Missing end of environment ''{name}''' format: {('name' -> self currentEnvironment name)} asDictionary) ].	^ object! !!PREnvironmentTransformer methodsFor: 'visiting-annotations'!visitBeginEnvironmentAnnotation: anAnnotation	| environment |	environment := PREnvironment named: anAnnotation name.	anAnnotation parameters keysAndValuesDo: [ :key :value |		environment propertyAt: key put: value ].	self pushEnvironment: environment! !!PREnvironmentTransformer methodsFor: 'visiting-annotations'!visitDocumentGroup: aGroup	self add: aGroup toCurrentEnvironmentOr: [ super visitDocumentGroup: aGroup ]! !!PREnvironmentTransformer methodsFor: 'visiting-annotations'!visitDocumentItem: anItem	self add: anItem toCurrentEnvironmentOr: [ super visitDocumentItem: anItem ]! !!PREnvironmentTransformer methodsFor: 'visiting-annotations'!visitEndEnvironmentAnnotation: anAnnotation	self hasEnvironment ifFalse: [ PRError signal: ('Missing begin of environment ''{name}''' format: {('name' -> anAnnotation name)} asDictionary) ].	self currentEnvironment name = anAnnotation name		ifFalse: [ PRError				signal:					('Mismatching environments: closing ''{closing}'' while ''{open}'' environment is open'						format: {('closing' -> anAnnotation name) . ('open' -> self currentEnvironment name)} asDictionary) ].	self popEnvironment.	"Remove the end annotation from the tree.	The end annotation marks the end of a scope and is replaced by a recursive environment structure."	self delete! !!PRFileInclusion methodsFor: 'configuration'!doNotTransform	shouldTransform := false! !!PRFileInclusion methodsFor: 'accessing'!expansionTask: aPRExpandInclusionsTask 	expansionTask := aPRExpandInclusionsTask! !!PRFileInclusion methodsFor: 'accessing'!goal: aGoal 	goal := aGoal! !!PRFileInclusion methodsFor: 'accessing'!inProcessFiles: aCollection 	inProcessFiles := aCollection! !!PRFileInclusion methodsFor: 'initialization'!initialize	super initialize.	inProcessFiles := #()! !!PRFileInclusion methodsFor: 'visiting-document'!input: anInputDocument	input := anInputDocument! !!PRFileInclusion methodsFor: 'testing'!isFileInclusionPhase		^ true! !!PRFileInclusion methodsFor: 'testing'!shouldTransform	^ shouldTransform ifNil: [ shouldTransform := true ]! !!PRFileInclusion methodsFor: 'accessing'!topFile: aFileReference	topFile := aFileReference! !!PRFileInclusion methodsFor: 'validation'!validateInclusionOfFile: aFileReference 		aFileReference = topFile ifTrue: [ 		PRCyclicFileInclusionError new			files: { topFile };			signal	].	(inProcessFiles includes: aFileReference)		ifTrue: [ PRCyclicFileInclusionError new			files: (inProcessFiles copyWith: aFileReference);			signal  ]! !!PRFileInclusion methodsFor: 'visiting-document'!visitInputFileAnnotation: anInputFileAnnotation	"I load the file and if the file exist I replace the node of the annotation by the content of the file."	| includedFile includedPillarAST cleanPillarAST |	includedFile := topFile parent resolve: anInputFileAnnotation path.	self validateInclusionOfFile: includedFile.		includedPillarAST := (PRInputDocument forFile: includedFile) parsedDocument.		cleanPillarAST := (PRCleanAnnotationInParagraphTransformer new		configuration: self configuration;		start: includedPillarAST).		"Execute a file inclusion step recursively" 	includedPillarAST := PRFileInclusion new		topFile: includedFile;		inProcessFiles: (inProcessFiles copyWith: topFile);		start: cleanPillarAST.		"If we include a file, we need to update all references to external files in it.	References that were before relative to the included document, should be now relative to the container document."	PRUpdateFileInclusionReference		start: includedPillarAST		with: (includedFile parent relativeTo: topFile parent) pillarPrintString.		self replace: includedPillarAST children.! !!PRFootnoteTransformer class methodsFor: 'testing'!isAbstract	^ false! !!PRFootnoteTransformer methodsFor: 'private'!createFootnote: aFootnoteAnnotation	^ PRFootnote noted: (aFootnoteAnnotation parameters at: 'note')! !!PRFootnoteTransformer methodsFor: 'visiting-annotations'!visitFootnoteAnnotation: aFootnoteAnnotation	self replace: {(self createFootnote: aFootnoteAnnotation)}! !!PRHeadingLevelOffsetTransformer methodsFor: 'visiting'!start: aPRDocument	| conf |	conf := ConfigurationForPillar newFromDictionary: aPRDocument properties.	conf parent: self configuration.	self configuration: conf.	super start: aPRDocument.	^ aPRDocument! !!PRHeadingLevelOffsetTransformer methodsFor: 'visiting-document'!visitHeader: aHeader	aHeader level: aHeader level + self configuration headingLevelOffset! !!PRNodeTransformer class methodsFor: 'instance-creation'!executeOn: aPillarContext	self new		configuration: aPillarContext configuration;		start: aPillarContext input.	^ aPillarContext! !!PRNodeTransformer class methodsFor: 'testing'!isAbstract	^ self = PRNodeTransformer ! !!PRNodeTransformer class methodsFor: 'instance-creation'!withContext: aContext	"The API is done this way (without using the parameter) because most of the subclasses do not need to access the context of the process (such as files, configuration). Some subclasses may get access by redefine it."		^ self new 		! !!PRNodeTransformer methodsFor: 'accessing'!configuration	^ configuration! !!PRNodeTransformer methodsFor: 'accessing'!configuration: anObject	configuration := anObject.	self flag: #SD.	"self halt: 'configuration: dans NodeTransformer'"! !!PRNodeTransformer methodsFor: 'pipeline'!contributeToPipelineBuilding: aPRPipelineBuilder 		aPRPipelineBuilder addPillarDocumentTransformation: self! !!PRNodeTransformer methodsFor: 'protected'!delete	"When we do a transformation I replace the current node by nothing."	self replace: {  }! !!PRNodeTransformer methodsFor: 'comparing'!executeOn: aPillarContext		self start: aPillarContext input.	^ aPillarContext! !!PRNodeTransformer methodsFor: 'initialization'!initialize	super initialize.	replacement := Stack new! !!PRNodeTransformer methodsFor: 'preparation'!prepareForExecutionOn: aPRProject 	"This is the setup of the process. This is before the pipeline building."	"Do nothing by default"! !!PRNodeTransformer methodsFor: 'protected'!replace: newNodes	"When we do a transformation I replace the current node by his transformation."	replacement pop.	replacement push: newNodes! !!PRNodeTransformer methodsFor: 'visiting'!start: anObject	super start: anObject.	^ anObject! !!PRNodeTransformer methodsFor: 'visiting-document'!visitDocumentGroup: aGroup	aGroup		setChildren:			(aGroup children				flatCollect: [ :child | 					replacement push: {child}.					self visit: child.					replacement pop]). ! !!PRNumeratingLinksVisitor class methodsFor: 'meta-data'!dependencies	^ {PRNumeratingVisitor}! !!PRNumeratingLinksVisitor class methodsFor: 'accessing'!executeOn: aPillarContext	self new		configuration: aPillarContext configuration;		anchorsMapping: (aPillarContext propertyAt: #anchorsMapping);		start: aPillarContext input.	^ aPillarContext! !!PRNumeratingLinksVisitor class methodsFor: 'instance creation'!with: anAnchorsMapping	^ self new		anchorsMapping: anAnchorsMapping;		yourself! !!PRNumeratingLinksVisitor methodsFor: 'accessing'!anchorCounter: aString	^ anchorsMapping at: aString ifAbsent: [ self cantFindCounterNamed: aString for: 'anchor' ]! !!PRNumeratingLinksVisitor methodsFor: 'accessing'!anchorsMapping: anObject	anchorsMapping := anObject! !!PRNumeratingLinksVisitor methodsFor: 'errors'!cantFindCounterNamed: counterName for: kind	PRReferenceNotFound signal: 'Can''t find ', kind, ' named ''', counterName, ''''.	^ PRNotFoundCounter new! !!PRNumeratingLinksVisitor methodsFor: 'testing'!isEmpty	^  anchorsMapping isEmpty ! !!PRNumeratingLinksVisitor methodsFor: 'visiting-document'!visitInternalLink: anInternalLink	anInternalLink hasAnchor		ifTrue: [ anInternalLink counter: (self anchorCounter: anInternalLink anchor) ]! !!PRNumeratingVisitor class methodsFor: 'instance creation'!executeOn: aPillarContext	self new		configuration: aPillarContext configuration;		start: aPillarContext input;		actionOn: aPillarContext.	^ aPillarContext! !!PRNumeratingVisitor class methodsFor: 'instance creation'!with: aConfiguration	^ self new		configuration: aConfiguration;		initializeTopNumerate;		yourself! !!PRNumeratingVisitor methodsFor: 'actions'!actionOn: anInput	^ anInput		propertyAt: #anchorsMapping put: anchorsMapping;		yourself! !!PRNumeratingVisitor methodsFor: 'initialization'!initialize	super initialize.	headerCounter := PRCascadingCounter maxLevel: 5.	figureCounter := PRCascadingCounter maxLevel: 2.	scriptCounter := PRCascadingCounter maxLevel: 2.	anchorsMapping := Dictionary new! !!PRNumeratingVisitor methodsFor: 'initialization'!initializeTopNumerate	| cpt |	cpt := 1.	[ (configuration printer perform: ('level' , cpt asString) asSymbol) numbering or: [ cpt > 5 ] ] whileFalse: [ cpt := cpt + 1 ].	topLevelNumerate := cpt! !!PRNumeratingVisitor methodsFor: 'test'!needNumbering: aHeader	^ (configuration levelConfigurationFor: aHeader) numbering! !!PRNumeratingVisitor methodsFor: 'visiting-document'!visitAnchor: anAnchor	anchorsMapping at: anAnchor name put: headerCounter current! !!PRNumeratingVisitor methodsFor: 'visiting-document'!visitCodeblock: aCodeBlock	"Figures and scripts are numbered based on the top-level header. This means that figures and scripts always have 2 numbers: one indicating the header they are in, and one indicating the position of the element in the corresponding section"	aCodeBlock isEvaluated		ifTrue: [ ^ self visitAll: aCodeBlock evaluate ].	aCodeBlock hasLabel		ifTrue: [ 			scriptCounter incrementAt: 2.			aCodeBlock counter: scriptCounter current.			aCodeBlock parameters at: 'label' ifPresent: [ :label | anchorsMapping at: label put: scriptCounter current ] ]! !!PRNumeratingVisitor methodsFor: 'visiting-document'!visitFigure: aFigure	"Figures and scripts are numbered based on the top-level header. This means that figures and scripts always have 2 numbers: one indicating the header they are in, and one indicating the position of the element in the corresponding section"	aFigure label		ifNotNil: [ 			figureCounter incrementAt: 2.			aFigure counter: figureCounter current.			aFigure parameters at: 'label' ifPresent: [ :label | anchorsMapping at: label put: figureCounter current ] ]! !!PRNumeratingVisitor methodsFor: 'visiting-document'!visitHeader: aHeader	| aLevel |	aLevel := aHeader level.	(self needNumbering: aHeader)		ifTrue: [ headerCounter incrementAt: aLevel ]		ifFalse: [ headerCounter dontIncrementAt: aLevel ].	aHeader level = topLevelNumerate		ifTrue: [ 			figureCounter incrementAt: 1.			scriptCounter incrementAt: 1 ].	"Figures and scripts are numbered based on the top-level header. This means that figures and scripts always have 2 numbers: one indicating the header they are in, and one indicating the position of the element in the corresponding section"	aHeader counter: headerCounter current! !!PRNumeratingVisitor methodsFor: 'visiting-document'!visitSlideTitleAnnotation: aSlideTitleAnnotation	aSlideTitleAnnotation parameters		at: 'label'		ifPresent: [ :label | anchorsMapping at: label put: headerCounter current ]! !!PRHeaderCapitalizationTransformer methodsFor: 'default'!capitalizationConfiguration	^ Dictionary		with: 'upper case' -> [ :text | text asUppercase ]		with: 'lower case' -> [ :text | text asLowercase ]		with: 'capitalize' -> [ :text | self capitalizeHeader: text ]		with: 'capitalize english' -> [ :text | self capitalizeEnglish: text ]		with: 'raw' -> [ :text | text ]! !!PRHeaderCapitalizationTransformer methodsFor: 'visiting-document'!capitalizeEnglish: aString	^ String streamContents: [ :s | 		aString substrings 			do: [ :each | s << (self englishWordCapitalize: each)]			separatedBy: [ s << ' ']]		! !!PRHeaderCapitalizationTransformer methodsFor: 'visiting-document'!capitalizeHeader: aString		^ String streamContents: [ :s | 		aString substrings			do: [ : each |  s << each capitalized]			separatedBy: [ s  <<' ' ] ]! !!PRHeaderCapitalizationTransformer methodsFor: 'visiting-document'!englishWordCapitalize: aWord	^  (self nonCapitalizedWordEnglish includes: aWord)					ifTrue: [ aWord ]					ifFalse: [ aWord capitalized ]							! !!PRHeaderCapitalizationTransformer methodsFor: 'initialization'!initialize	super initialize.	headerCapitalization := 'raw'! !!PRHeaderCapitalizationTransformer methodsFor: 'default'!nonCapitalizedWordEnglish	^ #( 'to' 'and' 'or' 'an'  'a' 'of'  'the' 'but' 'nor'  'for' 'yet'  'so' 'on' 'at' 'in')			! !!PRHeaderCapitalizationTransformer methodsFor: 'visiting-document'!visitHeader: aHeader		"this is done like that because the txt can be wrapped into bold and other"	headerCapitalization := (self configuration printer levelConfigurationFor: aHeader) capitalization.	super visitHeader: aHeader ! !!PRHeaderCapitalizationTransformer methodsFor: 'visiting-document'!visitText: aText	aText text: ((self capitalizationConfiguration at: headerCapitalization ifAbsent: [[:text|text]]) value: aText text).	headerCapitalization := 'raw'! !!PRPrintingTransformer methodsFor: 'initialization'!initialize	super initialize.	self flag: 'Why printer is not accessed via the configuration'.	printer := PRTitlePrinter new! !!PRPrintingTransformer methodsFor: 'accessing'!printer 	^ printer! !!PRPrintingTransformer methodsFor: 'accessing'!printer: aPrinter	printer := aPrinter! !!PRRemoveHideableScripts methodsFor: 'visiting-document'!visitCodeblock: aCodeBlock	(aCodeBlock isHideable)		ifTrue: [ self delete ]! !!PRScriptEvaluator methodsFor: 'visiting-document'!visitCodeblock: aCodeBlock	aCodeBlock isEvaluated		ifTrue: [ self replace: aCodeBlock evaluate ]! !!PRScriptFromFile methodsFor: 'adding'!addScript: aScript	| content |	content := String new writeStream.	aScript hasNoCode		ifFalse: [ 			PRWarning				signal:					'Be careful, you used the fromFile parameter on a script which is not empty. This has been erased : ' , aScript text ].	firstLine - 1 timesRepeat: [ fileStream nextLine ].	lastLine - firstLine + 1		timesRepeat: [ 			content nextPutAll: fileStream nextLine.			content nextPutAll: self configuration newLine ].	^ aScript text: content contents! !!PRScriptFromFile methodsFor: 'accessing'!fileLineNumber	| tmpStream cpt |	tmpStream := fileStream copy.	cpt := 0.	[ tmpStream nextLine isNotNil ] whileTrue: [ cpt := cpt + 1 ].	^ cpt! !!PRScriptFromFile methodsFor: 'testing'!hasFromFile: aScript	"I check if the transformer need to transform the script. If the script has bad parameters i raise a warning."	aScript parameters		at: 'firstLine'		ifPresent: [ :lineNumber | 			firstLine := lineNumber asInteger.			firstLine ifNil: [ PRPropertyError signal: 'firstLine parameter must contains digits' ].			aScript parameters				at: 'fromFile'				ifAbsent: [ PRWarning signal: 'firstLine has to be with a fromFile parameter.'.					^ false ] ].	aScript parameters		at: 'lastLine'		ifPresent: [ :lineNumber | 			lastLine := lineNumber asInteger.			lastLine ifNil: [ PRPropertyError signal: 'lastLine parameter must contains digits' ].			aScript parameters				at: 'fromFile'				ifAbsent: [ PRWarning signal: 'lastLine has to be with a fromFile parameter.'.					^ false ] ].	aScript parameters		at: 'fromFile'		ifPresent: [ :fileName | 			self setFileAndInterval: fileName.			^ true ]		ifAbsent: [ ^ false ]! !!PRScriptFromFile methodsFor: 'action'!setFileAndInterval: aFileName	"I get the File and i set the line numbers."	fileStream := self configuration baseDirectory resolve: aFileName.	fileStream exists		ifTrue: [ 			fileStream := fileStream contents readStream.			self updateInterval ]		ifFalse: [ PRInputFileError signal: aFileName , ' is not a valid file name into ' , self configuration baseDirectory asString , '.' ]! !!PRScriptFromFile methodsFor: 'action'!updateInterval	| fileLineNumber |	fileLineNumber := self fileLineNumber.	firstLine		ifNil: [ firstLine := 1 ]		ifNotNil: [ firstLine <= fileLineNumber				ifFalse: [ PRPropertyError signal: 'firstLine parameter is not a valid parameter. Please choose a firstLine lower than the file size.' ] ].	lastLine		ifNil: [ lastLine := fileLineNumber ]		ifNotNil: [ (lastLine >= firstLine and: [ lastLine <= fileLineNumber ])				ifFalse:					[ PRPropertyError signal: 'lastLine parameter is not a valid parameter. Please choose a lastLine lower than the file size and higher then the firstLine.' ] ]! !!PRScriptFromFile methodsFor: 'visiting-document'!visitCodeblock: aCodeBlock	(self hasFromFile: aCodeBlock)		ifTrue: [ self replace: {(self addScript: aCodeBlock)} ]! !!PRScriptLineNumber methodsFor: 'adding'!add: aString untilNewLineAt: firstOccurence withNumber: number	| length |	length := firstOccurence + self configuration newLine size -1.	self add: (aString first: length) withNumber: number.	^ aString allButFirst: length! !!PRScriptLineNumber methodsFor: 'adding'!add: aString withNumber: number	stream		<< number asString;		tab;		<< aString! !!PRScriptLineNumber methodsFor: 'adding'!addLineNumberTo: aScript	"I add a numerotation at each line of a script."	| text firstOccurence number |	text := aScript text.	number := 1.	firstOccurence := text indexOfSubCollection: self configuration newLine.	[ firstOccurence = 0 ]		whileFalse: [ 			text := self add: text untilNewLineAt: firstOccurence withNumber: number.			firstOccurence := text indexOfSubCollection: self configuration newLine.			number := number + 1 ].	self add: text withNumber: number.	^ aScript text: stream contents! !!PRScriptLineNumber methodsFor: 'testing'!hasLineNumber: aScript	^ aScript parameters 			at: 'lineNumber' 			ifPresent: [ :lN | lN = 'true' or: [ lN = true ] ] ifAbsent: [ false ]! !!PRScriptLineNumber methodsFor: 'initialization'!initialize	super initialize.	stream := PROutputStream on: (String new writeStream). ! !!PRScriptLineNumber methodsFor: 'visiting-document'!visitCodeblock: aScript	(self hasLineNumber: aScript)		ifTrue: [ self replace: {self addLineNumberTo: aScript} ]! !!PRSlideTransformer class methodsFor: 'meta-data'!dependencies	^ { PRCleanAnnotationInParagraphTransformer . PRColumnsTransformer }! !!PRSlideTransformer methodsFor: 'protected'!add: anObject toCurrentEnvironmentOr: aBlock	^ currentSlide		ifNil: [ aBlock value ]		ifNotNil: [ self delete.			currentSlide add: anObject ]! !!PRSlideTransformer methodsFor: 'accessing'!goal: aPRBuildGoal 		goal := aPRBuildGoal! !!PRSlideTransformer methodsFor: 'visiting'!start: anObject	"Execute column annotation before"	super start: (PRColumnsTransformer new start: anObject).	^ anObject! !!PRSlideTransformer methodsFor: 'visiting-document'!visitDocumentGroup: aGroup	self add: aGroup toCurrentEnvironmentOr: [ super visitDocumentGroup: aGroup ]! !!PRSlideTransformer methodsFor: 'visiting-document'!visitDocumentItem: anItem	self add: anItem toCurrentEnvironmentOr: [ super visitDocumentItem: anItem ]! !!PRSlideTransformer methodsFor: 'visiting-document'!visitHeader: anHeader	currentSlide := nil.	super visitHeader: anHeader! !!PRSlideTransformer methodsFor: 'visiting-annotations'!visitSlideTitleAnnotation: anAnnotation	currentSlide := (PRSlide		titled: (anAnnotation parameters at: 'title' ifAbsent: [ 'New Slide' ]))		label: (anAnnotation parameters at: 'label' ifAbsent: [ nil ]).	self replace: { currentSlide }! !!PRTemplatedWriter class methodsFor: 'templates'!anchorTemplateFileName		^ 'anchor.mustache'! !!PRTemplatedWriter class methodsFor: 'templates'!boldTemplateFileName		^ 'bold.mustache'! !!PRTemplatedWriter class methodsFor: 'templates'!codeBlockTemplateFileName		^ 'codeBlock.mustache'! !!PRTemplatedWriter class methodsFor: 'templates'!commentedLineTemplateFileName		^ 'commentedLine.mustache'! !!PRTemplatedWriter class methodsFor: 'templates'!dataItemTemplateFileName		^ 'dataItem.mustache'! !!PRTemplatedWriter class methodsFor: 'templates'!defaultAnnotatedParagraphTemplateFileName		^ 'defaultAnnotatedParagraph.mustache'! !!PRTemplatedWriter class methodsFor: 'templates'!definitionListTemplateFileName		^ 'definitionList.mustache'! !!PRTemplatedWriter class methodsFor: 'templates'!emptyParagraphTemplateFileName	^ 'emptyParagraph.mustache'! !!PRTemplatedWriter class methodsFor: 'templates'!externalLinkTemplateFileName		^ 'externalLink.mustache'! !!PRTemplatedWriter class methodsFor: 'templates'!figureTemplateFileName	^ 'figure.mustache'! !!PRTemplatedWriter class methodsFor: 'templates'!headerTemplateFileName		^ 'header.mustache'! !!PRTemplatedWriter class methodsFor: 'templates'!horizontalRuleTemplateFileName		^ 'horizontalRule.mustache'! !!PRTemplatedWriter class methodsFor: 'templates'!internalLinkTemplateFileName		^ 'internalLink.mustache'! !!PRTemplatedWriter class methodsFor: 'templates'!italicTemplateFileName		^ 'italic.mustache'! !!PRTemplatedWriter class methodsFor: 'templates'!lineBreakTemplateFileName		^ 'lineBreak.mustache'! !!PRTemplatedWriter class methodsFor: 'templates'!listItemTemplateFileName	^ 'listItem.mustache'! !!PRTemplatedWriter class methodsFor: 'templates'!mailLinkTemplateFileName		^ 'mailLink.mustache'! !!PRTemplatedWriter class methodsFor: 'templates'!monospaceTemplateFileName	^ 'monospace.mustache'! !!PRTemplatedWriter class methodsFor: 'templates'!orderedListTemplateFileName		^ 'orderedList.mustache'! !!PRTemplatedWriter class methodsFor: 'templates'!paragraphTemplateFileName		^ 'paragraph.mustache'! !!PRTemplatedWriter class methodsFor: 'templates'!preformattedTemplateFileName		^ 'preformatted.mustache'! !!PRTemplatedWriter class methodsFor: 'templates'!sectionTemplateFileName		^ 'section.mustache'! !!PRTemplatedWriter class methodsFor: 'templates'!unorderedListTemplateFileName	^ 'unorderedList.mustache'! !!PRTemplatedWriter class methodsFor: 'accessing'!writerName	^ #templatedWriter! !!PRTemplatedWriter methodsFor: 'accessing'!anchorTemplateFileName	^ self class anchorTemplateFileName! !!PRTemplatedWriter methodsFor: 'accessing'!boldTemplateFileName	^ self class boldTemplateFileName! !!PRTemplatedWriter methodsFor: 'accessing'!codeBlockTemplateFileName	^ self class codeBlockTemplateFileName! !!PRTemplatedWriter methodsFor: 'accessing'!commentedLineTemplateFileName	^ self class commentedLineTemplateFileName! !!PRTemplatedWriter methodsFor: 'accessing'!contents		^ defaultWriter contents! !!PRTemplatedWriter methodsFor: 'environment'!currentEnvironmentPath		^ RelativePath withAll: (environmentStack collect: #name) reversed! !!PRTemplatedWriter methodsFor: 'accessing'!dataItemTemplateFileName	^ self class dataItemTemplateFileName! !!PRTemplatedWriter methodsFor: 'accessing'!defaultAnnotatedParagraphTemplateFileName	^ self class defaultAnnotatedParagraphTemplateFileName! !!PRTemplatedWriter methodsFor: 'accessing'!defaultWriter	^ defaultWriter! !!PRTemplatedWriter methodsFor: 'accessing'!defaultWriter: anObject	defaultWriter := anObject! !!PRTemplatedWriter methodsFor: 'accessing'!definitionListTemplateFileName	^ self class definitionListTemplateFileName! !!PRTemplatedWriter methodsFor: 'accessing'!emptyParagraphTemplateFileName	^ self class emptyParagraphTemplateFileName! !!PRTemplatedWriter methodsFor: 'accessing'!environmentStack: aCollection 	environmentStack := aCollection! !!PRTemplatedWriter methodsFor: 'accessing'!externalLinkTemplateFileName	^ self class externalLinkTemplateFileName! !!PRTemplatedWriter methodsFor: 'accessing'!figureTemplateFileName	^ self class figureTemplateFileName! !!PRTemplatedWriter methodsFor: 'accessing'!folderName	^ defaultWriter folderName! !!PRTemplatedWriter methodsFor: 'accessing'!headerTemplateFileName	^ self class headerTemplateFileName! !!PRTemplatedWriter methodsFor: 'accessing'!horizontalRuleTemplateFileName	^ self class horizontalRuleTemplateFileName! !!PRTemplatedWriter methodsFor: 'accessing'!initialize	super initialize.	environmentStack := OrderedCollection new.! !!PRTemplatedWriter methodsFor: 'accessing'!internalLinkTemplateFileName	^ self class internalLinkTemplateFileName! !!PRTemplatedWriter methodsFor: 'accessing'!italicTemplateFileName			^ self class italicTemplateFileName! !!PRTemplatedWriter methodsFor: 'accessing'!lineBreakTemplateFileName	^ self class lineBreakTemplateFileName! !!PRTemplatedWriter methodsFor: 'accessing'!listItemTemplateFileName	^ self class listItemTemplateFileName! !!PRTemplatedWriter methodsFor: 'accessing'!mailLinkTemplateFileName	^ self class mailLinkTemplateFileName! !!PRTemplatedWriter methodsFor: 'accessing'!monospaceTemplateFileName	^ self class monospaceTemplateFileName! !!PRTemplatedWriter methodsFor: 'accessing'!orderedListTemplateFileName	^ self class orderedListTemplateFileName! !!PRTemplatedWriter methodsFor: 'accessing'!outputDocument	^ outputDocument! !!PRTemplatedWriter methodsFor: 'accessing'!outputDocument: anObject	outputDocument := anObject! !!PRTemplatedWriter methodsFor: 'accessing'!paragraphTemplateFileName	^ self class paragraphTemplateFileName! !!PRTemplatedWriter methodsFor: 'environment'!popEnvironment		environmentStack removeFirst! !!PRTemplatedWriter methodsFor: 'accessing'!preformattedTemplateFileName	^ self class preformattedTemplateFileName! !!PRTemplatedWriter methodsFor: 'environment'!pushEnvironment: aPREnvironment 		environmentStack addFirst: aPREnvironment! !!PRTemplatedWriter methodsFor: 'accessing'!sectionTemplateFileName	^ self class sectionTemplateFileName! !!PRTemplatedWriter methodsFor: 'accessing'!templateForConfiguration: aConfiguration	^ defaultWriter templateForConfiguration: aConfiguration! !!PRTemplatedWriter methodsFor: 'accessing'!unorderedListTemplateFileName	^ self class unorderedListTemplateFileName! !!PRTemplatedWriter methodsFor: 'visiting'!visitAnchor: aPRAnchor	self		writeRawText: ''		withTemplateFileName: self anchorTemplateFileName		extraArguments: { 'name' -> aPRAnchor name }		ifAbsent: [ defaultWriter visitAnchor: aPRAnchor ]! !!PRTemplatedWriter methodsFor: 'visiting'!visitAnnotatedParagraph: anAnnotatedParagraph	| arguments |	arguments := { 'annotation' -> anAnnotatedParagraph annotation }.	self		write: anAnnotatedParagraph		withTemplateFileName: anAnnotatedParagraph annotation , '.mustache'		extraArguments: arguments 		ifAbsent: [			self				write: anAnnotatedParagraph				withTemplateFileName: self defaultAnnotatedParagraphTemplateFileName				extraArguments: arguments 				ifAbsent: [ defaultWriter visitAnnotatedParagraph: anAnnotatedParagraph ] ]! !!PRTemplatedWriter methodsFor: 'visiting'!visitBoldFormat: aPRBoldFormat	self		write: aPRBoldFormat		withTemplateFileName: self boldTemplateFileName		ifAbsent: [ defaultWriter visitBoldFormat: aPRBoldFormat ]! !!PRTemplatedWriter methodsFor: 'visiting'!visitCodeblock: aPRCodeblock 	self		writeRawText: aPRCodeblock text		withTemplateFileName: self codeBlockTemplateFileName		extraArguments: { 'language' -> (defaultWriter languageForScript: aPRCodeblock) }		ifAbsent: [ defaultWriter visitCodeblock: aPRCodeblock ]! !!PRTemplatedWriter methodsFor: 'visiting'!visitCommentedLine: aPRText 	self		writeRawText: aPRText text		withTemplateFileName: self commentedLineTemplateFileName		ifAbsent: [ defaultWriter visitCommentedLine: aPRText  ]! !!PRTemplatedWriter methodsFor: 'visiting'!visitDataItem: aPRListItem	self		write: aPRListItem		withTemplateFileName: self dataItemTemplateFileName		ifAbsent: [ defaultWriter visitDataItem: aPRListItem ]! !!PRTemplatedWriter methodsFor: 'visiting'!visitDefinitionList: aPRList	self		write: aPRList		withTemplateFileName: self definitionListTemplateFileName		ifAbsent: [ defaultWriter visitDefinitionList: aPRList ]! !!PRTemplatedWriter methodsFor: 'visiting'!visitEmptyParagraph: anEmptyParagraph		self		writeRawText: anEmptyParagraph text		withTemplateFileName: self emptyParagraphTemplateFileName		ifAbsent: [ defaultWriter visitEmptyParagraph: anEmptyParagraph ]! !!PRTemplatedWriter methodsFor: 'visiting'!visitEnvironment: anEnvironment	self pushEnvironment: anEnvironment.	self		write: anEnvironment		withTemplateFileName: 'main.mustache'		extraArguments: anEnvironment properties associations		ifAbsent: [ self visitDocumentGroup: anEnvironment ].	self popEnvironment.! !!PRTemplatedWriter methodsFor: 'visiting'!visitExternalLink: aPRExternalLink	self		write: aPRExternalLink		withTemplateFileName: self externalLinkTemplateFileName		extraArguments: { 'reference' -> aPRExternalLink reference }		ifAbsent: [ defaultWriter visitExternalLink: aPRExternalLink ]! !!PRTemplatedWriter methodsFor: 'visiting'!visitFigure: aFigure	self		write: aFigure		withTemplateFileName: self figureTemplateFileName		extraArguments: {			'ref' -> aFigure localFileOrExternalReference.			'caption' -> (aFigure hasChildren ifTrue: [ aFigure text ] ifFalse: [ '' ]) }		ifAbsent: [ defaultWriter visitFigure: aFigure ]! !!PRTemplatedWriter methodsFor: 'visiting'!visitHeader: aHeader	self		write: aHeader		withTemplateFileName: self headerTemplateFileName		extraArguments: { 'level' -> (aHeader level min: 7 max: 1) }		ifAbsent: [ defaultWriter visitHeader: aHeader ]! !!PRTemplatedWriter methodsFor: 'visiting'!visitHorizontalRule: aPRHorizontalRule	self		writeRawText: ''		withTemplateFileName: self horizontalRuleTemplateFileName		ifAbsent: [ defaultWriter visitHorizontalRule: aPRHorizontalRule ]! !!PRTemplatedWriter methodsFor: 'visiting'!visitInternalLink: aPRInternalLink	self		write: aPRInternalLink		withTemplateFileName: self internalLinkTemplateFileName		extraArguments: { 'reference' -> aPRInternalLink reference }		ifAbsent: [ defaultWriter visitInternalLink: aPRInternalLink ]! !!PRTemplatedWriter methodsFor: 'visiting'!visitItalicFormat: aPRItalicFormat 		self		write: aPRItalicFormat		withTemplateFileName: self italicTemplateFileName		ifAbsent: [ defaultWriter visitItalicFormat: aPRItalicFormat ]! !!PRTemplatedWriter methodsFor: 'visiting'!visitLineBreak: aPRLineBreak	self		writeRawText: ''		withTemplateFileName: self lineBreakTemplateFileName		ifAbsent: [ defaultWriter visitLineBreak: aPRLineBreak ]! !!PRTemplatedWriter methodsFor: 'visiting'!visitListItem: aPRListItem	self		write: aPRListItem		withTemplateFileName: self listItemTemplateFileName		ifAbsent: [ defaultWriter visitListItem: aPRListItem ]! !!PRTemplatedWriter methodsFor: 'visiting'!visitMailLink: aPRMailLink	self		write: aPRMailLink		withTemplateFileName: self mailLinkTemplateFileName		extraArguments: { 'reference' -> aPRMailLink reference }		ifAbsent: [ defaultWriter visitExternalLink: aPRMailLink ]! !!PRTemplatedWriter methodsFor: 'visiting'!visitMonospaceFormat: aPRMonospaceFormat 		self		write: aPRMonospaceFormat		withTemplateFileName: self monospaceTemplateFileName		ifAbsent: [ defaultWriter visitMonospaceFormat: aPRMonospaceFormat ]! !!PRTemplatedWriter methodsFor: 'visiting'!visitOrderedList: aPROrderedList	self		write: aPROrderedList		withTemplateFileName: self orderedListTemplateFileName		ifAbsent: [ defaultWriter visitOrderedList: aPROrderedList ]! !!PRTemplatedWriter methodsFor: 'visiting'!visitParagraph: aParagraph	self		write: aParagraph		withTemplateFileName: self paragraphTemplateFileName		ifAbsent: [ defaultWriter visitParagraph: aParagraph ]! !!PRTemplatedWriter methodsFor: 'visiting'!visitPreformatted: aPRPreformatted	self		write: aPRPreformatted		withTemplateFileName: self preformattedTemplateFileName		ifAbsent: [ defaultWriter visitPreformatted: aPRPreformatted ]! !!PRTemplatedWriter methodsFor: 'delegating'!visitRaw: aPRRaw 		defaultWriter visitRaw: aPRRaw! !!PRTemplatedWriter methodsFor: 'visiting'!visitSection: aPRSection	self		write: aPRSection		withTemplateFileName: self sectionTemplateFileName		ifAbsent: [ defaultWriter visitSection: aPRSection ]! !!PRTemplatedWriter methodsFor: 'delegating'!visitText: aPRText 		defaultWriter visitText: aPRText! !!PRTemplatedWriter methodsFor: 'visiting'!visitUnorderedList: aPRUnorderedList 	self		write: aPRUnorderedList		withTemplateFileName: self unorderedListTemplateFileName		ifAbsent: [ defaultWriter visitUnorderedList: aPRUnorderedList ]! !!PRTemplatedWriter methodsFor: 'writing'!write: aPRElement 		aPRElement accept: self.	^ defaultWriter contents! !!PRTemplatedWriter methodsFor: 'writing'!write: aDocumentItem withTemplateFileName: templateFileName extraArguments: arguments ifAbsent: aBlock	self		writeRawText: [ | subWriter |			subWriter := outputDocument writer.			subWriter environmentStack: environmentStack. 			subWriter visitDocumentGroup: aDocumentItem.			subWriter contents ]		withTemplateFileName: templateFileName		extraArguments: arguments		ifAbsent: aBlock! !!PRTemplatedWriter methodsFor: 'writing'!write: aDocumentItem withTemplateFileName: templateFileName ifAbsent: aBlock	self		write: aDocumentItem		withTemplateFileName: templateFileName		extraArguments: #()		ifAbsent: aBlock! !!PRTemplatedWriter methodsFor: 'writing'!writeRawText: aText withTemplateFileName: templateFileName extraArguments: arguments ifAbsent: aBlock	| templateFile result environmentPath foundPath |	environmentPath := self currentEnvironmentPath.		foundPath := environmentPath		lookup: [ :path | ((outputDocument templateDirectory resolve: path) / templateFileName) exists ]		ifNone: [ ^ aBlock value ].		templateFile := outputDocument templateDirectory resolve: foundPath / templateFileName.			result := templateFile asMustacheTemplate value: ({ 'contents' -> aText value }, arguments) asDictionary.	self visitRaw: (PRRaw content: result type: defaultWriter writerName)! !!PRTemplatedWriter methodsFor: 'writing'!writeRawText: aText withTemplateFileName: templateFileName ifAbsent: aBlock	^ self		writeRawText: aText		withTemplateFileName: templateFileName		extraArguments: #()		ifAbsent: aBlock! !!PRTocBuilderVisitor class methodsFor: 'testing'!isAbstract	^ false! !!PRTocBuilderVisitor methodsFor: 'visiting'!addToToc: aTocTitle	self top level < aTocTitle level		ifTrue: [ self top addChildren: aTocTitle.			self push: aTocTitle ]		ifFalse: [ self pop.			self addToToc: aTocTitle ]! !!PRTocBuilderVisitor methodsFor: 'accessing'!currentFile	^ currentFile! !!PRTocBuilderVisitor methodsFor: 'accessing'!currentFile: anObject	currentFile := anObject! !!PRTocBuilderVisitor methodsFor: 'accessing'!documentSource	^ documentSource! !!PRTocBuilderVisitor methodsFor: 'accessing'!documentSource: anObject	documentSource := anObject! !!PRTocBuilderVisitor methodsFor: 'accessing'!inProcessFiles: anObject	inProcessFiles := anObject! !!PRTocBuilderVisitor methodsFor: 'initialization'!initialize	super initialize.	toc := PRToc new level: 0.	tocsStack := Stack new.	tocsStack push: toc.	inProcessFiles := #()! !!PRTocBuilderVisitor methodsFor: 'accessing'!pop	^ tocsStack pop! !!PRTocBuilderVisitor methodsFor: 'accessing'!push: aToc	^ tocsStack push: aToc! !!PRTocBuilderVisitor methodsFor: 'accessing'!tableOfContents	^ toc! !!PRTocBuilderVisitor methodsFor: 'accessing'!top	^ tocsStack top! !!PRTocBuilderVisitor methodsFor: 'initialization'!validateInclusionOfFile: aSource		self documentSource = aSource ifTrue: [ 		PRCyclicFileInclusionError new			files: { aSource };			signal	].	(inProcessFiles includes: aSource)		ifTrue: [ PRCyclicFileInclusionError new			files: (inProcessFiles copyWith: aSource);			signal 	]! !!PRTocBuilderVisitor methodsFor: 'visiting'!visit: aDocument	super visit: aDocument.	^ toc! !!PRTocBuilderVisitor methodsFor: 'visiting'!visitHeader: aHeader	| titleToc|	titleToc := PRToc new name: aHeader text; level: aHeader level; fileReference: currentFile.	self addToToc: titleToc	! !!PRTocBuilderVisitor methodsFor: 'initialization'!visitInputFileAnnotation: anAnnotation	| document sourceSave currentSave newSource |	"Resolve and parse the new file"	sourceSave := self documentSource.	currentSave := self currentFile.	newSource := self documentSource parent resolve: anAnnotation path.	self validateInclusionOfFile: newSource.	document := PRPillarParserMain parse: newSource contents.	self documentSource: newSource.	self currentFile: anAnnotation path.	"Update inProcessFiles with the actual document"	self		inProcessFiles: (inProcessFiles copyWith: self documentSource);		visit: document.	"Get the original values"	self currentFile: currentSave.	self documentSource: sourceSave! !!PRUpdateFileInclusionReference class methodsFor: 'visiting'!isAbstract	^ false! !!PRUpdateFileInclusionReference class methodsFor: 'visiting'!start: aDocument with: aPath	^ self new		path: aPath;		start: aDocument! !!PRUpdateFileInclusionReference methodsFor: 'instance creation'!newReferenceFor: aReference	(aReference reference includesSubstring: 'file://')		ifTrue: [ ^ aReference reference copyReplaceAll: 'file://' with: 'file://', self path , '/' ].	^ self path		ifEmpty: [ aReference reference ]			ifNotEmpty: [ self path , '/' , aReference reference]! !!PRUpdateFileInclusionReference methodsFor: 'accessing'!path	^ path! !!PRUpdateFileInclusionReference methodsFor: 'accessing'!path: aPath	path := aPath! !!PRUpdateFileInclusionReference methodsFor: 'visiting'!start: anObject	super start: anObject.	^ anObject! !!PRUpdateFileInclusionReference methodsFor: 'visiting'!visitFigure: aFigure	"self halt: 'PRUpdateFileInclusionReference'."	aFigure reference: (self newReferenceFor: aFigure).	super visitFigure: aFigure! !!PRUpdateFileInclusionReference methodsFor: 'visiting'!visitInternalLink: anInternalLink	anInternalLink hasReference  		ifTrue: [ anInternalLink reference: (self newReferenceFor: anInternalLink) ].	super visitInternalLink: anInternalLink! !!CTEnvironment methodsFor: '*Pillar-ExporterCore'!mustacheLookup: aString	(aString = '.') ifTrue: [ ^ self ].	^ self propertyAt: aString asSymbol		ifPresent: [ :elem | elem asMustachableValue ]		ifAbsent: [ (super mustacheLookup: aString) asMustachableValue ]! !"Pillar-ExporterCore"!!PRAsciiDocWriter commentStamp: '' prior: 0!Write a Pillar document to an AsciiDoc document!!PRAsciiDocCanvas commentStamp: '' prior: 0!An AsciiDoc canvas that facilitates writing AsciiDoc to a stream. The main methods are #surround:with: and #precede:by: that allow you to write something like this:canvas surround:  [ "some code that generates the string inside the bold" ] with: '*'canvas precede: [ "some code that generates the string which will be change by the label" ]  by: '[label]' !!PRAsciiDocWriter class methodsFor: 'accessing'!fileExtension	^ 'asciidoc'! !!PRAsciiDocWriter class methodsFor: 'accessing'!folderName	^ #asciidoc! !!PRAsciiDocWriter class methodsFor: 'testing'!isAbstract	^ false! !!PRAsciiDocWriter class methodsFor: 'accessing'!writerName	^ #asciidoc! !!PRAsciiDocWriter methodsFor: 'visiting-document'!addAnnotatedKeywords: aString to: aKey 	annotatedKeywords at: aKey put: aString! !!PRAsciiDocWriter methodsFor: 'accessing'!annotatedKeywords	^ annotatedKeywords ! !!PRAsciiDocWriter methodsFor: 'accessing'!canvasClass	^ PRAsciiDocCanvas! !!PRAsciiDocWriter methodsFor: 'visiting-document'!createAnchorWith: anId	canvas surround: anId with: '[[' and: ']]'! !!PRAsciiDocWriter methodsFor: 'initialization'!initAnnotatedKeywords	self addAnnotatedKeywords: 'CAUTION:' to: 'caution';		  addAnnotatedKeywords: 'IMPORTANT:' to: 'important';		  addAnnotatedKeywords: 'IMPORTANT:' to: 'todo';		  addAnnotatedKeywords: 'NOTE:' to: 'note';		  addAnnotatedKeywords: 'NOTE:' to: 'annotation';		  addAnnotatedKeywords: 'NOTE:' to: 'comment';		  addAnnotatedKeywords: 'TIP:' to: 'tip';		  addAnnotatedKeywords: 'TIP:' to: 'tips';		  addAnnotatedKeywords: 'WARNING:' to: 'warning'.! !!PRAsciiDocWriter methodsFor: 'initialization'!initialize	super initialize.	annotatedKeywords := Dictionary new.	self initAnnotatedKeywords.! !!PRAsciiDocWriter methodsFor: 'writing-text'!link: anUrl named: name	stream 		<< anUrl		<< '[' << name << ']'! !!PRAsciiDocWriter methodsFor: 'visiting-document'!nest: aString do: aBlock	nesting add: aString.	aBlock ensure: [ nesting removeLast ]! !!PRAsciiDocWriter methodsFor: 'visiting-document'!searchAnnotation: anAnnotationName	^ annotatedKeywords at: anAnnotationName ifAbsent: [ '' ].! !!PRAsciiDocWriter methodsFor: 'visiting-document'!searchParam: aString in: aFigure"Search in the figure parameters if the parameter aString is present and return the parameter and its value folowing the scheme param=""value"" "	^		aFigure parameters			at: aString			ifPresent: [ :param |  aString, '="', param asString, '"']			ifAbsent: [ '' ]! !!PRAsciiDocWriter methodsFor: 'visiting-document'!start: anObject	nesting := OrderedCollection new.	super start: anObject.! !!PRAsciiDocWriter methodsFor: 'visiting-document'!visitAnchor: anAnchor	self createAnchorWith: anAnchor name! !!PRAsciiDocWriter methodsFor: 'visiting-document'!visitAnnotatedParagraph: anAnnotatedParagraph	| annotation |	annotation := self searchAnnotation: anAnnotatedParagraph annotation.	canvas precede: [ super visitParagraph: anAnnotatedParagraph ] by: annotation , (annotation ifEmpty: [ '' ] ifNotEmpty: [ ' ' ]).	canvas potentialNewLine! !!PRAsciiDocWriter methodsFor: 'visiting-document'!visitBoldFormat: aFormat	canvas surround: [super visitBoldFormat: aFormat] with: '*'! !!PRAsciiDocWriter methodsFor: 'visiting-document'!visitCodeblock: aCodeBlock	|language   params |		aCodeBlock hasLabel		ifTrue: [ self createAnchorWith: aCodeBlock label ].		params := ''.		language := self languageForScript: aCodeBlock.	language isSyntaxHighlightingPossible		ifTrue: [ params := 'source,', language  printString, ','].		stream << '[' << params << 'caption="' << (self getStringForAll: aCodeBlock caption children) << '"]'.	canvas newLine.	stream << '----'.	canvas newLine.	stream << [ super visitCodeblock: aCodeBlock ].	canvas newLine.	stream << '----'! !!PRAsciiDocWriter methodsFor: 'visiting-document'!visitDataItem: anObject	self nest: '::' do: [ super visitDataItem: anObject ]! !!PRAsciiDocWriter methodsFor: 'visiting-document'!visitDefinitionList: anObject	canvas potentialNewLine.	self nest: '' do: [ super visitDefinitionList: anObject ]! !!PRAsciiDocWriter methodsFor: 'visiting-document'!visitExternalLink: anExternalLink	self link: anExternalLink localFileOrExternalReference named: [ stream << anExternalLink text ]! !!PRAsciiDocWriter methodsFor: 'visiting-document'!visitFigure: aFigure		| parameters |	parameters := Set  new.		parameters add: (self searchParam: 'width' in: aFigure);				  add: ('caption="', (self getStringForAll: aFigure children) ,'"').			aFigure label ifNotNil: [ :label | self createAnchorWith: label ].		canvas potentialNewLine;			 surround: (aFigure localFileOrExternalReference) with: 'image::' and: '[',parameters asCommaString ,']'.! !!PRAsciiDocWriter methodsFor: 'visiting-annotations'!visitFootnote: aFootnote	canvas precede: ('[', (aFootnote note) , ']') by: 'footnote:'	! !!PRAsciiDocWriter methodsFor: 'visiting-document'!visitHeader: aHeader	aHeader level timesRepeat: [ canvas raw: '=' ].	canvas space.	super visitHeader: aHeader.	canvas newLine! !!PRAsciiDocWriter methodsFor: 'visiting-document'!visitHorizontalRule: anHorizontalRule	canvas newLine; newLine;			 raw: '''''''';			 newLine.! !!PRAsciiDocWriter methodsFor: 'visiting-document'!visitInternalLink: anInternalLink	|alias|	alias := 	anInternalLink hasAlias					ifTrue: [ ',' , anInternalLink alias ]					ifFalse: [ '' ].	anInternalLink hasAnchor 		ifTrue: [ canvas surround: anInternalLink anchor, alias with: '<<' and: '>>']! !!PRAsciiDocWriter methodsFor: 'visiting-document'!visitItalicFormat: aFormat	canvas surround: [super visitItalicFormat: aFormat] with: ''''! !!PRAsciiDocWriter methodsFor: 'visiting-document'!visitListItem: anObject	nesting last isInteger ifTrue: [ nesting addLast: nesting removeLast + 1 ].	nesting size - 1 timesRepeat: [ canvas tab ].	canvas nextPutAll: nesting last asString.	canvas nextPutAll: (nesting last isInteger 			ifTrue: [ '. ' ]			ifFalse: [ ' ' ]).	super visitListItem: anObject.	canvas potentialNewLine! !!PRAsciiDocWriter methodsFor: 'visiting-document'!visitMailLink: aMail	self link: aMail unscrambledUrl named: [ stream << aMail text ]! !!PRAsciiDocWriter methodsFor: 'visiting-document'!visitMonospaceFormat: aFormat	canvas surround: [super visitMonospaceFormat: aFormat] with: '+'! !!PRAsciiDocWriter methodsFor: 'visiting-document'!visitOrderedList: anObject	canvas newLine.	self nest: '.' do: [ super visitOrderedList: anObject ]! !!PRAsciiDocWriter methodsFor: 'visiting-document'!visitParagraph: aParagraph	super visitParagraph: aParagraph.		canvas potentialNewLine.	canvas newLine.! !!PRAsciiDocWriter methodsFor: 'visiting-document'!visitPreformatted: aPreformatted	canvas precede: [ aPreformatted children do: [ :child | self visit: child ] separatedBy: [canvas newLine; raw: ' ' ]] by: ' '! !!PRAsciiDocWriter methodsFor: 'visiting-document'!visitStrikethroughFormat: aFormat	canvas precede: [super visitStrikethroughFormat: aFormat] by: '[line-through]'! !!PRAsciiDocWriter methodsFor: 'visiting-document'!visitSubscriptFormat: aFormat	canvas surround: [super visitSubscriptFormat: aFormat] with: '~'! !!PRAsciiDocWriter methodsFor: 'visiting-document'!visitSuperscriptFormat: aFormat	canvas surround: [super visitSuperscriptFormat: aFormat] with: '^'! !!PRAsciiDocWriter methodsFor: 'visiting-document'!visitTable: aTable	canvas surround: [super visitTable: aTable] with: '|==='.	canvas newLine.! !!PRAsciiDocWriter methodsFor: 'visiting-document'!visitTableCell: aCell	canvas precede: [ super visitTableCell: aCell ] by: '|'.	aCell isHeading 		ifFalse: [canvas newLine].! !!PRAsciiDocWriter methodsFor: 'visiting-document'!visitTableRow: aRow		canvas potentialNewLine.	canvas newLine.	super visitTableRow: aRow.! !!PRAsciiDocWriter methodsFor: 'visiting-document'!visitTermItem: anObject	self nest: '' do: [ super visitTermItem: anObject ]! !!PRAsciiDocWriter methodsFor: 'visiting-document'!visitUnderlineFormat: aFormat		canvas precede: [super visitStrikethroughFormat: aFormat] by: '[underline]'	! !!PRAsciiDocWriter methodsFor: 'visiting-document'!visitUnorderedList: anObject	canvas potentialNewLine.	self nest: '*' do: [ super visitUnorderedList: anObject ]! !!PRAsciiOutput class methodsFor: 'accessing'!builderName	^ 'ascii'! !!PRAsciiOutput methodsFor: 'building'!documentFor: aFile	^ PRAsciiDocument new		project: aFile project;		file: aFile;		target: self;		outputDirectory: aFile project outputDirectory / self extension;		yourself! !!PRAsciiOutput methodsFor: 'accessing'!extension	^ 'ascii'! !!PRAsciiOutput methodsFor: 'accessing'!outputDirectoryName		^ 'ascii'! !!PRAsciiOutput methodsFor: 'accessing'!writerFor: aPRPillarConfiguration 		^ PRAsciiDocWriter new! !!PRAsciiDocCanvas methodsFor: 'initialization'!initialize	super initialize.	lastIsNewLine := true! !!PRAsciiDocCanvas methodsFor: 'accessing'!lastIsNewLine	^lastIsNewLine! !!PRAsciiDocCanvas methodsFor: 'writing text'!newLine	super newLine.	lastIsNewLine := true! !!PRAsciiDocCanvas methodsFor: 'writing text'!nextPut: aCharacter	super nextPut: aCharacter.	lastIsNewLine := false! !!PRAsciiDocCanvas methodsFor: 'writing text'!potentialNewLine	lastIsNewLine 		ifFalse: [ self newLine ]! !!PRAsciiDocCanvas methodsFor: 'writing text'!precede: aStringOrABlock by: anotherString	stream << anotherString << aStringOrABlock ! !!PRAsciiDocCanvas methodsFor: 'writing text'!raw: aString	super raw: aString.	lastIsNewLine := false! !!PRAsciiDocCanvas methodsFor: 'writing text'!surround: aStringOrBlock with: anotherString	self surround: aStringOrBlock with: anotherString and: anotherString ! !!PRAsciiDocCanvas methodsFor: 'writing text'!surround: aStringOrBlock with: anotherString and: theLastString	stream << anotherString << aStringOrBlock << theLastString! !!PRAsciiDocCanvas methodsFor: 'stop conditions'!tab	self nextPut: Character tab! !"Pillar-ExporterAsciiDoc"!!ChrysalPillarConfigurationTest commentStamp: '' prior: 0!Check ChrysalConfigurationBuilder >> #itemDescriptionForXX for the!!ChrysalPillarishConfiguration commentStamp: '' prior: 0!I'm a pillar specific class to manage code not generated for the configuration class. Pillar code should not use me but my subclass.!!ConfigurationForPillar commentStamp: '' prior: 0!I'm a generated class that manages the conversion of configuration items written in STON format to Pharo objects. I'm used for example in Pillar to manage 'Pillar.conf' file.  I was generated by the ChrysalConfigurationBuilder based on a list of item descriptions (instances of subclasses of ChrysalItem).To help you remember from which configuration items I was generated from, I have a class side method which when executed in presence of the generating package will return a list of items. Note that such items only exist at compile time. Therefore executing this method with only the runtime does not make any sense.chrysalDescriptions ^ STON fromString: '[	StringConfigurationItem {		#propertyName : #title,		#default : 'my super cool book',		#noDefault : false	}, ... ]'Now to exist and be used I do not need the full Chrysal package, just the runtime containing the ChrysalConfiguration class. Note that I may inherit from one of its subclasses to support better customisation. 				Chrysal is hosted at: github.com/Ducasse/Chrysal					To generate me, a code snippet similar to the following one was executed: 				ChrysalConfigurationBuilder new 			configurationRootClass: ChrysalPillarishConfiguration;			defineConfigurationClassNamed: #ConfigurationForPillar packagedIn: Pillar-Chrysal; 			withDescriptionItems: ConfigurationDescriptionForXX itemDescriptionForXX !!ChrysalPillarConfigurationTest methodsFor: 'tests - from cocoon'!configurationClass	^ ConfigurationForPillar! !!ChrysalPillarConfigurationTest methodsFor: 'tests'!printerSample	^ '{	''levels'' : [		[    ''level'' : 1,			''renderAs'' : ''letter'',			''capitalization'' : ''uppercase'',			''numbering'' : true,			''size'' : 2,			''headerSize'' : 2		],		[	''level'' : 2,			''renderAs'' : ''number'',			''capitalization'' : ''uppercase'',			''numbering'' : true,			''size'' : 3,			''headerSize'' : 3		]	]}'! !!ChrysalPillarConfigurationTest methodsFor: 'tests'!testPrinter	| config level1 level2 |	config := self configurationClass newFromDictionary: (STON fromString: self printerSample).	config propertyAt: 'levels'.	level1 := config printer level1.	self assert: level1 capitalization equals: 'uppercase'.	self assert: level1 numbering.	self assert: level1 level equals: 1.	self assert: level1 size equals: 2.	self assert: level1 class equals: PRLevelLetterPrinter.	level2 := config printer level2.	self assert: level2 capitalization equals: 'uppercase'.	self assert: level2 numbering.	self assert: level2 level equals: 2.	self assert: level2 size equals: 3.	self assert: level2 class equals: PRLevelNumberPrinter! !!ChrysalPillarConfigurationTest methodsFor: 'tests - from cocoon'!testReadingDefaultScriptLanguage	|  config |	config := self configurationClass newFromDictionary:  (Dictionary with: 'defaultScriptLanguage' -> 'smalltalk').	self assert: config defaultScriptLanguage equals: (PRAbstractScriptLanguage for: 'smalltalk').		config := self configurationClass newFromDictionary:  (Dictionary with: 'defaultScriptLanguage' -> 'css').	self assert: config defaultScriptLanguage equals: (PRAbstractScriptLanguage for: 'css')! !!ChrysalPillarConfigurationTest methodsFor: 'tests - from cocoon'!testReadingHeadingLevelOffset	| dictionary config |	dictionary := Dictionary with: 'headingLevelOffset' -> 1.	config := self configurationClass newFromDictionary: dictionary.	self assert: config headingLevelOffset equals: 1! !!ChrysalPillarConfigurationTest methodsFor: 'tests - from cocoon'!testReadingNewLine	| dictionary config |	dictionary := Dictionary with: 'newLine' -> #unix.	config := self configurationClass newFromDictionary: dictionary.	self assert: config newLine equals: UnixPlatform new lineEnding! !!ChrysalPillarConfigurationTest methodsFor: 'tests - from cocoon'!testReadingRenderStructureAsSlide	| dictionary config |	dictionary := Dictionary with: 'renderStructureAsSlide' -> false.	config := self configurationClass newFromDictionary: dictionary.	self deny: config renderStructureAsSlide! !!ChrysalPillarConfigurationTest methodsFor: 'tests - from cocoon'!testReadingScrambledEmailAddresses	| dictionary config |	dictionary := STON fromStream: '{ "scrambledEmailAddresses" : true }' readStream.	config := self configurationClass newFromDictionary: dictionary.	self assert: config scrambledEmailAddresses! !!ChrysalPillarConfigurationTest methodsFor: 'tests - from cocoon'!testReadingSeparateOutputFiles	| dictionary config |	dictionary := Dictionary with: 'separateOutputFiles' -> false.	config := self configurationClass newFromDictionary: dictionary.	self deny: config separateOutputFiles! !!ChrysalPillarConfigurationTest methodsFor: 'tests - from cocoon'!testReadingTitle	| dictionary config |	dictionary := Dictionary with: 'title' -> 'foo'.	config := self configurationClass newFromDictionary: dictionary.	self assert: config title equals: 'foo'! !!ChrysalPillarConfigurationTest methodsFor: 'tests - from cocoon'!testReadingVerbose	| dictionary config |	dictionary := Dictionary with: 'verbose' -> false.	config := self configurationClass newFromDictionary: dictionary.	self deny: (config propertyAt: #verbose)! !!ChrysalPillarConfigurationTest methodsFor: 'tests - from cocoon'!testSeparateOutputFiles	| dictionary config |	dictionary := STON fromStream: '{  "separateOutputFiles" : false }' readStream.	config := self configurationClass newFromDictionary: dictionary.	self deny: config separateOutputFiles! !!ChrysalPillarishConfiguration methodsFor: 'accessing'!initialize	"This is a hack waiting for a better management of the printer for NodeTransformer."	super initialize. 	printer := PRTitlePrinter new.! !!ChrysalPillarishConfiguration methodsFor: 'backward compatibility'!levelConfigurationFor: aHeader	"I return a PRNumberingConfiguration corresponding for a Header."	^ self printer perform: ('level' , aHeader level asString) asSymbol! !!ChrysalPillarishConfiguration methodsFor: 'post hooks'!postTreat	(self propertyAt: #levels ifAbsent: [^ self ]) do: [ 			:levelSpec |			| instance |			instance := (self printer printerSpecFor: levelSpec renderAs).			instance fillFromAnother: levelSpec. 			self printer level: instance n: levelSpec level. 			 ]! !!ChrysalPillarishConfiguration methodsFor: 'accessing'!printer	^ printer! !!ConfigurationForPillar class methodsFor: 'description'!chrysalDescriptions	"I'm a generated method. I'm just here to help remembering how the class was generated. I should only be executed in presence of the configurationBuilder contained in the Chrysal package. Indeed the item objects only exist at compile-time and STON will recreate them."	 ^ STON fromString: '[	PathConfigurationItem {		#propertyName : #bibFile,		#default : ''book.bib'',		#explanation : ''Identify the file to be taken as input for the bibliography. This is the .bib file used to resolve the ${cite:ref=Key}$ annotation.''	},	StringConfigurationItem {		#propertyName : #title,		#default : ''my super cool book''	},	StringConfigurationItem {		#propertyName : #attribution,		#default : ''me, myself and I''	},	NumberConfigurationItem {		#propertyName : #headingLevelOffset,		#default : 0,		#explanation : ''Indicate how to convert from the level of a Pillar heading to the level of heading in your exported document.\r\tFor example, a headingLevelOffset of 3 converts a 1st level Pillar heading to an <h4>in HTML''	},	StringConfigurationItem {		#propertyName : #series,		#default : ''Square Bracket Associate Collection''	},	StringConfigurationItem {		#propertyName : #keywords,		#default : ''Pharo''	},	PathConfigurationItem {		#propertyName : #outputDirectory,		#default : ''build''	},	FolderConfigurationItem {		#propertyName : #baseDirectory,		#default : ''.''	},	FileConfigurationItem {		#propertyName : #outputFile,		#default : ''output'',		#explanation : ''If separateOutputFiles is false, indicate the name of the output file. This can also be a write stream.''	},	FileConfigurationItem {		#propertyName : #mainDocument,		#default : ''book''	},	FileConfigurationItem {		#propertyName : #inputFile,		#default : ''book'',		#explanation : ''The Pillar file that must be transformed. You can also specify an input file at the end of the command-line interface. Previously there was no default value''	},	StringConfigurationItem {		#propertyName : #latexTemplate,		#default : ''_support/templates/main.latex.mustache''	},	BooleanConfigurationItem {		#propertyName : #scrambledEmailAddresses,		#default : ''false''	},	BooleanConfigurationItem {		#propertyName : #separateOutputFiles,		#default : ''false'',		#explanation : ''If true, each input file is exported to one output file. If false (the default), all input files are exported to outputFile.''	},	BooleanConfigurationItem {		#propertyName : #renderStructureAsSlide,		#default : ''true'',		#explanation : ''When true (the default), Pillar will create a dedicated slide for each Pillar header. This parameter is meaningless when generating a written document''	},	StringConfigurationItem {		#propertyName : #latexChapterTemplate,		#default : ''_support/templates/chapter.latex.mustache''	},	StringConfigurationItem {		#propertyName : #htmlTemplate,		#default : ''_support/templates/html.mustache''	},	StringConfigurationItem {		#propertyName : #htmlChapterTemplate,		#default : ''_support/templates/html.mustache''	},	NewLineConfigurationItem {		#propertyName : #newLine,		#default : #platform,		#explanation : ''The string that separates lines in the exported document. This is often either LF or CR\\+LF but any string is possible. Values are #(#cr #lf #crlf #unix #mac #dos #platform)'',		#defaultKey : #platform	},	StringConfigurationItem {		#propertyName : #latexWriter,		#default : #''latex:sbabook''	},	StringConfigurationItem {		#propertyName : #htmlWriter,		#default : #html	},	NumberConfigurationItem {		#propertyName : #slideInTemplateForDeckJS,		#default : 1,		#explanation : ''Number of slides in Template: Indicate the number of slides created by the DeckJS template. This is important to create anchors.''	},	CodeBlockDefaultLanguageItem {		#propertyName : #defaultScriptLanguage,		#explanation : ''Indicate the language in scripts when none is specified. This language is used for syntax highlighting. The currently supported languages are bash, css, html, http, json, javascript, pillar, sql, ston, shellcommands and smalltalk''	},	CompositeConfigurationItem {		#propertyName : #levelSpecification,		#default : #PRTitlePrinterSpecification,		#fields : [			#level,			#renderAs,			#capitalization,			#numbering,			#headerSize		]	},	ListConfigurationItem {		#propertyName : #levels,		#default : #OrderedCollection,		#element : #levelSpecification	},	PathConfigurationItem {		#propertyName : #tocFile,		#default : ''.'',		#explanation : ''Identify the file to be taken as input for the root of the table of contents. When it is not specified, the table of contents will not be computed and displayed''	}]'! !!ConfigurationForPillar methodsFor: 'accessing'!attribution	"generated code"	^ self propertyAt: #attribution ifAbsent: ['me, myself and I']! !!ConfigurationForPillar methodsFor: 'accessing'!attribution: aValue	"generated code"	^ self propertyAt: #attribution put: aValue! !!ConfigurationForPillar methodsFor: 'accessing'!baseDirectory	"generated code"	^ self propertyAt: #baseDirectory ifAbsent: [(FileSystem workingDirectory / '.')]! !!ConfigurationForPillar methodsFor: 'accessing'!baseDirectory: aValue	"generated code"	^ self propertyAt: #baseDirectory put: aValue! !!ConfigurationForPillar methodsFor: 'accessing'!bibFile	"generated code"	^ self propertyAt: #bibFile ifAbsent: [Path from: 'book.bib']! !!ConfigurationForPillar methodsFor: 'accessing'!bibFile: aValue	"generated code"	^ self propertyAt: #bibFile put: aValue! !!ConfigurationForPillar methodsFor: 'conversion'!convertAttribution: aValue	"generated code"	^ aValue! !!ConfigurationForPillar methodsFor: 'conversion'!convertBaseDirectory: aValue	"generated code"	^ (FileSystem workingDirectory / aValue)! !!ConfigurationForPillar methodsFor: 'conversion'!convertBibFile: aValue	"generated code"	^ Path from: aValue! !!ConfigurationForPillar methodsFor: 'conversion'!convertDefaultScriptLanguage: aValue	"generated code"	^ PRAbstractScriptLanguage for: aValue! !!ConfigurationForPillar methodsFor: 'conversion'!convertHeadingLevelOffset: aValue	"generated code"	^ aValue! !!ConfigurationForPillar methodsFor: 'conversion'!convertHtmlChapterTemplate: aValue	"generated code"	^ aValue! !!ConfigurationForPillar methodsFor: 'conversion'!convertHtmlTemplate: aValue	"generated code"	^ aValue! !!ConfigurationForPillar methodsFor: 'conversion'!convertHtmlWriter: aValue	"generated code"	^ aValue! !!ConfigurationForPillar methodsFor: 'conversion'!convertInputFile: aValue	"generated code"	^ (FileSystem workingDirectory / aValue)! !!ConfigurationForPillar methodsFor: 'conversion'!convertKeywords: aValue	"generated code"	^ aValue! !!ConfigurationForPillar methodsFor: 'conversion'!convertLatexChapterTemplate: aValue	"generated code"	^ aValue! !!ConfigurationForPillar methodsFor: 'conversion'!convertLatexTemplate: aValue	"generated code"	^ aValue! !!ConfigurationForPillar methodsFor: 'conversion'!convertLatexWriter: aValue	"generated code"	^ aValue! !!ConfigurationForPillar methodsFor: 'conversion'!convertLevelSpecification: aValue	"generated code"	| composite |	composite := PRTitlePrinterSpecification new.	aValue		do: [ :v | 			"We ignore undeclared fields"			(#(#level #renderAs #capitalization #numbering #headerSize) includes: v key asSymbol)				ifTrue: [ | value |					"if the element has been described we convert"					value := (self declaredItems includes: v key asSymbol)						ifTrue: [ self perform: (#convert , v key capitalized , ':') asSymbol with: v value ]						ifFalse: [ v value ].					composite perform: (v key , ':') asSymbol with: value ] ].	^ composite! !!ConfigurationForPillar methodsFor: 'conversion'!convertLevels: aValue	"generated code"	| elements |	elements := OrderedCollection new.	aValue do: [:v | 		 elements add: (self convertLevelSpecification: v ) ].	^ elements! !!ConfigurationForPillar methodsFor: 'conversion'!convertMainDocument: aValue	"generated code"	^ (FileSystem workingDirectory / aValue)! !!ConfigurationForPillar methodsFor: 'conversion'!convertNewLine: aValue	"generated code"	^ (Dictionary			newFrom:				{(#cr -> String cr).				(#lf -> UnixPlatform new lineEnding).				(#crlf -> Win32Platform new lineEnding).				(#unix -> UnixPlatform new lineEnding).				(#mac -> UnixPlatform new lineEnding).				(#dos -> Win32Platform new lineEnding)}) at: aValue! !!ConfigurationForPillar methodsFor: 'conversion'!convertOutputDirectory: aValue	"generated code"	^ Path from: aValue! !!ConfigurationForPillar methodsFor: 'conversion'!convertOutputFile: aValue	"generated code"	^ (FileSystem workingDirectory / aValue)! !!ConfigurationForPillar methodsFor: 'conversion'!convertRenderStructureAsSlide: aValue	"generated code"	^ aValue ! !!ConfigurationForPillar methodsFor: 'conversion'!convertScrambledEmailAddresses: aValue	"generated code"	^ aValue ! !!ConfigurationForPillar methodsFor: 'conversion'!convertSeparateOutputFiles: aValue	"generated code"	^ aValue ! !!ConfigurationForPillar methodsFor: 'conversion'!convertSeries: aValue	"generated code"	^ aValue! !!ConfigurationForPillar methodsFor: 'conversion'!convertSlideInTemplateForDeckJS: aValue	"generated code"	^ aValue! !!ConfigurationForPillar methodsFor: 'conversion'!convertTitle: aValue	"generated code"	^ aValue! !!ConfigurationForPillar methodsFor: 'conversion'!convertTocFile: aValue	"generated code"	^ Path from: aValue! !!ConfigurationForPillar methodsFor: 'declared items'!declaredItems	"generated code"	^ #( #bibFile #title #attribution #headingLevelOffset #series #keywords #outputDirectory #baseDirectory #outputFile #mainDocument #inputFile #latexTemplate #scrambledEmailAddresses #separateOutputFiles #renderStructureAsSlide #latexChapterTemplate #htmlTemplate #htmlChapterTemplate #newLine #latexWriter #htmlWriter #slideInTemplateForDeckJS #defaultScriptLanguage #levelSpecification #levels #tocFile )! !!ConfigurationForPillar methodsFor: 'as yet unclassified'!defaultExport	^ self propertyAt: #defaultExport ifAbsent: [ '' ].! !!ConfigurationForPillar methodsFor: 'accessing'!defaultScriptLanguage	"generated code"	^ self propertyAt: #defaultScriptLanguage ifAbsent: [(PRRealScriptLanguage for: nil)]! !!ConfigurationForPillar methodsFor: 'accessing'!defaultScriptLanguage: aValue	"generated code"	^ self propertyAt: #defaultScriptLanguage put: aValue! !!ConfigurationForPillar methodsFor: 'accessing'!headingLevelOffset	"generated code"	^ self propertyAt: #headingLevelOffset ifAbsent: [0]! !!ConfigurationForPillar methodsFor: 'accessing'!headingLevelOffset: aValue	"generated code"	^ self propertyAt: #headingLevelOffset put: aValue! !!ConfigurationForPillar methodsFor: 'accessing'!htmlChapterTemplate	"generated code"	^ self propertyAt: #htmlChapterTemplate ifAbsent: ['_support/templates/html.mustache']! !!ConfigurationForPillar methodsFor: 'accessing'!htmlChapterTemplate: aValue	"generated code"	^ self propertyAt: #htmlChapterTemplate put: aValue! !!ConfigurationForPillar methodsFor: 'accessing'!htmlTemplate	"generated code"	^ self propertyAt: #htmlTemplate ifAbsent: ['_support/templates/html.mustache']! !!ConfigurationForPillar methodsFor: 'accessing'!htmlTemplate: aValue	"generated code"	^ self propertyAt: #htmlTemplate put: aValue! !!ConfigurationForPillar methodsFor: 'accessing'!htmlWriter	"generated code"	^ self propertyAt: #htmlWriter ifAbsent: ['html']! !!ConfigurationForPillar methodsFor: 'accessing'!htmlWriter: aValue	"generated code"	^ self propertyAt: #htmlWriter put: aValue! !!ConfigurationForPillar methodsFor: 'accessing'!inputFile	"generated code"	^ self propertyAt: #inputFile ifAbsent: [(FileSystem workingDirectory / 'book')]! !!ConfigurationForPillar methodsFor: 'accessing'!inputFile: aValue	"generated code"	^ self propertyAt: #inputFile put: aValue! !!ConfigurationForPillar methodsFor: 'accessing'!keywords	"generated code"	^ self propertyAt: #keywords ifAbsent: ['Pharo']! !!ConfigurationForPillar methodsFor: 'accessing'!keywords: aValue	"generated code"	^ self propertyAt: #keywords put: aValue! !!ConfigurationForPillar methodsFor: 'accessing'!latexChapterTemplate	"generated code"	^ self propertyAt: #latexChapterTemplate ifAbsent: ['_support/templates/chapter.latex.mustache']! !!ConfigurationForPillar methodsFor: 'accessing'!latexChapterTemplate: aValue	"generated code"	^ self propertyAt: #latexChapterTemplate put: aValue! !!ConfigurationForPillar methodsFor: 'accessing'!latexTemplate	"generated code"	^ self propertyAt: #latexTemplate ifAbsent: ['_support/templates/main.latex.mustache']! !!ConfigurationForPillar methodsFor: 'accessing'!latexTemplate: aValue	"generated code"	^ self propertyAt: #latexTemplate put: aValue! !!ConfigurationForPillar methodsFor: 'accessing'!latexWriter	"generated code"	^ self propertyAt: #latexWriter ifAbsent: ['latex:sbabook']! !!ConfigurationForPillar methodsFor: 'accessing'!latexWriter: aValue	"generated code"	^ self propertyAt: #latexWriter put: aValue! !!ConfigurationForPillar methodsFor: 'accessing'!levelSpecification	"generated code"	^ self propertyAt: #levelSpecification ifAbsent: [ PRTitlePrinterSpecification new ]! !!ConfigurationForPillar methodsFor: 'accessing'!levelSpecification: aValue	"generated code"	^ self propertyAt: #levelSpecification put: aValue! !!ConfigurationForPillar methodsFor: 'accessing'!levels	"generated code"	^ self propertyAt: #levels ifAbsent: [ OrderedCollection new ]! !!ConfigurationForPillar methodsFor: 'accessing'!levels: aValue	"generated code"	^ self propertyAt: #levels put: aValue! !!ConfigurationForPillar methodsFor: 'accessing'!mainDocument	"generated code"	^ self propertyAt: #mainDocument ifAbsent: [(FileSystem workingDirectory / 'book')]! !!ConfigurationForPillar methodsFor: 'accessing'!mainDocument: aValue	"generated code"	^ self propertyAt: #mainDocument put: aValue! !!ConfigurationForPillar methodsFor: 'accessing'!newLine	"generated code"	^ self propertyAt: #newLine ifAbsent: [Smalltalk os lineEnding]! !!ConfigurationForPillar methodsFor: 'accessing'!newLine: aValue	"generated code"	^ self propertyAt: #newLine put: aValue! !!ConfigurationForPillar methodsFor: 'accessing'!outputDirectory	"generated code"	^ self propertyAt: #outputDirectory ifAbsent: [Path from: 'build']! !!ConfigurationForPillar methodsFor: 'accessing'!outputDirectory: aValue	"generated code"	^ self propertyAt: #outputDirectory put: aValue! !!ConfigurationForPillar methodsFor: 'accessing'!outputFile	"generated code"	^ self propertyAt: #outputFile ifAbsent: [(FileSystem workingDirectory / 'output')]! !!ConfigurationForPillar methodsFor: 'accessing'!outputFile: aValue	"generated code"	^ self propertyAt: #outputFile put: aValue! !!ConfigurationForPillar methodsFor: 'accessing'!renderStructureAsSlide	"generated code"	^ self propertyAt: #renderStructureAsSlide ifAbsent: [true]! !!ConfigurationForPillar methodsFor: 'accessing'!renderStructureAsSlide: aValue	"generated code"	^ self propertyAt: #renderStructureAsSlide put: aValue! !!ConfigurationForPillar methodsFor: 'accessing'!scrambledEmailAddresses	"generated code"	^ self propertyAt: #scrambledEmailAddresses ifAbsent: [false]! !!ConfigurationForPillar methodsFor: 'accessing'!scrambledEmailAddresses: aValue	"generated code"	^ self propertyAt: #scrambledEmailAddresses put: aValue! !!ConfigurationForPillar methodsFor: 'accessing'!separateOutputFiles	"generated code"	^ self propertyAt: #separateOutputFiles ifAbsent: [false]! !!ConfigurationForPillar methodsFor: 'accessing'!separateOutputFiles: aValue	"generated code"	^ self propertyAt: #separateOutputFiles put: aValue! !!ConfigurationForPillar methodsFor: 'accessing'!series	"generated code"	^ self propertyAt: #series ifAbsent: ['Square Bracket Associate Collection']! !!ConfigurationForPillar methodsFor: 'accessing'!series: aValue	"generated code"	^ self propertyAt: #series put: aValue! !!ConfigurationForPillar methodsFor: 'accessing'!slideInTemplateForDeckJS	"generated code"	^ self propertyAt: #slideInTemplateForDeckJS ifAbsent: [1]! !!ConfigurationForPillar methodsFor: 'accessing'!slideInTemplateForDeckJS: aValue	"generated code"	^ self propertyAt: #slideInTemplateForDeckJS put: aValue! !!ConfigurationForPillar methodsFor: 'accessing'!title	"generated code"	^ self propertyAt: #title ifAbsent: ['my super cool book']! !!ConfigurationForPillar methodsFor: 'accessing'!title: aValue	"generated code"	^ self propertyAt: #title put: aValue! !!ConfigurationForPillar methodsFor: 'accessing'!tocFile	"generated code"	^ self propertyAt: #tocFile ifAbsent: [Path from: '.']! !!ConfigurationForPillar methodsFor: 'accessing'!tocFile: aValue	"generated code"	^ self propertyAt: #tocFile put: aValue! !"Pillar-Chrysal"!!PRCommandLineHandler commentStamp: '' prior: 0!Pillar is a system to produce documents (latex, html, markdown....) from a wiki like syntax named pillar. More information in https://github.com/pillar-markup/pillar.Usage: A typical example is 	pillar archetype book 		to install an archetype	pillar build pdf	pillar build html 		to build document in pdf or html	!!ClapPillarArchetypeCommand commentStamp: '' prior: 0!I am a command line handler to **create a pillar project in the current directory**.The pillar project contains a basic template and skeleton pillar files following the archetype convention.**Example of usage: **`./pillar archetype book`!!ClapPillarBuildCommand commentStamp: '' prior: 0!Clap Command to build files# Usage examplesTo build a book pdf: `./pharo-ui Pillar.image pillar build pdf`To use a template: `./pharo-ui Pillar.image pillar build --templatable html`To use a specific build strategy:- `pillar build -a pdf` >> build all Pillar documents found in directory- `pillar build -m pdf` >> default build, only index.pillar is build**NOTE:** there is no flag for "list" as buildList is called only if files are given as positionals after format# How to add a new export format?This method is based on existing writing targets and generate a CLAP command for each one.1. Create your target as a subclass of `PRWritingTarget` with the name: `PRxxxxxxOutput`2. Associate and create if needed, a PRDocument and a Writer!!ClapPillarCheckCommand commentStamp: '' prior: 0!I am a commandline to **check the code in all the codeblocks of a file, then I generate a report**.!!ClapPillarGenerateTestsCommand commentStamp: '' prior: 0!I am a commandline to **generate tests from examples in the codeblocks of some file(s)**.!!ClapPillarServeCommand commentStamp: '' prior: 0!I am a command line handler to **serve of the current project**.**Example of usage: **`./pillar serve -w`!!ClapPillarUpdateBuildCommand commentStamp: '' prior: 0!I am a commandline to **update archetypes in build repository**.Indeed, directory 'archetypes' used by CLAP isn't updated automatically by Git or Iceberg since it's located in another place.So use me when a file in 'archetype' changed to update it.!!ClapPillarUpdateTemplateCommand commentStamp: '' prior: 0!I am a command line handler to **update the template of the current project**.I overwrite the current template in the support folder.I assume that the support folder is read only and the user did not modify it.**Example of usage:** `./pillar updateTemplate book`!!PRSubCommandLineHandler commentStamp: '' prior: 0!I am the abstract super class of all sub commands for Pillar (export, export-all etc).I collaborate with a builder to which I pass the information: 	- configuration file	- base directory	- input file	and kick its execution. Subclasses should set the configurationInstaller!!PRArchetypeCommandLineHandler commentStamp: '' prior: 0!I am a command line handler to create a pillar project in the current directory.The pillar project contains a basic template and skeleton pillar files following the archetype convention.Example of usage:./pillar archetype book!!PRBuildCommandLineHandler commentStamp: '' prior: 0!here is a typical example of the use of this command lineTo build a book pdf./pharo-ui Pillar.image pillar build pdfTo use a template./pharo-ui Pillar.image pillar build --templatable htmlTo use a specific build strategy:pillar build -a pdf >> build all Pillar documents found in directorypillar build -m pdf >> default build, only index.pillar is buildNOTE: there is no flag for "list" as buildList is called only if files are given as positionals after format!!PRFileDependencyCommandLineHandler commentStamp: '' prior: 0!This pillar subcommand is about computing the dependent files of a given file. Usage: A typical example is 	./pharo-ui Pillar.image pillar fileDependencies  --configurationFile=pillar.conf Chapters/Chapter1/chapter1.pillar!!PRImageDependencyCommandLineHandler commentStamp: '' prior: 0!This pillar subcommand is about computing the dependent images of a given file. Usage: A typical example is 	./pharo-ui Pillar.image pillar imageDependencies  --configurationFile=pillar.conf Chapters/Chapter1/chapter1.pillar!!PRServeCommandLineHandler commentStamp: '' prior: 0!I am a command line handler to serve of the current project.Example of usage:./pillar serve -w!!PRUpdateTemplateCommandLineHandler commentStamp: '' prior: 0!I am a command line handler to update the template of the current project.I overwrite the current template in the support folder.I assume that the support folder is read only and the user did not modify it.Example of usage:./pillar updateTemplate book!!PRAbstractCommand commentStamp: '' prior: 0!I'm an object managing configuration. I'm usually invoked from a command line but not only.My main entry point is 	createConfiguration: confFilename baseDirectory: baseDirectory argDictionary: argumentsWhen you type on the command line		./pharo-ui Pillar.image pillar export --to="latex" Chapters/Chapter1/chapter1.pillar	You can obtain the same doing; 	PRExportBuilder new 			createConfiguration: 'pillar.conf' 		baseDirectory:  FileSystem workingDirectory   		argDictionary: {				'inputFile'-> (FileSystem workingDirectory / 'Chapters/Chapter1/chapter1.pillar') .				'defaultExporters' -> {'latex'}				} asDictionary;		export		!!PRArchetypeConfigurationInstallerCommand commentStamp: '' prior: 0!I'm responsible for handling and installing archetype related templates../pillar archetype --template=bookfor example. There should be a one to one mapping between the argument name and the github/pillar-language/pillar-archetypes folder.!!PRDependencyCommand commentStamp: '' prior: 0!Given information from the command line I manage dependency analysis.I can be invoked as follow ./pharo-ui Pillar.image fileDependencies  --configurationFile=pillar.conf Chapters/Chapter1/chapter1.pillarbut also from ur lovely system asPRDependencyScripter new	createConfiguration: 'pillar.conf' 	baseDirectory:  FileSystem workingDirectory   	argDictionary: {			'inputFile'-> (FileSystem workingDirectory / 'Chapters/Chapter1/chapter1.pillar') } asDictionary;	printDependencies!!PRWatcher commentStamp: '' prior: 0!A class to watch served sites.Each 5 seconds, the website is regenerated!!PRCommandLineHandler class methodsFor: 'accessing'!commandName	^ 'pillar'! !!PRCommandLineHandler class methodsFor: 'testing'!isResponsibleFor: aCommandLineArguments	^ aCommandLineArguments includesSubCommand: self commandName! !!PRCommandLineHandler methodsFor: 'private'!subCommandsRoot	^ PRSubCommandLineHandler! !!ClapPillarArchetypeCommand class methodsFor: 'accessing'!commandName	^'archetype'! !!ClapPillarArchetypeCommand class methodsFor: 'command line'!commandSpecification 	<commandline>	^ (ClapCommand id: self commandName asSymbol)		description: 'Create a pillar project in the current directory, which contains a basic template and skeleton pillar files following the archetype convention';		add: ClapFlag forHelp;		add: ((ClapPositional id: #requestedArchetype )			description: 'Archetype you want to use');		add: ((ClapFlag id: #templatable )			description: 'Use a template');					meaning:			[ :args |			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].			(self with: args) execute ]! !!ClapPillarArchetypeCommand methodsFor: 'execution'!execute	self project installArchetypeNamed: self requestedArchetype asString.! !!ClapPillarArchetypeCommand methodsFor: 'activation'!requestedArchetype	 ^ (arguments at: #requestedArchetype) value: self! !!ClapPillarBuildCommand class methodsFor: 'accessing'!commandName	^'build'! !!ClapPillarBuildCommand class methodsFor: 'command line'!commandSpecification	<commandline>		| defaultCommand  |	defaultCommand := self new project defaultTarget 		buildClapCommandWithId: #build 		withPositionals: false.	PRTarget clapCommandList do: [ :c | defaultCommand addSubcommand: c ].	^ defaultCommand! !!ClapPillarCheckCommand class methodsFor: 'accessing'!commandName	^ 'check'! !!ClapPillarCheckCommand class methodsFor: 'command line'!commandSpecification	<commandline>	| target |	target := PRCheckBookTarget new.	^ (ClapCommand id: self commandName asSymbol)		description: 'Check code in all the codeblocks in given file or book, then generate a report';		add: ClapFlag forHelp;		add: ((ClapPositional id: #requestedFiles )			description: 'Pillar document(s) you want to check';			implicitMeaning: [ '' ]);		meaning:			[ :args |			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].			(args at: #requestedFiles ) isExplicit 				ifTrue:[ 					target buildStrategy: (PRBuildListStrategy list: (args occurrencesOf: #requestedFiles collect: #value) )					]				ifFalse: [ 					target buildStrategy: (PRBuildAllStrategy new)					 ].			target buildOn: self new project.			]	! !!ClapPillarCommand class methodsFor: 'accessing'!commandName	self subclassResponsibility! !!ClapPillarCommand class methodsFor: 'command line'!commandSpecification	<commandline>		| command |		command := (ClapCommand id: #pillar)		description: 'Pillar is a markup syntax and associated tools to write and generate documents lie books in PDF, websites in html, or slides';		add: ClapFlag forHelp;		add: ((ClapFlag id: #version )			description: 'Prints the version of your Pharo VM');			yourself.		self pillarCommandsList do: [ :each | 		command addSubcommand: each		 ].	 ^ command meaning: [ :args | 		args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].		args at: #version ifPresent: [ 			| out |			out := args context stdout.			self printVersion: out ]		]! !!ClapPillarCommand class methodsFor: 'accessing'!pillarCommandsList	^ self allSubclasses		select: [ :each | each isAbstract not ]		thenCollect: [ :each | each commandSpecification ]! !!ClapPillarCommand class methodsFor: 'printing'!printVersion: stream	stream newLine.	stream newLine.	stream nextPutAll: 'INFORMATION ABOUT VERSION'.	stream newLine.	stream newLine.	stream nextPutAll: 'VM:    '; nextPutAll: Smalltalk vm version; cr.						 ! !!ClapPillarCommand methodsFor: 'accessing'!project	^ project ifNil: [ project := PRProject on: FileSystem workingDirectory  ]! !!ClapPillarGenerateTestsCommand class methodsFor: 'accessing'!commandName	^ 'generateTests'! !!ClapPillarGenerateTestsCommand class methodsFor: 'command line'!commandSpecification	<commandline>	| target |	target := PRCreateTestsTarget new.	^ (ClapCommand id: self commandName asSymbol)		description: 'Generate tests from examples in the codeblocks of Pillar file(s)';		add: ClapFlag forHelp;		add: ((ClapPositional id: #requestedFiles )			description: 'Pillar document(s) used to generate tests';			implicitMeaning: [ '' ]);		meaning:			[ :args |			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].			(args at: #requestedFiles ) isExplicit 				ifTrue:[ 					target buildStrategy: (PRBuildListStrategy list: (args occurrencesOf: #requestedFiles collect: #value) )					]				ifFalse: [ 					target buildStrategy: (PRBuildAllStrategy new)					 ].			target buildOn: self new project.			]! !!ClapPillarServeCommand class methodsFor: 'accessing'!commandName	^ 'serve'! !!ClapPillarServeCommand class methodsFor: 'command line'!commandSpecification	<commandline>	^ (ClapCommand id: self commandName asSymbol)		description: 'Serve of the current project';		add: ClapFlag forHelp;		add: ((ClapPositional id: #baseurl )			description: 'Your base URL, empty by default';			implicitMeaning: [ '' ]);		add: ((ClapPositional id: #port)			description: 'Your port, 8080 by default';			meaning: [ :m | m word asInteger ];			implicitMeaning: [ 8080 ]);				add: ((ClapFlag id: #watch )			canonicalName: 'w');		meaning:			[ :args |			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].			(self with: args) execute ]	! !!ClapPillarServeCommand methodsFor: 'activation'!baseurl	^ baseurl ifNil: [ baseurl := (arguments at: #baseurl) value]! !!ClapPillarServeCommand methodsFor: 'execution'!execute	self port.	self baseurl.		arguments context stdout		nextPutAll: 'Serving website at: http://localhost:';		nextPutAll: port asString;		nextPutAll: '/';		nextPutAll: baseurl;		lf.		(ZnServer defaultOn: port) start.	ZnServer default		delegate:			(ZnStaticFileServerDelegate new				prefixFromString: baseurl;				directory: self project baseDirectory / '_result/html/';				yourself).		^ self watch.! !!ClapPillarServeCommand methodsFor: 'activation'!port	^ port ifNil: [ port := (arguments at: #port) value]! !!ClapPillarServeCommand methodsFor: 'activation'!watch	(arguments at: #watch) isExplicit		ifFalse: [ ^ self ]		ifTrue: [ 			| watcher |			watcher := PRWatcher new.			watcher project: self project.			watcher start			 ]! !!ClapPillarUpdateBuildCommand class methodsFor: 'accessing'!commandName	^ 'updateBuild'! !!ClapPillarUpdateBuildCommand class methodsFor: 'command line'!commandSpecification	<commandline>	^ (ClapCommand id: self commandName asSymbol)		description: 'Update build/archetypes using folder in parent directory';		add: ClapFlag forHelp;		meaning:			[ :args |			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].			(self with: args) execute ]	! !!ClapPillarUpdateBuildCommand methodsFor: 'execution'!execute	self project updateBuild! !!ClapPillarUpdateTemplateCommand class methodsFor: 'accessing'!commandName	^ 'updateTemplate'! !!ClapPillarUpdateTemplateCommand class methodsFor: 'command line'!commandSpecification	<commandline>	^ (ClapCommand id: self commandName asSymbol)		description: 'Update a given template';		add: ClapFlag forHelp;		add: ((ClapPositional id: #requestedTemplate )			description: 'Template you want to update');				meaning:			[ :args |			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].			(self with: args) execute ]	! !!ClapPillarUpdateTemplateCommand methodsFor: 'execution'!execute	self project installTemplateNamed: self requestedTemplate! !!ClapPillarUpdateTemplateCommand methodsFor: 'activation'!requestedTemplate	 ^ (arguments at: #requestedTemplate) value: self! !!PRArchetypeCommandLineHandler class methodsFor: 'accessing'!commandName	^ 'archetype'! !!PRArchetypeCommandLineHandler methodsFor: 'activation'!activate	self project installArchetypeNamed: self requestedArchetype.	self exitSuccess! !!PRArchetypeCommandLineHandler methodsFor: 'activation'!requestedArchetype	| nonOptions |	self optionAt: 'template' ifPresent: [ :value | ^ value ].	"also managed ./pillar archetype book (to be backward compatible)"	nonOptions := self arguments reject: [ :a | a beginsWith: '-' ].	^ nonOptions size = 1		ifTrue: [ nonOptions last ]		ifFalse: [ self errorMissingParameter: 'template' ].! !!PRBuildCommandLineHandler class methodsFor: 'accessing'!commandName	^ 'build'! !!PRBuildCommandLineHandler methodsFor: 'activation'!activate		| target result |	target := PRTarget builderForName: self requestedBuilder.	self requestedFiles		ifEmpty: [ target onlyMainRootStrategy  ]		ifNotEmpty: [ :files | target explicitFilesStrategyOn: files ].	(self hasOption: 'templatable')		ifTrue: [ self project beTemplatable ].	(self hasOption: 'a')		ifTrue: [ target allFilesStrategy ].	(self hasOption: 'm')		ifTrue: [ target onlyMainRootStrategy ].	result := self project build: target.	result exitProcess! !!PRBuildCommandLineHandler methodsFor: 'activation'!requestedBuilder	| nonOptions |	"also managed ./pillar build book (to be backward compatible)"	nonOptions := self arguments reject: [ :a | a beginsWith: '-' ].	^ nonOptions		ifNotEmpty: [ nonOptions first ]		ifEmpty: [ self errorMissingParameter: 'template' ].! !!PRBuildCommandLineHandler methodsFor: 'activation'!requestedFiles	| nonOptions |	nonOptions := self arguments reject: [ :a | a beginsWith: '-' ].	^ nonOptions allButFirst! !!PREvalCommandLineHandler class methodsFor: 'accessing'!commandName	^ 'eval'! !!PREvalCommandLineHandler methodsFor: 'activation'!activate	| nonOptions |	nonOptions := self arguments reject: [ :a | a beginsWith: '-' ].	nonOptions do: [ :each | OpalCompiler evaluate: each ].! !!PRFileDependencyCommandLineHandler class methodsFor: 'accessing'!commandName	^ 'fileDependencies'! !!PRFileDependencyCommandLineHandler methodsFor: 'activation'!activate		self command doIt! !!PRFileDependencyCommandLineHandler methodsFor: 'activation'!newCommand		^ PRDependencyCommand new forFiles! !!PRImageDependencyCommandLineHandler class methodsFor: 'accessing'!commandName	^ 'imageDependencies'! !!PRImageDependencyCommandLineHandler methodsFor: 'activation'!activate		self command doIt! !!PRImageDependencyCommandLineHandler methodsFor: 'activation'!newCommand		^ PRDependencyCommand new forImages! !!PRServeCommandLineHandler class methodsFor: 'accessing'!commandName	^ 'serve'! !!PRServeCommandLineHandler methodsFor: 'activation'!activate	| baseurl watch port watcher |	baseurl := self optionAt: 'baseurl' ifAbsent: [ '' ].	watch := self hasOption: #w.	port := self		optionAt: 'p'		ifPresent: [ :portString | portString asInteger ]		ifAbsent: [ 8080 ].	self stdout		nextPutAll: 'Serving website at: http://localhost:';		nextPutAll: port asString;		nextPutAll: '/';		nextPutAll: baseurl;		lf.	(ZnServer defaultOn: port) start.	ZnServer default		delegate:			(ZnStaticFileServerDelegate new				prefixFromString: baseurl;				directory: self project baseDirectory / '_result/html/';				yourself).	watch		ifFalse: [ ^ self ].	watcher := PRWatcher new.	watcher project: self project.	watcher start! !!PRSubCommandLineHandler class methodsFor: 'accessing'!argumentsOutOfConfiguration	"such keys should get ignored after being treated by the command line"	^ #('configurationFile' 'to')! !!PRSubCommandLineHandler class methodsFor: 'accessing'!defaultConfigurationFileName	^ 'pillar.conf'! !!PRSubCommandLineHandler class methodsFor: 'testing'!isAbstract	^ self == PRSubCommandLineHandler! !!PRSubCommandLineHandler methodsFor: 'private'!add: argument to: arguments	"From the argument string '--key=value', add the key/value pair to the arguments dictionary."		^ arguments add: (self parseKeyValueArgument: argument)! !!PRSubCommandLineHandler methodsFor: 'accessing'!command	| command |	command := self newCommand.	command configurationFileName: self configurationFileName.	command workingDirectory: self workingDirectory.	command extraArguments: self extraArguments.	^ command! !!PRSubCommandLineHandler methodsFor: 'accessing'!configurationFileName	^ self		optionAt: 'configurationFile'		ifAbsent: [ self class defaultConfigurationFileName ]! !!PRSubCommandLineHandler methodsFor: 'error handling'!error: aString	self stderr << aString; lf.	self exitFailure! !!PRSubCommandLineHandler methodsFor: 'error handling'!errorMissingParameter: aParameterName	self error: 'Missing required parameter --', aParameterName ! !!PRSubCommandLineHandler methodsFor: 'accessing'!extraArguments	"We parse the options --key=value into associations"	| pairs argumentsDictionary |	pairs := self arguments		select: [ :commandLineArgPair | commandLineArgPair beginsWith: '--' ]		thenCollect: [ :commandLineArgPair | 			self parseKeyValueArgument: commandLineArgPair ].		"We filter out some arguments"	argumentsDictionary := (pairs reject: [ :p | self class argumentsOutOfConfiguration includes: p key ]) asDictionary.	^ argumentsDictionary! !!PRSubCommandLineHandler methodsFor: 'private'!parseKeyValueArgument: argument	| key value argumentStream |	argumentStream := argument readStream.	(argumentStream next: '--' size) ~= '--'		ifTrue: [ Error signal: 'Invalid parameter ', argument ].	key := argumentStream upTo: $=.	value := argumentStream upToEnd.	^ key -> value! !!PRSubCommandLineHandler methodsFor: 'accessing'!project	^ project ifNil: [ project := PRProject on: self workingDirectory ]! !!PRSubCommandLineHandler methodsFor: 'accessing'!workingDirectory	^ self		optionAt: 'baseDirectory'		ifPresent: [ :dir | ^ dir asFileReference ]		ifAbsent: [ self error: 'Should specify #baseDirectory option through command line' ]! !!PRUpdateTemplateCommandLineHandler class methodsFor: 'accessing'!commandName	^ 'updateTemplate'! !!PRUpdateTemplateCommandLineHandler methodsFor: 'activation'!activate	self project installTemplateNamed: self requestedTemplate.	self exitSuccess! !!PRUpdateTemplateCommandLineHandler methodsFor: 'activation'!requestedTemplate	| nonOptions |	self optionAt: 'template' ifPresent: [ :value | ^ value ].	"also managed ./pillar updateTemplate book (to be backward compatible)"	nonOptions := self arguments reject: [ :a | a beginsWith: '-' ].	^ nonOptions size = 1		ifTrue: [ nonOptions last ]		ifFalse: [ self errorMissingParameter: 'template' ].! !!PRAbstractCommand methodsFor: 'accessing'!buildConfiguration	| confFileReference |	confFileReference := workingDirectory / configurationFileName.		confFileReference exists ifFalse: [		self error: 'ConfigurationFile ', configurationFileName, ' does not exist in path ', workingDirectory fullName.	].		"We set the base diretory as an extended property and not afterwards.	Otherwise the file is loaded before and all properties are resolved EAGERLY with the default base directory: the working directory.	This is wrong particularly for Pharo <=6 where the working directory is not correctly set."	^ ConfigurationForPillar 			newFromFile: confFileReference			extendedWith: (extraArguments copyWith: ('baseDirectory' -> workingDirectory))! !!PRAbstractCommand methodsFor: 'accessing'!configuration	^ configuration ifNil: [ 		self configuration: self buildConfiguration.		configuration ]! !!PRAbstractCommand methodsFor: 'accessing'!configuration: aConfiguration	configuration := aConfiguration! !!PRAbstractCommand methodsFor: 'accessing'!configurationFileName: aFileName	configurationFileName := aFileName! !!PRAbstractCommand methodsFor: 'api'!createConfiguration: confFilename baseDirectory: baseDirectoryArg argDictionary: arguments	| confFile |	baseDirectory := baseDirectoryArg.	confFile := baseDirectory resolve: confFilename.	configuration := confFile exists		ifTrue: [ [ 				"We set the base diretory as an extended property and not afterwards.				Otherwise the file is loaded before and all properties are resolved EAGERLY with the default base directory: the working directory.				This is wrong particularly for Pharo <=6 where the working directory is not correctly set."				ConfigurationForPillar 							newFromFile: confFile 							extendedWith: (arguments								copyWith: ('baseDirectory' -> baseDirectoryArg))]						on: STONReaderError						do: [ :error | Exit signalFailure: error messageText ]  ]		ifFalse: [ ConfigurationForPillar newFromDictionary: arguments ]! !!PRAbstractCommand methodsFor: 'api'!doIt	"by default does nothing. Now the relation with createConfiguration:... is not clear. 	For example the PRArchetypeConfiguratioInstaller should probably not override the 	createConfiguration: but define a doIt method performing the download and action."! !!PRAbstractCommand methodsFor: 'accessing'!extraArguments: aDictionary	extraArguments := aDictionary! !!PRAbstractCommand methodsFor: 'accessing'!workingDirectory: aDirectory	workingDirectory := aDirectory! !!PRDependencyCommand methodsFor: 'api'!dependencies	| cache inputFile |	cache := Set new.	inputFile := baseDirectory resolve: self inputFile.	cache addAll: (self dependencyVisitor start: (PRDocument parser parse: inputFile contents)).	^ cache! !!PRDependencyCommand methodsFor: 'private'!dependencyVisitor	^ dependencyVisitor ! !!PRDependencyCommand methodsFor: 'api'!doIt	self printDependencies! !!PRDependencyCommand methodsFor: 'api'!forFiles	dependencyVisitor := PRFileDependencies new! !!PRDependencyCommand methodsFor: 'api'!forImages	dependencyVisitor := PRImageDependencies new! !!PRDependencyCommand methodsFor: 'private'!initialize	super initialize.	self forFiles.! !!PRDependencyCommand methodsFor: 'private'!inputFile	^ configuration propertyAt: 'inputFile'! !!PRDependencyCommand methodsFor: 'printing'!printDependencies	| path pathWithoutFile |	path := self inputFile pathString substrings: '/'.	pathWithoutFile := path allButLast		inject: ''		into: [ :substring :next | substring , next , '/' ].	Stdio stdout << 'Dependency analysis report: '.	self dependencies		do: [ :each | 			Stdio stdout				<< './';				<< pathWithoutFile;				<< each;				<< ' ' ].	Stdio stdout flush! !!PRWatcher class methodsFor: 'as yet unclassified'!stopAll	self allInstancesDo: #stop! !!PRWatcher methodsFor: 'as yet unclassified'!generateHtml	| target |	target := PRHtmlOutput new.	target allFilesStrategy.	"[" project 		beTemplatable; 		build: target "]		on: Error do: [ : error | self logError: error ]"! !!PRWatcher methodsFor: 'private'!logError: anError	Smalltalk logStdErrorDuring: [ :stderr|		"install the line end conversion and force initialize the converter"		stderr			nextPutAll: anError messageText; cr;			"reset the color"			nextPut: Character escape; nextPutAll: '[0m'.		anError signalerContext shortDebugStackOn: stderr.].! !!PRWatcher methodsFor: 'accessing'!project: anObject	project := anObject! !!PRWatcher methodsFor: 'accessing'!start	Stdio stdout nextPutAll: 'Watching: true'; lf.	"so that pharo does not quit"	[true] whileTrue: [ 		3 seconds wait.		self generateHtml ] ! !!PRWatcher methodsFor: 'accessing'!stop	process terminate! !"Pillar-Cli"!!PRDocumentListTransformer commentStamp: '' prior: 0!I am a tranformer in charge of transforming docList annotations. I just replace that annotation by  a document group containing an abstract of each file.How To !!!!??doc = PRDocument new.((PRDocListTransformer withContext: (PRProject on: testingFileSystem)) start: doc).!!PRHTMLWriter commentStamp: '' prior: 0!Writes a Pillar document as HTML.!!PRXHTMLWriter commentStamp: '' prior: 0!I write a document as XHTML for ePub!!PRHTMLCanvas commentStamp: '' prior: 0!An HTML canvas that facilitates writing HTML to a stream. The main method is #tag that allow you to write something like this:canvas tag        name: 'a';        parameterAt: 'href' put: href;        with: [ "some code that generates the HTML inside the link" ]!!PRHTMLBrush commentStamp: '' prior: 0!I'm an abstract brush dedicated to HTML documents. As of today, the only subclass is the tag brush but we can imagine others (e.g., to write HTML comments).!!PRHTMLEmptyTag commentStamp: '' prior: 0!I'm a helper class to generate HTML code. For example, to generate:     <img href="figure/test.png"/>you can write something like this:String streamContents: [ :stream | | canvas |	stream := PROutputStream on: stream.	canvas := PRHTMLCanvas on: stream.	canvas emptyTag 		name: 'img';		parameterAt: 'href' put: 'figure/test.png';		closeTag	 ]!!PRHTMLTag commentStamp: '' prior: 0!I'm a helper class to generate HTML code.!!!! Example For example, to generate: [[[    <p>foo <a href="url">bar</a></b>]]]You can write something like this:[[[String streamContents: [ :stream | | canvas |	stream := PROutputStream on: stream.	canvas := PRHTMLCanvas on: stream.	canvas tag 		name: 'p'; 		with: [ canvas nextPutAll: 'foo '.			    canvas tag 	     		      name: 'a';	    			parameterAt: 'href' put: 'url';	                  with: 'bar' ]	 ]]]]!!!! About with: argument Pay attention there is a difference between a block and a string as argument of the with: message.Using a string	simply puts the string as body of the tag.[[[	canvas tag 			name: 'xx';		with: 'foo'.]]]While when the argument is a block the block result is not used, just executed. [[[ 	canvas tag 			name: 'xx';		with: [ self foo ] ]]]!!PRDocumentListTransformer class methodsFor: 'instance-creation'!withContext: aContext	| inst |	inst := super withContext: aContext.	inst workingDirectory: aContext baseDirectory.	^ inst! !!PRDocumentListTransformer methodsFor: 'adding'!addAbstractOfCurrentFileToDocument: aDocument inAnnotation: aPRDocListAnnotation	| abstractOfCurrentFile |	abstractOfCurrentFile := PRPillarParserMain parse: self currentFile contents.	"arbitrary value for children"	abstractOfCurrentFile		setChildren: {(PRText content: (abstractOfCurrentFile text truncateWithElipsisTo: aPRDocListAnnotation summaryMaxSize))}.	^ self availableTemplates		ifNotEmpty: [ | previousContent |			previousContent := aDocument text.			aDocument				text: previousContent , (self generateFileUsingTemplateFromDocument: abstractOfCurrentFile) ]		ifEmpty: [ aDocument addAll: abstractOfCurrentFile children.			self addLinkToDocument: aDocument ]! !!PRDocumentListTransformer methodsFor: 'adding'!addLinkToDocument: aDocument	aDocument		add:			((PRInternalLink reference: self filesDirectory , '/' , self currentFile basename)				addAll: {(PRText content: 'Read more')};				yourself)! !!PRDocumentListTransformer methodsFor: 'accessing'!availableTemplates	^ availableTemplates! !!PRDocumentListTransformer methodsFor: 'transforming'!createDocList: aPRDocListAnnotation	| files document sortedFiles |	"Check if the specified path exist and get pillar files from it.	Get some abstract of these pillar files. The final document is a DocumentGroup, but when templates	are specified and exists It is a Raw HTML document"	document := PRDocumentGroup new.		availableTemplates := self lookForAvailableTemplates: aPRDocListAnnotation templates.	self availableTemplates ifNotEmpty: [ document := PRRaw new text: '' ].		filesDirectory := aPRDocListAnnotation path.	(workingDirectory resolve: self filesDirectory) exists		ifTrue: [ 			files := (workingDirectory resolve: aPRDocListAnnotation path) files select: [ :each | each extension = 'pillar' ].			sortedFiles := self sort: files limit: (aPRDocListAnnotation limit asInteger min: files size) by: aPRDocListAnnotation sort.						1 to: (aPRDocListAnnotation limit asInteger min: sortedFiles size) do: [ :index | 				currentFile := (sortedFiles at: index).								"Parse current file and add an abstract to the general document"				self addAbstractOfCurrentFileToDocument: document inAnnotation: aPRDocListAnnotation ] 		].	^ document! !!PRDocumentListTransformer methodsFor: 'adding'!currentDocumentInternalLink		^ PRInternalLink reference: self filesDirectory , '/' , self currentFile basename! !!PRDocumentListTransformer methodsFor: 'visiting'!currentFile	^ currentFile! !!PRDocumentListTransformer methodsFor: 'accessing'!filesDirectory	^ filesDirectory! !!PRDocumentListTransformer methodsFor: 'parsing'!generateFileUsingTemplateFromDocument: aDocument	| conf htmlDoc |	"Read configurations"	conf := ConfigurationForPillar newFromDictionary: aDocument properties.	conf parent: self configuration.	"Write the  document in HTML, It means that this template is only for HTML generation"	conf at: #content put: (PRHTMLWriter write: aDocument).	conf at: #link put: self currentDocumentInternalLink referenceAsHTML.		htmlDoc := (MustacheTemplate on: (self workingDirectory resolve: self availableTemplates first) contents) value: conf.	self availableTemplates add: availableTemplates first.	self availableTemplates remove: availableTemplates first. 	^ htmlDoc! !!PRDocumentListTransformer methodsFor: 'accessing'!lookForAvailableTemplates: aCollection	^ (aCollection select: [ :each | (self workingDirectory resolve: each) exists and: [ each asFileReference extension = 'mustache' ] ]) asOrderedCollection! !!PRDocumentListTransformer methodsFor: 'sorting'!sort: aCollectionOfReferences limit: anInteger by: aString	| references |	references := aCollectionOfReferences first: anInteger.	aString = 'date'		ifTrue: [ ^ PRDocumentListDateSorter with: references ].	aString = 'name'		ifTrue: [ ^ PRDocumentListNameSorter with: references ].	^ references! !!PRDocumentListTransformer methodsFor: 'visiting'!visitDocListAnnotation: aPRDocListAnnotation	self replace: { (self createDocList: aPRDocListAnnotation) }! !!PRDocumentListTransformer methodsFor: 'accessing'!workingDirectory	^ workingDirectory! !!PRDocumentListTransformer methodsFor: 'accessing'!workingDirectory: aFileReference	workingDirectory := aFileReference! !!PRHTMLWriter class methodsFor: 'accessing'!fileExtension	^ 'html'! !!PRHTMLWriter class methodsFor: 'accessing'!folderName	^ #html! !!PRHTMLWriter class methodsFor: 'accessing'!writerName	^ #html! !!PRHTMLWriter methodsFor: 'private'!addAnchorFrom: anInternalLink To: href	"I am here for the deck.js exporter or other exporter that would need to change the way anchor are generated."	^ href , '#' , anInternalLink anchor! !!PRHTMLWriter methodsFor: 'accessing'!canvas		^ canvas! !!PRHTMLWriter methodsFor: 'accessing'!canvasClass	^ PRHTMLCanvas! !!PRHTMLWriter methodsFor: 'templating'!chapterTemplateName	^ 'htmlChapterTemplate'! !!PRHTMLWriter methodsFor: 'private'!createAnchorWith: anId	canvas tag		name: 'a';		parameterAt: 'id' put: anId;		with: ''! !!PRHTMLWriter methodsFor: 'private'!exportImgFor: aFigure	| img |	img := canvas emptyTag		name: 'img';		parameterAt: 'src' put: (aFigure localFileOrExternalReference);		yourself.	aFigure parameters		at: 'width'		ifPresent: [ :width | img parameterAt: 'width' put: width asString , '%' ].	aFigure hasLabel ifTrue:[		img			parameterAt: 'id'			put: aFigure label ].	img		parameterAt: 'alt'		put: (aFigure hasChildren ifTrue: [ aFigure text ] ifFalse: [ '' ]).	img closeTag! !!PRHTMLWriter methodsFor: 'private'!internalLinkWillBeRender: anInternalLink	(anInternalLink hasReference and: [ anInternalLink hasAnchor not ])		ifTrue: [ 			PRLinkWarning				signal:					'Your inter-file link will not be rendered because you export without separate output files. If you want your link to be rendered add an anchor to the beginning of your file.' ]! !!PRHTMLWriter methodsFor: 'private'!noteAtEnd	self noteDictionary		ifNotEmpty: [ canvas newLine.			canvas tag				name: 'hr';				with: ''.			canvas newLine ].	self noteDictionary		keysAndValuesDo: [ :keys :value | 			canvas tag				name: 'sup';				parameterAt: 'id' put: 'footnote' , keys asString;				with: '[' , keys asString , '] ' , value.			canvas emptyTag				name: 'br';				closeTag.			canvas newLine ]! !!PRHTMLWriter methodsFor: 'accessing'!noteDictionary	^ noteDictionary! !!PRHTMLWriter methodsFor: 'visiting'!start: anObject	canvas := self canvasClass on: stream.	footnoteID := 0.	noteDictionary := Dictionary new.	super start: anObject.	self noteAtEnd.	canvas flush! !!PRHTMLWriter methodsFor: 'visiting-document'!visitAnchor: anAnchor	self createAnchorWith: anAnchor name! !!PRHTMLWriter methodsFor: 'visiting-document'!visitAnnotatedParagraph: anAnnotatedParagraph	"Annotations need to be defined as CSS styles. For example...		@@note 		@@dothis	could have...	 	<head><style>		p.note{colour:green}		p.dothis{colour:red}		</style></head> 	"	canvas tag		name: 'p';		parameterAt: 'class' put: anAnnotatedParagraph annotation;		with: [ 					"We call #visitParagraph: directly because we don't want 'self visitParagraph:' to be executed."					super visitParagraph: anAnnotatedParagraph ]! !!PRHTMLWriter methodsFor: 'visiting-document'!visitBoldFormat: aFormat	canvas tag		name: 'strong';		with: [ super visitBoldFormat: aFormat ]! !!PRHTMLWriter methodsFor: 'visiting-document'!visitCodeblock: aCodeBlock	canvas tag		name: 'figure';		with: [ 					canvas tag						name: 'pre';						with: [ 									| code language |									code := canvas tag										name: 'code';										yourself.									language := self languageForScript: aCodeBlock.									language isSyntaxHighlightingPossible										ifTrue: [ code parameterAt: 'class' put: language printString ].									code with: [ canvas lines: aCodeBlock text ] ].					canvas tag						name: 'figcaption';						with: [ 									aCodeBlock hasLabel										ifTrue: [ 											self createAnchorWith: aCodeBlock label.											self writeCounterForScript: aCodeBlock ].									aCodeBlock hasCaption										ifTrue: [ self visitAll: aCodeBlock caption children ] ] ].	canvas newLine! !!PRHTMLWriter methodsFor: 'visiting-document'!visitColumn: aColumn	canvas tag		name: 'div';		parameterAt: 'class' put: 'column';		parameterAt: 'style' put: 'float:left; margin:0; width:' , aColumn width asString , '%;';		with: [ super visitColumn: aColumn ].	canvas newLine! !!PRHTMLWriter methodsFor: 'visiting-document'!visitColumns: aColumns	canvas tag		name: 'div';		parameterAt: 'class' put: 'columns';		parameterAt: 'style' put: 'margin:0px auto; width:100%';		with: [ super visitColumns: aColumns ].	canvas newLine! !!PRHTMLWriter methodsFor: 'visiting-document'!visitDataItem: anItem	canvas tag		name: 'dd';		with: [ self visitAll: anItem children ].	canvas newLine! !!PRHTMLWriter methodsFor: 'visiting-document'!visitDefinitionList: aList	canvas tag		name: 'dl';		with: [ super visitDefinitionList: aList ].	canvas newLine! !!PRHTMLWriter methodsFor: 'visiting-document'!visitExternalLink: anExternalLink	canvas tag		name: 'a';		parameterAt: 'href' put: anExternalLink localFileOrExternalReference;		with: anExternalLink alias! !!PRHTMLWriter methodsFor: 'visiting-document'!visitFigure: aFigure	(aFigure hasLabel not and: [ aFigure hasCaption not ])		ifTrue: [ 			self exportImgFor: aFigure.			^ self ].	aFigure label ifNotNil: [ :label | self createAnchorWith: label ].	canvas newLine.	canvas tag		name: 'figure';		with:				[ 			canvas newLine.			canvas nextPut: Character tab.			self exportImgFor: aFigure.			canvas newLine.			canvas nextPut: Character tab.			canvas tag				name: 'figcaption';				with:						[ 					aFigure label ifNotNil: [ self writeCounterForFigure: aFigure ].					super visitFigure: aFigure ].			canvas newLine ]! !!PRHTMLWriter methodsFor: 'visiting-annotations'!visitFootnote: aFootnote	footnoteID := footnoteID + 1.	canvas tag		name: 'sup';		with: [ canvas tag				name: 'a';				parameterAt: 'href' put: '#footnote' , footnoteID asString;				with: '[' , footnoteID asString , ']' ].	noteDictionary at: footnoteID ifAbsentPut: aFootnote note! !!PRHTMLWriter methodsFor: 'visiting-document'!visitHeader: aHeader	| level |	"h1 to h7 exist."	level := aHeader level min: 7 max: 1.	canvas tag		name: 'h' , level asString;		with: [ 					self writeCounterForHeader: aHeader.					super visitHeader: aHeader ].	canvas newLine! !!PRHTMLWriter methodsFor: 'visiting-document'!visitHorizontalRule: anHorizontalRule	canvas newLine; newLine.	canvas raw: '<hr>'.	canvas newLine.! !!PRHTMLWriter methodsFor: 'visiting-document'!visitInternalLink: anInternalLink	| href |	href := String new.	anInternalLink hasReference		ifTrue: [ href := href , anInternalLink referenceAsHTML ].	anInternalLink hasAnchor		ifTrue: [ href := self addAnchorFrom: anInternalLink To: href ].	canvas tag		name: 'a';		parameterAt: 'href' put: href;		with: [ 					anInternalLink counter isValidCounter						ifTrue: [ 							self writeCounter: anInternalLink counter.							anInternalLink hasAlias								ifTrue: [ canvas nextPutAll: ' ' ] ].					super visitInternalLink: anInternalLink ]! !!PRHTMLWriter methodsFor: 'visiting-document'!visitItalicFormat: aFormat	canvas tag		name: 'em';		with: [ super visitItalicFormat: aFormat ]! !!PRHTMLWriter methodsFor: 'visiting-document'!visitListItem: anItem	canvas tag		name: 'li';		with: [ super visitListItem: anItem ].	canvas newLine! !!PRHTMLWriter methodsFor: 'visiting-document'!visitMailLink: aLink	canvas tag		name: 'a';		parameterAt: 'href' put: aLink unscrambledUrl;		with: aLink alias! !!PRHTMLWriter methodsFor: 'visiting-document'!visitMonospaceFormat: aFormat	canvas tag		name: 'code';		with: [ super visitBoldFormat: aFormat ]! !!PRHTMLWriter methodsFor: 'visiting-document'!visitOrderedList: aList	canvas tag		name: 'ol';		with: [ super visitOrderedList: aList ].	canvas newLine! !!PRHTMLWriter methodsFor: 'visiting-document'!visitParagraph: aParagraph	(aParagraph children size = 1 and: [ aParagraph children first isKindOf: PRRaw ])		ifTrue: [ 			self				flag:					'TODO: ugly fix. The idea is that you don''t want the <p> when using a Raw that potentially displays a <div>, because this is not HTML compliant'.			self visitRaw: aParagraph children first ]		ifFalse: [ 			canvas tag				name: 'p';				with: [ 							canvas newLine.							super visitParagraph: aParagraph.							canvas newLine ] ]! !!PRHTMLWriter methodsFor: 'visiting-document'!visitPreformatted: aPreformatted	canvas tag		name: 'pre';		with: [ aPreformatted children do: [ :child | self visit: child ] separatedBy: [ canvas newLine ] ]! !!PRHTMLWriter methodsFor: 'visiting-document'!visitSection: aSection	canvas tag		name: 'section';		with: [ 					canvas newLine.					super visitSection: aSection ]! !!PRHTMLWriter methodsFor: 'visiting-document'!visitStrikethroughFormat: aFormat	canvas tag		name: 's';		with: [ super visitStrikethroughFormat: aFormat ]! !!PRHTMLWriter methodsFor: 'visiting-document'!visitSubscriptFormat: aFormat	canvas tag		name: 'sub';		with: [ super visitSubscriptFormat: aFormat ]! !!PRHTMLWriter methodsFor: 'visiting-document'!visitSuperscriptFormat: aFormat	canvas tag		name: 'sup';		with: [ super visitSuperscriptFormat: aFormat ]! !!PRHTMLWriter methodsFor: 'visiting-document'!visitTable: aTable	canvas tag		name: 'table';		parameterAt: 'style' put: 'border: solid thin';		with: [ super visitTable: aTable ].	canvas newLine! !!PRHTMLWriter methodsFor: 'visiting-document'!visitTableCell: aCell	| tagName tag |	tagName := aCell isHeading		ifTrue: [ 'th' ]		ifFalse: [ 'td' ].	tag := canvas tag name: tagName.	aCell isAligned		ifTrue: [ 			aCell isAlignedLeft				ifTrue: [ tag parameterAt: 'style' put: 'text-align: left' ].			aCell isAlignedCenter				ifTrue: [ tag parameterAt: 'style' put: 'text-align: center' ].			aCell isAlignedRight				ifTrue: [ tag parameterAt: 'style' put: 'text-align: right' ] ].	tag with: [ super visitTableCell: aCell ].	canvas newLine! !!PRHTMLWriter methodsFor: 'visiting-document'!visitTableRow: aRow	canvas tag		name: 'tr';		with: [ super visitTableRow: aRow ].	canvas newLine! !!PRHTMLWriter methodsFor: 'visiting-document'!visitTermItem: anItem	canvas tag		name: 'dt';		with: [ self visitAll: anItem children ].	canvas newLine! !!PRHTMLWriter methodsFor: 'visiting-document'!visitUnderlineFormat: aFormat	canvas tag		name: 'u';		with: [ super visitUnderlineFormat: aFormat ]! !!PRHTMLWriter methodsFor: 'visiting-document'!visitUnorderedList: aList	canvas tag		name: 'ul';		with: [ 					canvas newLine.					super visitUnorderedList: aList ].	canvas newLine! !!PRHTMLWriter methodsFor: 'writing'!writeParagraphDuring: aBlockClosure 		canvas tag		name: 'p';		with: [ 			canvas newLine.			aBlockClosure value.			canvas newLine ]! !!PRHTMLWriter methodsFor: 'accessing'!writerFor: aPRPillarConfiguration 		^ (PRDocumentWriter allSubclasses detect: [ :each | 		each isAbstract not			and: [ each writerName = (aPRPillarConfiguration propertyAt: #htmlWriter) ] ])				new! !!PRXHTMLWriter class methodsFor: 'accessing'!fileExtension	^'xhtml'! !!PRXHTMLWriter class methodsFor: 'accessing'!folderName	^#xhtml! !!PRXHTMLWriter class methodsFor: 'accessing'!writerName	^#xhtml! !!PRXHTMLWriter methodsFor: 'visiting-document'!templateForConfiguration: aConfiguration		^ aConfiguration propertyAt: 'epubTemplate' ifAbsent: [ '_support/templates/epub/xhtml.mustache' ]! !!PRXHTMLWriter methodsFor: 'visiting-document'!visitCodeblock: aCodeBlock	canvas tag		name: 'div';		with: [ 					canvas tag						name: 'pre';						with: [ 									| code language |									code := canvas tag										name: 'code';										yourself.									language := self languageForScript: aCodeBlock.									language isSyntaxHighlightingPossible										ifTrue: [ code parameterAt: 'class' put: language printString ].									code with: [ canvas lines: aCodeBlock text ] ].					canvas tag						name: 'span';						with: [ 									aCodeBlock hasLabel										ifTrue: [ 											self createAnchorWith: aCodeBlock label.											self writeCounterForScript: aCodeBlock ].									aCodeBlock hasCaption										ifTrue: [ self visitAll: aCodeBlock caption children ] ] ].	canvas newLine! !!PRXHTMLWriter methodsFor: 'visiting-document'!visitFigure: aFigure	self exportImgFor: aFigure.! !!PRXHTMLWriter methodsFor: 'visiting-document'!visitHeader: aHeader	canvas tag		name: 'div';		parameterAt: 'id' put: aHeader text asValidSelector;		with: [ super visitHeader: aHeader ].	canvas newLine! !!PRXHTMLWriter methodsFor: 'visiting-document'!visitStrikethroughFormat: aFormat	canvas tag		name: 'span';		parameterAt: 'class' put: 'striked';		with: [ self visitFormat: aFormat ]! !!PRXHTMLWriter methodsFor: 'visiting-document'!visitUnderlineFormat: aFormat	canvas tag		name: 'span';		parameterAt: 'class' put: 'underline';		with: [ self visitFormat: aFormat ]! !!PRInternalLink methodsFor: '*Pillar-ExporterHTML'!referenceAsHTML	"I return a reference to a pillar file as an html file."	| ref |	ref := self reference.	((ref endsWith: '.pillar') or: [ ref endsWith: '.pier' ])		ifTrue: [ ref := (ref copyUpToLast: $.) , '.html' ]		ifFalse: [ PRLinkWarning signal: 'Reference : ' , ref , ' should end with .pillar or .pier' ].	^ ref! !!PRHTMLCanvas class methodsFor: 'class initialization'!initialize	HTMLCharacters := Dictionary new.	HTMLCharacters		at: $" put: '&quot;';		at: $& put: '&amp;';		at: $< put: '&lt;';		at: $> put: '&gt;'! !!PRHTMLCanvas methodsFor: 'tags'!emptyTag	^ self brush: PRHTMLEmptyTag new! !!PRHTMLCanvas methodsFor: 'writing text'!nextPut: aCharacter	(HTMLCharacters at: aCharacter ifAbsent: nil)		ifNil: [ super nextPut: aCharacter ]		ifNotNil: [ :string | self raw: string ]! !!PRHTMLCanvas methodsFor: 'tags'!tag	^ self brush: PRHTMLTag new! !!PRHTMLEmptyTag methodsFor: 'accessing'!closeTag	stream << '/>'! !!PRHTMLEmptyTag methodsFor: 'accessing'!name: aString	name := aString.	stream nextPut: $<; << aString! !!PRHTMLEmptyTag methodsFor: 'accessing'!parameterAt: aString put: anotherString	stream space. stream << aString << '="' << anotherString << '"'! !!PRHTMLTag methodsFor: 'accessing'!name: aString	name := aString.	stream nextPut: $<; << aString! !!PRHTMLTag methodsFor: 'accessing'!parameterAt: aString put: anotherString	stream space. stream << aString << '="' << anotherString << '"'! !!PRHTMLTag methodsFor: 'accessing'!with: aString	stream 		nextPut: $>; 		<< aString;		<< '</'; 		<< name;		nextPut: $>! !!PRHtmlDocument methodsFor: 'accessing'!basicWriter		^ (PRDocumentWriter allSubclasses detect: [ :each | 		each isAbstract not			and: [ each writerName = (project configuration propertyAt: #htmlWriter) ] ])				new! !!PRHtmlDocument methodsFor: 'accessing'!extension		^ 'html'! !!PRHtmlDocument methodsFor: 'building'!getMustacheTemplateValuesFromDocument: aDocument	"aDocument already has a dictionary holding potential metadata. 	We add the text contents to the dictionary.	This dictionary will be used by the mustache."		| template |	template := super getMustacheTemplateValuesFromDocument: aDocument.	template 		at: #toc 		put: (self tableOfContents asCTEnvironmentWithParent: template).	^ template! !!PRXHtmlDocument methodsFor: 'accessing'!basicWriter		^ PRXHTMLWriter new! !!PRXHtmlDocument methodsFor: 'accessing'!extension	^ 'xhtml'! !!PRHtmlOutput class methodsFor: 'accessing'!builderName		^ #html! !!PRHtmlOutput methodsFor: 'building'!documentFor: aFile	^ PRHtmlDocument new		project: aFile project;		file: aFile;		target: self;		outputDirectory: aFile project outputDirectory / self extension;		yourself! !!PRHtmlOutput methodsFor: 'accessing'!extension		^ 'html'! !!PRHtmlOutput methodsFor: 'accessing'!outputDirectoryName		^ 'html'! !!PRHtmlOutput methodsFor: 'accessing'!writerFor: aPRPillarConfiguration 		^ self writerFor: aPRPillarConfiguration forConfigurationTag: #htmlWriter! !"Pillar-ExporterHTML"!!PREPubDocument commentStamp: '' prior: 0!EPub document Version 3.1Specs: http://www.idpf.org/epub/31/spec/Helpful links: - validator: https://www.ebookit.com/tools/bp/Bo/eBookIt/epub-validator - validator: http://validator.idpf.org/application/validate - blog: http://www.hxa.name/articles/content/epub-guide_hxa7241_2007.html!!PREPubMenuWriter commentStamp: '' prior: 0!I am an abstract  writer for menus for ePub!!PREPubNavigationMenuWriter commentStamp: '' prior: 0!I write a document as a navigation menu for ePub!!PREPubTocMenuWriter commentStamp: '' prior: 0!I write a document as a ToC menu for ePub table of content.!!PREPubMenuJustHeaderTransformer commentStamp: '' prior: 0!I am a transformer which Just keep headers with the hierarchy. I am useful for EPub Menus.!!PREPubDocument methodsFor: 'writing'!epubContentsGenerationDirectory	^ (self outputDirectory resolve: (file file parent relativeTo: project baseDirectory asAbsolute)) / file file withoutExtension basename! !!PREPubDocument methodsFor: 'accessing'!extension		^ 'epub'! !!PREPubDocument methodsFor: 'accessing'!files	^ files! !!PREPubDocument methodsFor: 'accessing'!files: anObject	files := anObject! !!PREPubDocument methodsFor: 'writing'!navigationTemplateFile	^ project supportDirectory / 'templates' / 'nav.html.mustache'! !!PREPubDocument methodsFor: 'writing'!postWriteTransform: aFile	"Package the EPUB into a zip file.	The first element of the zip file should be a non compressed mimetype file"	| fileReference |	fileReference := self epubContentsGenerationDirectory, self extension.	fileReference ensureDelete.		SystemVersion current major <= 6 ifTrue: [ 		fileReference writeStreamDo: [ :stream | 			stream binary.			self writeZipFileOn: stream.			^ self ] ].	fileReference binaryWriteStreamDo: [ :stream | self writeZipFileOn: stream ]! !!PREPubDocument methodsFor: 'writing'!templateFile		| epubTemplatePath |	epubTemplatePath := project configuration propertyAt: 'epubTemplate' ifAbsent: [ '_support/templates/epub/xhtml.mustache' ].	^ project baseDirectory / epubTemplatePath! !!PREPubDocument methodsFor: 'writing'!templateFile: aDocument		| epubTemplatePath |	epubTemplatePath := project configuration propertyAt: 'epubTemplate' ifAbsent: [ '_support/templates/epub/xhtml.mustache' ].	^ project baseDirectory / (aDocument propertyAt: 'epubTemplate' ifAbsent: [ epubTemplatePath ])! !!PREPubDocument methodsFor: 'writing'!writeContentsFileForDocument: aDocument	self		writeDocument: aDocument		inFile: (self epubContentsGenerationDirectory / 'contents.xhtml')		withWriter: PRXHTMLWriter new! !!PREPubDocument methodsFor: 'writing'!writeDocument: aDocument	"A pillar generated epub document contains a navigation xhtml file and a contents xhtml file.	This is done like that because the only way so far of expression a table of contents (TOC) is by 	  - including files	  - then traversing their headings and sections		Then, If you want o generate a big epub file, create a pillar file including all the other pillar files"	self flag: #SD. "Why there is no call to super? How do we manage	mustache variables in ePub"	self writeNavigationFileForDocument: aDocument.	self writeContentsFileForDocument: aDocument.	self writePackageManifestFile.	self writeEPubDependencies.	self writeEPubSupportFiles.! !!PREPubDocument methodsFor: 'writing'!writeDocument: aDocument inFile: aFileReference withWriter: aWriter	| content templateValues templatedOutput |		content := aWriter write: aDocument.	templateValues := aDocument properties.	templateValues at: #content put: content.		templatedOutput := (MustacheTemplate on: self templateFile readStream contents) value: templateValues.	aFileReference ensureDelete.	aFileReference parent ensureCreateDirectory.	aFileReference writeStreamDo: [ :stream | 		stream nextPutAll: templatedOutput ]! !!PREPubDocument methodsFor: 'writing'!writeEPubDependencies	project baseDirectory children do: [ :each |		((each basename beginsWith: '_') or: [ each basename beginsWith: '.' ]) ifFalse: [ 			each copyAllTo: self epubContentsGenerationDirectory / each basename ] ]! !!PREPubDocument methodsFor: 'writing'!writeEPubSupportFiles	(project baseDirectory resolve: '_support/epub')		copyAllTo: self epubContentsGenerationDirectory! !!PREPubDocument methodsFor: 'writing'!writeNavigationFileForDocument: aDocument	self		writeDocument: aDocument		inFile: (self epubContentsGenerationDirectory / 'navigation.xhtml')		withWriter: PREPubNavigationMenuWriter new! !!PREPubDocument methodsFor: 'writing'!writePackageManifestFile	| configuration contentsOpfTemplate |		configuration := self configuration allProperties.	configuration		at: 'manifestItems'		put: '		<item id="navigation" properties="nav" href="navigation.xhtml" media-type="application/xhtml+xml"/>		<item id="contents" href="contents.xhtml" media-type="application/xhtml+xml" />'.	configuration		at: 'spineItems'		put: '		<itemref idref="navigation" linear="yes" />		<itemref idref="contents" linear="yes" />'.	contentsOpfTemplate := (project baseDirectory / '_support' / 'templates' / 'epub' / 'contents.opf.mustache') asMustacheTemplate.	self epubContentsGenerationDirectory / 'contents', 'opf' writeStreamDo: [:stream |		stream nextPutAll: (contentsOpfTemplate value: configuration) ]! !!PREPubDocument methodsFor: 'writing'!writeZipFileOn: stream	| archive |	archive := ZipArchive new.	(archive addFile: (self epubContentsGenerationDirectory / 'mimetype') fullName as: 'mimetype')		desiredCompressionMethod: ZipArchive compressionStored;		unixFileAttributes: 0.	self epubContentsGenerationDirectory allChildren		do: [ :each | 			each = self epubContentsGenerationDirectory asAbsolute				ifFalse: [ | absolutePathString relativePathString |					absolutePathString := each fullName.					relativePathString := each fileSystem stringFromPath: (each relativeTo: self epubContentsGenerationDirectory asAbsolute).					(each isDirectory						ifTrue: [ archive addDirectory: absolutePathString as: relativePathString ]						ifFalse: [ archive addFile: absolutePathString as: relativePathString ]) unixFileAttributes: 0 ] ].	archive writeTo: stream! !!PREPubMenuWriter class methodsFor: 'accessing'!fileExtension	^self subclassResponsibility ! !!PREPubMenuWriter class methodsFor: 'accessing'!folderName	^ self subclassResponsibility ! !!PREPubMenuWriter class methodsFor: 'testing'!isAbstract	^ self = PREPubMenuWriter ! !!PREPubMenuWriter class methodsFor: 'accessing'!writerName	^ self subclassResponsibility ! !!PREPubMenuWriter methodsFor: 'private'!refFor: aHeader	^ 'contents.xhtml#',aHeader text asValidSelector ! !!PREPubMenuWriter methodsFor: 'accessing'!writerFor: aConfiguration	^ self! !!PREPubNavigationMenuWriter class methodsFor: 'accessing'!fileExtension	^'nav.xhtml'! !!PREPubNavigationMenuWriter class methodsFor: 'accessing'!folderName	^#navmenu! !!PREPubNavigationMenuWriter class methodsFor: 'accessing'!writerName	^#navmenu! !!PREPubNavigationMenuWriter methodsFor: 'visiting-document'!visitAnnotatedParagraph: anAnnotatedParagraph		"Do nothing, I should only write headers and sections"! !!PREPubNavigationMenuWriter methodsFor: 'visiting-document'!visitCodeblock: aCodeBlock		"Do nothing, I should only write headers and sections"! !!PREPubNavigationMenuWriter methodsFor: 'visiting-document'!visitDefinitionList: aList	"Do nothing, I should only write headers and sections"! !!PREPubNavigationMenuWriter methodsFor: 'visiting-document'!visitFigure: aFigure		"Do nothing, I should only write headers and sections"! !!PREPubNavigationMenuWriter methodsFor: 'visiting-document'!visitHeader: aHeader	canvas tag		name: 'li';		with: [ canvas tag				name: 'a';				parameterAt: 'href' put: (self refFor: aHeader);				with: [ self visitDocumentGroup: aHeader ] ]! !!PREPubNavigationMenuWriter methodsFor: 'visiting-document'!visitList: aList	"Do nothing, I should only write headers and sections"! !!PREPubNavigationMenuWriter methodsFor: 'visiting-document'!visitOrderedList: aList	"Do nothing, I should only write headers and sections"! !!PREPubNavigationMenuWriter methodsFor: 'visiting-document'!visitParagraph: aParagraph		"Do nothing, I should only write headers and sections"! !!PREPubNavigationMenuWriter methodsFor: 'visiting-document'!visitSection: aSection	canvas tag		name: 'ol';		with: [ super visitDocumentGroup: aSection ]! !!PREPubNavigationMenuWriter methodsFor: 'visiting-document'!visitUnorderedList: aList	"Do nothing, I should only write headers and sections"! !!PREPubTocMenuWriter class methodsFor: 'accessing'!fileExtension	^'toc.ncx'! !!PREPubTocMenuWriter class methodsFor: 'accessing'!folderName	^ #tocmenu! !!PREPubTocMenuWriter class methodsFor: 'accessing'!writerName	^ #tocmenu! !!PREPubTocMenuWriter methodsFor: 'initialization'!initialize	counter := 0.	super initialize.! !!PREPubTocMenuWriter methodsFor: 'visiting-document'!visitHeader: aHeader	canvas tag		name: 'navLabel';		with: [ canvas tag				name: 'text';				with: [ self visitDocumentGroup: aHeader ] ].	canvas emptyTag		name: 'content';		parameterAt: 'src' put: (self refFor: aHeader);		closeTag! !!PREPubTocMenuWriter methodsFor: 'visiting-document'!visitSection: aSection			counter := counter + 1.			canvas tag				name: 'navPoint';				parameterAt: 'playOrder' put: counter;				with: [ super visitDocumentGroup: aSection ]! !!PREPubOutput class methodsFor: 'accessing'!builderName		^ #epub! !!PREPubOutput methodsFor: 'building'!documentFor: aFile	^ PREPubDocument new		project: aFile project;		file: aFile;		target: self;		outputDirectory: aFile project outputDirectory / self extension;		yourself! !!PREPubOutput methodsFor: 'accessing'!extension		^ 'epub'! !!PREPubOutput methodsFor: 'accessing'!outputDirectoryName		^ 'epub'! !!PREPubOutput methodsFor: 'accessing'!prepareForExecutionOn: aPRProject 	"As a temporary solution, remove the old results folder before building the document.	This should be replaced by a smarter solution replacing only modified files"	| configuration outputFormat target source |	aPRProject wipeout.		configuration :=  self createConfigurationFrom: aPRProject.		outputFormat := configuration propertyAt: #_outputFormat.	target := aPRProject outputDirectory  / outputFormat outputDirectoryName resolve: (Path from: '_support').	source := aPRProject baseDirectory /  '_support'.		PRCopyPhase new		sourceDirectory: source;		destinationDirectory: target;		executeOn: nil "We used a configuration context here that is not needed anymore".! !!PREPubOutput methodsFor: 'building'!writerFor: aPRPillarConfiguration 		^ PRXHTMLWriter new! !!PREPubMenuJustHeaderTransformer class methodsFor: 'accessing'!key	^#justKeepHeaders! !!PREPubMenuJustHeaderTransformer class methodsFor: 'accessing'!writers	^ #(#tocmenu #navmenu)! !!PREPubMenuJustHeaderTransformer methodsFor: 'actions'!actionOn: anInput	^ (self class writers		includes: ((anInput configuration propertyAt: #_outputFormat) writerFor: anInput configuration) class writerName)		ifTrue: [ maxHeader := self maxHeaderOf: anInput input.			super actionOn: anInput ]		ifFalse: [ anInput ]! !!PREPubMenuJustHeaderTransformer methodsFor: 'private'!initCurrentsArray	currentsArray := #(nil nil nil nil nil nil nil) copy.! !!PREPubMenuJustHeaderTransformer methodsFor: 'private'!manageItem: aDocumentItem	| newSection parent |	^ (aDocumentItem isHeader and: [ aDocumentItem level = maxHeader ])		ifTrue: [ newSection := self cleanSectionsAndOpenNewWith: aDocumentItem.			self initCurrentsArray.			currentsArray at: maxHeader put: newSection ]		ifFalse: [ aDocumentItem isHeader				ifTrue: [ parent := self sectionToLinkWith: aDocumentItem.					newSection := PRSection with: aDocumentItem.					parent add: newSection.					currentsArray at: aDocumentItem level put: newSection ]				ifFalse: [ aDocumentItem isGroup						ifTrue: [ aDocumentItem children do: [ :each | self manageItem: each ] ] ] ]! !!PREPubMenuJustHeaderTransformer methodsFor: 'private'!maxHeaderOf: anObject	^ anObject isHeader		ifTrue: [ anObject level ]		ifFalse: [ anObject isGroup				ifTrue: [ anObject children size > 0						ifTrue: [ (anObject children								collect: [ :child | 									child isHeader										ifTrue: [ child level ]										ifFalse: [ 7 ] ]) min ] ]				ifFalse: [ 7 ] ]! !!PREPubMenuJustHeaderTransformer methodsFor: 'private'!sectionToLinkWith: aHeader	| headerLevel |	headerLevel := aHeader level - 1.	[ (currentsArray at: headerLevel) isNil ] whileTrue: [ headerLevel := headerLevel - 1 ].	^ currentsArray at: headerLevel! !"Pillar-ExporterEPub"!!PRDeckJSWriter commentStamp: '' prior: 0!I'm a writer generating Deck.js slides from a Pillar document. Deck.js is a javascript framework specialized in slide creation.To generate the internalLinks I use an anchorMapping to know the number of the slide where is the anchor.!!PRAssociateAnchorToSlideNumber commentStamp: '' prior: 0!On Deck.js the anchor doesn't work the same as HTML. At each slide deck.js create an anchor named "slide-X" where X is the number of the slide (we begin at 0). I am a visitor, I will visit a document and return a Dictionary with all the anchors of a document in key and the number of the slide where is the anchor as value.I work with the "slideInTemplateForDeckJS" configuration to know how many slides I have before the document in the template.currentSlide is the number of the current slide.anchorMapping is the dictionary of anchor/counter.!!PRDeckJSWriter class methodsFor: 'accessing'!folderName	^ #deckJS! !!PRDeckJSWriter class methodsFor: 'accessing'!writerName	^ #deckJS! !!PRDeckJSWriter methodsFor: 'visiting-document'!addAnchorFrom: anInternalLink To: href	| anchor |	anchor := anchorMapping		at: anInternalLink anchor		ifPresent: [ :num | (num - 1) asString	"We do -1 because the first slide have an anchor with 0 and not 1" ]		ifAbsent: [ 			PRReferenceNotFound signal: 'Can''t find anchor named ''' , anInternalLink anchor , ''''.			'' ].	^ href , '#slide-' , anchor! !!PRDeckJSWriter methodsFor: 'private'!createNewSlideTitle: aTitle	canvas tag		name: 'h2';		with: aTitle.	canvas newLine! !!PRDeckJSWriter methodsFor: 'visiting'!start: aDocument	anchorMapping := PRAssociateAnchorToSlideNumber new		configuration: self configuration;		start: aDocument.	super start: aDocument! !!PRDeckJSWriter methodsFor: 'templating'!templateForConfiguration: aConfiguration	^ 'presentation.template'! !!PRDeckJSWriter methodsFor: 'visiting-document'!visitAnchor: anAnchor	"I do nothing because the anchors created by the user doesn't work with Deck.js."	! !!PRDeckJSWriter methodsFor: 'visiting-document'!visitHeader: aHeader	self configuration renderStructureAsSlide		ifTrue: [ 			canvas tag				name: 'div';				parameterAt: 'class' put: 'slide';				with: [ 							canvas newLine.							super visitHeader: aHeader ].			canvas newLine ]! !!PRDeckJSWriter methodsFor: 'visiting-document'!visitSection: aSection	"Sections should not be render in a Deck.js file because it breack the transitions."	self visitDocumentGroup: aSection! !!PRDeckJSWriter methodsFor: 'visiting-document'!visitSlide: aSlide	canvas tag		name: 'div';		parameterAt: 'class' put: 'slide';		with: [ 					canvas newLine.					aSlide hasLabel						ifTrue: [ 							self createAnchorWith: aSlide label.							canvas newLine ].					self createNewSlideTitle: aSlide title.					super visitSlide: aSlide ].	canvas newLine! !!PRAssociateAnchorToSlideNumber class methodsFor: 'testing'!isAbstract	^ false! !!PRAssociateAnchorToSlideNumber methodsFor: 'accessing'!configuration	^ configuration ifNil: [ configuration := ConfigurationForPillar new ]! !!PRAssociateAnchorToSlideNumber methodsFor: 'accessing'!configuration: aConfiguration	configuration := aConfiguration! !!PRAssociateAnchorToSlideNumber methodsFor: 'visiting'!start: aDocument	currentSlide := self configuration slideInTemplateForDeckJS. "I do not understand what is this configuration property."	anchorMapping := Dictionary new.	super start: aDocument.	^ anchorMapping! !!PRAssociateAnchorToSlideNumber methodsFor: 'visiting-document'!visitAnchor: anObject	anchorMapping at: anObject name put: currentSlide.	super visitAnchor: anObject! !!PRAssociateAnchorToSlideNumber methodsFor: 'visiting-document'!visitCodeblock: aCodeBlock	aCodeBlock hasLabel		ifTrue: [ anchorMapping at: aCodeBlock label put: currentSlide ].	super visitCodeblock: aCodeBlock! !!PRAssociateAnchorToSlideNumber methodsFor: 'visiting-document'!visitFigure: anObject	anObject hasLabel		ifTrue: [ anchorMapping at: anObject label put: currentSlide ].	super visitFigure: anObject! !!PRAssociateAnchorToSlideNumber methodsFor: 'visiting-document'!visitHeader: aHeader	"If we create a slide when we have a header in DeckJS we need to increase the counter."	self configuration renderStructureAsSlide		ifTrue: [ currentSlide := currentSlide + 1 ].	super visitHeader: aHeader! !!PRAssociateAnchorToSlideNumber methodsFor: 'visiting-document'!visitSlide: aSlide	currentSlide := currentSlide + 1.	aSlide hasLabel		ifTrue: [ anchorMapping at: aSlide label put: currentSlide ].	super visitSlide: aSlide! !"Pillar-ExporterDeckJS"!!PRMarkdownWriter commentStamp: '' prior: 0!I am a writer for CommonMarkhttp://spec.commonmark.org/0.28/!!PRGithubMarkdownWriter commentStamp: '' prior: 0!I am a writer for GitHub Flavored Markdownhttps://github.github.com/gfm/GFM is based on CommonMark and adds couple of extensions.!!PRGitlabMarkdownWriter commentStamp: '' prior: 0!I am a writer for GitLab Flavored Markdownhttps://docs.gitlab.com/ee/user/markdown.htmlNote that Gitlab Flavored Markdown is not an extension of CommonMark, however the syntax is similar for the most part.!!PRMarkdownCanvas commentStamp: '' prior: 0!A Markdown canvas that facilitates writing Markdown to a stream. It essentially use to nesting the lists!!PRInternalLink methodsFor: '*Pillar-ExporterMarkdown'!referenceAsMarkdown	"I return a reference to a pillar file as a markdown file."	| ref |	ref := self reference.	((ref endsWith: '.pillar') or: [ ref endsWith: '.pier' ])		ifTrue: [ ref := (ref copyUpToLast: $.) , '.md' ]		ifFalse: [ PRLinkWarning signal: 'Reference : ' , ref , ' should end with .pillar or .pier' ].	^ ref! !!PRGithubMarkdownWriter class methodsFor: 'accessing'!folderName	^ #githubmarkdown! !!PRGithubMarkdownWriter class methodsFor: 'accessing'!writerName	^ #githubmarkdown! !!PRGithubMarkdownWriter methodsFor: 'protected'!scriptLayout: aScript	| language |	language := self languageForScript: aScript.	canvas nextPutAll: '```'.	language isSyntaxHighlightingPossible ifTrue: [ canvas raw: language printString ].	canvas raw: aScript text, '```'! !!PRGithubMarkdownWriter methodsFor: 'visiting-document'!visitStrikethroughFormat: aFormat	"https://github.github.com/gfm/#strikethrough-extension-"	canvas raw: '~'.	self visitFormat: aFormat.	canvas raw: '~'! !!PRGithubMarkdownWriter methodsFor: 'visiting-document'!visitTable: aTableCell	firstRow := true.	self visitDocumentGroup: aTableCell.	canvas newLine.! !!PRGithubMarkdownWriter methodsFor: 'visiting-document'!visitTableCell: aTableCell	canvas raw: aTableCell text! !!PRGithubMarkdownWriter methodsFor: 'visiting-document'!visitTableRow: aTableRow	"https://github.github.com/gfm/#tables-extension-"	canvas raw: '| '.	self visitAll: aTableRow children separatedBy: [ canvas raw: ' | ' ].	canvas raw: ' |'.	"GFM doesn't recognize tables without headers, so we always use the first row as headers (alternatively the header row would have to be empty)"	firstRow		ifTrue: [ firstRow := false.			self writeTableConfiguration: aTableRow ].	stream newLine! !!PRGithubMarkdownWriter methodsFor: 'visiting-document'!visitUnderlineFormat: aFormat	super visitFormat: aFormat ! !!PRGithubMarkdownWriter methodsFor: 'visiting-document'!writeTableColumnAlignment: aTableCell	"https://github.github.com/gfm/#tables-extension-"	aTableCell isAlignedLeft | aTableCell isAlignedCenter		ifTrue: [ canvas raw: ':' ].	canvas raw: '---'.	aTableCell isAlignedRight | aTableCell isAlignedCenter		ifTrue: [ canvas raw: ':' ]! !!PRGithubMarkdownWriter methodsFor: 'visiting-document'!writeTableConfiguration: aTableRow	stream newLine.	firstRow := false.	canvas raw: '| '.	aTableRow children		do: [ :aTableCell | self writeTableColumnAlignment: aTableCell ]		separatedBy: [ canvas raw: ' | ' ].	canvas raw: ' |'! !!PRGitlabMarkdownWriter methodsFor: 'visiting-document'!visitStrikethroughFormat: aFormat	"https://docs.gitlab.com/ee/user/markdown.html#emphasis"	canvas raw: '~~'.	self visitFormat: aFormat.	canvas raw: '~~'! !!PRGitlabMarkdownWriter methodsFor: 'visiting-document'!visitTable: aTableCell	firstRow := true.	self visitDocumentGroup: aTableCell.	canvas newLine.! !!PRGitlabMarkdownWriter methodsFor: 'visiting-document'!visitTableCell: aTableCell	canvas raw: aTableCell text! !!PRGitlabMarkdownWriter methodsFor: 'visiting-document'!visitTableRow: aTableRow	"https://docs.gitlab.com/ee/user/markdown.html#tables"	canvas raw: '| '.	self visitAll: aTableRow children separatedBy: [ canvas raw: ' | ' ].	canvas raw: ' |'.	"GFM doesn't recognize tables without headers, so we always use the first row as headers (alternatively the header row would have to be empty)"	firstRow		ifTrue: [ firstRow := false.			self writeTableConfiguration: aTableRow ].	stream newLine! !!PRGitlabMarkdownWriter methodsFor: 'visiting-document'!writeTableColumnAlignment: aTableCell	"https://docs.gitlab.com/ee/user/markdown.html#tables"	aTableCell isAlignedLeft | aTableCell isAlignedCenter		ifTrue: [ canvas raw: ':' ].	canvas raw: '---'.	aTableCell isAlignedRight | aTableCell isAlignedCenter		ifTrue: [ canvas raw: ':' ]! !!PRGitlabMarkdownWriter methodsFor: 'visiting-document'!writeTableConfiguration: aTableRow	stream newLine.	firstRow := false.	canvas raw: '| '.	aTableRow children		do: [ :aTableCell | self writeTableColumnAlignment: aTableCell ]		separatedBy: [ canvas raw: ' | ' ].	canvas raw: ' |'! !!PRMarkdownWriter class methodsFor: 'accessing'!fileExtension	^ 'md'! !!PRMarkdownWriter class methodsFor: 'accessing'!folderName	^ #markdown! !!PRMarkdownWriter class methodsFor: 'accessing'!writerName	^ #markdown! !!PRMarkdownWriter methodsFor: 'accessing'!canvasClass	^ PRMarkdownCanvas! !!PRMarkdownWriter methodsFor: 'as yet unclassified'!createAnchorWith: aString 	self shouldBeImplemented.! !!PRMarkdownWriter methodsFor: 'visiting-document'!nest: aString do: aBlock	nesting add: aString.	aBlock ensure: [ nesting removeLast ]! !!PRMarkdownWriter methodsFor: 'protected'!scriptLayout: aScript	| text lines |	text := aScript text.	lines := (text substrings: self configuration newLine)		collect: [ :each | '    ' , each , self configuration newLine ].	canvas raw: lines.! !!PRMarkdownWriter methodsFor: 'visiting'!start: anObject	nesting := OrderedCollection new.	super start: anObject! !!PRMarkdownWriter methodsFor: 'visiting-document'!visitAnnotatedParagraph: anAnnotatedParagraph	"Annotations need to be defined as block quotes. For example...		@@note 		@@dothis	could have...	 	> Note:		> DoThis:	"	canvas writeBlockQuoteDuring: [		canvas			bold: anAnnotatedParagraph annotation;			raw: ': '.		self visitParagraph: anAnnotatedParagraph	]! !!PRMarkdownWriter methodsFor: 'visiting-document'!visitBoldFormat: aFormat	"http://spec.commonmark.org/0.28/#emphasis-and-strong-emphasis"	canvas bold: aFormat text! !!PRMarkdownWriter methodsFor: 'visiting-document'!visitCodeblock: aCodeBlock	"Markdown by default does not support labels nor captions in scripts"	aCodeBlock hasLabel ifTrue: [ 		Warning signal: 'Unsupported feature: Markdown writer does not support code block labels' ].	aCodeBlock hasCaption ifTrue: [ 		Warning signal: 'Unsupported feature: Markdown writer does not support code block captions' ].	self writeScript: aCodeBlock.! !!PRMarkdownWriter methodsFor: 'visiting-document'!visitDataItem: anObject		canvas raw: anObject text! !!PRMarkdownWriter methodsFor: 'visiting-document'!visitDefinitionList: anObject	canvas potentialNewLine.	self nest: '- ' do: [ super visitDefinitionList: anObject ]! !!PRMarkdownWriter methodsFor: 'visiting-document'!visitExternalLink: anExternalLink	"http://spec.commonmark.org/0.28/#links"	self writeExternalLink: anExternalLink! !!PRMarkdownWriter methodsFor: 'visiting'!visitFigure: aFigure	"http://spec.commonmark.org/0.28/#images"	canvas raw: '!!['.	aFigure hasLabel ifTrue: [ canvas raw: aFigure label ].	canvas raw: '](' , aFigure localFileOrExternalReference.	aFigure hasCaption ifTrue: [ canvas raw: ' "' , aFigure text , '"' ].	canvas raw: ')'! !!PRMarkdownWriter methodsFor: 'visiting-document'!visitHeader: aHeader	"http://spec.commonmark.org/0.28/#atx-headings"	| level |	level := aHeader level min: 6 max: 1.	1 to: level do: [ :each | canvas nextPut: $# ].	canvas nextPut: Character space.	self writeCounterForHeader: aHeader.	canvas raw: aHeader text trimmed.	canvas newLine! !!PRMarkdownWriter methodsFor: 'visiting'!visitHorizontalRule: anHorizontalRule	"http://spec.commonmark.org/0.28/#thematic-breaks"		"The result is line, so using dashes and not e.g. asterisks would make more sense."	canvas		newLine;		newLine.	canvas raw: '---'.	canvas newLine! !!PRMarkdownWriter methodsFor: 'visiting-document'!visitInternalLink: anInternalLink	| href |	href := String new.	anInternalLink hasReference ifTrue: [ href := href , anInternalLink referenceAsHTML ].	anInternalLink hasAnchor ifTrue: [ href := href , '#' , anInternalLink anchor ].	self writeInternalLink: anInternalLink withRef: href.! !!PRMarkdownWriter methodsFor: 'visiting-document'!visitItalicFormat: aFormat	"http://spec.commonmark.org/0.28/#emphasis-and-strong-emphasis"	canvas raw: '*' , aFormat text , '*'! !!PRMarkdownWriter methodsFor: 'visiting-document'!visitListItem: aListItem	"http://spec.commonmark.org/0.28/#list-items and http://spec.commonmark.org/0.28/#lists"	nesting last isInteger ifTrue: [ nesting addLast: nesting removeLast + 1 ].	nesting size - 1 timesRepeat: [ canvas raw: '  ' ].	canvas nextPutAll: nesting last asString.	canvas nextPutAll: (nesting last isInteger 			ifTrue: [ '. ' ]			ifFalse: [ ' ' ]).	self visitDocumentGroup: aListItem.	canvas potentialNewLine! !!PRMarkdownWriter methodsFor: 'visiting-document'!visitMailLink: aMail	canvas		writeLinkDuring: [ self visitAll: aMail children ]		destination: aMail unscrambledUrl.! !!PRMarkdownWriter methodsFor: 'visiting-document'!visitMonospaceFormat: aFormat	"http://spec.commonmark.org/0.28/#code-spans"	canvas raw: '`' , aFormat text , '`'! !!PRMarkdownWriter methodsFor: 'visiting-document'!visitOrderedList: aList	"http://spec.commonmark.org/0.28/#list-items and http://spec.commonmark.org/0.28/#lists"	canvas potentialNewLine.	aList children		withIndexDo: [ :each :i | self nest: i asString , '.' do: [ self visit: each ] ]! !!PRMarkdownWriter methodsFor: 'visiting-document'!visitParagraph: aParagraph	self visitDocumentGroup: aParagraph.! !!PRMarkdownWriter methodsFor: 'visiting-document'!visitPreformatted: aPreformatted		canvas writeIndentedCodeBlockDuring: [		aPreformatted children			do: [ :child | self visit: child ]			separatedBy: [canvas newLine ] ]! !!PRMarkdownWriter methodsFor: 'visiting-document'!visitTermItem: anObject		canvas		raw: '- ';		bold: anObject text;		raw: '.'! !!PRMarkdownWriter methodsFor: 'visiting-document'!visitUnorderedList: aList	"http://spec.commonmark.org/0.28/#list-items and http://spec.commonmark.org/0.28/#lists"	canvas potentialNewLine.	self nest: '-' do: [ self visitDocumentGroup: aList ]! !!PRMarkdownWriter methodsFor: 'writing'!writeExternalLink: anExternalLink	"http://spec.commonmark.org/0.28/#links"	canvas		writeLinkDuring: [ self visitDocumentGroup: anExternalLink ]		destination: anExternalLink localFileOrExternalReference.! !!PRMarkdownWriter methodsFor: 'writing'!writeInternalLink: anInternalLink withRef: href	"http://spec.commonmark.org/0.28/#links"	canvas		writeLinkDuring: [ 			anInternalLink counter isValidCounter				ifTrue: [ self writeCounter: anInternalLink counter.					anInternalLink hasAlias						ifTrue: [ canvas nextPutAll: ' ' ] ].			anInternalLink hasAlias				ifTrue: [ canvas nextPutAll: anInternalLink alias ]. ]		destination: href! !!PRMarkdownWriter methodsFor: 'writing'!writeScript: aScript	"http://spec.commonmark.org/0.28/#fenced-code-blocks"	"I am not using indented code blocks (http://spec.commonmark.org/0.28/#indented-code-blocks), because they have no info strings (http://spec.commonmark.org/0.28/#info-string)"	| language |	canvas		newLine;		raw: '```'.	language := self languageForScript: aScript.	language isSyntaxHighlightingPossible		ifTrue: [ canvas raw: language originalName ].	canvas		newLine;		raw: aScript text;		newLine;		raw: '```';		newLine! !!PRMarkdownOutput class methodsFor: 'accessing'!builderName	^ 'markdown'! !!PRMarkdownOutput methodsFor: 'building'!documentFor: aFile	^ PRMarkdownDocument new		project: aFile project;		file: aFile;		target: self;		outputDirectory: aFile project outputDirectory / self extension;		yourself! !!PRMarkdownOutput methodsFor: 'accessing'!extension	^ 'markdown'! !!PRMarkdownOutput methodsFor: 'accessing'!outputDirectoryName		^ 'markdown'! !!PRMarkdownOutput methodsFor: 'accessing'!writerFor: aPRPillarConfiguration 		^ PRMarkdownWriter new! !!PRMicrodownOutput class methodsFor: 'accessing'!builderName	^ 'microdown'! !!PRMicrodownOutput methodsFor: 'building'!documentFor: aFile	^ PRMicrodownDocument new		project: aFile project;		file: aFile;		target: self;		outputDirectory: aFile project outputDirectory / self extension;		yourself! !!PRMicrodownOutput methodsFor: 'accessing'!extension		^ 'microdown'! !!PRMicrodownOutput methodsFor: 'accessing'!outputDirectoryName		^ 'microdown'! !!PRMicrodownOutput methodsFor: 'accessing'!writerFor: aPRPillarConfiguration 		^ PRMicrodownWriter new! !!PRMarkdownCanvas methodsFor: 'accessing'!bold: aText	^ self		raw: '**';		raw: aText;		raw: '**'! !!PRMarkdownCanvas methodsFor: 'initialization'!initialize	super initialize.	prefixStack := OrderedCollection new.	lastIsNewLine := true! !!PRMarkdownCanvas methodsFor: 'accessing'!lastIsNewLine	^ lastIsNewLine! !!PRMarkdownCanvas methodsFor: 'writing text'!newLine	super newLine.	lastIsNewLine := true! !!PRMarkdownCanvas methodsFor: 'writing text'!nextPut: aCharacter	super nextPut: aCharacter.	lastIsNewLine := false! !!PRMarkdownCanvas methodsFor: 'prefix-stack'!popPrefix		prefixStack removeLast! !!PRMarkdownCanvas methodsFor: 'writing text'!potentialNewLine	lastIsNewLine ifFalse: [ self newLine ]! !!PRMarkdownCanvas methodsFor: 'prefix-stack'!pushPrefix: aString 		prefixStack addLast: aString! !!PRMarkdownCanvas methodsFor: 'writing text'!raw: aString		lastIsNewLine ifTrue: [ 		prefixStack do: [ :each |			super raw: each ].	].	super raw: aString.	lastIsNewLine := false! !!PRMarkdownCanvas methodsFor: 'writing'!writeBlockQuoteDuring: aBlockClosure 		self		writePrefix: '> '		forEachLineDuring: aBlockClosure.! !!PRMarkdownCanvas methodsFor: 'writing'!writeIndentedCodeBlockDuring: aBlockClosure 		self		writePrefix: '    '		forEachLineDuring: aBlockClosure.! !!PRMarkdownCanvas methodsFor: 'writing'!writeLinkDuring: aBlockClosure destination: aString 		self		writeLinkDuring: aBlockClosure		destination: aString		title: nil! !!PRMarkdownCanvas methodsFor: 'writing'!writeLinkDuring: aBlockClosure destination: aDestination title: aTitle 	self raw: '['.	aBlockClosure ensure: [ 		self			raw: '](';			raw: aDestination.				aTitle ifNotNil: [ 			self				raw: ' "';				raw: aTitle;				raw: '"'.		].		self raw: ')'	 ]! !!PRMarkdownCanvas methodsFor: 'writing'!writePrefix: aString forEachLineDuring: aBlockClosure 	self pushPrefix: aString.	aBlockClosure ensure: [ self popPrefix ].! !"Pillar-ExporterMarkdown"!!PRTextWriter commentStamp: '' prior: 0!A writer for text !!PRTextCanvas commentStamp: '' prior: 0!A canvas for writing text!!PRAsciiDocument methodsFor: 'accessing'!basicWriter	^ PRAsciiDocWriter new! !!PRAsciiDocument methodsFor: 'accessing'!extension	^ 'ascii'! !!PRMarkdownDocument methodsFor: 'accessing'!basicWriter	^ PRMarkdownWriter new! !!PRMarkdownDocument methodsFor: 'accessing'!extension	^ 'markdown'! !!PRMicrodownDocument methodsFor: 'accessing'!basicWriter	^ PRMicrodownWriter new! !!PRMicrodownDocument methodsFor: 'accessing'!extension	^ 'microdown'! !!PRTextDocument methodsFor: 'accessing'!basicWriter		^ PRTextWriter new! !!PRTextDocument methodsFor: 'accessing'!extension		^ 'txt'! !!PRTextDocument methodsFor: 'building'!writeDocument: aDocument	| outputContent outputFile |	outputContent := self basicWriter write: aDocument.			self flag: #DuplicatedInSubclass.	outputFile := (self outputDirectory resolve: (file file asAbsolute relativeTo: project baseDirectory asAbsolute)) withoutExtension , self extension.	outputFile ensureDelete.	outputFile parent ensureCreateDirectory.	outputFile writeStreamDo: [ :stream | stream nextPutAll: outputContent ].	^ outputFile! !!PRTextWriter class methodsFor: 'accessing'!fileExtension	^ 'txt'! !!PRTextWriter class methodsFor: 'accessing'!folderName	^ #text! !!PRTextWriter class methodsFor: 'accessing'!writerName	^ #text! !!PRTextWriter methodsFor: 'accessing'!canvasClass	^ PRTextCanvas! !!PRTextWriter methodsFor: 'private'!nest: aString do: aBlock	nesting add: aString.	aBlock ensure: [ nesting removeLast ]! !!PRTextWriter methodsFor: 'visiting'!start: anObject	nesting := OrderedCollection new.	super start: anObject.	canvas lastIsNewLine		ifTrue: [ stream trimLastNewLine ]! !!PRTextWriter methodsFor: 'visiting-document'!visitDataItem: anObject	self nest: ' ' do: [ super visitDataItem: anObject ]! !!PRTextWriter methodsFor: 'visiting-document'!visitDefinitionList: anObject	canvas potentialNewLine.	self visitAll: anObject children! !!PRTextWriter methodsFor: 'visiting-document'!visitHeader: anObject	super visitHeader: anObject.	canvas newLine! !!PRTextWriter methodsFor: 'visiting-document'!visitHorizontalRule: anObject	canvas		nextPutAll: ((String new: 40) atAllPut: $-);		newLine! !!PRTextWriter methodsFor: 'visiting-document'!visitListItem: anObject 	nesting last isInteger ifTrue: [ nesting addLast: nesting removeLast + 1 ].	nesting size - 1 timesRepeat: [ canvas tab ].	canvas nextPutAll: nesting last asString.	canvas nextPutAll: (nesting last isInteger 			ifTrue: [ '. ' ]			ifFalse: [ ' ' ]).	super visitListItem: anObject.	canvas potentialNewLine! !!PRTextWriter methodsFor: 'visiting-document'!visitOrderedList: anObject	canvas potentialNewLine.	self nest: 0 do: [ super visitOrderedList: anObject ]! !!PRTextWriter methodsFor: 'visiting-document'!visitParagraph: anObject	super visitParagraph: anObject.	canvas newLine! !!PRTextWriter methodsFor: 'visiting-document'!visitPreformatted: anObject	anObject children do: [ :each | self visit: each. canvas newLine ]! !!PRTextWriter methodsFor: 'visiting-document'!visitRaw: anObject	(anObject type isNil or: [ anObject type = 'text' ])		ifTrue: [ canvas nextPutAll: anObject text ]! !!PRTextWriter methodsFor: 'visiting-document'!visitReference: anObject	anObject hasAlias		ifTrue: [ super visitReference: anObject ]		ifFalse: [ canvas nextPutAll: anObject title ]! !!PRTextWriter methodsFor: 'visiting-document'!visitTableRow: anObject	anObject children		do: [ :each | self visit: each ]		separatedBy: [ canvas tab ].	canvas newLine! !!PRTextWriter methodsFor: 'visiting-document'!visitTermItem: anObject	self nest: '-' do: [ super visitDataItem: anObject ]! !!PRTextWriter methodsFor: 'visiting-document'!visitText: anObject	canvas nextPutAll: anObject text! !!PRTextWriter methodsFor: 'visiting-document'!visitUnorderedList: anObject	canvas potentialNewLine.	self nest: '*' do: [ super visitUnorderedList: anObject ]! !!PRDocument methodsFor: '*pillar-exportertext'!defaultTitle	^ 'No title'! !!PRDocument methodsFor: '*pillar-exportertext'!title	^ self propertyAt: 'title' ifAbsent: [ self titleFromFirstHeader ]! !!PRDocument methodsFor: '*pillar-exportertext'!titleFromFirstHeader	^ self children		detect: [ :child | child isHeader ]		ifFound: [ :header | PRTextWriter write: header ]		ifNone: [ self defaultTitle ]! !!PRTextCanvas methodsFor: 'initialization'!initialize	super initialize.	lastIsNewLine := true! !!PRTextCanvas methodsFor: 'testing'!lastIsNewLine	^ lastIsNewLine! !!PRTextCanvas methodsFor: 'writing text'!newLine	super newLine.	lastIsNewLine := true! !!PRTextCanvas methodsFor: 'writing text'!nextPut: aCharacter	super nextPut: aCharacter.	lastIsNewLine := false! !!PRTextCanvas methodsFor: 'writing text'!potentialNewLine	lastIsNewLine		ifFalse: [ self newLine ]! !!PRTextCanvas methodsFor: 'writing text'!raw: aString	super raw: aString.	lastIsNewLine := false.! !!PRTextCanvas methodsFor: 'writing'!tab	self nextPut: Character tab! !"Pillar-ExporterText"!!PRScriptEvaluationEnvironment commentStamp: '' prior: 0!A script evaluator!!PRScriptEvaluationEnvironment methodsFor: 'initialize-release'!setStream: aStream	stream := aStream! !!PRCodeblock methodsFor: '*Pillar-CodeBlockEvaluator'!evaluate	| content |	content := self evaluationString.	^ [ (PRDocument parser parse: content) children ]		on: Error		do: [ :e | PRBoldFormat with: (PRText content: e messageText) ]! !!PRCodeblock methodsFor: '*Pillar-CodeBlockEvaluator'!evaluationString	^ String		streamContents: [ :stream | 			| evaluator |			evaluator := PRScriptEvaluationEnvironment new				setStream: stream;				yourself.			[ self class compiler				source: self text;				logged: false;				receiver: evaluator;				evaluate ]				on: Error				do: [ :e | 					stream						nextPutAll: '= ';						nextPutAll: e description ] ]! !"Pillar-CodeBlockEvaluator"!!PRParseWarning commentStamp: '' prior: 0!I am a warning for the parse of a Pillar file.!!ManifestPillarPetitPillar commentStamp: '' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!PRPillarGrammar commentStamp: '' prior: 0!I am a grammar to parse Pillar files with PetitParser!!PRPillarParser commentStamp: '' prior: 0!I am a parser for a Pillar syntax. I use the PRPillarGrammar and I build a PRDocument.!!PRPillarParserMain commentStamp: '' prior: 0!I'm responsible for starting the parsing process of a Pillar document. If possible, I will use a compiled version of PRPillarParser. I will also use the STON reader to read potentital metadata at the begining of the stream.!!PRParagraph class methodsFor: '*Pillar-PetitPillar'!paragraphWithOtherMarkups	<sampleInstance>		^ PRPillarParser parse: 'Here is a list of publications	${publications:Ducasse|bibFile=rmod.bib}$The paragraph continues here.- a- b[[[a test  ]]]You can contact me if you want.'! !!PRAbstractAnnotation class methodsFor: '*Pillar-PetitPillar'!withParameters: aPRParameters	| parameters anInstance |	anInstance := self with: aPRParameters.	PRParserUtility fixFirstParameter: aPRParameters for: anInstance.	parameters := aPRParameters asDictionary. 	"parameters := PRParametersToOrderedDictionary of: aPRParameters."	self validateParameters: aPRParameters dictionary: parameters in: anInstance.	^ anInstance		hadAllKeys:			(self possibleParameters				difference: (parameters keys collect: #asSymbol)) isEmpty;		parameters: parameters;		yourself! !!PRDocumentItem class methodsFor: '*Pillar-PetitPillar'!parser	^ PRPillarParserMain! !!PRPillarGrammar class methodsFor: 'accessing'!defaultEndMarkups	| markups |	markups := Dictionary new.	markups		at: PRAbstractAnnotation put: '}$';		at: PRRaw put: '}}}';		at: PRCodeblock put: ']]]'.	^ markups! !!PRPillarGrammar class methodsFor: 'accessing'!defaultMarkupAnnotationSeparator	^ $:! !!PRPillarGrammar class methodsFor: 'accessing'!defaultMarkupParameter	^ '|'! !!PRPillarGrammar class methodsFor: 'accessing'!defaultMarkupParameterValue	^ '='! !!PRPillarGrammar class methodsFor: 'accessing'!defaultMarkupRawType	^ ':'! !!PRPillarGrammar class methodsFor: 'accessing'!defaultMarkupReferenceAlias	^ '>'! !!PRPillarGrammar class methodsFor: 'accessing'!defaultMarkupReferenceAnchor	^ '@'! !!PRPillarGrammar class methodsFor: 'accessing'!defaultMarkupTableCenter	^ '|'! !!PRPillarGrammar class methodsFor: 'accessing'!defaultMarkupTableHeader	^ '!!'! !!PRPillarGrammar class methodsFor: 'accessing'!defaultMarkupTableLeft	^ '{'! !!PRPillarGrammar class methodsFor: 'accessing'!defaultMarkupTableRight	^ '}'! !!PRPillarGrammar class methodsFor: 'accessing'!defaultMarkups	^ self textMarkups , self lineMarkups! !!PRPillarGrammar class methodsFor: 'accessing'!endMarkups	^ EndMarkups! !!PRPillarGrammar class methodsFor: 'accessing'!endMarkups: anObject	EndMarkups := anObject! !!PRPillarGrammar class methodsFor: 'class initialization'!initialize	Markups := self defaultMarkups.	EndMarkups := self defaultEndMarkups.! !!PRPillarGrammar class methodsFor: 'accessing'!lineMarkups	| markups |	markups := Dictionary new.	markups		at: PRAnchor put: '@';		at: PRHeader put: '!!';		at: PROrderedList put: '#';		at: PRUnorderedList put: '-';		at: PRDataItem put: ':';		at: PRTermItem put: ';';		at: PRAnnotatedParagraph put: '@@';		at: PRPreformatted put: '= ';		at: PRHorizontalRule put: '_';		at: PRCommentedLine put: '%';		at: PRTableCell put: '|'.	^ markups! !!PRPillarGrammar class methodsFor: 'accessing'!markups	^ Markups! !!PRPillarGrammar class methodsFor: 'accessing'!markups: anObject	Markups := anObject! !!PRPillarGrammar class methodsFor: 'accessing'!textMarkups	| markups |	markups := Dictionary new.	markups		at: PRBoldFormat put: '""';		at: PRItalicFormat put: '''''';		at: PRMonospaceFormat put: '==';		at: PRStrikethroughFormat put: '--';		at: PRSubscriptFormat put: '@@';		at: PRSuperscriptFormat put: '^^';		at: PRUnderlineFormat put: '__';		at: PRFigure put: '+';		at: PRLink put: '*';		at: PRCodeblock put: '[[[';		at: PRRaw put: '{{{';		at: PRAbstractAnnotation put: '${'.	^ markups! !!PRPillarGrammar methodsFor: 'grammar - Anchor'!anchor	^ (Markups at: PRAnchor) asPParser , lineEnd negate plus flatten! !!PRPillarGrammar methodsFor: 'grammar - Paragraph'!annotatedParagraph	^	epsilonToken , 		(Markups at: PRAnnotatedParagraph) asPParser , 		($  asPParser / newline) negate star flatten , 		($  asPParser , oneLineContent) optional ,		epsilonToken ! !!PRPillarGrammar methodsFor: 'grammar - Annotation'!annotation	"Todo: An annotation should have the possibility to be outside of a paragraph."	^	epsilonToken , 			(Markups at: PRAbstractAnnotation) asPParser , 		annotationTag , 		annotationParameters optional ,		annotationEndMarkup , 		epsilonToken ,		#blank asPParser star! !!PRPillarGrammar methodsFor: 'grammar - Annotation'!annotationEndMarkup	^ (EndMarkups at: PRAbstractAnnotation) asPParser! !!PRPillarGrammar methodsFor: 'grammar - Annotation'!annotationMarkupSeparator	^ self class defaultMarkupAnnotationSeparator asPParser! !!PRPillarGrammar methodsFor: 'grammar - Annotation'!annotationParameters	^	epsilonToken , 			annotationMarkupSeparator ,		epsilonToken , 		parametersUntilEndAnnotation, 		epsilonToken! !!PRPillarGrammar methodsFor: 'grammar - Annotation'!annotationTag	^ (escapedCharacter / annotationMarkupSeparator / annotationEndMarkup) negate plus! !!PRPillarGrammar methodsFor: 'grammar - Format'!boldFormat	^ self formatFor: boldMarkup! !!PRPillarGrammar methodsFor: 'grammar - Format'!boldMarkup	^ (Markups at: PRBoldFormat) asPParser! !!PRPillarGrammar methodsFor: 'grammar - Text'!commentedLine	^ epsilonToken , 		(Markups at: PRCommentedLine) asPParser , 		lineEnd negate star flatten ,		epsilonToken! !!PRPillarGrammar methodsFor: 'grammar - Document'!content	^ oneLineContent , lineBreak optional! !!PRPillarGrammar methodsFor: 'grammar - Document'!contents	^ content plus! !!PRPillarGrammar methodsFor: 'grammar - List'!dataBasicListItem	^ (dataMarkup trimBlanks, listMarkup not , oneLineContent optional , lineEnd)		==> [ :array | array third ifNil: [ {} ] ]! !!PRPillarGrammar methodsFor: 'grammar - List'!dataListItem	"This and the overriden method of the parser are REALLY bad. We parse several times the same input, this is bad."	^	epsilonToken , 		dataMarkup and , 		dataBasicListItem optional , 		((commentedLine , newline) ==> [ :array | array first ]) star , 		dataSubListItem optional , 		epsilonToken! !!PRPillarGrammar methodsFor: 'grammar - List'!dataMarkup	^ (Markups at: PRDataItem) asPParser! !!PRPillarGrammar methodsFor: 'grammar - List'!dataSubListItem	^ ((dataMarkup , subList) / (commentedLine , newline) flatten) plus! !!PRPillarGrammar methodsFor: 'grammar - List'!definitionList	^ 	epsilonToken ,		(termListItem / dataListItem) plus , 		epsilonToken! !!PRPillarGrammar methodsFor: 'grammar - Document'!document	"A document contain everything that can be at the top of a document. It can contain for example some headers, paragraph, tables etc."	^ (elementsAtLineBeginning / paragraph) star! !!PRPillarGrammar methodsFor: 'grammar - Document'!elementWithNewline	^ (header / annotatedParagraph / anchor / commentedLine / horizontalRule , lineEnd) ==> #first! !!PRPillarGrammar methodsFor: 'grammar - Document'!elementsAtLineBeginning	^  elementWithNewline / list / script / table / commentedLine / preformatedText / emptyParagraph! !!PRPillarGrammar methodsFor: 'grammar - Paragraph'!emptyParagraph	^ epsilonToken , 		newline , 		epsilonToken ! !!PRPillarGrammar methodsFor: 'grammar - Helper'!epsilonToken	^ #epsilon asPParser token! !!PRPillarGrammar methodsFor: 'grammar - Document'!escapedCharacter	^ ($\ asPParser , #any asPParser) ==> #second! !!PRPillarGrammar methodsFor: 'grammar - Reference'!figure	^	epsilonToken , 		figureMarkup , 		figureAlias optional , 		referenceFigure , 		parametersFigure optional , 		figureMarkup ,		epsilonToken! !!PRPillarGrammar methodsFor: 'grammar - Reference'!figureAlias	^ 	epsilonToken ,		(escapedCharacter / 			(figureMarkup / referenceAliasMarkup) negate) star flatten , 		epsilonToken ,		referenceAliasMarkup! !!PRPillarGrammar methodsFor: 'grammar - Reference'!figureMarkup	^ (Markups at: PRFigure) asPParser! !!PRPillarGrammar methodsFor: 'grammar - Reference'!figureReference	^ (figureMarkup / parameterMarkup) negate plus flatten! !!PRPillarGrammar methodsFor: 'grammar - Format'!format	"Now a format can be empty (use of star instead of plus in these parsers). Do we really want this ? Some unit tests specify that a format can be empty but we can remove them'."		^ monospaceFormat / boldFormat / italicFormat / underlineFormat / strikethroughFormat / subscriptFormat / superscriptFormat! !!PRPillarGrammar methodsFor: 'from markdown'!formatContent	^ 	epsilonToken ,		(escapedCharacter / specialFormatMarkups negate) plus ,		epsilonToken! !!PRPillarGrammar methodsFor: 'grammar - Format'!formatFor: aMarkupParser	^ 	epsilonToken ,		aMarkupParser , 		(aMarkupParser not , ( otherContent / formatContent)) star , 		aMarkupParser,		epsilonToken! !!PRPillarGrammar methodsFor: 'grammar - Header'!header	"A header begin by a certain amount of $!! and contains a text and/or some formatedText"	^ 	epsilonToken ,		(Markups at: PRHeader) asPParser plus , 		oneLineContent optional trimBlanks , 		epsilonToken! !!PRPillarGrammar methodsFor: 'grammar - HorizontalRule'!horizontalRule	^ (Markups at: PRHorizontalRule) asPParser , #blank asPParser star! !!PRPillarGrammar methodsFor: 'grammar - Format'!italicFormat	^ self formatFor: italicMarkup! !!PRPillarGrammar methodsFor: 'grammar - Format'!italicMarkup	^ (Markups at: PRItalicFormat) asPParser! !!PRPillarGrammar methodsFor: 'grammar - Text'!lineBreak	^ newline , elementsAtLineBeginning not! !!PRPillarGrammar methodsFor: 'grammar - Document'!lineEnd	^ newline / #eoi asPParser! !!PRPillarGrammar methodsFor: 'grammar - Reference'!link	^ 	epsilonToken , 		linkMarkup , 		linkAlias optional , 		referenceLink , 		parametersLink optional , 		linkMarkup ,		epsilonToken! !!PRPillarGrammar methodsFor: 'grammar - Reference'!linkAlias	^ 	epsilonToken , 		(escapedCharacter / 			(linkMarkup / referenceAliasMarkup) negate) star flatten , 		epsilonToken ,		referenceAliasMarkup! !!PRPillarGrammar methodsFor: 'grammar - Reference'!linkMarkup	^ (Markups at: PRLink) asPParser! !!PRPillarGrammar methodsFor: 'grammar - List'!list	"The list elements should be trim."	^ (unorderedList / orderedList / definitionList) memoize! !!PRPillarGrammar methodsFor: 'grammar - List'!listMarkup	^ orderedMarkup / unorderedMarkup / termMarkup / dataMarkup! !!PRPillarGrammar methodsFor: 'grammar - List'!lists	^ list plus! !!PRPillarGrammar methodsFor: 'grammar - Format'!monospaceFormat	^ self formatFor: monospaceMarkup! !!PRPillarGrammar methodsFor: 'grammar - Format'!monospaceMarkup	^ (Markups at: PRMonospaceFormat) asPParser! !!PRPillarGrammar methodsFor: 'grammar - Document'!newline	^ String crlf asPParser / String lf asPParser / String cr asPParser! !!PRPillarGrammar methodsFor: 'grammar - Document'!oneLineContent	^ (otherContent / text) plus! !!PRPillarGrammar methodsFor: 'grammar - List'!orderedBasicListItem	^ (orderedMarkup trimBlanks, listMarkup not , oneLineContent optional , lineEnd)		==> [ :array | array third ifNil: [ {} ] ]! !!PRPillarGrammar methodsFor: 'grammar - List'!orderedList	^ 	epsilonToken , 		orderedListItem plus , 		epsilonToken! !!PRPillarGrammar methodsFor: 'grammar - List'!orderedListItem	"This and the overriden method of the parser are REALLY bad. We parse several times the same input, this is bad."	^	epsilonToken , 		orderedMarkup and , 		orderedBasicListItem optional , 		((commentedLine , newline) ==> [ :array | array first ]) star , 		orderedSubListItem optional ,		epsilonToken! !!PRPillarGrammar methodsFor: 'grammar - List'!orderedMarkup	^ (Markups at: PROrderedList) asPParser! !!PRPillarGrammar methodsFor: 'grammar - List'!orderedSubListItem	^ ((orderedMarkup , subList) / (commentedLine , newline) flatten) plus! !!PRPillarGrammar methodsFor: 'grammar - Document'!otherContent	^ format / annotation / reference / raw! !!PRPillarGrammar methodsFor: 'grammar - Paragraph'!paragraph	^ 	epsilonToken ,		contents , 		lineEnd ,		epsilonToken! !!PRPillarGrammar methodsFor: 'grammar - Parameter'!parameterKeyUntilEndAnnotation	^ self parameterKeyUntilParser: annotationEndMarkup! !!PRPillarGrammar methodsFor: 'grammar - Parameter'!parameterKeyUntilEndFigure	^ self parameterKeyUntilParser: figureMarkup! !!PRPillarGrammar methodsFor: 'grammar - Parameter'!parameterKeyUntilEndLink	^ self parameterKeyUntilParser: linkMarkup! !!PRPillarGrammar methodsFor: 'grammar - Parameter'!parameterKeyUntilNewline	^ self parameterKeyUntilParser: newline! !!PRPillarGrammar methodsFor: 'grammar - Parameter'!parameterKeyUntilParser: aParser	^ 	epsilonToken ,		(escapedCharacter / (aParser / parameterMarkup / parameterValueMarkup) negate) star,		epsilonToken! !!PRPillarGrammar methodsFor: 'grammar - Parameter'!parameterMarkup	^ self class defaultMarkupParameter asPParser! !!PRPillarGrammar methodsFor: 'grammar - Parameter'!parameterUntilEndAnnotation	^ 	epsilonToken ,		parameterKeyUntilEndAnnotation , 		parameterValueUntilEndAnnotation optional , 		epsilonToken ! !!PRPillarGrammar methodsFor: 'grammar - Parameter'!parameterUntilEndFigure	^ parameterKeyUntilEndFigure , parameterValueUntilEndFigure optional! !!PRPillarGrammar methodsFor: 'grammar - Parameter'!parameterUntilEndLink	^ parameterKeyUntilEndLink , parameterValueUntilEndLink optional! !!PRPillarGrammar methodsFor: 'grammar - Parameter'!parameterUntilNewline	^ parameterKeyUntilNewline , parameterValueUntilNewline optional! !!PRPillarGrammar methodsFor: 'grammar - Parameter'!parameterValue	^ (figureMarkup / parameterMarkup) negate star flatten! !!PRPillarGrammar methodsFor: 'grammar - Parameter'!parameterValueMarkup	^ self class defaultMarkupParameterValue asPParser! !!PRPillarGrammar methodsFor: 'grammar - Parameter'!parameterValueUntilEndAnnotation	^ self parameterValueUntilParser: annotationEndMarkup! !!PRPillarGrammar methodsFor: 'grammar - Parameter'!parameterValueUntilEndFigure	^ self parameterValueUntilParser: figureMarkup! !!PRPillarGrammar methodsFor: 'grammar - Parameter'!parameterValueUntilEndLink	^ self parameterValueUntilParser: linkMarkup! !!PRPillarGrammar methodsFor: 'grammar - Parameter'!parameterValueUntilNewline	^ self parameterValueUntilParser: newline! !!PRPillarGrammar methodsFor: 'grammar - Parameter'!parameterValueUntilParser: aParser	^ 	(parameterValueMarkup , 		epsilonToken ,		(escapedCharacter / (aParser / parameterMarkup) negate) star , 		epsilonToken)! !!PRPillarGrammar methodsFor: 'grammar - Reference'!parametersFigure	^ (parameterMarkup , parametersUntilEndFigure) ==> [ :array | array second ]! !!PRPillarGrammar methodsFor: 'grammar - Reference'!parametersLink	^ (parameterMarkup , parametersUntilEndLink) ==> #second! !!PRPillarGrammar methodsFor: 'grammar - Parameter'!parametersUntilEndAnnotation	^ parameterUntilEndAnnotation , ((parameterMarkup , parameterUntilEndAnnotation) ==> [ :array | array second ]) star! !!PRPillarGrammar methodsFor: 'grammar - Parameter'!parametersUntilEndFigure	^ parameterUntilEndFigure		, ((parameterMarkup , parameterUntilEndFigure) ==> [ :array | array second ]) star! !!PRPillarGrammar methodsFor: 'grammar - Parameter'!parametersUntilEndLink	^ parameterUntilEndLink		, ((parameterMarkup , parameterUntilEndLink) ==> [ :array | array second ]) star! !!PRPillarGrammar methodsFor: 'grammar - Parameter'!parametersUntilNewline	^ parameterUntilNewline , ((parameterMarkup , parameterUntilNewline) ==> [ :array | array second ]) star! !!PRPillarGrammar methodsFor: 'grammar - Text'!preformatedLine	^ (Markups at: PRPreformatted) asPParser , lineEnd negate star flatten , lineEnd! !!PRPillarGrammar methodsFor: 'grammar - Text'!preformatedText	^ preformatedLine plus! !!PRPillarGrammar methodsFor: 'grammar - Raw'!raw	^ (Markups at: PRRaw) asPParser , rawType optional		, rawEndMarkup negate star flatten , rawEndMarkup! !!PRPillarGrammar methodsFor: 'grammar - Raw'!rawEndMarkup	^ (EndMarkups at: PRRaw) asPParser! !!PRPillarGrammar methodsFor: 'grammar - Raw'!rawType	^ (rawEndMarkup / rawTypeMarkup) negate plus flatten , rawTypeMarkup ==> [ :array | array first ] ! !!PRPillarGrammar methodsFor: 'grammar - Raw'!rawTypeMarkup	^ self class defaultMarkupRawType asPParser! !!PRPillarGrammar methodsFor: 'grammar - Reference'!reference	^ link / figure! !!PRPillarGrammar methodsFor: 'grammar - Reference'!referenceAliasMarkup	^ self class defaultMarkupReferenceAlias asPParser! !!PRPillarGrammar methodsFor: 'from markdown'!referenceContent	^ (escapedCharacter / specialReferenceMarkups negate) plus! !!PRPillarGrammar methodsFor: 'grammar - Reference'!referenceFigure	^ self referenceUntil: figureMarkup! !!PRPillarGrammar methodsFor: 'grammar - Reference'!referenceLink	^ self referenceUntil: linkMarkup! !!PRPillarGrammar methodsFor: 'grammar - Reference'!referenceUntil: aParser	^ (escapedCharacter / (aParser / parameterMarkup / newline) negate) plus! !!PRPillarGrammar methodsFor: 'grammar - Script'!script	| endParser |	endParser := newline asPParser , (EndMarkups at: PRCodeblock) asPParser , space star , lineEnd.	^	epsilonToken, 		(Markups at: PRCodeblock) asPParser , 		scriptParameters , 		endParser negate plus flatten , 		endParser,		epsilonToken! !!PRPillarGrammar methodsFor: 'grammar - Script'!scriptParameters	^ parametersUntilNewline , newline ==> [ :array | array first ]! !!PRPillarGrammar methodsFor: 'from markdown'!space	^ #blank asPParser! !!PRPillarGrammar methodsFor: 'from markdown'!specialFormatMarkups	^ boldMarkup  / italicMarkup / monospaceMarkup / strikethroughMarkup / subscriptMarkup / superscriptMarkup / underlineMarkup! !!PRPillarGrammar methodsFor: 'from markdown'!specialReferenceMarkups	^ referenceAliasMarkup / linkMarkup / figureMarkup! !!PRPillarGrammar methodsFor: 'grammar - Document'!start	^ document end! !!PRPillarGrammar methodsFor: 'grammar - Format'!strikethroughFormat	^ self formatFor: strikethroughMarkup! !!PRPillarGrammar methodsFor: 'grammar - Format'!strikethroughMarkup	^ (Markups at: PRStrikethroughFormat) asPParser! !!PRPillarGrammar methodsFor: 'grammar - List'!subList	^ (listMarkup plus , oneLineContent optional , lineEnd) flatten! !!PRPillarGrammar methodsFor: 'grammar - Format'!subscriptFormat	^ self formatFor: subscriptMarkup! !!PRPillarGrammar methodsFor: 'grammar - Format'!subscriptMarkup	^ (Markups at: PRSubscriptFormat) asPParser! !!PRPillarGrammar methodsFor: 'grammar - Format'!superscriptFormat	^ self formatFor: superscriptMarkup! !!PRPillarGrammar methodsFor: 'grammar - Format'!superscriptMarkup	^ (Markups at: PRSuperscriptFormat) asPParser! !!PRPillarGrammar methodsFor: 'grammar - Table'!table	"Todo: Add the possibility to have comment inside a table. See PRPillarGrammarTest>>testTableWithComment."	^ tableRow plus! !!PRPillarGrammar methodsFor: 'grammar - Table'!tableAlignMarkup	^ tableCenterMarkup / tableLeftMarkup / tableRightMarkup! !!PRPillarGrammar methodsFor: 'grammar - Table'!tableCell	| cellSeparator |	cellSeparator := (Markups at: PRTableCell) asPParser.	^ tableMarkups , (escapedCharacter / (cellSeparator / lineEnd) negate) star flatten! !!PRPillarGrammar methodsFor: 'grammar - Table'!tableCenterMarkup	^ self class defaultMarkupTableCenter asPParser! !!PRPillarGrammar methodsFor: 'grammar - Table'!tableHeadingMarkup	^ self class defaultMarkupTableHeader asPParser! !!PRPillarGrammar methodsFor: 'grammar - Table'!tableLeftMarkup	^ self class defaultMarkupTableLeft asPParser! !!PRPillarGrammar methodsFor: 'grammar - Table'!tableMarkups	| optionalParser |	optionalParser := (tableAlignMarkup / tableHeadingMarkup) optional.	^ (Markups at: PRTableCell) asPParser , optionalParser , optionalParser! !!PRPillarGrammar methodsFor: 'grammar - Table'!tableRightMarkup	^ self class defaultMarkupTableRight asPParser! !!PRPillarGrammar methodsFor: 'grammar - Table'!tableRow	^ tableCell plus , lineEnd! !!PRPillarGrammar methodsFor: 'grammar - List'!termBasicListItem	^ (termMarkup trimBlanks, listMarkup not , oneLineContent optional , lineEnd)		==> [ :array | array third ifNil: [ {} ] ]! !!PRPillarGrammar methodsFor: 'grammar - List'!termListItem	"This and the overriden method of the parser are REALLY bad. We parse several times the same input, this is bad."	^	epsilonToken , 		termMarkup and , 		termBasicListItem optional , 		((commentedLine , newline) ==> [ :array | array first ]) star , 		termSubListItem optional , 		epsilonToken ! !!PRPillarGrammar methodsFor: 'grammar - List'!termMarkup	^ (Markups at: PRTermItem) asPParser! !!PRPillarGrammar methodsFor: 'grammar - List'!termSubListItem	^ ((termMarkup , subList) / (commentedLine , newline) flatten) plus! !!PRPillarGrammar methodsFor: 'grammar - Text'!text	"Everything that is a pure text and nothing else (not a format, not a link, ...)"	^  epsilonToken, 		(escapedCharacter / ((newline , elementsAtLineBeginning) / otherContent / lineEnd) negate) plus, 		epsilonToken! !!PRPillarGrammar methodsFor: 'grammar - Format'!underlineFormat	^ self formatFor: underlineMarkup! !!PRPillarGrammar methodsFor: 'grammar - Format'!underlineMarkup	^ (Markups at: PRUnderlineFormat) asPParser! !!PRPillarGrammar methodsFor: 'grammar - List'!unorderedBasicListItem	^ (unorderedMarkup trimBlanks, listMarkup not , oneLineContent optional , lineEnd)		==> [ :array | array third ifNil: [ {} ] ]! !!PRPillarGrammar methodsFor: 'grammar - List'!unorderedList	^ 	epsilonToken , 		unorderedListItem plus , 		epsilonToken! !!PRPillarGrammar methodsFor: 'grammar - List'!unorderedListItem	"This and the overriden method of the parser are REALLY bad. We parse several times the same input, this is bad."	^	epsilonToken , 		unorderedMarkup and , 		unorderedBasicListItem optional , 		((commentedLine , newline) ==> [ :array | array first ]) star , 		unorderedSubListItem optional ,		epsilonToken! !!PRPillarGrammar methodsFor: 'grammar - List'!unorderedMarkup	^ (Markups at: PRUnorderedList) asPParser! !!PRPillarGrammar methodsFor: 'grammar - List'!unorderedSubListItem	^ ((unorderedMarkup , subList) / (commentedLine , newline) flatten) plus! !!PRPillarParser class methodsFor: 'parsing'!parse: aStream	^ self new optimize parse: aStream! !!PRPillarParser methodsFor: 'grammar - Anchor'!anchor	"An anchor is just a line that begin with the character $@ and contains a text that we trim."	^ super anchor ==> [ :array | PRAnchor named: array second ]! !!PRPillarParser methodsFor: 'grammar - Paragraph'!annotatedParagraph	^ super annotatedParagraph		==> [ :array | 				(PRAnnotatedParagraph 					withAll: (array fourth						ifNil: [ {} ] 						ifNotNil: [ :elem | elem second ]) 					annotation: array third)						start: array first start;						stop: array last stop ]! !!PRPillarParser methodsFor: 'grammar - Annotation'!annotation	^ super annotation ==> [ :array | 			(array third withParameters: (array fourth ifNil: [ PRParameters new ]))				start: array first start;				stop: array sixth stop ]! !!PRPillarParser methodsFor: 'grammar - Annotation'!annotationParameters	^ super annotationParameters ==> [ :array | self parametersObjectFrom: array ]! !!PRPillarParser methodsFor: 'grammar - Annotation'!annotationTag	^ super annotationTag		==> [ :array | | aTagName |				aTagName := self stringFrom: array.				PRAbstractAnnotation 					findClassAcceptingTag: aTagName					ifNone: [ PRValidation strategy missingAnnotationSupport: aTagName ] ]! !!PRPillarParser methodsFor: 'grammar - Format'!boldFormat	^ super boldFormat ==> [ :array | self formatForArray: array ]! !!PRPillarParser methodsFor: 'grammar - Format'!boldMarkup	^ super boldMarkup ==> [ :token | PRBoldFormat ]! !!PRPillarParser methodsFor: 'grammar - Text'!commentedLine	^ super commentedLine ==> [ :array | 		(PRCommentedLine content: array third)			start: array first start;			stop: array last stop ]! !!PRPillarParser methodsFor: 'grammar - Document'!content	^ super content ==> [ :array | array second ifNil: [ {array first} ] ifNotNil: [ array ] ]! !!PRPillarParser methodsFor: 'grammar - Document'!contents	^ super contents		==> [ :array | 			| result |			result := OrderedCollection new.			array				do: [ :each | 					result addAll: each first.					each size = 2						ifTrue: [ result add: each second ] ].			result ]! !!PRPillarParser methodsFor: 'grammar - List'!dataListItem	^ super dataListItem		==> [ :array | 			| item |			item := array second withAll: (array third ifNil: [ {} ]).			item addAll: array fourth.			array fifth ifNotNil: [ :fifth | item addAll: (self listsParser parse: fifth) ].			item				start: array first start;				stop: array last stop.			item ]! !!PRPillarParser methodsFor: 'grammar - List'!dataMarkup	^ super dataMarkup ==> [ :token | PRDataItem ]! !!PRPillarParser methodsFor: 'grammar - List'!dataSubListItem	^ super dataSubListItem		==>			[ :array | 			| result |			result := '' writeStream.			array				do: [ :elem | 					elem isString						ifTrue: [ result nextPutAll: elem ]						ifFalse: [ result nextPutAll: elem second ] ].			result contents ]! !!PRPillarParser methodsFor: 'grammar - List'!definitionList	^ super definitionList ==> [ :array | 			(PRDefinitionList withAll: array second)				start: array first start;				stop: array last stop ]! !!PRPillarParser methodsFor: 'grammar - Document'!document	"I build a PRDocument. I get a collection with all the children of the PRDocument and I dd them one by one."	^ super document ==> [ :array | PRDocument withAll: array ]! !!PRPillarParser methodsFor: 'grammar - Paragraph'!emptyParagraph	^ super emptyParagraph ==> [ :array |		PREmptyParagraph new start: array first start; stop: array third stop ]! !!PRPillarParser methodsFor: 'grammar - Reference'!figure	^ super figure ==> [ :array | 			| fig |			fig := PRFigure reference: array fourth.			fig addAll: (array third ifNil: [ {} ]).			fig parameters: (array fifth ifNil: [ OrderedDictionary new ]).			fig start: array first start; stop: array last stop.			fig ]! !!PRPillarParser methodsFor: 'grammar - Reference'!figureAlias	^ super figureAlias ==> [ :anArray | 			anArray second				ifEmpty: [ { (PRText content: '') start: anArray first start; stop: anArray first start } ]				ifNotEmpty: [ 					| aCollection |					aCollection := (self parse: anArray second startingAt: #oneLineContent).					aCollection do: [ :each | 						each start: each start + anArray first start - 1.						each stop: each stop + anArray first start - 1 ] ] ]! !!PRPillarParser methodsFor: 'from markdown'!formatContent	^ super formatContent ==> [ :array | 		(PRText content: (self stringFrom: array second))			start: array first start;			stop: array third stop ]! !!PRPillarParser methodsFor: 'grammar - Format'!formatForArray: array	^ (array second withAll: (array third collect: [ :each | each second ]))		start: array first start;		stop: array last stop! !!PRPillarParser methodsFor: 'grammar - Header'!header	"I create a PRHeader"	^ super header ==> [ :array | 		(PRHeader 			withAll: (array third ifNil: [ {} ]) 			level: array second size)			start: array first start;			stop: array last stop ]! !!PRPillarParser methodsFor: 'grammar - HorizontalRule'!horizontalRule	^ super horizontalRule ==> [ :array | PRHorizontalRule new ]! !!PRPillarParser methodsFor: 'grammar - Format'!italicFormat	^ super italicFormat ==> [ :array | self formatForArray: array ]! !!PRPillarParser methodsFor: 'grammar - Format'!italicMarkup	^ super italicMarkup ==> [ :token | PRItalicFormat ]! !!PRPillarParser methodsFor: 'grammar - Document'!lineBreak	^ super lineBreak ==> [ :array | PRLineBreak new ]! !!PRPillarParser methodsFor: 'grammar - Reference'!link	^ super link		==>			[ :array | 			| linkRes |			linkRes := PRLink fromReference: array fourth.			array third ifNotNil: [ :aliasChildren | linkRes addAll: aliasChildren ].			linkRes parameters: (array fifth ifNil: [ OrderedDictionary new ]).			linkRes start: array first start; stop: array last stop.			linkRes ]! !!PRPillarParser methodsFor: 'grammar - Reference'!linkAlias	^ super linkAlias ==> [ :anArray | 			anArray second				ifEmpty: [ { (PRText content: '') start: anArray first start; stop: anArray first start } ]				ifNotEmpty: [ 					| aCollection |					aCollection := (self parse: anArray second startingAt: #oneLineContent).					aCollection do: [ :each | 						each start: each start + anArray first start - 1.						each stop: each stop + anArray first start - 1 ] ] ]! !!PRPillarParser methodsFor: 'helpers'!listsParser	"We cache the lists parser to be faster"	"Attention: we refer to PRPillarParser explicitely here instead of using ==self== so that the PRPillarCompiled parser, if it exists, can work."	^ self 		propertyAt: #listsParser 		ifAbsentPut: [ (PRPillarParser newStartingAt: #lists) optimize ]! !!PRPillarParser methodsFor: 'helpers'!literalFrom: characterArray	^ PRParserUtility convertToPharoObject: (self stringFrom: characterArray)! !!PRPillarParser methodsFor: 'grammar - Format'!monospaceFormat	^ super monospaceFormat ==> [ :array | self formatForArray: array ]! !!PRPillarParser methodsFor: 'grammar - Format'!monospaceMarkup	^ super monospaceMarkup ==> [ :token | PRMonospaceFormat ]! !!PRPillarParser methodsFor: 'grammar - List'!orderedList	^ super orderedList ==> [ :array | 			(PROrderedList withAll: array second)				start: array first start;				stop: array last stop ]! !!PRPillarParser methodsFor: 'grammar - List'!orderedListItem	^ super orderedListItem		==> [ :array | 			| item |			item := PRListItem withAll: (array third ifNil: [ {} ]).			item addAll: array fourth.			array fifth ifNotNil: [ :fifth | item addAll: (self listsParser parse: fifth) ].			item				start: array first start;				stop: array last stop.			item ]! !!PRPillarParser methodsFor: 'grammar - List'!orderedSubListItem	^ super orderedSubListItem		==>			[ :array | 			| result |			result := '' writeStream.			array				do: [ :elem | 					elem isString						ifTrue: [ result nextPutAll: elem ]						ifFalse: [ result nextPutAll: elem second ] ].			result contents ]! !!PRPillarParser methodsFor: 'grammar - Paragraph'!paragraph	^ super paragraph ==> [ :array | 		(PRParagraph withAll: array second)			start: array first start;			stop: array last stop ]! !!PRPillarParser methodsFor: 'grammar - Parameter'!parameterFrom: array	^ (PRParameter 			keyNode: array second 			valueNode: (array third ifNil: [ PRParserUtility newDefaultParameterValue ]))		start: array first start;		stop: array last stop! !!PRPillarParser methodsFor: 'grammar - Parameter'!parameterKeyFrom: array	^ (PRParameterKey named: (self stringFrom: array second))		start: array first start;		stop: array last stop! !!PRPillarParser methodsFor: 'grammar - Parameter'!parameterKeyUntilEndAnnotation	^ super parameterKeyUntilEndAnnotation ==> [ :array | self parameterKeyFrom: array ]! !!PRPillarParser methodsFor: 'grammar - Parameter'!parameterKeyUntilEndFigure	^ super parameterKeyUntilEndFigure ==> [ :array | self stringFrom: array second ]! !!PRPillarParser methodsFor: 'grammar - Parameter'!parameterKeyUntilEndLink	^ super parameterKeyUntilEndLink ==> [ :array | self stringFrom: array second ]! !!PRPillarParser methodsFor: 'grammar - Parameter'!parameterKeyUntilNewline	^ super parameterKeyUntilNewline ==> [ :array | self stringFrom: array second ]! !!PRPillarParser methodsFor: 'grammar - Parameter'!parameterUntilEndAnnotation	^ super parameterUntilEndAnnotation ==>			[ :array | self parameterFrom: array ]! !!PRPillarParser methodsFor: 'grammar - Parameter'!parameterValueFrom: array	^ (PRParameterValue value: (self literalFrom: array third))		start: array second start;		stop: array last stop! !!PRPillarParser methodsFor: 'grammar - Parameter'!parameterValueUntilEndAnnotation	^ super parameterValueUntilEndAnnotation ==> [ :array | self parameterValueFrom: array ]! !!PRPillarParser methodsFor: 'grammar - Parameter'!parameterValueUntilEndFigure	^ super parameterValueUntilEndFigure ==> [ :array | self stringFrom: array third ]! !!PRPillarParser methodsFor: 'grammar - Parameter'!parameterValueUntilEndLink	^ super parameterValueUntilEndLink ==> [ :array | self stringFrom: array third ]! !!PRPillarParser methodsFor: 'grammar - Parameter'!parameterValueUntilNewline	^ super parameterValueUntilNewline ==> [ :array | self stringFrom: array third ]! !!PRPillarParser methodsFor: 'grammar - Parameter'!parametersConvertToPharoObject: aString	"Convert if possible the aString argument into a Pharo object, we also replace nil by true"	"We assume that aString represents only one possible value"	| parsed |	aString ifNil: [ ^ true ]. 	"This is for the case where for example we have [[[foo, its value is nil and it should be true"	parsed := (RBParser parseFaultyExpression: aString).	^ parsed isLiteralNode 			ifTrue: [ parsed value]		ifFalse: [ aString ]	"^ [(Object readFrom: aString)			ifNil: [ aString trimBoth ]		ifNotNil: [ :e | e ]		] on: Exception  do: [ :e | PRSyntaxError signal: aString, ' is not a valid value'			aString ]"! !!PRPillarParser methodsFor: 'grammar - Reference'!parametersFigure	^ super parametersFigure ==> [ :array | self parametersFrom: array ]! !!PRPillarParser methodsFor: 'grammar - Parameter'!parametersFrom: array	| result |	result := OrderedDictionary new.		array first first		ifNotEmpty:			[ :string | 			result at: string trimBoth put: (self parametersConvertToPharoObject: array first second).			array second				do:					[ :each | each first ifNotEmpty: [ result at: each first trimBoth put: (self parametersConvertToPharoObject: each second) ] ] ].	^ result! !!PRPillarParser methodsFor: 'grammar - Reference'!parametersLink	^ super parametersLink ==> [ :array | self parametersFrom: array ]! !!PRPillarParser methodsFor: 'grammar - Parameter'!parametersObjectFrom: array	^ (PRParameters with: array fourth first withAll: array fourth second)			start: array third start;			stop: array fifth stop! !!PRPillarParser methodsFor: 'helpers'!parse: anObject startingAt: aRule	^ (self class newStartingAt: aRule) parse: anObject! !!PRPillarParser methodsFor: 'grammar - Text'!preformatedLine	^ super preformatedLine ==> [ :array | PRText content: array second ]! !!PRPillarParser methodsFor: 'grammar - Text'!preformatedText	^ super preformatedText ==> [ :array | PRPreformatted withAll: array ]! !!PRPillarParser methodsFor: 'grammar - Raw'!raw	^ super raw		==>			[ :array | 			| contentRaw |			contentRaw := '' writeStream.			contentRaw nextPutAll: array third.			PRRaw content: contentRaw contents type: array second ]! !!PRPillarParser methodsFor: 'from markdown'!referenceContent	^ super referenceContent ==> [ :array | PRText content: (self stringFrom: array) ]! !!PRPillarParser methodsFor: 'grammar - Reference'!referenceFigure	"Todo: We should maybe check for a :// inside the reference and maybe an extension."	^ super referenceFigure ==> [ :array | self stringFrom: array ]! !!PRPillarParser methodsFor: 'grammar - Reference'!referenceLink	^ super referenceLink ==> [ :array | self stringFrom: array ]! !!PRPillarParser methodsFor: 'grammar - Script'!script	"I create a PRScript."	^ super script ==> [ :array | 		(PRCodeblock content: array fourth parameters: array third)			start: array first start;			stop: array last stop ]! !!PRPillarParser methodsFor: 'grammar - Script'!scriptParameters	^ super scriptParameters ==> [ :array | self parametersFrom: array ]! !!PRPillarParser methodsFor: 'grammar - Format'!strikethroughFormat	^ super strikethroughFormat ==> [ :array | self formatForArray: array ]! !!PRPillarParser methodsFor: 'grammar - Format'!strikethroughMarkup	^ super strikethroughMarkup ==> [ :token | PRStrikethroughFormat ]! !!PRPillarParser methodsFor: 'helpers'!stringFrom: characterArray	^ String streamContents: [ :stream | characterArray do: [ :character | stream nextPut: character ] ]! !!PRPillarParser methodsFor: 'grammar - Format'!subscriptFormat	^ super subscriptFormat ==> [ :array | self formatForArray: array ]! !!PRPillarParser methodsFor: 'grammar - Format'!subscriptMarkup	^ super subscriptMarkup ==> [ :token | PRSubscriptFormat ]! !!PRPillarParser methodsFor: 'grammar - Format'!superscriptFormat	^ super superscriptFormat ==> [ :array | self formatForArray: array ]! !!PRPillarParser methodsFor: 'grammar - Format'!superscriptMarkup	^ super superscriptMarkup ==> [ :token | PRSuperscriptFormat ]! !!PRPillarParser methodsFor: 'grammar - Table'!table	^ super table ==> [ :array | PRTable withAll: array ]! !!PRPillarParser methodsFor: 'grammar - Table'!tableCell	^ super tableCell		==>			[ :array | 			PRTableCell				align: array first first				heading: array first second				withAll:					(array second trim						ifEmpty: [ Array new ]						ifNotEmpty:							[ :string | self parse: string startingAt: #oneLineContent ]) ]! !!PRPillarParser methodsFor: 'grammar - Table'!tableCenterMarkup	^ super tableCenterMarkup ==> [ :token | #center ]! !!PRPillarParser methodsFor: 'grammar - Table'!tableHeadingMarkup	^ super tableHeadingMarkup ==> [ :token | true ]! !!PRPillarParser methodsFor: 'grammar - Table'!tableLeftMarkup	^ super tableLeftMarkup ==> [ :token | #left ]! !!PRPillarParser methodsFor: 'grammar - Table'!tableMarkups	^ super tableMarkups		==> [ :array | 			| result |			result := Array ofSize: 2.			result at: 2 put: (array second = true or: [ array third = true ]).			result				at: 1				put:					(array second isSymbol						ifTrue: [ array second ]						ifFalse: [ 							array third isSymbol								ifTrue: [ array third ] ]).			result ]! !!PRPillarParser methodsFor: 'grammar - Table'!tableRightMarkup	^ super tableRightMarkup ==> [ :token | #right ]! !!PRPillarParser methodsFor: 'grammar - Table'!tableRow	^ super tableRow		==> [ :array | 			| result |			result := PRTableRow new.			array first do: [ :cell | result add: cell ].			result ]! !!PRPillarParser methodsFor: 'grammar - List'!termListItem	^ super termListItem		==> [ :array | 			| item |			item := array second withAll: (array third ifNil: [ {} ]).			item addAll: array fourth.			array fifth ifNotNil: [ :fifth | item addAll: (self listsParser parse: fifth) ].			item				start: array first start;				stop: array last stop.			item ]! !!PRPillarParser methodsFor: 'grammar - List'!termMarkup	^ super termMarkup ==> [ :token | PRTermItem ]! !!PRPillarParser methodsFor: 'grammar - List'!termSubListItem	^ super termSubListItem		==>			[ :array | 			| result |			result := '' writeStream.			array				do: [ :elem | 					elem isString						ifTrue: [ result nextPutAll: elem ]						ifFalse: [ result nextPutAll: elem second ] ].			result contents ]! !!PRPillarParser methodsFor: 'grammar - Text'!text	"A text is a PRText with a string that contains any character inside."	^ super text ==> [ :array | 			(PRText content: (self stringFrom: array second))				start: array first start;				stop: array third start - 1 ]! !!PRPillarParser methodsFor: 'grammar - Format'!underlineFormat	^ super underlineFormat ==> [ :array | self formatForArray: array ]! !!PRPillarParser methodsFor: 'grammar - Format'!underlineMarkup	^ super underlineMarkup ==> [ :token | PRUnderlineFormat ]! !!PRPillarParser methodsFor: 'grammar - List'!unorderedList	^ super unorderedList ==> [ :array | 			(PRUnorderedList withAll: array second)				start: array first start;				stop: array last stop ]! !!PRPillarParser methodsFor: 'grammar - List'!unorderedListItem	^ super unorderedListItem		==> [ :array | 			| item |			item := PRListItem withAll: (array third ifNil: [ {} ]).			item addAll: array fourth.			array fifth ifNotNil: [ :fifth | item addAll: (self listsParser parse: fifth) ].			item				start: array first start;				stop: array last stop.			item ]! !!PRPillarParser methodsFor: 'grammar - List'!unorderedSubListItem	^ super unorderedSubListItem		==>			[ :array | 			| result |			result := '' writeStream.			array				do: [ :elem | 					elem isString						ifTrue: [ result nextPutAll: elem ]						ifFalse: [ result nextPutAll: elem second ] ].			result contents ]! !!PRParserUtility class methodsFor: 'pharo environment'!convertToPharoObject: aString	"Convert if possible the aString argument into a Pharo object.	We also replace nil by true.	We assume that aString represents only one possible value"	| parsed |	aString ifNil: [ ^ true ]. 	"This is for the case where for example we have [[[foo, its value is nil and it should be true"	parsed := (RBParser parseFaultyExpression: aString).	^ parsed isLiteralNode 			ifTrue: [ parsed value]		ifFalse: [ aString ]! !!PRParserUtility class methodsFor: 'parameters'!defaultParameterValue	^ true! !!PRParserUtility class methodsFor: 'parameters'!fixFirstParameter: aPRParameters for: aPRAnnotation 	"The first parameter can be defined without parameter name.	In such situation, it is necessary to set properly parameter key and value."	| aParameter aValue |	aPRParameters size isZero ifTrue: [ ^ self ].	aParameter := aPRParameters children first.	((aPRAnnotation possibleParameters includes: aParameter key) or: [ 		aParameter value = PRParserUtility defaultParameterValue not ]) 			ifTrue: [ ^ self ].	aValue := self convertToPharoObject: aParameter keyNode name.	aParameter valueNode value: aValue.	aParameter valueNode start: aParameter keyNode start.	aParameter valueNode stop: aParameter keyNode stop.	aParameter keyNode name: aPRAnnotation defaultParameterName.	aParameter keyNode stop: aParameter keyNode start.! !!PRParserUtility class methodsFor: 'parameters'!newDefaultParameterValue	^ PRParameterValue value: self defaultParameterValue! !!PRPillarParserMain class methodsFor: 'compiled parser'!beCompiled	UseCompiledParser := true! !!PRPillarParserMain class methodsFor: 'compiled parser'!beNonCompiled	UseCompiledParser := false! !!PRPillarParserMain class methodsFor: 'compiled parser'!compileParser	PRPillarParser new compileWithOptions: {#parserName: . self compiledParserName asSymbol}.	^ Smalltalk classNamed: self compiledParserName	! !!PRPillarParserMain class methodsFor: 'compiled parser'!compiledParser	^ (self environment hasClassNamed: self compiledParserName)		ifTrue: [ self environment classNamed: self compiledParserName ]		ifFalse: [ self compileParser ]! !!PRPillarParserMain class methodsFor: 'compiled parser'!compiledParserName	^ 'PRPillarCompiled'! !!PRPillarParserMain class methodsFor: 'accessing'!documentParser	^ (self useCompiled and: [ Smalltalk globals hasClassNamed: 'PPCompiledParser' ])		ifTrue: [ self compiledParser ]		ifFalse: [ self usedParser ]! !!PRPillarParserMain class methodsFor: 'parsing'!parse: aStringOrStream	| stream hasProperties properties doc |	stream := aStringOrStream readStream.	[ stream atEnd			ifTrue: [ ^ PRDocument new ].		hasProperties := stream next = ${ and: [ stream next ~~ ${ ] ]			ensure: [ stream close ].		stream := aStringOrStream readStream.	[ properties := hasProperties			ifTrue: [ (STON reader on: stream) next ]			ifFalse: [ Dictionary new ].		doc := self parseDocument: stream upToEnd.		properties			keysAndValuesDo: [ :key :value | doc propertyAt: key put: value ].		^ doc ] ensure: [ stream close ]! !!PRPillarParserMain class methodsFor: 'parsing'!parse: aString startingAt: aSymbol	^ self documentParser parse: aString startingAt: aSymbol! !!PRPillarParserMain class methodsFor: 'parsing'!parseDocument: stream	^ self documentParser parse: stream! !!PRPillarParserMain class methodsFor: 'compiled parser'!useCompiled	^ UseCompiledParser ifNil: [ self beCompiled. UseCompiledParser ]! !!PRPillarParserMain class methodsFor: 'configuration'!usePetitParserTwo	UsedParser := PRPillarParser new optimize ! !!PRPillarParserMain class methodsFor: 'configuration'!usedParser	UsedParser ifNil: [ self usePetitParserTwo ].	^ UsedParser! !"Pillar-PetitPillar"!!PRPillarWriter commentStamp: '' prior: 0!I'm  a visitor of Pillar object entities that generates pillar file back. I collaborate with a PillarCanvas (which encodes the low level formatting). I start with start: anPillarEntity.Now I also propose some utilities to escape markup elements. !!PRPillarCanvas commentStamp: '' prior: 0!A pillar canvasInstance Variables	lastIsNewLine:		<Object>lastIsNewLine	- xxxxx!!PRPillarWriter class methodsFor: 'private'!escapeMarkup: markup	^ String streamContents: [ :str | markup do: [ :each | str nextPut: $\; nextPut: each ] ]! !!PRPillarWriter class methodsFor: 'accessing'!fileExtension	^ 'pillar'! !!PRPillarWriter class methodsFor: 'accessing'!folderName	^ #pillar! !!PRPillarWriter class methodsFor: 'accessing'!writerName	^ #pillar! !!PRPillarWriter methodsFor: 'accessing'!canvasClass	^ PRPillarCanvas! !!PRPillarWriter methodsFor: 'private'!escape: aString	^ self escape: aString all: markupsToEscape! !!PRPillarWriter methodsFor: 'private'!escape: aString all: anArray	^ anArray		inject: (self escape: aString using: '\')		into: [ :result :each | self escape: result using: each ]! !!PRPillarWriter methodsFor: 'private'!escape: aString during: aBlock	"Protect ==aString== (additionally to already existing protected strings) by adding $\ while evaluating ==aBlock==."	^ (markupsToEscape includes: aString)		ifTrue: aBlock		ifFalse: [ 			markupsToEscape add: aString.			aBlock ensure: [ markupsToEscape remove: aString ] ]! !!PRPillarWriter methodsFor: 'private'!escape: aString using: aSearchString	| string index escapedMarkup |	string := aString.	escapedMarkup := self escapeMarkup: aSearchString.	index := string findString: aSearchString.	[ index > 0 ] whileTrue: [		string := (string first: index - 1) , escapedMarkup , (string allButFirst: index - 1 + aSearchString size).		index := string findString: aSearchString startingAt: index + escapedMarkup size].	^ string! !!PRPillarWriter methodsFor: 'private'!escapeMarkup: markup	^ self class escapeMarkup: markup! !!PRPillarWriter methodsFor: 'initialize-release'!initialize	super initialize.	markupsToEscape := PRPillarParser textMarkups values asSet! !!PRPillarWriter methodsFor: 'accessing'!markupEndFor: aPRObject	"Return the ending character for a given Pillar entity. Given a script (environment) returns ']]]'"	^ PRPillarGrammar endMarkups at: aPRObject class! !!PRPillarWriter methodsFor: 'accessing'!markupFor: aPRObject	"Return the markup for a given pillar object. For example, given a pillar PRAnchor returns '@'"	^ PRPillarGrammar markups at: aPRObject class! !!PRPillarWriter methodsFor: 'private'!nest: aString do: aBlock	nesting add: aString.	aBlock ensure: [ nesting removeLast ]! !!PRPillarWriter methodsFor: 'visiting'!start: anObject	nesting := OrderedCollection new.	super start: anObject.	canvas lastIsNewLine		ifTrue: [ stream trimLastNewLine ]! !!PRPillarWriter methodsFor: 'visiting-document'!visitAnchor: anObject	canvas		raw: (self markupFor: anObject);		nextPutAll: anObject name;		newLine! !!PRPillarWriter methodsFor: 'visiting-document'!visitAnnotatedParagraph: anObject	canvas 		raw: (self markupFor: anObject);		nextPutAll: anObject annotation.	anObject hasChildren 		ifTrue: [ canvas space ].	super visitAnnotatedParagraph: anObject! !!PRPillarWriter methodsFor: 'visiting-document'!visitAnnotation: anAnnotation 		canvas raw: anAnnotation asPillar! !!PRPillarWriter methodsFor: 'visiting-document'!visitCodeblock: aCodeBlock	canvas raw: (self markupFor: aCodeBlock).	self visitParametersOf: aCodeBlock.	canvas		newLine;		nextPutAllLines: aCodeBlock text;		newLine;		raw: (self markupEndFor: aCodeBlock)! !!PRPillarWriter methodsFor: 'visiting-document'!visitCommentedLine: aCommentedLine	canvas potentialNewLine.	canvas raw: (self markupFor: aCommentedLine).	canvas raw: aCommentedLine text.! !!PRPillarWriter methodsFor: 'visiting-document'!visitDefinitionList: anObject	canvas potentialNewLine.	anObject children do: [ :each |		self 			nest: (self markupFor: each)			do: [ self visit: each ] ]! !!PRPillarWriter methodsFor: 'visiting-document'!visitDocument: aDocument	| propertiesSton |	aDocument properties ifNotEmpty: [		propertiesSton := String new: 100 streamContents: [ :internalStream |		(STON writer on: internalStream) nextPut: aDocument properties ].		canvas raw: propertiesSton.		canvas newLine ].	super visitDocument: aDocument! !!PRPillarWriter methodsFor: 'visiting-document'!visitFigure: aFigure	canvas raw: (self markupFor: aFigure).	super visitFigure: aFigure.	canvas raw: (self markupFor: aFigure)! !!PRPillarWriter methodsFor: 'visiting-document'!visitFormat: anObject	canvas raw: (self markupFor: anObject).	super visitFormat: anObject.	canvas raw: (self markupFor: anObject)! !!PRPillarWriter methodsFor: 'visiting-document'!visitHeader: aHeader	aHeader level timesRepeat: [ canvas raw: (self markupFor: aHeader) ].	super visitHeader: aHeader.	canvas newLine! !!PRPillarWriter methodsFor: 'visiting-document'!visitHorizontalRule: anHorizontalRule	canvas		raw: (self markupFor: anHorizontalRule);		newLine! !!PRPillarWriter methodsFor: 'visiting-document'!visitLink: aLink	canvas raw: (PRPillarParser markups at: PRLink).	super visitLink: aLink.	canvas raw: (PRPillarParser markups at: PRLink)! !!PRPillarWriter methodsFor: 'visiting-document'!visitList: aList	canvas potentialNewLine.	self nest: (self markupFor: aList) do: [ super visitList: aList ]! !!PRPillarWriter methodsFor: 'visiting-document'!visitListItem: aListItem	nesting do: [ :each | canvas raw: each ].	super visitListItem: aListItem.	canvas potentialNewLine.! !!PRPillarWriter methodsFor: 'visiting-document'!visitParagraph: aParagraph	super visitParagraph: aParagraph.	canvas newLine! !!PRPillarWriter methodsFor: 'visiting-document'!visitParametersOf: objectWithParams	| needSeparator |	self flag: 'TODO: fix this ugly code. Caption here are treated separately because they contain Pillar text in a string (and this string should not be protected)'.	needSeparator := false.	objectWithParams parameters associations		do:			[ :assoc | 			assoc key = 'caption'				ifFalse:					[ needSeparator := true.					canvas nextPutAll: assoc key.					assoc value						ifNotNil:							[ :value | 							canvas								raw: PRPillarParser defaultMarkupParameterValue;								nextPutAll: value asString ] ] ]		separatedBy: [ canvas raw: PRPillarParser defaultMarkupParameter ].	objectWithParams parameters at: 'caption'		ifPresent:			[ :caption | needSeparator				ifTrue: [ canvas raw: PRPillarParser defaultMarkupParameter ].			canvas				nextPutAll: 'caption';				raw: PRPillarParser defaultMarkupParameterValue.				stream << [ self visitAll: objectWithParams caption children ] ]! !!PRPillarWriter methodsFor: 'visiting-document'!visitPreformatted: aPreformatted	self		writeRawDuring: [ 			aPreformatted children				do: [ :child | 					canvas raw: (self markupFor: aPreformatted).					self visit: child.					canvas newLine ] ]! !!PRPillarWriter methodsFor: 'visiting-document'!visitRaw: anObject	canvas raw: (self markupFor: anObject).	anObject type		ifNotNil: [ canvas				nextPutAll: anObject type;				raw: PRPillarParser defaultMarkupRawType ].	canvas raw: anObject text.	canvas raw: (self markupEndFor: anObject)! !!PRPillarWriter methodsFor: 'visiting-document'!visitReference: aReference	aReference hasAlias		ifTrue: [ super visitReference: aReference.			canvas raw: PRPillarParser defaultMarkupReferenceAlias ].	canvas raw: (aReference reference ifNil: [ '' ]).	aReference hasAnchor		ifTrue: [ canvas raw: PRPillarParser defaultMarkupReferenceAnchor.			canvas nextPutAll: aReference anchor ].	aReference hasParameters		ifTrue: [ canvas raw: PRPillarParser defaultMarkupParameter.			self visitParametersOf: aReference ]! !!PRPillarWriter methodsFor: 'visiting-document'!visitTableCell: anObject	| cellMarkup |	cellMarkup := self markupFor: anObject.	canvas raw: cellMarkup.	anObject isAligned ifTrue: [		anObject isAlignedLeft ifTrue: [ canvas raw: PRPillarParser defaultMarkupTableLeft ].		anObject isAlignedCenter ifTrue: [ canvas raw: PRPillarParser defaultMarkupTableCenter ].		anObject isAlignedRight ifTrue: [ canvas raw: PRPillarParser defaultMarkupTableRight ] ].	anObject isHeading ifTrue: [ canvas raw: PRPillarParser defaultMarkupTableHeader ].	self escape: cellMarkup during: [	super visitTableCell: anObject ]! !!PRPillarWriter methodsFor: 'visiting-document'!visitTableRow: aTableRow	super visitTableRow: aTableRow.	canvas newLine! !!PRPillarWriter methodsFor: 'visiting-document'!visitText: anObject	"Write out ==anObject=='s text to the receivers output-stream and escape special characters within and at the beginning of a line."	| string |	string := anObject text.	writingRaw		ifTrue: [ canvas rawLines: string.			^ self ].	canvas lastIsNewLine		ifTrue: [ | markup |			markup := PRPillarParser lineMarkups values				detect: [ :each | string beginsWith: each ]				ifNone: [ nil ].			markup				ifNotNil: [ canvas						nextPut: $\;						raw: markup.					string := string allButFirst: markup size ] ].	canvas raw: (self escape: string)! !!PRPillarCanvas class methodsFor: 'class initialization'!initialize	" self initialize "	PillarCharacters := Dictionary new.	PRPillarGrammar markups		valuesDo:			[ :markup | 			markup				do:					[ :char | 					char = Character space						ifFalse: [ PillarCharacters at: char put: '\' , char asString ] ] ]! !!PRPillarCanvas methodsFor: 'initialization'!initialize	super initialize.	lastIsNewLine := true! !!PRPillarCanvas methodsFor: 'writing text'!lastIsNewLine	^ lastIsNewLine! !!PRPillarCanvas methodsFor: 'writing text'!newLine	super newLine.	lastIsNewLine := true! !!PRPillarCanvas methodsFor: 'writing text'!nextPut: aCharacter	(PillarCharacters at: aCharacter ifAbsent: nil) 		ifNil: [ super nextPut: aCharacter ] 		ifNotNil: [ :string | self raw: string ].	lastIsNewLine := false! !!PRPillarCanvas methodsFor: 'writing text'!potentialNewLine	lastIsNewLine		ifFalse: [ self newLine ]! !!PRPillarCanvas methodsFor: 'writing text'!raw: aString	super raw: aString.	lastIsNewLine := false.! !"Pillar-ExporterPillar"!!ManifestPillarExporterLaTeX commentStamp: '' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!PRLaTeXCanvas commentStamp: '' prior: 0!A LaTeX canvas!!PRLaTeXBrush commentStamp: '' prior: 0!A LaTeX brush!!PRLaTeXCommand commentStamp: '' prior: 0!A LaTeX commandto emit \mycommand potentially with arguments and optionals. \mycommand[1]{#1}!!PRLaTeXEnvironment commentStamp: '' prior: 0!A LaTeX environmentTo emit\begin{XXX}kjlkjkl\end{XXX}!!PRLaTeXWriter commentStamp: '' prior: 0!A LaTeX writer!!PRSBALaTeXWriter commentStamp: '' prior: 0!Writes LaTeX code in the style expected by sbabook (https://github.com/cdlm/sbabook). sbabook is a special LaTeX book class for our technical books.!!PRLatexPathUpdateVisitor commentStamp: '' prior: 0!I am a pillar visitor that updates all references to be latex compatible. I am particularly useful in windows platforms that use the \ delimiter, which is not correctly parsed by the latex compiler.Latex Paths have to use the / delimiter, even in windows. The following are examples of correct paths:/usr/lib/blaC:/Program Files/Something!!PRTable methodsFor: '*Pillar-ExporterLaTeX'!latexSpecification	^ String new: self columnCount withAll: $l! !!PRRelativeReferenceTransformer methodsFor: 'accessing'!baseDirectory	^ baseDirectory! !!PRRelativeReferenceTransformer methodsFor: 'accessing'!baseDirectory: anObject	baseDirectory := anObject! !!PRRelativeReferenceTransformer methodsFor: 'accessing'!destinationDirectoryFor: aDocument 		| filePath relativePath |	filePath := inputFile parent.	relativePath := filePath asAbsolute relativeTo: baseDirectory asAbsolute.	^ outputDirectory resolve: relativePath.! !!PRRelativeReferenceTransformer methodsFor: 'actions'!executeOn: aPRDocument	PRUpdateFileInclusionReference		start: aPRDocument		with: (PRLaTeXWriter toLatexPath: (self destinationDirectoryFor: aPRDocument) fullName).	^ aPRDocument! !!PRRelativeReferenceTransformer methodsFor: 'accessing'!inputFile	^ inputFile! !!PRRelativeReferenceTransformer methodsFor: 'accessing'!inputFile: anObject	inputFile := anObject! !!PRRelativeReferenceTransformer methodsFor: 'accessing'!outputDirectory	^ outputDirectory! !!PRRelativeReferenceTransformer methodsFor: 'accessing'!outputDirectory: anObject	outputDirectory := anObject! !!PRRelativeReferenceTransformer methodsFor: 'execution'!start: aPRDocument 		^ self executeOn: aPRDocument! !!PRNoScriptLanguage methodsFor: '*Pillar-ExporterLaTeX'!sbaString	^ 'plain'! !!PRAbstractScriptLanguage methodsFor: '*Pillar-ExporterLaTeX'!sbaString	"was ^ self printString but this prevents us to improve the printOn: for debugging purpose.			[[[language=bash	...	]]]	And that generated the following broken latex:	\begin{displaycode}{a PRBashScriptLanguage[635751168] (bash)}	Let us try with standardName	"	^ self class standardName	! !!ManifestPillarExporterLaTeX class methodsFor: 'code-critics'!ruleRBSendsDifferentSuperRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#PRLaTeXWriter #visitAnnotatedParagraph: #false)) #'2015-09-24T11:14:45.010115+02:00') )! !!PRLaTeXCanvas class methodsFor: 'class initialization'!initialize	" self initialize "	LatexCharacters := Dictionary new.	LatexCharacters		at: $# put: '\#';		at: $& put: '\&';		at: $% put: '\%';		at: $$ put: '\$';		at: ${ put: '\{';		at: $} put: '\}';		at: $_ put: '\_';		at: $" put: '\symbol{34}';		" -- "		at: $[ put: '{[}';		at: $] put: '{]}';		at: $| put: '\textbar{}';		at: $< put: '\textless{}';		at: $> put: '\textgreater{}';		"at: $/ put: '\slash{}';"		at: $\ put: '\textbackslash{}';		at: $^ put: '\string^';		" -- "		at: $ä put: '\"{a}';		at: $Ä put: '\"{A}';		at: $ë put: '\"{e}';		at: $Ë put: '\"{E}';		at: $ï put: '\"{i}';		at: $Ï put: '\"{I}';		at: $ö put: '\"{o}';		at: $Ö put: '\"{O}';		at: $ü put: '\"{u}';		at: $Ü put: '\"{U}';		at: $ÿ put: '\"{y}';		at: (Character value: 159) put: '\"{Y}';		" -- "		at: $â put: '\^{a}';		at: $Â put: '\^{A}';		at: $ê put: '\^{e}';		at: $Ê put: '\^{E}';		at: $î put: '\^{i}';		at: $Î put: '\^{I}';		at: $ô put: '\^{o}';		at: $Ô put: '\^{O}';		at: $û put: '\^{u}';		at: $Û put: '\^{U}';		" -- "		at: $à put: '\`{a}';		at: $À put: '\`{A}';		at: $è put: '\`{e}';		at: $È put: '\`{E}';		at: $ì put: '\`{i}';		at: $Ì put: '\`{I}';		at: $ò put: '\`{o}';		at: $Ò put: '\`{O}';		at: $ù put: '\`{u}';		at: $Ù put: '\`{U}';		" -- "		at: $á put: '\''{a}';		at: $Á put: '\''{A}';		at: $é put: '\''{e}';		at: $í put: '\''{i}';		at: $Í put: '\''{I}';		at: $ó put: '\''{o}';		at: $Ó put: '\''{O}';		at: $ú put: '\''{u}';		at: $Ú put: '\''{U}';		" -- "		at: $ç put: '\c{c}';		at: $Ç put: '\c{C}';		" -- "		at: $~ put: '\textasciitilde{}';		at: $ñ put: '\~{n}';		at: $Ñ put: '\~{N}'! !!PRLaTeXCanvas methodsFor: 'tags'!command	^ self brush: PRLaTeXCommand new! !!PRLaTeXCanvas methodsFor: 'tags'!environment	^ self brush: PRLaTeXEnvironment new! !!PRLaTeXCanvas methodsFor: 'writing text'!nextPut: aCharacter	(LatexCharacters at: aCharacter ifAbsent: nil)		ifNil: [ super nextPut: aCharacter ]		ifNotNil: [ :string | self raw: string ]! !!PRLaTeXBrush methodsFor: 'accessing'!optParameter: aString 	stream		<< $[		<< aString		<< $]! !!PRLaTeXBrush methodsFor: 'accessing'!parameter: aString 	stream		<< ${		<< aString		<< $}! !!PRLaTeXCommand methodsFor: 'accessing'!name: aString 	stream		<< $\		<< aString! !!PRLaTeXEnvironment methodsFor: 'accessing'!name: aString	name := aString.	stream newLine.	stream << '\begin{' << aString << '}'! !!PRLaTeXEnvironment methodsFor: 'accessing'!with: aBlock	stream newLine.	aBlock value.	(stream << '\end{' << name)		<< '}';		newLine! !!PRPDFDocument methodsFor: 'writing'!basicWriter		^ target writerFor: project configuration! !!PRPDFDocument methodsFor: 'compiling'!executeCommand: command arguments: arguments workingDirectory: aWorkingDirectory	OSPlatform current isWindows ifTrue: [ 		^ self			executeOnWindowsCommand: command			arguments: arguments			workingDirectory: aWorkingDirectory	].	^ self		executeOnUnixCommand: command		arguments: arguments		workingDirectory: aWorkingDirectory! !!PRPDFDocument methodsFor: 'compiling'!executeOnUnixCommand: command arguments: arguments workingDirectory: aWorkingDirectory	| process |	process := OSSUnixSubprocess new		command: command;		workingDirectory: aWorkingDirectory;		arguments: arguments;		runAndWait.	process isSuccess ifFalse: [		self error: 'command ', command ,' failed' ]! !!PRPDFDocument methodsFor: 'compiling'!executeOnWindowsCommand: command arguments: arguments workingDirectory: aWorkingDirectory	| process success commandString |	commandString := 'cd "', aWorkingDirectory, '" && ', command, ' ', (' ' join: arguments).		process := ProcessWrapper new.	process useStderr; useStdout.	success := process startWithShellCommand: commandString.	success ifFalse: [		self error: 'command ', commandString ,' failed' ].	success := process waitForExit.	success ifFalse: [		self error: 'command ', commandString ,' failed' ].		Transcript show: process stdoutStream upToEnd.	Transcript show: process stderrStream upToEnd.	process closeStdin.	process closeStderr.	process exitCode = 0 ifFalse: [		self error: 'command ', commandString ,' failed' ].! !!PRPDFDocument methodsFor: 'accessing'!extension		^ 'pdf'! !!PRPDFDocument methodsFor: 'accessing'!pdfTransformationsFor: aDocument	^ aDocument pdfTransformationsFor: self! !!PRPDFDocument methodsFor: 'writing'!postWriteTransform: aFile	| relativePath outputFileReference |	relativePath := file file asAbsolute relativeTo: project baseDirectory asAbsolute.	outputFileReference := outputDirectory resolve: relativePath parent.	self		executeCommand: 'latexmk'		arguments: {			'-pdflatex=lualatex' . 			'-pdf' .			'-ps-' .			'-f' .			'-interaction=nonstopmode' .			'-outdir=', (self toCommandPath: outputFileReference fullName).			self toCommandPath: (PRLaTeXWriter toLatexPath: (aFile relativeTo: outputDirectory) pillarPrintString) }		workingDirectory: outputDirectory fullName! !!PRPDFDocument methodsFor: 'compiling'!toCommandPath: aPathString	OSPlatform current isWindows ifTrue: [ 		^ aPathString surroundedBy: '"'	].	^ aPathString! !!PRPDFDocument methodsFor: 'accessing'!transformations	self halt.	^ super transformations		", self pdfTransformations to test if for MD we need them." ! !!PRPDFDocument methodsFor: 'accessing'!transformationsFor: aDocument		^ (super transformationsFor: aDocument)		, (self pdfTransformationsFor: aDocument)! !!PRPDFDocument methodsFor: 'writing'!writeDocument: aDocument	| content environment templatedOutput outputFile |		environment := self getMustacheTemplateValuesFromDocument: aDocument.	content := self writer write: aDocument.	environment at: #content put: content.	"so that we can force to have book.bib in the environment"	"we will have to fix that"	"environment at: #bibFile put: (environment bibFile)."	templatedOutput := (MustacheTemplate on: (self templateFile: aDocument) readStream contents) value: environment.	self flag: #DuplicatedInSuperclass.	outputFile := (self outputDirectory resolve: (file file asAbsolute relativeTo: project baseDirectory asAbsolute)) withoutExtension , 'tex'.	outputFile ensureDelete.	outputFile parent ensureCreateDirectory.	outputFile writeStreamDo: [ :stream | 		stream nextPutAll: templatedOutput ].	^ outputFile! !!PRLaTeXWriter class methodsFor: 'accessing'!fileExtension	^ 'tex'! !!PRLaTeXWriter class methodsFor: 'accessing'!folderName	^ #latex! !!PRLaTeXWriter class methodsFor: 'accessing'!toLatexPath: aString	"Replace all (windows style) back slashes in paths by (unix style) forward slashes.	This is required as path in latex only support unix style pathes like		  /home/xxx		or		  C:/home/xxx		See https://tex.stackexchange.com/questions/9363/how-does-one-insert-a-backslash-or-a-tilde-into-latex	"	^ aString copyReplaceAll: '\' with: '/'! !!PRLaTeXWriter class methodsFor: 'accessing'!writerName	^ #latex! !!PRLaTeXWriter methodsFor: 'accessing'!canvasClass	^ PRLaTeXCanvas! !!PRLaTeXWriter methodsFor: 'templating'!chapterTemplateName		^ 'latexChapterTemplate'! !!PRLaTeXWriter methodsFor: 'helpers'!createLinkToLabelWithAlias: anInternalLink	canvas command		name: 'hyperref';		optParameter: [ canvas nextPutAll: anInternalLink anchor ];		parameter: [ 					anInternalLink counter isValidCounter						ifTrue: [ self writeCounter: anInternalLink counter ].					canvas nextPutAll: anInternalLink alias ]! !!PRLaTeXWriter methodsFor: 'helpers'!createLinkToLabelWithoutAlias: anInternalLink	canvas command		name: 'ref';		parameter: [ canvas raw: anInternalLink anchor ]! !!PRLaTeXWriter methodsFor: 'visiting-document'!getLevelFor: aHeader	^ aHeader level! !!PRLaTeXWriter methodsFor: 'visiting-document'!getTypeOfSectionFor: aHeader	| sections level section |	sections := self sectioningCommands.	level := self getLevelFor: aHeader.	section := sections at: (level min: sections size max: 1).	^ section! !!PRLaTeXWriter methodsFor: 'visiting-document'!includeGraphicsFor: aFigure	canvas command		name: 'includegraphics';		optParameter: [ self writeGraphicsParametersOfExternalLink: aFigure ];		parameter: [ canvas raw: (aFigure localFileOrExternalReference) ]! !!PRLaTeXWriter methodsFor: 'protected'!monospaceMacro	^ 'code'! !!PRLaTeXWriter methodsFor: 'helpers'!protectUrl: aString	^ ((aString copyReplaceAll: '\' with: '\\') copyReplaceAll: '#' with: '\#') copyReplaceAll: '%' with: '\%'! !!PRLaTeXWriter methodsFor: 'helpers'!sectioningCommands	^ #('part' 'chapter' 'section' 'subsection' 'subsubsection' 'paragraph' 'subparagraph')! !!PRLaTeXWriter methodsFor: 'protected'!tabularEnvironment	^ 'tabular'! !!PRLaTeXWriter methodsFor: 'visiting-document'!visitAnchor: anAnchor	canvas command		name: 'label';		parameter: anAnchor name! !!PRLaTeXWriter methodsFor: 'visiting-document'!visitAnnotatedParagraph: anAnnotatedParagraph	"Annotations need to be defined as environments in LaTeX include files (e.g. common.tex)"	canvas environment		name: anAnnotatedParagraph annotation;		with: [ super visitParagraph: anAnnotatedParagraph.			canvas newLine ]	"Attention: we do a super call on #visitParagraph: instead of #visitAnnotatedParagraph:. The goal of this hack is to avoid trailing new line characters. This is related to PRLaTeXWriterTest>>#testStrictLineBreaksInAnnotatedParagraphs"! !!PRLaTeXWriter methodsFor: 'visiting-document'!visitBoldFormat: aFormat	canvas command name: 'textbf'; parameter: [ super visitBoldFormat: aFormat ]! !!PRLaTeXWriter methodsFor: 'visiting-document'!visitCitation: aCitation	canvas command		name: 'cite';		parameter: aCitation ref.! !!PRLaTeXWriter methodsFor: 'visiting-document'!visitCodeblock: aCodeBlock	| env parameters |	parameters := OrderedCollection new.	aCodeBlock hasCaption		ifTrue: [ parameters add: 'caption={' , (self getStringForAll: aCodeBlock caption children), '}' ].	aCodeBlock hasLabel		ifTrue: [ parameters add: 'label=' , aCodeBlock label ].	(self languageForScript: aCodeBlock) isSyntaxHighlightingPossible		ifTrue:			[ parameters add: 'language=' , (self languageForScript: aCodeBlock) printString ].	env := canvas environment		name: 'listing';		yourself.	parameters ifNotEmpty: [ env optParameter: parameters asCommaString ].	env		with: [ self writeRawDuring: [ super visitCodeblock: aCodeBlock ].			canvas newLine ]! !!PRLaTeXWriter methodsFor: 'visiting-document'!visitDataItem: anItem	self visitAll: anItem children.	canvas newLine.! !!PRLaTeXWriter methodsFor: 'visiting-document'!visitDefinitionList: aList	canvas environment		name: 'description';		with: [ super visitDefinitionList: aList ]! !!PRLaTeXWriter methodsFor: 'visiting-document'!visitEmptyParagraph: aParagraph	! !!PRLaTeXWriter methodsFor: 'visiting-document'!visitExternalLink: anExternalLink	| text reference |	reference := anExternalLink localFileOrExternalReference.	text := anExternalLink text.	(text isEmptyOrNil or: [ reference = text ])		ifTrue: [ canvas command				name: 'url';				parameter: reference ]		ifFalse: [			canvas command				name: 'href';				parameter: reference;				parameter: [ canvas nextPutAll: text ].			canvas command				name: 'footnote';				parameter: [ canvas command name: 'url'; parameter: (self protectUrl: reference) ] ]! !!PRLaTeXWriter methodsFor: 'visiting-document'!visitFigure: aFigure	(aFigure hasCaption not and: [ aFigure hasLabel not ])		ifTrue: [ 			self includeGraphicsFor: aFigure.			^ self ].	canvas environment		name: 'figure';		with:				[ 			canvas environment				name: 'center';				with:						[ 					self includeGraphicsFor: aFigure.					canvas command						name: 'caption';						parameter: [ 							self								writeCaptionOfExternalLink: aFigure;								writeLabelOfExternalLink: aFigure ] ] ]! !!PRLaTeXWriter methodsFor: 'visiting-document'!visitFootnote: aFootnote	canvas command name: 'footnote'; parameter: (aFootnote note)! !!PRLaTeXWriter methodsFor: 'visiting-document'!visitHeader: aHeader	| section |	section := self getTypeOfSectionFor: aHeader.	canvas command		name: section;		parameter: [ super visitHeader: aHeader ]! !!PRLaTeXWriter methodsFor: 'visiting-document'!visitHorizontalRule: anHorizontalRule	canvas newLine; newLine.	canvas raw: '\rule{\textwidth}{0.1pt}'.	canvas newLine.! !!PRLaTeXWriter methodsFor: 'visiting-document'!visitInternalLink: anInternalLink	(anInternalLink reference isNil or: [ self configuration separateOutputFiles not ])		ifTrue: [ 			anInternalLink hasAlias				ifTrue: [ 					anInternalLink hasAnchor						ifTrue: [ self createLinkToLabelWithAlias: anInternalLink ]						ifFalse: [ 							PRLinkWarning								signal:									(PRPillarWriter write: anInternalLink)										,											' will not be render because you export without separate output files. If you want your link to be render add an anchor to the beginning of your file.'.							canvas nextPutAll: anInternalLink alias ] ]				ifFalse: [ 					anInternalLink hasAnchor						ifTrue: [ self createLinkToLabelWithoutAlias: anInternalLink ] ] ]		ifFalse: [ 			anInternalLink hasAlias				ifTrue: [ 					self flag: #todo.	"If we don't render the link we can put it as Footer. We need to do it."					canvas nextPutAll: anInternalLink alias ]				ifFalse: [ 					PRLinkWarning						signal:							(PRPillarWriter write: anInternalLink)								,									' will not be exported because LaTeX doesn''t support the inter-files links. Please add an Alias to keep this internal link.' ] ]! !!PRLaTeXWriter methodsFor: 'visiting-document'!visitItalicFormat: aFormat	canvas command name: 'textit'; parameter: [ super visitItalicFormat: aFormat ]! !!PRLaTeXWriter methodsFor: 'visiting-document'!visitListItem: anItem	canvas command name: 'item'.	canvas space.	canvas raw: [ super visitListItem: anItem ].	canvas newLine! !!PRLaTeXWriter methodsFor: 'visiting-document'!visitMailLink: aLink	canvas command		name: 'href';		parameter: aLink unscrambledUrl;		parameter: aLink alias! !!PRLaTeXWriter methodsFor: 'visiting-document'!visitMonospaceFormat: aFormat	canvas command		name: self monospaceMacro;		parameter: [ super visitMonospaceFormat: aFormat ]! !!PRLaTeXWriter methodsFor: 'visiting-document'!visitOrderedList: aList	canvas environment		name: 'enumerate';		with: [ super visitOrderedList: aList ]! !!PRLaTeXWriter methodsFor: 'visiting-document'!visitParagraph: aParagraph	canvas newLine.	super visitParagraph: aParagraph.	canvas newLine.! !!PRLaTeXWriter methodsFor: 'visiting-document'!visitPreformatted: aPreformatted	canvas environment		name: 'verbatim';		with: [ 					self						writeRawDuring: [ 							aPreformatted children								do: [ :child | 									self visit: child.									canvas newLine ] ] ]! !!PRLaTeXWriter methodsFor: 'visiting-document'!visitStrikethroughFormat: aFormat	canvas command name: 'sout'; parameter: [ super visitStrikethroughFormat: aFormat ]! !!PRLaTeXWriter methodsFor: 'visiting-document'!visitSubscriptFormat: aFormat	canvas command		name: 'textsubscript';		parameter: [ super visitSubscriptFormat: aFormat ]! !!PRLaTeXWriter methodsFor: 'visiting-document'!visitSuperscriptFormat: aFormat	canvas command		name: 'textsuperscript';		parameter: [ super visitSuperscriptFormat: aFormat ]! !!PRLaTeXWriter methodsFor: 'visiting-document'!visitTable: aTable	| environment |	environment := canvas environment name: self tabularEnvironment.	aTable rowCount = 0		ifTrue: [ environment with: [  ].			^ self ].	environment parameter: aTable latexSpecification.	environment		with: [ canvas command name: 'toprule'.			canvas newLine.			super visitTable: aTable.			canvas command name: 'bottomrule'.			canvas newLine ]! !!PRLaTeXWriter methodsFor: 'visiting-document'!visitTableCell: aCell	aCell isAligned		ifFalse: [ self writeTableCellContent: aCell ]		ifTrue: [ 			canvas command				name: 'multicolumn';				parameter: '1';				parameter: aCell latexAlignment;				parameter: [ self writeTableCellContent: aCell ] ]! !!PRLaTeXWriter methodsFor: 'visiting-document'!visitTableRow: aRow	self visitAll: aRow children separatedBy: [ canvas raw: ' & ' ].	canvas		raw: ' \\';		newLine.	aRow isHeading		ifTrue: [ 			canvas command name: 'midrule'.			canvas newLine ]! !!PRLaTeXWriter methodsFor: 'visiting-document'!visitTermItem: anItem	canvas command		name: 'item';		optParameter: [ self visitAll: anItem children ].	canvas space.! !!PRLaTeXWriter methodsFor: 'visiting-document'!visitUnderlineFormat: aFormat	canvas command		name: 'uline';		parameter: [ super visitUnderlineFormat: aFormat ]! !!PRLaTeXWriter methodsFor: 'visiting-document'!visitUnorderedList: aList	canvas environment		name: 'itemize';		with: [ super visitUnorderedList: aList ]! !!PRLaTeXWriter methodsFor: 'helpers'!writeCaptionOfExternalLink: anExternalLink	self visitAll: anExternalLink children! !!PRLaTeXWriter methodsFor: 'helpers'!writeGraphicsParametersOfExternalLink: anExternalLink	canvas		nextPutAll: 'width=';		nextPutAll: ((anExternalLink parameters at: 'width' ifAbsent: [ 100 ]) asNumber / 100.0) printString;		raw: '\textwidth'! !!PRLaTeXWriter methodsFor: 'helpers'!writeLabelOfExternalLink: anExternalLink	| label |	label := anExternalLink parameters at: 'label' ifAbsent: [ anExternalLink localFileOrExternalReference ].	canvas command		name: 'label';		parameter: [ canvas raw: label ]! !!PRLaTeXWriter methodsFor: 'helpers'!writeTableCellContent: aCell	^ aCell isHeading		ifTrue: [ 			canvas command				name: 'textbf';				parameter: [ super visitTableCell: aCell ] ]		ifFalse: [ super visitTableCell: aCell ]! !!PRSBALaTeXWriter class methodsFor: 'accessing'!writerName	^ #latex:sbabook! !!PRSBALaTeXWriter methodsFor: 'protected'!monospaceMacro	^ 'textcode'! !!PRSBALaTeXWriter methodsFor: 'protected'!optionalParametersForFloatingScript: aScript 	| parameters |	parameters := OrderedCollection new.	parameters add: 'float'.	aScript hasLabel ifTrue: [ parameters add: 'label=', aScript label ].	aScript hasShortCaption ifTrue: [ parameters add: 'list text={', aScript shortCaption, '}' ].	^ parameters asCommaString! !!PRSBALaTeXWriter methodsFor: 'visiting-document'!tabularEnvironment	^ 'fullwidthtabular'! !!PRSBALaTeXWriter methodsFor: 'visiting-document'!visitCodeblock: aCodeBlock	aCodeBlock hasCaption | aCodeBlock hasLabel		ifTrue: [ self visitFloatingScript: aCodeBlock ]		ifFalse: [ self visitInFlowScript: aCodeBlock ]! !!PRSBALaTeXWriter methodsFor: 'visiting-document'!visitFloatingScript: aScript 	canvas environment		name: 'listing';		optParameter: (self optionalParametersForFloatingScript: aScript);		parameter: (self languageForScript: aScript) sbaString;		parameter: [ self visitAll: aScript caption children ];		with: [			self writeRawDuring: [ self visitText: aScript ].			canvas newLine ]! !!PRSBALaTeXWriter methodsFor: 'visiting-document'!visitInFlowScript: aScript 	canvas environment		name: 'displaycode';		parameter: (self languageForScript: aScript) sbaString;		with: [			self writeRawDuring: [ self visitText: aScript ].			canvas newLine ]! !!PRPdfOutput class methodsFor: 'accessing'!builderName		^ #pdf! !!PRPdfOutput methodsFor: 'building'!documentFor: aFile	^ PRPDFDocument new		project: aFile project;		file: aFile;		target: self;		outputDirectory: aFile project outputDirectory / self extension;		yourself! !!PRPdfOutput methodsFor: 'accessing'!extension		^ 'pdf'! !!PRPdfOutput methodsFor: 'accessing'!outputDirectoryName		^ 'pdf'! !!PRPdfOutput methodsFor: 'accessing'!writerFor: aPRPillarConfiguration 		^ self writerFor: aPRPillarConfiguration forConfigurationTag: #latexWriter! !!PRLatexPathUpdateVisitor class methodsFor: 'visiting'!isAbstract	^ false! !!PRLatexPathUpdateVisitor class methodsFor: 'visiting'!key	^ #latexPathUpdate! !!PRLatexPathUpdateVisitor class methodsFor: 'visiting'!start: aDocument	^ self new start: aDocument! !!PRLatexPathUpdateVisitor methodsFor: 'instance creation'!newReferenceFor: aReference		^ aReference reference copyReplaceAll: '\' with: '/'! !!PRLatexPathUpdateVisitor methodsFor: 'visiting'!visitFigure: aFigure	aFigure reference: (self newReferenceFor: aFigure).	super visitFigure: aFigure! !!PRLatexPathUpdateVisitor methodsFor: 'visiting'!visitInternalLink: anInternalLink	anInternalLink hasReference  		ifTrue: [ anInternalLink reference: (self newReferenceFor: anInternalLink) ].	super visitInternalLink: anInternalLink! !!PRTableCell methodsFor: '*Pillar-ExporterLaTeX'!latexAlignment	self isAlignedCenter ifTrue: [ ^ 'c' ].	self isAlignedRight ifTrue: [ ^ 'r' ].	^ 'l'! !!PRUnspecifiedScriptLanguage methodsFor: '*Pillar-ExporterLaTeX'!sbaString	^ 'plain'! !"Pillar-ExporterLaTeX"!!PRBeamerWriter commentStamp: '' prior: 0!I'm a writer generating Beamer slides from a Pillar document. Beamer is a LaTeX package specialized in slide creation.!!PRBeamerWriter class methodsFor: 'as yet unclassified'!codeSmalltalk	^ '% Source Code\usepackage{color}\definecolor{source}{gray}{0.85}% my comment style\newcommand{\myCommentStyle}[1]{{\footnotesize\sffamily\color{gray!!100!!white} #1}}% my string style\newcommand{\myStringStyle}[1]{{\footnotesize\sffamily\color{violet!!100!!black} #1}}% my symbol style\newcommand{\mySymbolStyle}[1]{{\footnotesize\sffamily\color{violet!!100!!black} #1}}% my keyword style\newcommand{\myKeywordStyle}[1]{{\footnotesize\sffamily\color{green!!70!!black} #1}}% my global style\newcommand{\myGlobalStyle}[1]{{\footnotesize\sffamily\color{blue!!100!!black} #1}}% my number style\newcommand{\myNumberStyle}[1]{{\footnotesize\sffamily\color{brown!!100!!black} #1}}\lstset{language={},tabsize=3,escapechar={!!},keepspaces=true,breaklines=true,alsoletter={\#},literate={\$}{{{\$}}}1,breakautoindent=true,columns=fullflexible,showstringspaces=false,frame=single,aboveskip=1em, % automatic space beforeframerule=0pt,basicstyle=\footnotesize\sffamily\color{black},keywordstyle=\myKeywordStyle,% keyword stylecommentstyle=\myCommentStyle,% comment styleframe=single,%backgroundcolor=\color{source},stepnumber=1,numbersep=10pt,numberstyle=\tiny,numberfirstline=true,captionpos=b,moredelim=[is][\bfseries]{&lt;b&gt;}{&lt;/b&gt;},moredelim=[is][\textit]{&lt;i&gt;}{&lt;/i&gt;},moredelim=[is][\underbar]{&lt;u&gt;}{&lt;/u&gt;},moredelim=[is][\color{red}\uwave]{&lt;wave&gt;}{&lt;/wave&gt;},moredelim=[is][\color{red}\sout]{&lt;del&gt;}{&lt;/del&gt;},moredelim=[is][\color{blue}\underbar]{&lt;ins&gt;}{&lt;/ins&gt;},morecomment=[s][\myCommentStyle]{"}{"},morestring=[b][\myStringStyle]'',moredelim=[is][]{&lt;sel&gt;}{&lt;/sel&gt;},moredelim=[is][]{&lt;rcv&gt;}{&lt;/rcv&gt;},moredelim=[is][\itshape]{&lt;symb&gt;}{&lt;/symb&gt;},moredelim=[is][\scshape]{&lt;class&gt;}{&lt;/class&gt;},morekeywords={true,false,nil,self,super,thisContext},identifierstyle=\idstyle,} \makeatletter\newcommand*\idstyle[1]{%\expandafter\id@style\the\lst@token{#1}\relax%}\def\id@style#1#2\relax{%\ifnum\pdfstrcmp{#1}{\#}=0%% this is a symbol\mySymbolStyle{\the\lst@token}%\else%\edef\tempa{\uccode`#1}%\edef\tempb{`#1}%\ifnum\tempa=\tempb%% this is a global\myGlobalStyle{\the\lst@token}%\else%\the\lst@token%\fi%\fi%}\makeatother\newcommand{\lct}{\texttt} \lstnewenvironment{code}{% \lstset{% frame=single, framerule=0pt, mathescape=false }% \noindent% \minipage{\linewidth}%}{% \endminipage%}%\lstnewenvironment{codeWithLineNumbers}{% \lstset{% frame=single, framerule=0pt, mathescape=false, numbers=left }% \noindent% \minipage{\linewidth}%}{% \endminipage%}%\newenvironment{codeNonSmalltalk}{\begin{alltt}\sffamily}{\end{alltt}\normalsize}'! !!PRBeamerWriter class methodsFor: 'accessing'!folderName	^ #beamer! !!PRBeamerWriter class methodsFor: 'accessing'!writerName	^ #beamer! !!PRBeamerWriter methodsFor: 'helpers'!createFrametitle: aTitle	canvas command		name: 'frametitle';		parameter: aTitle! !!PRBeamerWriter methodsFor: 'helpers'!createLinkToLabelWithAlias: anInternalLink	canvas command		name: 'hyperlink';		parameter: [ canvas raw: anInternalLink anchor ];		parameter: [ canvas raw: anInternalLink alias ]! !!PRBeamerWriter methodsFor: 'helpers'!createTOCWith: aCollection	| parameters |	parameters := LinkedList new.	"highlight := aCollection at: 'highlight' ifPresent: [ :param | param ] ifAbsent: [ false ].	highlight = 1		ifTrue: [ parameters add: 'currentsection, hideallsubsections' ]		ifFalse: [ 			highlight = 2				ifTrue: [ parameters add: 'currentsection, currentsubsection' ]				ifFalse: [ self sectionOptionFrom: (aCollection at: 'level') asInteger To: (aCollection at: 'depthLevel') asInteger On: parameters ] ]."	self flag: #todo.	"We need to change the highlight"	canvas command		name: 'tableofcontents';		optParameter: (String streamContents: [ :s | parameters do: [ :each | s nextPutAll: each ] separatedBy: [ s nextPut: $, ] ])! !!PRBeamerWriter methodsFor: 'visiting-document'!getLevelFor: aHeader	^ 2 + (super getLevelFor: aHeader)! !!PRBeamerWriter methodsFor: 'helpers'!sectionOptionFrom: level To: depth On: parameters	parameters		add:			((1 > level and: [ 1 <= depth ])				ifTrue: [ 'sectionstyle=show/show' ]				ifFalse: [ 'sectionstyle=hide/hide' ]).	parameters		add:			((2 > level and: [ 2 <= depth ])				ifTrue: [ 'subsectionstyle=show/show/show' ]				ifFalse: [ 'subsectionstyle=hide/hide/hide' ]).	parameters		add:			((3 > level and: [ 3 <= depth ])				ifTrue: [ 'subsubsectionstyle=show/show/show' ]				ifFalse: [ 'subsubsectionstyle=hide/hide/hide' ])! !!PRBeamerWriter methodsFor: 'templating'!templateForConfiguration: aConfiguration	^ 'presentation.template'! !!PRBeamerWriter methodsFor: 'visiting-document'!visitCodeblock: aCodeBlock	| env |	aCodeBlock language isSyntaxHighlightingPossible		ifTrue: [ 			canvas				raw: '% syntax highlighting = ' , (self languageForScript: aCodeBlock) printString;				newLine ].	env := (aCodeBlock hasCaption or: [ aCodeBlock hasLabel ])		ifTrue: [ 			canvas environment				name: 'script';				optParameter: aCodeBlock label;				parameter: [ self noNewLineDuring: [ self visit: aCodeBlock caption ] ];				yourself ]		ifFalse: [ 			canvas environment				name: 'listing';				parameter: '';				yourself ].	env with: [ self writeRawDuring: [ self visitText: aCodeBlock ]. canvas newLine ]! !!PRBeamerWriter methodsFor: 'visiting-annotations'!visitColumn: aColumn	canvas environment		name: 'column';		parameter: [ 					canvas						nextPutAll: (aColumn width asNumber / 100.0) printString;						raw: '\textwidth' ];		with: [ super visitColumn: aColumn ].	canvas newLine! !!PRBeamerWriter methodsFor: 'visiting-annotations'!visitColumns: aColumns	canvas environment		name: 'columns';		with: [ 					super visitColumns: aColumns ].	canvas newLine! !!PRBeamerWriter methodsFor: 'visiting-document'!visitFigure: aFigure	canvas environment		name: 'center';		with: [ self includeGraphicsFor: aFigure ]! !!PRBeamerWriter methodsFor: 'visiting-document'!visitHeader: aHeader	super visitHeader: aHeader.	self configuration renderStructureAsSlide		ifTrue: [ 			canvas newLine.			canvas environment				name: 'frame';				with: [ 							canvas newLine.							canvas environment								name: 'center';								with: [ 											canvas newLine.											canvas command												name: 'huge';												parameter: [ self visitDocumentGroup: aHeader ].											canvas newLine ] ].			canvas newLine ]! !!PRBeamerWriter methodsFor: 'visiting-document'!visitSlide: aSlide	canvas newLine.	canvas environment		name: 'frame';		optParameter: 'fragile';		with: [ 					canvas newLine.					aSlide hasLabel						ifTrue: [ 							canvas command								name: 'label';								parameter: aSlide label.							canvas newLine ].					self createFrametitle: aSlide title.					canvas newLine.					super visitSlide: aSlide ].	canvas newLine! !!PRBeamerWriter methodsFor: 'visiting-annotations'!visitTOCAnnotation: aTOCAnnotation	canvas newLine.	canvas environment		name: 'frame';		with: [ 					canvas newLine.					self createFrametitle: (aTOCAnnotation parameters at: 'title' ifAbsent: [ 'Table Of Content' ]).					canvas newLine.					self createTOCWith: aTOCAnnotation parameters.					canvas newLine ].	canvas newLine! !"Pillar-ExporterBeamer"!!PRDocumentItemTest commentStamp: '' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State the name of the class with one line description: For example, I'm xxx the root of the hierarchy of visitor objects.For the Responsibility part: Three sentences about my main responsibility, what I'm doing, what services do I offer.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - what is the way to create instances is a plus.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!PRAbstractAnnotationTest commentStamp: '' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State the name of the class with one line description: For example, I'm xxx the root of the hierarchy of visitor objects.For the Responsibility part: Three sentences about my main responsibility, what I'm doing, what services do I offer.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - what is the way to create instances is a plus.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!PRObjectTest commentStamp: '' prior: 0!Tests for expectations that must be valid on all pillar objects!!PRParametersTest methodsFor: 'tests'!testAsDictionary	| p dict |	p :=  PRParameters withAll: { 		PRParameter 			keyNode: (PRParameterKey named: 'name')			valueNode: (PRParameterValue value: 'card').		PRParameter 			keyNode: (PRParameterKey named: 'number')			valueNode: (PRParameterValue value: 10).		PRParameter 			keyNode: (PRParameterKey named: 'string')			valueNode: (PRParameterValue value: 'a string').		PRParameter 			keyNode: (PRParameterKey named: 'boolean')			valueNode: (PRParameterValue value: true).		}.	dict := p asDictionary. 	self assert: (dict at: 'name') equals: 'card'.	self assert: (dict at: 'number') equals: 10.! !!PRParametersTest methodsFor: 'tests'!testParameters	| p |	p :=  PRParameters withAll: { 		PRParameter 			keyNode: (PRParameterKey named: 'name')			valueNode: (PRParameterValue value: 'card').		PRParameter 			keyNode: (PRParameterKey named: 'number')			valueNode: (PRParameterValue value: 10).		PRParameter 			keyNode: (PRParameterKey named: 'string')			valueNode: (PRParameterValue value: 'a string').		PRParameter 			keyNode: (PRParameterKey named: 'boolean')			valueNode: (PRParameterValue value: true).		}.	self assert: p parameters size equals: 4! !!PRBasicObjectTest class methodsFor: 'testing'!isAbstract	^ true! !!PRBasicObjectTest class methodsFor: 'accessing'!packageNamesUnderTest	^ #('Pillar-Model')! !!PRBasicObjectTest class methodsFor: 'testing'!shouldInheritSelectors	^ true! !!PRBasicObjectTest methodsFor: 'private'!actualClass	^ PRObject! !!PRBasicObjectTest methodsFor: 'private'!actualInstance	^ self actualClass new! !!PRBasicObjectTest methodsFor: 'accessing'!instance	^ instance! !!PRBasicObjectTest methodsFor: 'tests'!lineEnding	^ Smalltalk os lineEnding! !!PRBasicObjectTest methodsFor: 'running'!setUp	super setUp.	instance := self actualInstance! !!PRAbstractAnnotationTest class methodsFor: 'testing'!isAbstract	^ self = PRAbstractAnnotationTest! !!PRAbstractAnnotationTest methodsFor: 'helpers'!actualClass	^ self subclassResponsibility! !!PRAbstractAnnotationTest methodsFor: 'helpers'!annoteName	^ self actualClass tag! !!PRAbstractAnnotationTest methodsFor: 'helpers'!referenceParameters	self subclassResponsibility! !!PRAbstractAnnotationTest methodsFor: 'helpers'!referenceString	"Pay attention to order the parameters according to sorted"	self		subclassResponsibility! !!PRAbstractAnnotationTest methodsFor: 'tests'!testAsPillar	| wiki tree |	wiki := '${' , self referenceString , '}$'.	tree := self actualClass withParameters: self referenceParameters.	self assert: tree asPillar equals: wiki! !!PRAbstractAnnotationTest methodsFor: 'tests'!testParsedHadAllKeys	self assert: (self parser parse:  '${' , self referenceString , '}$') children first children first hadAllKeys! !!PRAbstractAnnotationTest methodsFor: 'tests'!testWithParameters	self assert: (self actualClass withParameters: self referenceParameters) hadAllKeys! !!PRBeginEnvironmentAnnotationTest methodsFor: 'helpers'!actualClass	^ PRBeginEnvironmentAnnotation! !!PRBeginEnvironmentAnnotationTest methodsFor: 'helpers'!referenceParameters	^ PRParameters withAll: { 		PRParameter 			keyNode: (PRParameterKey named: 'name')			valueNode: (PRParameterValue value: 'card').		PRParameter 			keyNode: (PRParameterKey named: 'number')			valueNode: (PRParameterValue value: 10).		PRParameter 			keyNode: (PRParameterKey named: 'string')			valueNode: (PRParameterValue value: 'a string').		PRParameter 			keyNode: (PRParameterKey named: 'boolean')			valueNode: (PRParameterValue value: true).		}! !!PRBeginEnvironmentAnnotationTest methodsFor: 'helpers'!referenceString	^ 'begin:name=card|number=10|string=a string|boolean=true'! !!PREndEnvironmentAnnotationTest methodsFor: 'helpers'!actualClass	^ PREndEnvironmentAnnotation! !!PREndEnvironmentAnnotationTest methodsFor: 'helpers'!referenceParameters	^ PRParameters withAll: { 		PRParameter 			keyNode: (PRParameterKey named: 'name')			valueNode: (PRParameterValue value: 'card').		PRParameter 			keyNode: (PRParameterKey named: 'number')			valueNode: (PRParameterValue value: 10).		PRParameter 			keyNode: (PRParameterKey named: 'string')			valueNode: (PRParameterValue value: 'a string').		PRParameter 			keyNode: (PRParameterKey named: 'boolean')			valueNode: (PRParameterValue value: true).		}! !!PREndEnvironmentAnnotationTest methodsFor: 'helpers'!referenceString	^ 'end:name=card|number=10|string=a string|boolean=true'! !!PRAnchorTest class methodsFor: 'testing'!isAbstract	^ false! !!PRAnchorTest methodsFor: 'private'!actualClass	^ PRAnchor! !!PRAnchorTest methodsFor: 'tests-comparing'!testEqualName	self deny: (self actualClass named: 'foo') equals: (self actualClass named: 'bar')! !!PRAnchorTest methodsFor: 'tests-accessing'!testName	self instance name: 'zork'.	self assert: self instance name equals: 'zork'! !!PRAnchorTest methodsFor: 'tests-instantiation'!testWith	instance := self actualClass named: 'test'.	self assert: self instance name equals: 'test'! !!PRAnnotatedParagraphTest class methodsFor: 'testing'!isAbstract	^ false! !!PRAnnotatedParagraphTest methodsFor: 'private'!actualClass	^ PRAnnotatedParagraph! !!PRDocumentGroupTest methodsFor: 'private'!actualClass	^ PRDocumentGroup! !!PRDocumentGroupTest methodsFor: 'tests-adding'!testAdd	self instance add: self fooInstance.	self assert: self instance children size equals: 1.	self assert: self instance children first equals: self fooInstance.	self instance add: self barInstance.	self assert: self instance children size equals: 2.	self assert: self instance children first equals: self fooInstance.	self assert: self instance children second equals: self barInstance! !!PRDocumentGroupTest methodsFor: 'tests-adding'!testAddAll	self instance addAll: self foobarInstances.	self assert: self instance children size equals: 2.	self assert: self instance children first equals: self fooInstance.	self assert: self instance children second equals: self barInstance! !!PRDocumentGroupTest methodsFor: 'tests-copying'!testCopyChildren	self instance addAll: self foobarInstances.	self assert: self instance children equals: self instance copy children.	self deny: self instance children identicalTo: self instance copy children.	self instance children		with: self instance copy children		do: [ :a :b | 			self assert: a equals: b.			self deny: a identicalTo: b ]! !!PRDocumentGroupTest methodsFor: 'tests-testing'!testHasChildren	self deny: self instance hasChildren.	self instance add: self fooInstance.	self assert: self instance hasChildren! !!PRDocumentGroupTest methodsFor: 'tests-accessing'!testSize	self assert: self instance size equals: 0.	self instance add: self fooInstance.	self assert: self instance size equals: 1! !!PRDocumentGroupTest methodsFor: 'tests-accessing'!testText	self instance addAll: self foobarInstances.	self assert: self instance text equals: 'foobar'! !!PRDocumentGroupTest methodsFor: 'tests-instantiation'!testWith	instance := self actualClass with: self fooInstance.	self assert: instance children size equals: 1.	self assert: instance children first equals: self fooInstance! !!PRDocumentGroupTest methodsFor: 'tests-instantiation'!testWithAll	instance := self actualClass withAll: self foobarInstances.	self assert: instance children size equals: 2.	self assert: instance children first equals: self fooInstance.	self assert: instance children second equals: self barInstance! !!PRDocumentTest class methodsFor: 'testing'!isAbstract	^ false! !!PRDocumentTest methodsFor: 'private'!actualClass	^ PRDocument! !!PRDocumentTest methodsFor: 'tests'!testTitle	| tree |	tree := PRDocument new		propertyAt: 'title' put: 'Atom heart mother';		yourself.	self assert: tree title equals: 'Atom heart mother'.	tree := PRDocument new		add:			(PRHeader new				level: 1;				add: (PRText content: 'Echoes');				yourself).	self assert: tree title equals: 'Echoes'.	self assert: PRDocument new title equals: 'No title'! !!PRFormatTest class methodsFor: 'building suites'!isAbstract	^ false! !!PRFormatTest class methodsFor: 'building suites'!testParameters	^ (ParametrizedTestMatrix new			forSelector: #actualClass addOptions: PRFormat subclasses )! !!PRFormatTest methodsFor: 'private'!actualClass	^ actualClass ! !!PRFormatTest methodsFor: 'accessing'!actualClass: anObject	actualClass := anObject! !!PRFormatTest methodsFor: 'accessing'!otherClass	^ otherClass ifNil: [ otherClass := PRFormat allSubclasses detect: [ :each | self actualClass ~= each ] ]! !!PRListTest methodsFor: 'private'!actualClass	^ PRList! !!PRListTest methodsFor: 'private'!listItemClass	^ PRListItem! !!PRListTest methodsFor: 'private'!listItemWithText: aString	^ self listItemClass new		add: (PRText content: aString);		yourself! !!PRListTest methodsFor: 'private'!textString: anObject level: anInteger	^ (2 to: anInteger) inject: '' into: [ :result :each | result , '	' ]! !!PROrderedListTest class methodsFor: 'testing'!isAbstract	^ false! !!PROrderedListTest methodsFor: 'private'!actualClass	^ PROrderedList! !!PROrderedListTest methodsFor: 'private'!textString: anObject level: anInteger 	^ (super 		textString: anObject		level: anInteger) , anObject asString , '. '! !!PRUnorderedListTest class methodsFor: 'testing'!isAbstract	^ false! !!PRUnorderedListTest methodsFor: 'private'!actualClass	^ PRUnorderedList! !!PRUnorderedListTest methodsFor: 'private'!textString: anObject level: anInteger	^ (super textString: anObject level: anInteger) , '* '! !!PREmptyParagraphTest methodsFor: 'private'!actualClass	^ PREmptyParagraph! !!PRParagraphTest class methodsFor: 'testing'!isAbstract	^ false! !!PRParagraphTest methodsFor: 'private'!actualClass	^ PRParagraph! !!PRParagraphTest methodsFor: 'tests-parsing'!testParent	| tree text |	text := PRText content: 'Lorem ipsum dolor sit amet.'.	tree := PRDocument new		add: PREmptyParagraph new;		add:				(PRParagraph new						add: text;						yourself);		yourself.	self assert: tree children first parent equals: tree.	self assert: tree children second parent equals: tree.	self assert: text parent equals: tree children second! !!PRSectionTest class methodsFor: 'testing'!isAbstract	^ false! !!PRSectionTest methodsFor: 'private'!actualClass	^ PRSection! !!PRDocumentItemTest methodsFor: 'private'!actualClass	^ PRDocumentItem! !!PRDocumentItemTest methodsFor: 'utilities'!addText: aString to: aDocumentItem	^ aDocumentItem		add: (PRText content: aString);		yourself! !!PRDocumentItemTest methodsFor: 'private'!barInstance	^ PRText content: 'bar'! !!PRDocumentItemTest methodsFor: 'private'!fooInstance	^ PRText content: 'foo'! !!PRDocumentItemTest methodsFor: 'private'!foobarInstances	^ Array with: self fooInstance with: self barInstance! !!PRDocumentItemTest methodsFor: 'helper'!parser	^ PRDocument parser! !!PRDocumentItemTest methodsFor: 'tests-copying'!testCopy	self assert: self instance equals: self instance copy.	self assert: self instance hash equals: self instance copy hash.	self deny: self instance identicalTo: self instance copy! !!PRDocumentItemTest methodsFor: 'tests-comparing'!testEqual	self assert: self instance equals: self instance.	self assert: self instance equals: self actualInstance! !!PRDocumentItemTest methodsFor: 'tests-comparing'!testEqualNil	self deny: self instance isNil! !!PRDocumentItemTest methodsFor: 'tests-comparing'!testEqualOther	self deny: self instance equals: self fooInstance.	self deny: self instance equals: self barInstance! !!PRDocumentItemTest methodsFor: 'tests-testing'!testHasChildren	self deny: self instance hasChildren! !!PRDocumentItemTest methodsFor: 'tests-comparing'!testHash	self assert: self instance hash equals: self instance copy hash! !!PRDocumentItemTest methodsFor: 'tests'!testIsHeader	self deny: self instance isHeader! !!PRDocumentItemTest methodsFor: 'tests'!testIsLink	self deny: self instance isLink! !!PRDocumentItemTest methodsFor: 'tests-accessing'!testText	self assert: self instance text isString! !!PRObjectTest methodsFor: 'tests-copying'!testCopyProperties	self deny: self instance properties identicalTo: self instance copy properties! !!PRObjectTest methodsFor: 'tests-properties'!testHasProperty	self deny: (self instance hasProperty: #foo).	self instance propertyAt: #foo put: 'bar'.	self assert: (self instance hasProperty: #foo).	self deny: (self instance hasProperty: #bar)! !!PRObjectTest methodsFor: 'tests-properties'!testProperties	self assert: self instance properties isNotNil.	self instance instVarNamed: 'properties' put: nil.	self instance propertyAt: #foo put: #bar.	self instance instVarNamed: 'properties' put: nil.	self instance propertyAt: #foo ifAbsent: [ nil ].	self instance instVarNamed: 'properties' put: nil.	self instance propertyAt: #foo ifAbsentPut: [ #bar ].	self instance instVarNamed: 'properties' put: nil.	self instance hasProperty: #foo.	self instance instVarNamed: 'properties' put: nil! !!PRObjectTest methodsFor: 'tests-properties'!testPropertyAt	self assert: (self instance propertyAt: #foo put: 'bar') equals: 'bar'.	self assert: (self instance propertyAt: #foo) equals: 'bar'.	self should: [ self instance propertyAt: #bar ] raise: PRPropertyError! !!PRObjectTest methodsFor: 'tests-properties'!testPropertyAtIfAbsent	self assert: (self instance propertyAt: #foo put: 'bar') equals: 'bar'.	self assert: (self instance propertyAt: #foo ifAbsent: [ 'baz' ]) equals: 'bar'.	self assert: (self instance propertyAt: #bar ifAbsent: [ 'baz' ]) equals: 'baz'! !!PRObjectTest methodsFor: 'tests-properties'!testPropertyAtIfAbsentPut	self assert: (self instance propertyAt: #foo put: 'bar') equals: 'bar'.	self assert: (self instance propertyAt: #foo ifAbsentPut: [ 'baz' ]) equals: 'bar'.	self assert: (self instance propertyAt: #foo) equals: 'bar'.	self assert: (self instance propertyAt: #bar ifAbsentPut: [ 'baz' ]) equals: 'baz'.	self assert: (self instance propertyAt: #bar) equals: 'baz'! !!PRObjectTest methodsFor: 'tests-properties'!testPropertyAtPut	self instance propertyAt: #foo put: 'bar'.	self assert: (self instance propertyAt: #foo) equals: 'bar'.	self instance propertyAt: #foo put: 'baz'.	self assert: (self instance propertyAt: #foo) equals: 'baz'! !!PRObjectTest methodsFor: 'tests'!testSanity	"If this test case fails, there is something wrong with the setup of the test-case."	self		assert: self actualClass isAbstract not		description: 'Unable to test abstract class.'.	self		assert: self instance class = self actualClass		description: 'Invalid test instance.'! !"Pillar-Tests-Core"!!PRInputFileFinder commentStamp: '' prior: 0!I'm a visitor that returns all the `${inputFile:path=xxx}$` in a document. !!ClapPillarMicrodownBookConverterCommand commentStamp: '' prior: 0!I am a command line handler to convert a pillar file (for now) in a microdown file in the current directory and all the files that are includes in it.## Example of usage: `./pillar convertBook SUnit.pillar`!!ClapPillarMicrodownChapterConverterCommand commentStamp: '' prior: 0!I am a command line handler to convert a pillar file (for now) in a microdown file in the current directory.## Example of usage: `./pillar convertChapter SUnit.pillar`!!ClapPillarMicrodownSlideConverterCommand commentStamp: '' prior: 0!I am a command line handler to convert a pillar slide file in a microdown file in the current directory.## Example of usage: `./pillar convertSlide SUnit.pillar`!!PRConverterToMic commentStamp: '' prior: 0!```PRConverterToMic new goForBook: '/Users/ducasse/Workspace/FirstCircle/ActiveResearch/Pharo/PillarDev/Booklet-PharoWithStyle/withStyle.pillar' asFileReference```!!PRMicrodownWriter commentStamp: '' prior: 0!I'm a pillar visitor converting a pillar tree to microdown exporter text.The current strategy is that there is one line separating every elements of the document. But we do not have enough information (such as am I the latest of the list and is my container another list or the root document) to control the fact that we should not emit a newline for the last item.Therefore we generate an extra line while ideally it should not be the case.#### Known todo or limits  - externallink url is printing / and we should check it.- externallink should be tested with real URL.!!PRMicrodownWriterTest commentStamp: '' prior: 0!This class contains tests designed in the way that we will be able to remove the pillar transformation (asPillar in method textWithInitialText:) in the future and still reuse the tests.Therefore the input is Microdown generated via the Microdown builder, then such Microdown text is parsed and transformed into pillar using the asPillar, then compare that the output is the same as the orginal generated code. !!PRInputFileFinder class methodsFor: 'creation'!fromFileIndex: aFileReference 	^ self new 		fromFileIndex: aFileReference;		yourself! !!PRInputFileFinder methodsFor: 'accessing'!files	^ files ! !!PRInputFileFinder methodsFor: 'API'!fromFileIndex: aFileReference	self start: (PRPillarParser parse: aFileReference contents)	! !!PRInputFileFinder methodsFor: 'accessing'!initialize	super initialize.	files := OrderedCollection new.! !!PRInputFileFinder methodsFor: 'visiting'!visitInputFileAnnotation: anInputFileAnnotation	files add: anInputFileAnnotation path! !!ClapPillarMicrodownBookConverterCommand class methodsFor: 'accessing'!commandName	^'convertBook'! !!ClapPillarMicrodownBookConverterCommand class methodsFor: 'command line'!commandSpecification 	<commandline>	^ (ClapCommand id: self commandName asSymbol)		description: 'Create a microdown book in the current directory, which contains the conversion in microdown format of the argument.';		add: ClapFlag forHelp;		add: ((ClapPositional id: #requestedFile)			description: 'File for the book you want to convert');		meaning:			[ :args |			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].			(self with: args) execute ]! !!ClapPillarMicrodownBookConverterCommand methodsFor: 'execution'!execute	| file |	file :=  self requestedFile asString asFileReference. 	file exists 		ifTrue: [ PRConverterToMic new convertBook: file ]		ifFalse: [ self outputStreamDo: [ :str | str nextPutAll: 'File ', file fullName, ' does not exist'  ] ]! !!ClapPillarMicrodownBookConverterCommand methodsFor: 'execution'!requestedFile	 ^ (arguments at: #requestedFile) value: self! !!ClapPillarMicrodownChapterConverterCommand class methodsFor: 'accessing'!commandName	^'convertChapter'! !!ClapPillarMicrodownChapterConverterCommand class methodsFor: 'command line'!commandSpecification 	<commandline>	^ (ClapCommand id: self commandName asSymbol)		description: 'Create a microdown book chapter in the current directory, which contains the conversion in microdown format of the argument.';		add: ClapFlag forHelp;		add: ((ClapPositional id: #requestedFile)			description: 'File for the book chapter you want to convert');		meaning:			[ :args |			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].			(self with: args) execute ]! !!ClapPillarMicrodownChapterConverterCommand methodsFor: 'execution'!execute	| file |	file :=  self requestedFile asString asFileReference. 	file exists 		ifTrue: [ PRConverterToMic new convertChapter: file ]		ifFalse: [ self outputStreamDo: [ :str | str nextPutAll: 'File ', file fullName, ' does not exist'  ] ]! !!ClapPillarMicrodownChapterConverterCommand methodsFor: 'activation'!requestedFile	 ^ (arguments at: #requestedFile) value: self! !!ClapPillarMicrodownSlideConverterCommand class methodsFor: 'accessing'!commandName	^'convertSlide'! !!ClapPillarMicrodownSlideConverterCommand class methodsFor: 'command line'!commandSpecification 	<commandline>	^ (ClapCommand id: self commandName asSymbol)		description: 'Create a microdown slide file in the current directory, which contains the conversion in microdown format of the argument.';		add: ClapFlag forHelp;		add: ((ClapPositional id: #requestedFile)			description: 'File for the slide you want to convert');		meaning:			[ :args |			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].			(self with: args) execute ]! !!ClapPillarMicrodownSlideConverterCommand methodsFor: 'execution'!execute	| file |	file :=  self requestedFile asString asFileReference. 	file exists 		ifTrue: [ PRConverterToMic new convertSlide: file ]		ifFalse: [ self outputStreamDo: [ :str | str nextPutAll: 'File ', file fullName, ' does not exist'  ] ]! !!ClapPillarMicrodownSlideConverterCommand methodsFor: 'activation'!requestedFile	 ^ (arguments at: #requestedFile) value: self! !!PRInputFileFinderTest class methodsFor: 'accessing'!indexPillar	^ '%reviewed SD: 4th of march${inputFile:path=Chapters/Preface/Preface.pillar}$${inputFile:path=Chapters/PharoTour/PharoTour.pillar}$%Reviewed finished${inputFile:path=Chapters/Counter/Exo-Counter.pillar}$${inputFile:path=Chapters/FirstApplication/FirstApplication.pillar}$${inputFile:path=Chapters/IcebergIntro/StartedWithIceberg.pillar}$ %cha:Iceberg${inputFile:path=Chapters/IcebergIntro/FirstConfiguration.pillar}$%@cha:configure%reviewed SD: 4th of march${inputFile:path=Chapters/SyntaxNutshell/SyntaxNutshell.pillar}$%reviewed SD: 4th of march${inputFile:path=Chapters/UnderstandingMessage/UnderstandingMessage.pillar}$%reviewed SD: 6th of march${inputFile:path=Chapters/PharoObjectModel/PharoObjectModel.pillar}$%To be finished${inputFile:path=Chapters/PharoObjectModel/Traits.pillar}$%Under reviewed SD: 7th of April HERE${inputFile:path=Chapters/SUnit/SUnit.pillar}$${inputFile:path=Chapters/BasicClasses/BasicClasses.pillar}$${inputFile:path=Chapters/Collections/Collections.pillar}$${inputFile:path=Chapters/Streams/Streams.pillar}$%migrated and reviewed SD: 7th of April${inputFile:path=Chapters/Morphic/Morphic.pillar}$${inputFile:path=Chapters/Metaclasses/Metaclasses.pillar}$${inputFile:path=Chapters/Reflection/Reflection.pillar}$'! !!PRInputFileFinderTest methodsFor: 'running'!setUp	super setUp.	filesystem := FileSystem memory.	index := filesystem workingDirectory / 'index.pillar'.	index writeStreamDo: [ :stream | stream nextPutAll: self class indexPillar ].	! !!PRInputFileFinderTest methodsFor: 'running'!testFinderFindInputFiles	| files |	files := PRInputFileFinder new 		start: (PRPillarParser parse: index contents);		files.	self assert: files size equals: 17		! !!PRInputFileFinderTest methodsFor: 'running'!testFinderFindInputFilesFromFileIndex		| files |	files := (PRInputFileFinder fromFileIndex: index) files.	self assert: files size equals: 17		! !!PRPillarToMicrodownConverterTest methodsFor: 'running'!setUp 	super setUp.	pillarParser := PRPillarParser new.	writer := PRMicrodownWriter new.		! !!PRPillarToMicrodownConverterTest methodsFor: 'tests - code blocks'!testCodeBlock	| pillarobject result |	pillarobject := pillarParser parse: '[[[language=pharo|caption=PointclassPoint class >> new	self foo	]]] 	'.	result := writer start: pillarobject ; contents.	self assert: result equals: '```language=pharo&caption=PointclassPoint class >> new	self foo	```'! !!PRPillarToMicrodownConverterTest methodsFor: 'tests - code blocks'!testCodeBlockWithTags	| pillarobject result |	pillarobject := pillarParser parse: '[[[language=smalltalkPoint class >> new	self foo	]]]'.	result := writer start: pillarobject ; contents.	self assert: result equals: '```language=smalltalkPoint class >> new	self foo	```'! !!PRPillarToMicrodownConverterTest methodsFor: 'tests - paragraph list'!testFigure    | pillarobject result |    pillarobject := pillarParser parse: '+this is a caption>file://Chapters/Preface/Preface.pillar+'.    result := writer start: pillarobject ; contents.    self assert: result equals: '!![this is a caption](Chapters/Preface/Preface.pillar)'! !!PRPillarToMicrodownConverterTest methodsFor: 'tests - paragraph list'!testFigureWithArguments    | pillarobject result |    pillarobject := pillarParser parse: '+this is a caption>file://Chapters/Preface/Preface.pillar|label=MyLabel&width=80+'.    result := writer start: pillarobject ; contents.    self assert: result equals: '!![this is a caption](Chapters/Preface/Preface.pillar label=MyLabel&width=80)'"not sure that we have size in microdow. may be this is width"! !!PRPillarToMicrodownConverterTest methodsFor: 'tests - paragraph list'!testInputFile    | pillarobject result |    pillarobject := pillarParser parse: '${inputFile:path=Chapters/Preface/Preface.pillar}$'.    result := writer start: pillarobject ; contents.    self assert: result equals: '<!!inputFile|path=Chapters/Preface/Preface.md!!>'! !!PRPillarToMicrodownConverterTest methodsFor: 'tests - paragraph list'!testInputFileWithFileColumnColumn    | pillarobject result |    pillarobject := pillarParser parse: '${inputFile:path=file://Chapters/Preface/Preface}$'.    result := writer start: pillarobject ; contents.    self assert: result equals: '<!!inputFile|path=Chapters/Preface/Preface.md!!>'! !!PRPillarToMicrodownConverterTest methodsFor: 'tests - paragraph list'!testInputFileWithoutExtension    | pillarobject result |    pillarobject := pillarParser parse: '${inputFile:path=Chapters/Preface/Preface}$'.    result := writer start: pillarobject ; contents.    self assert: result equals: '<!!inputFile|path=Chapters/Preface/Preface.md!!>'! !!PRPillarToMicrodownConverterTest methodsFor: 'tests - paragraph list'!testLink    | pillarobject result |    pillarobject := pillarParser parse: '*this is a caption>file://Chapters/Preface/Preface.pillar*'.    result := writer start: pillarobject ; contents.    self assert: result equals: '[this is a caption](Chapters/Preface/Preface.pillar)'! !!PRPillarToMicrodownConverterTest methodsFor: 'tests - paragraph list'!testMathEnvironment | pillarobject result |    pillarobject := pillarParser parse: '{{{[ X = Y + 2 ]}}}'.    result := writer start: pillarobject ; contents.    self assert: result equals: '$$[ X = Y + 2 ]$$'! !!PRPillarToMicrodownConverterTest methodsFor: 'tests - paragraph list'!testMathInline| pillarobject result |    pillarobject := pillarParser parse: '{{{$X$}}}'.    result := writer start: pillarobject ; contents.    self assert: result equals: '$X$'! !!PRPillarToMicrodownConverterTest methodsFor: 'tests - paragraph list'!testNestedLists	| pillarobject result |	pillarobject := pillarParser parse: 'This is a list- item 1 ""this is bold again my friend"" and not-- item 11-- item 12- item 2-- item 21- item 3'.	result := writer start: pillarobject ; contents.	self assert: result equals: 'This is a list- item 1 **this is bold again my friend** and not  - item 11  - item 12- item 2  - item 21- item 3'! !!PRPillarToMicrodownConverterTest methodsFor: 'tests - paragraph list'!testParagraphList	| pillarobject result |	pillarobject := pillarParser parse: 'This is not bold This is a list- item 1 ""this is bold again my friend""- item 2'.	result := writer start: pillarobject ; contents.	self assert: result equals: 'This is not bold This is a list- item 1 **this is bold again my friend**- item 2'.! !!PRPillarToMicrodownConverterTest methodsFor: 'tests - sections'!testSectionParagraphWithBold	| pillarobject result |	pillarobject := pillarParser parse: '!!!!Heading Twoo ""this is bold""This is not bold '.	result := writer start: pillarobject ; contents.	"we get extra lines because the pillar parser generates empty paragraphs the structure holds an empty paragraph and by default there is a new line emitted after any children."	self assert: result equals: '## Heading Twoo **this is bold**This is not bold '.! !!PRPillarToMicrodownConverterTest methodsFor: 'tests - code blocks'!testSimpleCodeBlock	| pillarobject result |	pillarobject := pillarParser parse: '[[[Point class >> new	self foo	]]]'.	result := writer start: pillarobject ; contents.	self assert: result equals: '```Point class >> new	self foo	```'! !!PRPillarToMicrodownConverterTest methodsFor: 'tests - sections'!testThreeSectionsNoExtraLines	| pillarobject result |	pillarobject := pillarParser parse: '!! Section 1!!Section 2!!Section 3'.	result := writer start: pillarobject ; contents.	self assert: result equals: '# Section 1# Section 2# Section 3'! !!PRPillarToMicrodownConverterTest methodsFor: 'tests - paragraph list'!testTwoLists	| pillarobject result |	pillarobject := pillarParser parse: 'This is list 1- item 11 ""this is bold again my friend""- item 12This is list 2- item 21 ""this is bold again my friend""- item 22 and not bold'.	result := writer start: pillarobject ; contents.	self assert: result equals: 'This is list 1- item 11 **this is bold again my friend**- item 12This is list 2- item 21 **this is bold again my friend**- item 22 and not bold'! !!PRPillarToMicrodownConverterTest methodsFor: 'tests - sections'!testTwoSections	| pillarobject result |	pillarobject := pillarParser parse: '!! Section 1!!Section 2'.	result := writer start: pillarobject ; contents.	"we get an extra line because the structure holds an empty paragraph and by default there is a new line emitted after any children."	self assert: result equals: '# Section 1# Section 2'.! !!PRPillarToMicrodownConverterTest methodsFor: 'tests - sections'!testTwoSectionsNoExtraLines	| pillarobject result |	pillarobject := pillarParser parse: '!! Section 1!!Section 2'.	result := writer start: pillarobject ; contents.	self assert: result equals: '# Section 1# Section 2'.! !!PRPillarToMicrodownConverterTest methodsFor: 'tests - sections'!testTwoSectionsWithParagraph	| pillarobject result |	pillarobject := pillarParser parse: '!! Section 1This is a paragraph.On two lines.!!Section 2'.	result := writer start: pillarobject ; contents.	self assert: result equals: '# Section 1This is a paragraph.On two lines.# Section 2'.! !!BookAsDocBuilder methodsFor: 'stuff'!bookFiles	^ PRInputFileFinder 		fromFileIndex: self fileIndex; files! !!BookAsDocBuilder methodsFor: 'stuff'!fileIndex	"self new readingTitle"	| folder index | 	folder := '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet-PharoWithStyle' asFileReference.	index := folder asFileReference children detect: [ :f | f extension = 'pillar' ]. 	PRPillarParser parse: index contents! !!BookAsDocBuilder methodsFor: 'stuff'!loadMetaData	"self new readingTitle"		| folder | 	folder := '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet-PharoWithStyle' asFileReference.	metadata := STON fromStream: (folder / 'pillar.conf') readStream.! !!BookAsDocBuilder methodsFor: 'stuff'!title 	^ metadata at: #title ifAbsent: [ 'Strange there is no title' ]! !!PRConverterToMic methodsFor: 'conversion'!convertBook: aPath	| input paths |	paths := self getInputFilesPaths: aPath contents.	self handleConfigFile.	input := PRPillarParser parse:  aPath readStream contents.	self writeMicrodownOn: aPath forInput: input.	paths do: [ :path | self convertChapter: path ]! !!PRConverterToMic methodsFor: 'conversion'!convertChapter: aPath	| input |	input := PRPillarParser parse:  aPath readStream contents.	self writeMicrodownOn: aPath forInput: input! !!PRConverterToMic methodsFor: 'conversion'!convertSlide: aPath	| input firstParagraph dict metadata |	input := PRSlideTransformer new start:		         (PRPillarParser parse: aPath readStream contents).	firstParagraph := input children first.	dict := STONJSON fromString: firstParagraph text.	metadata := PRMetadata new metadata: dict.	input children at: 1 put: metadata.	self writeMicrodownOn: aPath forInput: input! !!PRConverterToMic methodsFor: 'collect'!getInputFilesPaths: aString	| paths |	paths := aString substrings.	paths := paths select: [ :string | string beginsWith: '${inputFile:path=' ].		paths replace: [ :string | FileSystem workingDirectory / (string copyFrom: 18 to: string size - 2)].		^ paths! !!PRConverterToMic methodsFor: 'config'!handleConfigFile	"We copy the config file to 'pillarconf.old'	then we migrate it."	| ston conf |	conf := (FileSystem workingDirectory / 'pillar.conf').	conf exists		ifTrue: [ 				| str |				(FileSystem workingDirectory / 'pillarconf.old') ensureDelete.				conf copyTo: (FileSystem workingDirectory / 'pillarconf.old').				ston := (STON reader on: conf readStream) next.				"unsure is this is like that for the plugin but no expansion is needed for annotation				in Microdown" 				ston removeKey: #plugins ifAbsent: [].				ston at: #latexWriter put: ('mic', (ston at: #latexWriter)) asSymbol.				conf ensureDelete.				str := conf writeStream.				STON put: ston asJsonOnStreamPretty: str.				str close.				]		ifFalse: [ Stdio stdout nextPutAll: conf fullName , ' does not exist']! !!PRConverterToMic methodsFor: 'conversion'!writeMicrodownOn: aPath forInput: input	| fileReference |	fileReference := aPath parent / (aPath basenameWithoutExtension , '.md').	fileReference ensureDelete.	^ PRMicrodownWriter new		  setStream: fileReference writeStream;		  start: input! !!PRMicrodownWriter class methodsFor: 'accessing'!fileExtension	^ 'md'! !!PRMicrodownWriter class methodsFor: 'accessing'!folderName	"This method is for decoupling the writer from its physical representation.	It represents the physical folder name in the archetype, used when this writer is specified.	For example your writerName can be latex:sbabook but the corresponding folderName is latex"	^ 'Microdown'! !!PRMicrodownWriter class methodsFor: 'accessing'!writerName	"Each writer define this to know the appropriate files to take for process. This one is different from folderName which corresponds to the physical representation. See folderName"	^ 'Microdown'! !!PRMicrodownWriter methodsFor: 'visiting - formatting'!backSlashString: aString	^ String streamContents: [ :st | 		aString doWithIndex: [ :each :i | 			((Delimiters includes: each asString) or:				 (Delimiters includes:					  each asString , (aString at: (i + 1 min: aString size)) asString)) 			ifTrue: [ st nextPutAll: '\' ].		st nextPutAll: each asString ]]! !!PRMicrodownWriter methodsFor: 'accessing'!canvasClass	^ MicMicrodownTextualBuilder! !!PRMicrodownWriter methodsFor: 'accessing'!canvasSetLF	canvas setNewLineCharacterString: String lf.! !!PRMicrodownWriter methodsFor: 'accessing'!start: anObject	nesting := OrderedCollection new.	super start: anObject! !!PRMicrodownWriter methodsFor: 'visiting - document'!visitAnchor: anAnchor 	canvas anchor: anAnchor name! !!PRMicrodownWriter methodsFor: 'visiting - document'!visitAnnotatedParagraph: anAnnotatedParagraph	"!!!!label paragraph	And Paragraph keeps going here"	canvas annotatedAnnotation: anAnnotatedParagraph annotation.	self visitParagraph: anAnnotatedParagraph	! !!PRMicrodownWriter methodsFor: 'visiting - formatting'!visitBoldFormat: aFormat	canvas bold: [aFormat children do: [:each |each accept: self]]! !!PRMicrodownWriter methodsFor: 'visiting - formatting'!visitChildrenWithoutBackslash: aChildren	aChildren do: [ :each | self visitTextWithoutBackslash: each ]! !!PRMicrodownWriter methodsFor: 'visiting - document'!visitCodeblock: aCodeBlock 		"the only parameter that could be contain a Pillar element is the caption so let us treat separately"	| microdownizedCaption parameters caption |	parameters := aCodeBlock parameters .	"aCodeBlock hasCaption is not working well so use the accessor"	caption := aCodeBlock caption.	caption text isEmpty		ifFalse: [ microdownizedCaption := self class new start: caption; contents.					parameters at: 'caption' put: microdownizedCaption].					"may be we should change the builder to accept an orderedDictionary so that we can just change the caption."	canvas codeblock: aCodeBlock text firstLineAssociations: parameters associations.	! !!PRMicrodownWriter methodsFor: 'visiting - slides'!visitColumn: aColumn	canvas columnWidth: aColumn width asString withBody: [ self visitDocumentGroup: aColumn ]! !!PRMicrodownWriter methodsFor: 'visiting - slides'!visitColumns: aColumns	canvas columnsWithBody: [ self visitDocumentGroup: aColumns ]! !!PRMicrodownWriter methodsFor: 'visiting - document'!visitCommentedLine: aCommentedLine	canvas comment: aCommentedLine text! !!PRMicrodownWriter methodsFor: 'visiting - list'!visitDataItem: aDataItem	self visitAll: aDataItem children! !!PRMicrodownWriter methodsFor: 'visiting - list'!visitDefinitionList: aDefinitionList	aDefinitionList children do: [ :child | 		child accept: self ]! !!PRMicrodownWriter methodsFor: 'visiting - document'!visitDocument: aDocument	aDocument children		do: [ :child | self visit: child ]		separatedBy: [ canvas newLine ]! !!PRMicrodownWriter methodsFor: 'visiting - document'!visitEmptyParagraph: aParagraph	"canvas potentialNewLine"! !!PRMicrodownWriter methodsFor: 'visiting - document'!visitExternalLink: anExternalLink	canvas		externalLink: (self withoutFileColumnColumn: anExternalLink reference)		withDescription: [ canvas text: (self backSlashString: anExternalLink text) ]! !!PRMicrodownWriter methodsFor: 'visiting - document'!visitFigure: aFigure	canvas figureURLString: (self withoutFileColumnColumn: aFigure reference)		withCaption: [ aFigure children do: [:each | each accept: self]] 		withParameters: aFigure parameters! !!PRMicrodownWriter methodsFor: 'visiting - document'!visitHeader: aHeader	| level |	level := aHeader level min: 6 max: 1.	canvas rawHeader:  [ super visitHeader: aHeader ] withLevel: level.	canvas newLine! !!PRMicrodownWriter methodsFor: 'visiting - document'!visitHorizontalRule: anHorizontalLine	canvas horizontalLine! !!PRMicrodownWriter methodsFor: 'visiting'!visitInputFileAnnotation: anInput    | newParameters |	 canvas raw: EnvironmentOpeningBlockMarkup.    canvas raw: 'inputFile'.    anInput parameters ifNotEmpty: [ canvas raw: '|' ].    newParameters := anInput parameters copy.    newParameters        at: 'path'        ifPresent: [ :pathString | | newPath |            newPath := (Path from: (self withoutFileColumnColumn: pathString)) withExtension: 'md'.            newParameters at: 'path' put: newPath pathString ].    newParameters keysAndValuesDo: [ :key :value |         canvas            raw: key asString;            raw: '=';            raw: value asString.        anInput parameters keys last = key ifFalse: [ canvas raw: '&' ] ].	 canvas newLine.    canvas raw: EnvironmentClosingBlockMarkup! !!PRMicrodownWriter methodsFor: 'visiting - document'!visitInternalLink: anInternalLink	"Corresponding to *@fig1* in Pillar"		canvas internalLink: anInternalLink anchor ! !!PRMicrodownWriter methodsFor: 'visiting - formatting'!visitItalicFormat: aFormat	canvas italic: [aFormat children do: [:each |each accept: self]]! !!PRMicrodownWriter methodsFor: 'visiting'!visitListItem: anObject	^ self visitDocumentGroup: anObject! !!PRMicrodownWriter methodsFor: 'visiting-document'!visitMathEnvironment: aMathEnv    canvas mathblock: aMathEnv text! !!PRMicrodownWriter methodsFor: 'visiting - list'!visitMathInline: aMathLine    | text |    text := aMathLine text.    text := text copyFrom: 2 to: (text size - 1).     canvas mathInline: text! !!PRMicrodownWriter methodsFor: 'visiting - document'!visitMetadata: aMetaData	canvas metaDataFrom: aMetaData metaData	! !!PRMicrodownWriter methodsFor: 'visiting - formatting'!visitMonospaceFormat: aFormat	canvas monospace: [self visitChildrenWithoutBackslash: aFormat children]! !!PRMicrodownWriter methodsFor: 'visiting - list'!visitOrderedList2: anOrderedList	| i |	i := 1.	anOrderedList children			do: [ :child | 				canvas writeStartOfOrderedListIndex: i.				i := i + 1. 				self visit: child ]			separatedBy: [ canvas newLine ]! !!PRMicrodownWriter methodsFor: 'visiting - list'!visitOrderedList: anOrderedList	canvas orderedListDuring: [		anOrderedList children			do: [ :child | canvas orderedItem: [ self visit: child ] ] ]! !!PRMicrodownWriter methodsFor: 'visiting - document'!visitParagraph: aParagraph	aParagraph children do: [ :each | self visit: each ].	"canvas potentialNewLine."! !!PRMicrodownWriter methodsFor: 'visiting - document'!visitPreformatted: aPreformatted	canvas writeQuoteCodeBlockDuring: [		aPreformatted children			do: [ :child | self visit: child ]			separatedBy: [ canvas newLine ] ]! !!PRMicrodownWriter methodsFor: 'visiting-document'!visitRaw: aRaw	| text |	text := aRaw text trimBoth.	((text beginsWith: '[') and: [ text endsWith: ']' ])		ifTrue: [ self visitMathEnvironment: aRaw ]		ifFalse: [ 			((text beginsWith: '$') and: [ text endsWith: '$' ])				ifTrue: [ self visitMathInline: aRaw ]				ifFalse: [ 					(aRaw isForType: self writerName) ifTrue: [ 						self writeRawDuring: [ super visitRaw: aRaw ] ] ] ]! !!PRMicrodownWriter methodsFor: 'visiting - slides'!visitSlide: aPRSlide	canvas slideTitle: aPRSlide title withBody: [ self visitDocumentGroup: aPRSlide ]! !!PRMicrodownWriter methodsFor: 'visiting - formatting'!visitStrikethroughFormat: aFormat	canvas strike: [aFormat children do: [:each |each accept: self]]! !!PRMicrodownWriter methodsFor: 'visiting'!visitTable: aTable	self visitAll: aTable children! !!PRMicrodownWriter methodsFor: 'visiting'!visitTableCell: aTableRow	canvas cell: [self visitAll: aTableRow children] 	! !!PRMicrodownWriter methodsFor: 'visiting'!visitTableRow: aTableRow	canvas newLine.	self visitAll: aTableRow children.	canvas raw: '|'.	aTableRow isHeading 		ifTrue:[ canvas newLine.			aTableRow children do: [ :each | canvas headCell ].				canvas raw: '|' ]! !!PRMicrodownWriter methodsFor: 'visiting - list'!visitTermItem: aTermItem	canvas newLine.	canvas newLine.	self visitAll: aTermItem children.	canvas newLine! !!PRMicrodownWriter methodsFor: 'visiting - formatting'!visitText: aText	canvas raw: (self backSlashString: aText text)! !!PRMicrodownWriter methodsFor: 'visiting - formatting'!visitTextWithoutBackslash: aText	canvas text: aText text! !!PRMicrodownWriter methodsFor: 'visiting - list'!visitUnorderedList: anUnorderedList	"We do not have enough information (such as am I the latest of the list and is my container another list or the root document) to control the fact that we should not emit a newline for the last item."			canvas unorderedListDuring: [		anUnorderedList children			do: [ :child | canvas item: [self visit: child ] ] ]! !!PRMicrodownWriter methodsFor: 'visiting - document'!withoutFileColumnColumn: aString	| figref |	figref := aString.	(figref beginsWith: 'file://') ifTrue: [ figref :=  aString allButFirst: 7 ].	^ figref	! !!PRMicrodownWriter methodsFor: 'writing'!writeParagraphDuring: aBlockClosure 		canvas rawParagraph: aBlockClosure! !!PRMicrodownWriterTest methodsFor: 'running'!exampleText	^ 'Hello Pharo'! !!PRMicrodownWriterTest methodsFor: 'running'!exampleTextMultipleLines	^ 'HelloPharo'! !!PRMicrodownWriterTest methodsFor: 'running'!exampleTextMultipleLinesWithNewLine	^ 'HelloPharo'! !!PRMicrodownWriterTest methodsFor: 'running'!exampleTextMultipleLinesWithNewLineBetween	^ 'HelloPharo'! !!PRMicrodownWriterTest methodsFor: 'accessing'!parser	^ parser ! !!PRMicrodownWriterTest methodsFor: 'running'!setUp	super setUp.	parser := Microdown new.	writer := PRMicrodownWriter new.	builder := MicMicrodownTextualBuilder on: String new writeStream	! !!PRMicrodownWriterTest methodsFor: 'tests - anchor'!testAnchor 	"!!!!Note Pharo is cool and microdown too." 	self testWithInitialText: (builder anchor: 'Note'; contents). 	self assert: parsedBloc children first label equals: 'Note'.! !!PRMicrodownWriterTest methodsFor: 'tests - annotated'!testAnnotated	"!!!!Note Pharo is cool and microdown too."		self testWithInitialText: (builder rawAnnotated: 'Note' paragraph:  'Pharo is cool and microdown too'; contents).	self assert: parsedBloc children first label equals: 'Note'.! !!PRMicrodownWriterTest methodsFor: 'tests - annotated'!testAnnotatedOnMultipleLines	self testWithInitialText: (builder rawAnnotated: 'Note' paragraph:  'Pharo is cooland microdown too'; contents).	self assert: parsedBloc children first label equals: 'Note'.! !!PRMicrodownWriterTest methodsFor: 'tests - formatting'!testBold	"**Hello Pharo**"	self testWithInitialText: (builder rawParagraph: [ builder bold: [builder text: self exampleText]]; contents)! !!PRMicrodownWriterTest methodsFor: 'tests - formatting'!testBoldMultipleLines	"**Hello 	Pharo**"		self testWithInitialText: (builder rawParagraph: [ builder bold: [ builder text: self exampleTextMultipleLines]] ; contents)! !!PRMicrodownWriterTest methodsFor: 'tests - code block'!testCodeBlockCaptionContainsMonospace	"```language2=Pharo&caption=`Color` is cool	Hello	Pharo	```"	| mictext |	mictext := builder		           codeblock: self exampleTextMultipleLines		           firstLineAssociations: { 							  ('language' -> 'pharo').				           ('language2' -> 'Pharo').				           ('caption' -> '`Color` is cool') };		           contents.	self testWithInitialText: mictext.	self assert: ('*language*' match: mictext)! !!PRMicrodownWriterTest methodsFor: 'tests - code block'!testCodeBlockParametersWithValueTrue	"```	Hello	Pharo	```"	| pillar |	pillar := PRPillarParser new parse: '[[[testcase=truethis is a code block]]]'.	self assert: (pillar accept: writer) contents equals: '```testcase=truethis is a code block```'! !!PRMicrodownWriterTest methodsFor: 'tests - comments'!testComment	"% Hello Pharo"		self testWithInitialText: (builder comment: self exampleText; contents).! !!PRMicrodownWriterTest methodsFor: 'tests - comments'!testCommentOnMultipleLines	"% Hello 	% Pharo"		self testWithInitialText: (builder comment: self exampleTextMultipleLines ; contents)! !!PRMicrodownWriterTest methodsFor: 'tests - external link'!testExternalLink 	"[Hello Pharo](url)" 	self testWithInitialText: (builder 										rawParagraph: [builder externalLink: 'http://pharo.org/' 											withDescription: [ builder text: self exampleText]]; contents)! !!PRMicrodownWriterTest methodsFor: 'tests - external link'!testExternalLinkWithMicroDownMarkup	"[Hello Pharo](url)"	self testWithInitialText: (builder			 rawParagraph: [ 				 builder					 externalLink: 'http://pharo.org/'					 withDescription: [ builder text: 'Pharo \~is c\**ool' ] ];			 contents)! !!PRMicrodownWriterTest methodsFor: 'tests - figures'!testFigure	"!![Hello Pharo](http://www.pharo.org/foo.png)"	self testWithInitialText: (builder 		rawParagraph: [ builder 								figureURLString: 'http://www.pharo.org/foo.png' 								withCaption: [ builder text: self exampleText ]]; contents)! !!PRMicrodownWriterTest methodsFor: 'tests - figures'!testFigureDoesNotAddFilePointPoint	"!![Hello Pharo](figures/CollectionHierarchy.png)"	self testWithInitialText: (builder 		rawParagraph: [ builder 								figureURLString: 'figures/CollectionHierarchy.png' 								withCaption: [ builder text: self exampleText ]]; contents)! !!PRMicrodownWriterTest methodsFor: 'tests - figures'!testFigureWithArgument	self testWithInitialText: (builder			 rawParagraph: [ 				 builder					 figureURLString: 'http://pharo.org/'					 withCaption: [ builder text: self exampleText ]					 withParameters: (OrderedDictionary new							  at: 'label' put: 'fig1';							  at: 'width' put: '80';							  yourself) ];			 contents)! !!PRMicrodownWriterTest methodsFor: 'tests - figures'!testFigureWithArgumentContainingFormatting	self testWithInitialText: (builder rawParagraph: [ (builder figureURLString: 'http://pharo.org/foo.png' 																				  withCaption: [ builder rawParagraph: [builder text:'You can have '.																																	builder bold: [ builder text: 'bold' ].																																		builder text: ' but also '.																																	builder italic:	[builder text: 'italic']]]																				  withParameters: {'label'->'fig' . 'size'->80 } asDictionary)]; contents)! !!PRMicrodownWriterTest methodsFor: 'tests - figures'!testFigureWithArguments		"!![Hello Pharo](http://pharo.org/label=fig&width=120."		self testWithInitialText: 		(builder rawParagraph: [ 			builder 				figureURLString: 'http://pharo.org/label=fig&width=120' 				withCaption: [ builder text: self exampleText]] ; contents)! !!PRMicrodownWriterTest methodsFor: 'tests - figures'!testFigureWithCaptionContainingFormatting	"!![This is a caption and it can contain **bol** but also `code`.](http://pharo.org)"	self testWithInitialText: (builder			 rawParagraph: [ 				 builder					 figureURLString: 'http://pharo.org/light.png'					 withCaption: [ 						 builder							 text: 'This is a caption and it can contain ';							 bold: [ builder text: 'bol' ];							 text: ' but also ';							 monospace: 'code' ] ];			 contents)! !!PRMicrodownWriterTest methodsFor: 'tests - figures'!testFigureWithMicroDownMarkup	self testWithInitialText: (builder			 rawParagraph: [ 				 builder					 figureURLString: 'http://pharo.org/'					 withCaption: [ builder text: 'Pharo \~is\_\**cool' ]					 withParameters: (OrderedDictionary new							  at: 'label' put: 'fig1';							  at: 'width' put: '80';							  yourself) ];			 contents)! !!PRMicrodownWriterTest methodsFor: 'tests - header'!testHeader	"# Hello Pharo"	| text |	text := builder		        header: [ builder text: self exampleText ] withLevel: 1;		        contents.	self assert: ('*Pharo*' match: text).	self testWithInitialText: text! !!PRMicrodownWriterTest methodsFor: 'tests - header'!testHeaderLvl3	"### Hello Pharo"		self testWithInitialText: (builder header: [ builder text: self exampleText ] withLevel: 3; contents)! !!PRMicrodownWriterTest methodsFor: 'tests - header'!testHeaderWithBold	"# Hello **Pharo** is cool"	self testWithInitialText: (builder 							header: [ builder text: 'Hello ';											 bold: [ builder text: 'Pharo'];											 text: ' is cool'] 							withLevel: 1;												contents)! !!PRMicrodownWriterTest methodsFor: 'tests - header'!testHeaderWithCode	"# Hello `Pharo` is cool"		self testWithInitialText: (builder 							header: [ builder text: 'Hello ';											 monospace: 'Pharo';											 text: ' is cool']  withLevel: 1;											contents)! !!PRMicrodownWriterTest methodsFor: 'tests - header'!testHeaderWithExternalLink	"# Hello [Pharo](http://pharo.org) is cool"		self testWithInitialText: (builder 										header: [ builder 											text: 'Hello ';											externalLink: 'http://pharo.org/' withDescription: [ builder text: 'Pharo' ];											text: ' is cool'] 										withLevel: 1;										contents)! !!PRMicrodownWriterTest methodsFor: 'tests - header'!testHeaderWithItalic	"# Hello _Pharo_ is cool"		self testWithInitialText: (builder 							header: [ builder 											text: 'Hello ';											italic: [ builder text: 'Pharo'];											text: ' is cool']  withLevel: 1;											contents)! !!PRMicrodownWriterTest methodsFor: 'tests - header'!testHeaderWithMircroDownMarkup	"# Hello Pharo"	| text |	text := builder		        header: [ builder text: 'Pharo \~is c\**ool' ] withLevel: 1;		        contents.	self assert: ('*Pharo*' match: text).	self testWithInitialText: text! !!PRMicrodownWriterTest methodsFor: 'tests - header'!testHeaderWithStrike	"# Hello ~Pharo~ is cool"	self testWithInitialText: (builder 							header: [ builder 											text: 'Hello ';											strike: [ builder text: 'Pharo'];											text: ' is cool']  withLevel: 1;											contents)! !!PRMicrodownWriterTest methodsFor: 'tests - horizontal line'!testHorizontalLine	"***"		self testWithInitialText: (builder horizontalLine; contents)! !!PRMicrodownWriterTest methodsFor: 'tests - horizontal line'!testHorizontalLineWithIgnoredText	"*** kjlkjkljkl"	initialText := (builder raw: HorizontalLineMarkup; space; raw: 'Blblblbl'; contents).	parsedBloc := self parser parse: initialText readStream.	writtenText := self writer start: parsedBloc asPillar; contents.	self assert: writtenText equals: HorizontalLineMarkup, String cr.	! !!PRMicrodownWriterTest methodsFor: 'tests - internal link'!testInternalLink	"*@fig1*"		self testWithInitialText: (builder rawParagraph: [ builder internalLink: 'fig1' ]; contents)! !!PRMicrodownWriterTest methodsFor: 'tests - formatting'!testItalic	"_Hello Pharo_"		self testWithInitialText: (builder rawParagraph: [ builder italic: self exampleText] ; contents)! !!PRMicrodownWriterTest methodsFor: 'tests - formatting'!testItalicMultipleLines	"_Hello	Pharo_"		self testWithInitialText: (builder rawParagraph: [ builder italic: self exampleTextMultipleLines]; contents)! !!PRMicrodownWriterTest methodsFor: 'tests - meta data'!testMetaData		| mictext |	'{ 	"authors": "S. Ducasse", "title" : "Pharo by Example" 	}'.	mictext := (builder metaDataFromAssociations: { 'authors' -> 'S. Ducasse' .  'title' -> 'Pharo by Example' };		contents).	self testWithInitialText: mictext.	self assert: ('*authors*' match: mictext)	! !!PRMicrodownWriterTest methodsFor: 'tests - meta data'!testMetaData2		| mictext |	'{ 	"authors": "S. Ducasse"	}'.	mictext := (builder metaDataFromAssociations: { 'authors' -> 'S. Ducasse' };		contents).	self testWithInitialText: mictext.	self assert: ('*authors*' match: mictext)	! !!PRMicrodownWriterTest methodsFor: 'tests - meta data'!testMetaData3		| mictext |	'{ 	"authors": "S. Ducasse"	}'.	mictext := (builder metaDataFromAssociations: { 'authors' -> 'S. Ducasse' };		contents).	self testWithInitialText: mictext.	self assert: ('*authors*' match: mictext)	! !!PRMicrodownWriterTest methodsFor: 'tests - formatting'!testMonospace	"`Hello Pharo`"		self testWithInitialText: (builder rawParagraph: [ builder monospace: self exampleText]; contents)! !!PRMicrodownWriterTest methodsFor: 'tests - formatting'!testMonospaceMultipleLines	"`Hello	Pharo`"		self testWithInitialText: (builder rawParagraph: [ builder monospace: self exampleTextMultipleLines] ; contents)! !!PRMicrodownWriterTest methodsFor: 'tests - list'!testNestedUnorderedList	"- Hello	- Pharo"	| mictext |	mictext := (builder unorderedListDuring: [ 					builder item: [ builder text: 'Level 1' ].					builder unorderedListDuring: [ 								builder item: [ builder text: 'Level 2 1' ].								builder item: [ builder text: 'Level 2 2' ] ] .					builder item: [ builder text: 'Microdown item list' ]];		contents).	self testWithInitialText: mictext.	self assert: mictext equals: '- Level 1  - Level 2 1  - Level 2 2- Microdown item list'.	! !!PRMicrodownWriterTest methodsFor: 'tests - paragraph'!testOneParagraph	self testWithInitialText: (builder rawParagraph: [ builder text: 'Pharo is super cool']; contents)! !!PRMicrodownWriterTest methodsFor: 'tests - paragraph'!testOneParagraphWithAdorment	"**Pharo** is `COOL`"	self testWithInitialText: (builder rawParagraph: [ builder bold: [builder text:'Microdown']; text: ' is '; monospace: 'COOL' ]; contents)! !!PRMicrodownWriterTest methodsFor: 'tests - list'!testOrderedList	"- Hello	- Pharo"	| mictext |	mictext := (builder orderedListDuring: [		builder orderedItem: [ builder text: 'Hello' ].		builder orderedItem: [ builder text: 'Beautiful' ].		builder orderedItem: [ builder text: 'Microdown item list' ]];		contents).	self testWithInitialText: mictext.	self assert: (mictext occurrencesOf: $.) equals: 3	! !!PRMicrodownWriterTest methodsFor: 'tests - list'!testOrderedListWithFormat	"1. **Hello**	2. Pharo"		| mictext |	mictext := (builder orderedListDuring: [						builder orderedItem: [ builder bold: 'Hello'; space; text: 'beautiful' ].						builder orderedItem: [ builder text: 'Pharo' ] ] ;						contents).	self testWithInitialText: mictext.	self assert: (mictext occurrencesOf: $.) equals: 2! !!PRMicrodownWriterTest methodsFor: 'tests - list'!testOrderedListWithMicroDownMarkup	"- Hello	- Pharo"	| mictext |	mictext := builder		           orderedListDuring: [ 			           builder orderedItem: [ builder text: '\~Hello' ].			           builder orderedItem: [ builder text: '\**Beautiful' ].			           builder orderedItem: [ 					           builder text: 'Microdown item list' ] ];		           contents.	self testWithInitialText: mictext.	self assert: (mictext occurrencesOf: $.) equals: 3! !!PRMicrodownWriterTest methodsFor: 'tests'!testPRInputFileAnnotation	| pillar |	pillar := PRPillarParser new parse:		          '${inputFile:path=Chapters/Smacc/SmaccIntro.pillar}$${inputFile:path=Chapters/Smacc/SmaccTutorial.pillar}$${inputFile:path=Chapters/Smacc/SmaccScanner.pillar}$${inputFile:path=Chapters/Smacc/SmaccParser.pillar}$'.	self		assert: (self writer start: pillar) contents		equals: '<!!inputFile|path=Chapters/Smacc/SmaccIntro.md!!><!!inputFile|path=Chapters/Smacc/SmaccTutorial.md!!><!!inputFile|path=Chapters/Smacc/SmaccScanner.md!!><!!inputFile|path=Chapters/Smacc/SmaccParser.md!!>'! !!PRMicrodownWriterTest methodsFor: 'tests - paragraph'!testParagraphWithMicroDownMarkup	self testWithInitialText: (builder			 rawParagraph: [ builder text: 'Pharo \_is su\~per c\**ool' ];			 contents)! !!PRMicrodownWriterTest methodsFor: 'tests - quote block'!testQuoteBlock	"> Hello Pharo"		self testWithInitialText: (builder quoteBlock: self exampleText; contents)! !!PRMicrodownWriterTest methodsFor: 'tests - quote block'!testQuoteBlockOnMultipleLines	"> Hello Pharo"	self skip.	"The problem here is that quote a un seul text donc si on traite les formatting nous allons perdre les cr 	et du coup on ne peut pas avoir la semantique d'isomorphisme. 	But the question is if we want it:		if quote block is a pure preformatted this is easy. Noformatting so we keep the cr. 		if quote block is more different way to describe a paragraph then we cannot keep the cr		because in that case					aa *bb			bb* cc			should be handled			as				aa boldbb 				boldbb cc			so the termination due to to new line should propagate to the next line.					"	self testWithInitialText: (builder quoteBlock: self exampleText; newLine; quoteBlock: self exampleText ; contents)! !!PRMicrodownWriterTest methodsFor: 'tests - quote block'!testQuoteBlockOnMultipleLinesWithFormatting	"> Hello Pharo"	"to be changed explicit use of ** should only for testing strange human edition"	self skip.	self testWithInitialText: (builder quoteBlock: 'hello **bold**'; newLine; quoteBlock: self exampleText ; contents)	"MicInlineSplitter new start: parsedBloc children first text"		"MicInlineSplitter new start: 'hello **bold**', String cr, 'Pharo'	ne garde pas les sauts de ligne.	Donc cela veut dire que pour les lignes qui ne sont pas des paragraphes et que l'on veut garder comme	telles on ne peut pas avoir des formatting qui debutent et finissent sur deux lignes.	"! !!PRMicrodownWriterTest methodsFor: 'tests - code block'!testSimpleCodeBlock	"```	Hello	Pharo	```"		self testWithInitialText: (builder codeblock: self exampleTextMultipleLines 												 firstLineAssociations: {('language' -> 'pharo')}; contents)! !!PRMicrodownWriterTest methodsFor: 'tests - code block'!testSimpleCodeBlockWithFirstTag	"```language=Pharo	Hello	Pharo	```"	| mictext |	mictext := builder codeblock: self exampleTextMultipleLines firstLineAssociations: {'language' -> 'Pharo'} ; contents.	self testWithInitialText: mictext.	self assert: ('*language*' match: mictext) ! !!PRMicrodownWriterTest methodsFor: 'tests - formatting'!testStrike	"~Hello Pharo~"		self testWithInitialText: (builder rawParagraph: [ builder strike: self exampleText]; contents)! !!PRMicrodownWriterTest methodsFor: 'tests - formatting'!testStrikeMultipleLines	"~Hello	Pharo~"		self testWithInitialText: (builder rawParagraph: [ builder strike: self exampleTextMultipleLines]; contents)! !!PRMicrodownWriterTest methodsFor: 'tests - paragraph'!testTwoParagraphs	"Hello		Pharo"	self testWithInitialText: (builder rawParagraph: [builder text: 'hello'] ; newLine;												rawParagraph: [ builder text: 'Pharo' ] ; contents)! !!PRMicrodownWriterTest methodsFor: 'tests - list'!testUnorderedList	"- Hello	- Pharo"	| mictext |	mictext := (builder unorderedListDuring: [ 		builder item: [ builder text: 'Hello' ].		builder item: [ builder text: 'Beautiful' ].		builder item: [ builder text: 'Microdown item list' ]];		contents).	self testWithInitialText: mictext.	self assert: (mictext occurrencesOf: $-) equals: 3	! !!PRMicrodownWriterTest methodsFor: 'tests - list'!testUnorderedListWithFormat	"- **Hello**	- Pharo"		| mictext |	mictext := (builder unorderedListDuring: [						builder item: [ builder bold: 'Hello'; space; text: 'beautiful...' ].						builder item: [ builder text: 'Pharo' ] ] ;						contents).	self testWithInitialText: mictext.	self assert: (mictext occurrencesOf: $-) equals: 2! !!PRMicrodownWriterTest methodsFor: 'tests - list'!testUnorderedListWithMicroDownMarkup	"- Hello	- Pharo"	| mictext |	mictext := builder		           unorderedListDuring: [ 			           builder item: [ builder text: '\~Hello' ].			           builder item: [ builder text: '\**Beautiful' ].			           builder item: [ builder text: 'Microdown item list' ] ];		           contents.	self testWithInitialText: mictext.	self assert: (mictext occurrencesOf: $-) equals: 3! !!PRMicrodownWriterTest methodsFor: 'running'!testWithInitialText: expectedString	parsedBloc := self parser parse: expectedString readStream.	writtenText := self writer		               start: parsedBloc asPillar;		               contents.	self assert: expectedString equals: writtenText! !!PRMicrodownWriterTest methodsFor: 'accessing'!writer	^ writer! !"Pillar-ExporterMicrodown"!!PRToolIconSelector commentStamp: '' prior: 0!An item selector for SpotterInstance Variables	icon:		<Object>icon	- xxxxx!!PRToolLabelSelector commentStamp: '' prior: 0!A visitor to display the correct label in spotterInstance Variables	label:		<String>label	- xxxxx!!PRToolIcons commentStamp: '' prior: 0!An icon cache!!PRToolIconSelector class methodsFor: 'testing'!isAbstract	^ false! !!PRToolIconSelector methodsFor: 'accessing'!icon	^icon! !!PRToolIconSelector methodsFor: 'visiting-document'!visitAnchor: anObject		icon := PRToolIcons anchorIcon ! !!PRToolIconSelector methodsFor: 'visiting-document'!visitBoldFormat: anObject	icon := PRToolIcons boldIcon! !!PRToolIconSelector methodsFor: 'visiting-document'!visitEmptyParagraph: anObject		icon := PRToolIcons emptyParagraphIcon ! !!PRToolIconSelector methodsFor: 'visiting-document'!visitHeader: aHeader	aHeader level = 1 ifTrue: [ icon := PRToolIcons heading1Icon ].	aHeader level = 2 ifTrue: [ icon := PRToolIcons heading2Icon ].	aHeader level = 3 ifTrue: [ icon := PRToolIcons heading3Icon ].	aHeader level = 4 ifTrue: [ icon := PRToolIcons heading4Icon ].	aHeader level = 5 ifTrue: [ icon := PRToolIcons heading5Icon ].	aHeader level = 6 ifTrue: [ icon := PRToolIcons heading6Icon ].	aHeader level > 6 ifTrue: [ icon := PRToolIcons headingXIcon ].! !!PRToolIconSelector methodsFor: 'visiting-document'!visitItalicFormat: anObject	icon := PRToolIcons italicIcon  ! !!PRToolIconSelector methodsFor: 'visiting-document'!visitListItem: anObject	icon := PRToolIcons listItemIcon! !!PRToolIconSelector methodsFor: 'visiting-document'!visitOrderedList: anObject	icon := PRToolIcons orderedList ! !!PRToolIconSelector methodsFor: 'visiting-document'!visitParagraph: anObject		icon := PRToolIcons paragraphIcon ! !!PRToolIconSelector methodsFor: 'visiting-document'!visitSubscriptFormat: anObject	icon := PRToolIcons subscriptIcon  ! !!PRToolIconSelector methodsFor: 'visiting-document'!visitSuperscriptFormat: anObject	icon := PRToolIcons superscriptIcon ! !!PRToolIconSelector methodsFor: 'visiting-document'!visitTable: anObject		icon := PRToolIcons tableIcon ! !!PRToolIconSelector methodsFor: 'visiting-document'!visitTableCell: anObject		icon := PRToolIcons tableCellIcon! !!PRToolIconSelector methodsFor: 'visiting-document'!visitTableRow: anObject		icon := PRToolIcons tableRowIcon! !!PRToolIconSelector methodsFor: 'visiting-document'!visitText: anObject	icon := PRToolIcons textIcon  ! !!PRToolIconSelector methodsFor: 'visiting-document'!visitUnorderedList: anObject	icon := PRToolIcons unorderedList ! !!PRToolLabelSelector class methodsFor: 'testing'!isAbstract	^ false! !!PRToolLabelSelector methodsFor: 'accessing'!label	^ label! !!PRToolLabelSelector methodsFor: 'accessing'!label: anObject	label := anObject! !!PRToolLabelSelector methodsFor: 'visiting-document'!visitAnchor: anObject		label := anObject name! !!PRToolLabelSelector methodsFor: 'visiting-document'!visitCommentedLine: aCommentedLine	label := aCommentedLine text! !!PRToolLabelSelector methodsFor: 'visiting-document'!visitEmptyParagraph: anObject	label := ''! !!PRToolLabelSelector methodsFor: 'visiting-document'!visitOrderedList: anObject	label := '#... (', anObject children size asString, ')' ! !!PRToolLabelSelector methodsFor: 'visiting-document'!visitTable: anObject	label := anObject rowCount asString, ' row(s) x ', anObject columnCount asString, ' column(s)'! !!PRToolLabelSelector methodsFor: 'visiting-document'!visitText: anObject	label := anObject text! !!PRToolLabelSelector methodsFor: 'visiting-document'!visitUnorderedList: anObject	label := '-... (', anObject children size asString, ')' ! !!PRToolIcons class methodsFor: 'icons'!anchorIcon	^(self iconCache) 		at: #anchorIcon		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 4278190080 4278190080 0 0 0 4278190080 4278190080 0 0 0 4278190080 4278190080 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 0 0 0 0 4278190080 4278190080 0 0 0 4278190080 4278190080 0 0 0 4278190080 4278190080 0 0 0 0 0 4278190080 4278190080 0 4278190080 4278190080 4278190080 4278190080 0 4278190080 4278190080 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons'!boldIcon	^(self iconCache) 		at: #boldIcon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'utilities'!browseIcons	<script>		self iconCache inspect! !!PRToolIcons class methodsFor: 'icons'!commentIcon	^(self iconCache) 		at: #commentIcon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 4278190080 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 4278190080 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 4278190080 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 4278190080 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 4278190080 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 4278190080 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons'!emptyParagraphIcon	^(self iconCache) 		at: #emptyParagraphIcon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 4278190080 4278190080 0 4278190080 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 4278190080 4278190080 0 4278190080 0 0 4278190080 0 0 4278190080 0 0 0 0 0 0 4278190080 4278190080 0 4278190080 0 0 4278190080 0 0 4278190080 0 0 0 0 0 0 0 4278190080 0 4278190080 0 0 4278190080 0 0 4278190080 0 0 0 0 0 0 0 4278190080 0 4278190080 0 0 4278190080 0 0 4278190080 0 0 0 0 0 0 0 4278190080 0 4278190080 0 0 4278190080 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons'!heading1Icon	^(self iconCache) 		at: #heading1Icon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons'!heading2Icon	^(self iconCache) 		at: #heading2Icon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons'!heading3Icon	^(self iconCache) 		at: #heading3Icon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 0 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons'!heading4Icon	^(self iconCache) 		at: #heading4Icon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 0 4278190080 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons'!heading5Icon	^(self iconCache) 		at: #heading5Icon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 4278190080 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 4278190080 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 0 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons'!heading6Icon	^(self iconCache) 		at: #heading6Icon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 4278190080 4278190080 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 0 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons'!headingXIcon	^(self iconCache) 		at: #headingXIcon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'private accessing'!iconCache	^ IconCache ifNil: [ IconCache := Dictionary new ]! !!PRToolIcons class methodsFor: 'accessing'!iconNamed: aSymbol	"Returns the icon with the given name"		^(self iconCache) 		at: aSymbol 		ifAbsentPut: [ 			"this is a hack to make Nautilus work"			(self class canUnderstand: aSymbol) 				ifTrue: [ self perform: aSymbol ]				ifFalse: [ super iconNamed: aSymbol ] ]! !!PRToolIcons class methodsFor: 'icons'!italicIcon	^(self iconCache) 		at: #italicIcon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons'!listItemIcon	^(self iconCache) 		at: #listItemIcon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons'!orderedList	^(self iconCache) 		at: #orderedList 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons'!paragraphIcon	^(self iconCache) 		at: #paragraphIcon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 4278190080 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 4278190080 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'initialization-release'!reset	"Reset the icon cache"		<script>		IconCache := nil! !!PRToolIcons class methodsFor: 'icons'!subscriptIcon	^(self iconCache) 		at: #subscriptIcon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 0 0 0 4278190080 0 0 4278190080 0 0 0 0 4278190080 4278190080 0 0 4278190080 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 4278190080 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons'!superscriptIcon	^(self iconCache) 		at: #superscriptIcon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 4278190080 0 0 4278190080 0 0 0 0 0 0 4278190080 4278190080 0 0 4278190080 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons'!tableCellIcon	^(self iconCache) 		at: #tableCellIcon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons'!tableIcon	^(self iconCache) 		at: #tableIcon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons'!tableRowIcon	^(self iconCache) 		at: #tableRowIcon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons'!textIcon	^(self iconCache) 		at: #textIcon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 4278190080 0 0 0 4278190080 4278190080 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons'!unorderedList	^(self iconCache) 		at: #unorderedList 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRDocumentGroup methodsFor: '*Pillar-Pharo-Tools'!gtInspectorTreeRepresentationIn: composite	<gtInspectorPresentationOrder: 30>	composite tree		title: 'Tree';		children: [ :item | 					item hasChildren						ifTrue: [ item children ] ];		format: [ :item | (item class name allButFirst: 2) , '(' , item asString , ')' ]! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools'!gtInspectorAsciiDocRepresentationIn: composite	<gtInspectorPresentationOrder: 80>	composite text 		title: 'AsciiDoc';		display: [ 			(PRAsciiDocWriter write: self) ]! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools'!gtInspectorBeamerRepresentationIn: composite	<gtInspectorPresentationOrder: 80>	composite text 		title: 'Beamer';		display: [ 			(PRBeamerWriter write: self) ]! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools'!gtInspectorDeckJSRepresentationIn: composite	<gtInspectorPresentationOrder: 51>	composite text 		title: 'DeckJS';		display: [ 			(PRDeckJSWriter write: self) ]! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools'!gtInspectorHTMLRepresentationIn: composite	<gtInspectorPresentationOrder: 50>	composite text 		title: 'HTML';		display: [ 			(PRHTMLWriter write: self) ]! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools'!gtInspectorLaTeXRepresentationIn: composite	<gtInspectorPresentationOrder: 80>	composite text 		title: 'LaTeX';		display: [ 			(PRLaTeXWriter write: self) ]! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools'!gtInspectorMarkdownRepresentationIn: composite	<gtInspectorPresentationOrder: 70>	composite text 		title: 'Markdown';		display: [ 			(PRMarkdownWriter write: self) ]! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools'!gtInspectorPillarRepresentationIn: composite	<gtInspectorPresentationOrder: 40>	composite text 		title: 'Pillar';		display: [ 			(PRPillarWriter write: self) ]! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools'!gtInspectorSBALaTeXRepresentationIn: composite	<gtInspectorPresentationOrder: 80>	composite text 		title: 'LaTeX (sbabook)';		display: [ 			(PRSBALaTeXWriter write: self) ]! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools'!gtInspectorTextRepresentationIn: composite	<gtInspectorPresentationOrder: 60>	composite text 		title: 'Text';		display: [ 			(PRTextWriter write: self) ]! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools'!inpectionASCIIDOCWriter	<inspectorPresentationOrder: 60 title: 'PRBeamerWriter'>	^ SpTextPresenter new 		text: (PRBeamerWriter write: self);		yourself! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools'!inpectionBeamerWriter	<inspectorPresentationOrder: 60 title: 'Beamer'>	^ SpTextPresenter new 		text: (PRBeamerWriter write: self);		yourself! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools'!inpectionDeckJSWriter	<inspectorPresentationOrder: 60 title: 'LaTeX'>	^ SpTextPresenter new 		text: (PRDeckJSWriter write: self);		yourself! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools'!inpectionHTMLWriter	<inspectorPresentationOrder: 30 title: 'HTML'>	^ SpTextPresenter new 		text: (PRHTMLWriter write: self);		yourself			! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools'!inpectionLaTeXSBAWriter	<inspectorPresentationOrder: 60 title: 'SBA'>	^ SpTextPresenter new 		text: (PRSBALaTeXWriter write: self);		yourself! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools'!inpectionLaTeXWriter	<inspectorPresentationOrder: 60 title: 'LaTeX'>	^ SpTextPresenter new 		text: (PRLaTeXWriter write: self);		yourself! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools'!inpectionMarkdownWriter	<inspectorPresentationOrder: 30 title: 'MarkDown'>	^ SpTextPresenter new 		text: (PRMarkdownWriter write: self);		yourself			! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools'!inpectionMicrodownWriter	<inspectorPresentationOrder: 20 title: 'MuDown'>	^ SpTextPresenter new 		text: ([ (PRMicrodownWriter write: self)] on: Error do: [:ex | 'Got an error']);		yourself			! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools'!inpectionPillarTree 	<inspectorPresentationOrder: 35 title: 'PillarTree'>	"(PRPillarParser parse: '!!This is a test Pillar is cool but microdown Cooler. Yes') inspect" 	^ SpTreePresenter new  		roots: { self }; 		children: [ :aNode | aNode children ]; 		display: [ :each |  			String 				streamContents: [ :stream |  					each displayStringOn: stream]. 			 ]; 		yourself! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools'!inpectionPillarWriter	<inspectorPresentationOrder: 35 title: 'Pillar'>	^ SpTextPresenter new 		text: (PRPillarWriter write: self);		yourself			! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools'!inpectionTextWriter	<inspectorPresentationOrder: 30 title: 'Text'>	^ SpTextPresenter new 		text: (PRTextWriter write: self);		yourself			! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools'!spotterForPillarDocumentFor: aStep	<spotterOrder: 40>	aStep listProcessor 		title: 'Children';		candidatesLimit: Float infinity;		allCandidates: [ self children ];		itemName: [:item | (PRToolLabelSelector new)									visit: item;									label ];		itemIcon: [:item | (PRToolIconSelector new)									visit: item;									icon ];		matchSubstring! !"Pillar-Pharo-Tools"!!ClapPillarBuildCommandTest methodsFor: 'tests'!configContent	^ '{  "title": "The Pillar Super Book Archetype",  "attribution": "The Pillar team",  "series": "Square Bracket tutorials",  "keywords": "project template, Pillar, Pharo, Smalltalk",  "language": "en-UK",  "epub-id": "urn:uuid:A1B0D67E-2E81-4DF5-9E67-A64CBE366809",  "defaultExport": "pdf",    "latexTemplate": "main.latex.mustache",  "htmlTemplate": "html.mustache",  "latexWriter" : #''latex:sbabook'',  "htmlWriter": #html}'! !!ClapPillarBuildCommandTest methodsFor: 'running'!setUp	"Create a setup project with: index.pillar, a conf, and Chapters with Chap1 and Chap2"	| workingDir |	super setUp.	workingDir := FileSystem workingDirectory.	workingDir / 'pillar.conf' writeStreamDo: [ :st | st nextPutAll: self configContent ]! !!ClapPillarBuildCommandTest methodsFor: 'running'!tearDown	(FileSystem workingDirectory / 'pillar.conf') delete.	super tearDown! !!ClapPillarBuildCommandTest methodsFor: 'adding'!testAddSubcommand	| allIds defaultCommand |	defaultCommand := ClapPillarBuildCommand commandSpecification.	allIds := PRTarget clapCommandList collect: [ :c | c identifier ].	allIds do: 		[ :id | 			self assert: 				(defaultCommand subcommands anySatisfy: 					[ :c | c class = ClapCommand new class and: c identifier = id asSymbol]			) 		]! !!ClapPillarBuildCommandTest methodsFor: 'tests'!testDefaultCommandIsBuild	| defaultCommand |	defaultCommand := ClapPillarBuildCommand commandSpecification.	self assert: defaultCommand identifier equals: #build! !!ClapPillarBuildCommandTest methodsFor: 'tests'!testSameFlagsMainAndDefault	| defaultCommand mainCommand |	defaultCommand := ClapPillarBuildCommand commandSpecification .	mainCommand := (PRProject on: FileSystem workingDirectory) defaultTarget buildClapCommand.	self assert: defaultCommand flags asString equals: mainCommand flags asString! !!PRSubCommandLineHandlerTest methodsFor: 'tests'!testAddingBaseDirectoryWithADash	|cli arguments |	cli := PRSubCommandLineHandler new.	arguments := Dictionary new.	cli add: '--baseDirectory=/foo/bar-baz' to: arguments.	self assert: (arguments at: 'baseDirectory') equals: '/foo/bar-baz'! !!PRSubCommandLineHandlerTest methodsFor: 'tests'!testAddingBaseDirectoryWithAnEqual	|cli arguments |	cli := PRSubCommandLineHandler new.	arguments := Dictionary new.	cli add: '--baseDirectory=/foo/bar=baz' to: arguments.	self assert: (arguments at: 'baseDirectory') equals: '/foo/bar=baz'! !"Pillar-Tests-Cli"!!PRPillarGrammarTest methodsFor: 'tests - Script'!codeBlockSample	^ factory codeBlockSample ! !!PRPillarGrammarTest methodsFor: 'accessing'!factory	^ factory ! !!PRPillarGrammarTest methodsFor: 'accessing'!factory: aFactory	factory := aFactory! !!PRPillarGrammarTest methodsFor: 'accessing'!parserClass	^ PRPillarGrammar! !!PRPillarGrammarTest methodsFor: 'running'!setUp 	super setUp.	self factory: PillarSnippetFactory new.! !!PRPillarGrammarTest methodsFor: 'tests - Reference'!testAliasFigure	self parse: factory aliasFigureSample rule: #figureAlias! !!PRPillarGrammarTest methodsFor: 'tests - Reference'!testAliasFigureEscape	self parse: factory aliasFigureEscapeSample rule: #figureAlias! !!PRPillarGrammarTest methodsFor: 'tests - Reference'!testAliasLink	self parse: factory aliasLinkSample rule: #linkAlias! !!PRPillarGrammarTest methodsFor: 'tests - Reference'!testAliasLinkEscape	self parse: factory aliasLinkEscapeSample rule: #linkAlias! !!PRPillarGrammarTest methodsFor: 'tests - Anchor'!testAnchor	self parse: factory anchorSample rule: #anchor! !!PRPillarGrammarTest methodsFor: 'tests - Anchor'!testAnchorAreTrimed	self parse: factory anchorAreTrimedSample rule: #anchor! !!PRPillarGrammarTest methodsFor: 'tests - Anchor'!testAnchorWithNewLine	self parse: factory anchorWithNewLineSample rule: #elementWithNewline! !!PRPillarGrammarTest methodsFor: 'tests - Anchor'!testAnchorWithSpaceInside	self parse: factory anchorWithSpaceInsideSample rule: #anchor! !!PRPillarGrammarTest methodsFor: 'tests - Paragraph'!testAnnotatedParagraph	self		parse: factory annotatedParagraphSample		rule: #annotatedParagraph! !!PRPillarGrammarTest methodsFor: 'tests - Paragraph'!testAnnotatedParagraphEmpty	self		parse: factory annotatedParagraphEmptySample		rule: #annotatedParagraph! !!PRPillarGrammarTest methodsFor: 'tests - Paragraph'!testAnnotatedParagraphEmptyWithNewLine	self		parse: factory annotatedParagraphEmptyWithNewLineSample		rule: #elementWithNewline! !!PRPillarGrammarTest methodsFor: 'tests - Annotation'!testAnnotation	self parse: factory annotationSample rule: #annotation! !!PRPillarGrammarTest methodsFor: 'tests - Annotation'!testAnnotationAreTrimedAtTheRight	self		parse: factory annotationAreTrimedAtTheRightSample		rule: #annotation! !!PRPillarGrammarTest methodsFor: 'tests - Annotation'!testAnnotationOnlyWithParameterName	self		parse: factory annotationOnlyWithParameterNameSample		rule: #annotation! !!PRPillarGrammarTest methodsFor: 'tests - Annotation'!testAnnotationParameter	self		parse: factory annotationParameterSample		rule: #parameterUntilEndAnnotation! !!PRPillarGrammarTest methodsFor: 'tests - Annotation'!testAnnotationParameters	self		parse: factory annotationParametersSample		rule: #annotationParameters! !!PRPillarGrammarTest methodsFor: 'tests - Annotation'!testAnnotationParameters2	self		parse: factory annotationParameters2Sample		rule: #parametersUntilEndAnnotation! !!PRPillarGrammarTest methodsFor: 'tests - Annotation'!testAnnotationTag	self parse: factory annotationTagSample rule: #annotationTag! !!PRPillarGrammarTest methodsFor: 'tests - Annotation'!testAnnotationWithUnknownKey	self parse: factory annotationWithUnknownKeySample rule: #annotation! !!PRPillarGrammarTest methodsFor: 'tests - Annotation'!testAnnotationWithoutFirstParameterNameAndDefaultValues	self		parse: factory annotationWithoutFirstParameterNameAndDefaultValuesSample		rule: #annotation! !!PRPillarGrammarTest methodsFor: 'tests - Annotation'!testAnnotationWithoutParameterName	self		parse: factory annotationWithoutParameterNameSample		rule: #annotation! !!PRPillarGrammarTest methodsFor: 'tests - Annotation'!testAnnotationWithoutParameters	self		parse: factory annotationWithoutParametersSample		rule: #annotation! !!PRPillarGrammarTest methodsFor: 'tests - Format'!testBoldFormat	self parse: factory boldFormatSample rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format'!testBoldFormatEmpty	self parse: factory boldFormatEmptySample rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format'!testBoldFormatWithEscaped	self parse: factory boldFormatWithEscapedSample rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Text'!testCommentedLine	self parse: factory commentedLineSample rule: #commentedLine! !!PRPillarGrammarTest methodsFor: 'tests - Text'!testCommentedLineWithNewline	self		parse: factory commentedLineWithNewlineSample		rule: #elementWithNewline! !!PRPillarGrammarTest methodsFor: 'tests - List'!testDefinitionList	self parse: factory definitionListSample rule: #definitionList! !!PRPillarGrammarTest methodsFor: 'tests - Paragraph'!testEmptyParagraph	self parse: factory emptyParagraphSample rule: #emptyParagraph! !!PRPillarGrammarTest methodsFor: 'tests - Text'!testEscapedCharacter	self parse: factory escapedCharacterSample rule: #escapedCharacter! !!PRPillarGrammarTest methodsFor: 'tests - Reference'!testFigureFollowedByLinkWithAlias	self		parse: factory figureFollowedByLinkWithAliasSample		rule: #paragraph! !!PRPillarGrammarTest methodsFor: 'tests - Format'!testFormatWithLink	self parse: factory formatWithLinkSample rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Header'!testHeaderEmpty	self parse: factory headerEmptySample rule: #header! !!PRPillarGrammarTest methodsFor: 'tests - Header'!testHeaderLevel1	self parse: factory headerLevel1Sample rule: #header! !!PRPillarGrammarTest methodsFor: 'tests - Header'!testHeaderLevel2	self parse: factory headerLevel2Sample rule: #header! !!PRPillarGrammarTest methodsFor: 'tests - Header'!testHeaderLevel3	self parse: factory headerLevel3Sample rule: #header! !!PRPillarGrammarTest methodsFor: 'tests - Header'!testHeaderLevel4	self parse: factory headerLevel4Sample rule: #header! !!PRPillarGrammarTest methodsFor: 'tests - Header'!testHeaderLevel5	self parse: factory headerLevel5Sample rule: #header! !!PRPillarGrammarTest methodsFor: 'tests - Header'!testHeaderLevel6	self parse: factory headerLevel6Sample rule: #header! !!PRPillarGrammarTest methodsFor: 'tests - Header'!testHeaderWithFormat	self parse: factory headerWithFormatSample rule: #header! !!PRPillarGrammarTest methodsFor: 'tests - Header'!testHeaderWithFormatAndText	self parse: factory headerWithFormatAndTextSample rule: #header! !!PRPillarGrammarTest methodsFor: 'tests - Header'!testHeaderWithNewLine	self parse: factory headerWithNewLineSample rule: #elementWithNewline! !!PRPillarGrammarTest methodsFor: 'tests - Header'!testHeaderWithWithLink	self parse: factory headerWithWithLinkSample rule: #header! !!PRPillarGrammarTest methodsFor: 'tests - HorizontalRule'!testHorizontalRule	self parse: factory horizontalRuleSample rule: #horizontalRule! !!PRPillarGrammarTest methodsFor: 'tests - HorizontalRule'!testHorizontalRuleFollowByNewLine	self		parse: factory horizontalRuleFollowByNewLineSample		rule: #elementWithNewline! !!PRPillarGrammarTest methodsFor: 'tests - HorizontalRule'!testHorizontalRuleTrimRight	self		parse: factory horizontalRuleTrimRightSample		rule: #horizontalRule! !!PRPillarGrammarTest methodsFor: 'tests - Format'!testItalicFormat	self parse: factory italicFormatSample rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format'!testItalicFormatEmpty	self parse: factory italicFormatEmptySample rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format'!testItalicFormatWithEscaped	self parse: factory italicFormatWithEscapedSample rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Document'!testLineEnd	self parse: factory lineEndSample rule: #lineEnd! !!PRPillarGrammarTest methodsFor: 'tests - Document'!testLineEndwithNewline	self parse: factory lineEndwithNewlineSample rule: #lineEnd! !!PRPillarGrammarTest methodsFor: 'tests - Reference'!testLinkFollowedByFigureWithAlias	self		parse: factory linkFollowedByFigureWithAliasSample		rule: #paragraph! !!PRPillarGrammarTest methodsFor: 'tests - List'!testListMulti	self parse: factory listMultiSample rule: #list! !!PRPillarGrammarTest methodsFor: 'tests - List'!testListWithComment	self parse: factory listWithCommentSample rule: #list! !!PRPillarGrammarTest methodsFor: 'tests - Format'!testMonospaceFormat	self parse: factory monospaceFormatSample rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format'!testMonospaceFormatEmpty	self parse: factory monospaceFormatEmptySample rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format'!testMonospaceFormatWithEscaped	self parse: factory monospaceFormatWithEscapedSample rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Document'!testNewline	self parse: factory newlineSample rule: #newline! !!PRPillarGrammarTest methodsFor: 'tests - Document'!testNewlineCR	self parse: factory newlineCRSample rule: #newline! !!PRPillarGrammarTest methodsFor: 'tests - Document'!testNewlineCRLF	self parse: factory newlineCRLFSample rule: #newline! !!PRPillarGrammarTest methodsFor: 'tests - Document'!testNewlineLF	self parse: factory newlineLFSample rule: #newline! !!PRPillarGrammarTest methodsFor: 'tests - List'!testOrderedList	self parse: factory orderedListSample rule: #orderedList! !!PRPillarGrammarTest methodsFor: 'tests - List'!testOrderedListEmpty	self parse: factory orderedListEmptySample rule: #orderedList! !!PRPillarGrammarTest methodsFor: 'tests - List'!testOrderedListMulti	self parse: factory orderedListMultiSample rule: #orderedList! !!PRPillarGrammarTest methodsFor: 'tests - List'!testOrderedListWithSubList	self parse: factory orderedListWithSubListSample rule: #orderedList! !!PRPillarGrammarTest methodsFor: 'tests - List'!testOrderedListWithTwoItems	self parse: factory orderedListWithTwoItemsSample rule: #orderedList! !!PRPillarGrammarTest methodsFor: 'tests - Paragraph'!testParagraph	self parse: factory paragraphSample rule: #paragraph! !!PRPillarGrammarTest methodsFor: 'tests - Paragraph'!testParagraphWithFormat	self parse: factory paragraphWithFormatSample rule: #paragraph! !!PRPillarGrammarTest methodsFor: 'tests - Reference'!testParameterFigure	self		parse: factory parameterFigureSample		rule: #parameterUntilEndFigure! !!PRPillarGrammarTest methodsFor: 'tests - Parameter'!testParameterKeyUntilNewline	self		parse: factory parameterKeyUntilNewlineSample		rule: #parameterKeyUntilNewline! !!PRPillarGrammarTest methodsFor: 'tests - Reference'!testParameterLink	self parse: factory parameterLinkSample rule: #parameterUntilEndLink! !!PRPillarGrammarTest methodsFor: 'tests - Parameter'!testParameterUntilNewline	self		parse: factory parameterUntilNewlineSample		rule: #parameterUntilNewline! !!PRPillarGrammarTest methodsFor: 'tests - Parameter'!testParameterValueUntilNewline	self		parse: factory parameterValueUntilNewlineSample		rule: #parameterValueUntilNewline! !!PRPillarGrammarTest methodsFor: 'tests - Reference'!testParametersFigure	self parse: factory parametersFigureSample rule: #parametersFigure! !!PRPillarGrammarTest methodsFor: 'tests - Reference'!testParametersLink	self parse: factory parametersLinkSample rule: #parametersLink! !!PRPillarGrammarTest methodsFor: 'tests - Parameter'!testParametersUntilNewline	self		parse: factory parametersUntilNewlineSample		rule: #parametersUntilNewline! !!PRPillarGrammarTest methodsFor: 'tests - Text'!testPreformatedLine	self parse: factory preformatedLineSample rule: #preformatedLine! !!PRPillarGrammarTest methodsFor: 'tests - Text'!testPreformatedText	self parse: factory preformatedTextSample rule: #preformatedText! !!PRPillarGrammarTest methodsFor: 'tests - Text'!testPreformatedTextEmpty	self parse: factory preformatedTextEmptySample rule: #preformatedText! !!PRPillarGrammarTest methodsFor: 'tests - Text'!testPreformatedTextWithMultiLines	self		parse: factory preformatedTextWithMultiLinesSample		rule: #preformatedText! !!PRPillarGrammarTest methodsFor: 'tests - Text'!testPreformatedTextWithNewline	self		parse: factory preformatedTextWithNewlineSample		rule: #preformatedText! !!PRPillarGrammarTest methodsFor: 'tests - Text'!testPreformatedTextWithSpaces	self		parse: factory preformatedTextWithSpacesSample		rule: #preformatedText! !!PRPillarGrammarTest methodsFor: 'tests - Text'!testPreformatedTextWithTab	self		parse: factory preformatedTextWithTabSample		rule: #preformatedText! !!PRPillarGrammarTest methodsFor: 'tests - Text'!testRaw	self parse: factory rawSample rule: #raw! !!PRPillarGrammarTest methodsFor: 'tests - Text'!testRawEmpty	self parse: factory rawEmptySample rule: #raw! !!PRPillarGrammarTest methodsFor: 'tests - Text'!testRawHTML	self parse: factory rawHTMLSample rule: #raw! !!PRPillarGrammarTest methodsFor: 'tests - Text'!testRawInvalid	self parse: factory rawInvalidSample rule: #raw! !!PRPillarGrammarTest methodsFor: 'tests - Text'!testRawMultiLines	self parse: factory rawMultiLinesSample rule: #raw! !!PRPillarGrammarTest methodsFor: 'tests - Reference'!testReference	self parse: factory referenceSample rule: #reference! !!PRPillarGrammarTest methodsFor: 'tests - Reference'!testReferenceFigure	self parse: factory referenceFigureSample rule: #referenceFigure! !!PRPillarGrammarTest methodsFor: 'tests - Reference'!testReferenceFigureEscape	self		parse: factory referenceFigureEscapeSample		rule: #referenceFigure! !!PRPillarGrammarTest methodsFor: 'tests - Reference'!testReferenceLink	self parse: factory referenceLinkSample rule: #referenceLink! !!PRPillarGrammarTest methodsFor: 'tests - Reference'!testReferenceLinkEscape	self parse: factory referenceLinkEscapeSample rule: #referenceLink! !!PRPillarGrammarTest methodsFor: 'tests - Script'!testScript	self parse: factory scriptSample rule: #script! !!PRPillarGrammarTest methodsFor: 'tests - Script'!testScriptParameter	self		parse: factory scriptParameterSample		rule: #parameterUntilNewline! !!PRPillarGrammarTest methodsFor: 'tests - Script'!testScriptParameterEscape	self		parse: factory scriptParameterEscapeSample		rule: #parameterUntilNewline! !!PRPillarGrammarTest methodsFor: 'tests - Script'!testScriptParameterTrueByDefault	self parse: factory scriptParameterTrueByDefaultSample rule: #script! !!PRPillarGrammarTest methodsFor: 'tests - Script'!testScriptParameterValue	self		parse: factory scriptParameterValueSample		rule: #parameterValueUntilNewline! !!PRPillarGrammarTest methodsFor: 'tests - Script'!testScriptParameterWithFloat	self parse: factory scriptParameterWithFloatSample rule: #script! !!PRPillarGrammarTest methodsFor: 'tests - Script'!testScriptParameterWithLiteralArray	self		parse: factory scriptParameterWithLiteralArraySample		rule: #script! !!PRPillarGrammarTest methodsFor: 'tests - Script'!testScriptParameterWithNoValues	self parse: factory scriptParameterWithNoValuesSample rule: #script! !!PRPillarGrammarTest methodsFor: 'tests - Script'!testScriptParameterWithSpacesBeforeAndAfter	self		parse: factory scriptParameterWithSpacesBeforeAndAfterSample		rule: #scriptParameters! !!PRPillarGrammarTest methodsFor: 'tests - Script'!testScriptParameterWithoutValue	self		parse: factory scriptParameterWithoutValueSample		rule: #parameterUntilNewline! !!PRPillarGrammarTest methodsFor: 'tests - Script'!testScriptParameters	self parse: factory scriptParametersSample rule: #scriptParameters! !!PRPillarGrammarTest methodsFor: 'tests - Script'!testScriptParametersEscape	self		parse: factory scriptParametersEscapeSample		rule: #scriptParameters! !!PRPillarGrammarTest methodsFor: 'tests - Script'!testScriptParametersMultiple	self		parse: factory scriptParametersMultipleSample		rule: #scriptParameters! !!PRPillarGrammarTest methodsFor: 'tests - Script'!testScriptSampleWithTrailingBlankOnTheFirstLine	self parse: factory scriptSampleWithTrailingBlankOnTheFirstLine rule: #script! !!PRPillarGrammarTest methodsFor: 'tests - Script'!testScriptSampleWithTrailingBlanksOnTheFirstLine	self parse: factory scriptSampleWithTrailingBlanksOnTheFirstLine rule: #script! !!PRPillarGrammarTest methodsFor: 'tests - Script'!testScriptSampleWithTrailingTabOnTheFirstLine	self parse: factory scriptSampleWithTrailingTabOnTheFirstLine rule: #script! !!PRPillarGrammarTest methodsFor: 'tests - Script'!testScriptTwoParametersNoValue	self		parse: factory scriptTwoParametersNoValueSample		rule: #scriptParameters! !!PRPillarGrammarTest methodsFor: 'tests - Script'!testScriptWithLanguage	self parse: factory scriptWithLanguageSample rule: #script! !!PRPillarGrammarTest methodsFor: 'tests - Script'!testScriptWithNewLine	self parse: factory scriptWithNewLineSample rule: #script! !!PRPillarGrammarTest methodsFor: 'tests - Script'!testScriptWithSpaceAtTheEnd	self parse: factory scriptWithSpaceAtTheEndSample rule: #script! !!PRPillarGrammarTest methodsFor: 'tests - Script'!testScriptWithSpacedParameters	self parse: factory scriptWithSpacedParametersSample rule: #script! !!PRPillarGrammarTest methodsFor: 'tests - Format'!testStrikethroughFormat	self parse: factory strikethroughFormatSample rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format'!testStrikethroughFormatEmpty	self parse: factory strikethroughFormatEmptySample rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format'!testStrikethroughFormatWithEscaped	self		parse: factory strikethroughFormatWithEscapedSample		rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format'!testSubscriptFormat	self parse: factory subscriptFormatSample rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format'!testSubscriptFormatEmpty	self parse: factory subscriptFormatEmptySample rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format'!testSubscriptFormatWithEscaped	self parse: factory subscriptFormatWithEscapedSample rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format'!testSuperscriptFormat	self parse: factory superscriptFormatSample rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format'!testSuperscriptFormatEmpty	self parse: factory superscriptFormatEmptySample rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format'!testSuperscriptFormatWithEscaped	self parse: factory superscriptFormatWithEscapedSample rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Table'!testTable	self parse: factory tableSample rule: #table! !!PRPillarGrammarTest methodsFor: 'tests - Table'!testTableAlignMarkup	self parse: factory tableAlignMarkupSample rule: #tableAlignMarkup! !!PRPillarGrammarTest methodsFor: 'tests - Table'!testTableCell	self parse: factory tableCellSample rule: #tableCell! !!PRPillarGrammarTest methodsFor: 'tests - Table'!testTableCellAreTrimed	self parse: factory tableCellAreTrimedSample rule: #tableCell! !!PRPillarGrammarTest methodsFor: 'tests - Table'!testTableCellCenter	self parse: factory tableCellCenterSample rule: #tableCell! !!PRPillarGrammarTest methodsFor: 'tests - Table'!testTableCellHeader	self parse: factory tableCellHeaderSample rule: #tableCell! !!PRPillarGrammarTest methodsFor: 'tests - Table'!testTableCellHeaderCenter	self parse: factory tableCellHeaderCenterSample rule: #tableCell! !!PRPillarGrammarTest methodsFor: 'tests - Table'!testTableCellHeaderCenter2	self parse: factory tableCellHeaderCenter2Sample rule: #tableCell! !!PRPillarGrammarTest methodsFor: 'tests - Table'!testTableCellHeaderLeft	self parse: factory tableCellHeaderLeftSample rule: #tableCell! !!PRPillarGrammarTest methodsFor: 'tests - Table'!testTableCellHeaderLeft2	self parse: factory tableCellHeaderLeft2Sample rule: #tableCell! !!PRPillarGrammarTest methodsFor: 'tests - Table'!testTableCellHeaderRight	self parse: factory tableCellHeaderRightSample rule: #tableCell! !!PRPillarGrammarTest methodsFor: 'tests - Table'!testTableCellHeaderRight2	self parse: factory tableCellHeaderRight2Sample rule: #tableCell! !!PRPillarGrammarTest methodsFor: 'tests - Table'!testTableCellLeft	self parse: factory tableCellLeftSample rule: #tableCell! !!PRPillarGrammarTest methodsFor: 'tests - Table'!testTableCellRight	self parse: factory tableCellRightSample rule: #tableCell! !!PRPillarGrammarTest methodsFor: 'tests - Table'!testTableCellWithFormat	self parse: factory tableCellWithFormatSample rule: #tableCell! !!PRPillarGrammarTest methodsFor: 'tests - Table'!testTableCenterMarkup	self parse: factory tableCenterMarkupSample rule: #tableCenterMarkup! !!PRPillarGrammarTest methodsFor: 'tests - Table'!testTableHeadingMarkup	self		parse: factory tableHeadingMarkupSample		rule: #tableHeadingMarkup! !!PRPillarGrammarTest methodsFor: 'tests - Table'!testTableLeftMarkup	self parse: factory tableLeftMarkupSample rule: #tableLeftMarkup! !!PRPillarGrammarTest methodsFor: 'tests - Table'!testTableMarkups	self parse: factory tableMarkupsSample rule: #tableMarkups! !!PRPillarGrammarTest methodsFor: 'tests - Table'!testTableMarkupsCenter	self parse: factory tableMarkupsCenterSample rule: #tableMarkups! !!PRPillarGrammarTest methodsFor: 'tests - Table'!testTableMarkupsHeading	self parse: factory tableMarkupsHeadingSample rule: #tableMarkups! !!PRPillarGrammarTest methodsFor: 'tests - Table'!testTableMarkupsHeadingAndCenter	self		parse: factory tableMarkupsHeadingAndCenterSample		rule: #tableMarkups! !!PRPillarGrammarTest methodsFor: 'tests - Table'!testTableMarkupsHeadingAndCenter2	self		parse: factory tableMarkupsHeadingAndCenter2Sample		rule: #tableMarkups! !!PRPillarGrammarTest methodsFor: 'tests - Table'!testTableRightMarkup	self parse: factory tableRightMarkupSample rule: #tableRightMarkup! !!PRPillarGrammarTest methodsFor: 'tests - Table'!testTableRow	self parse: factory tableRowSample rule: #tableRow! !!PRPillarGrammarTest methodsFor: 'tests - Table'!testTableRowWithEmptyCells	self parse: factory tableRowWithEmptyCellsSample rule: #tableRow! !!PRPillarGrammarTest methodsFor: 'tests - Table'!testTableRowWithHeading	self parse: factory tableRowWithHeadingSample rule: #tableRow! !!PRPillarGrammarTest methodsFor: 'tests - Table'!testTableWithComment	self flag: #todo	"We need to add that later."	"self		parse:			'|Foo%Comment|Bar'		rule: #table"! !!PRPillarGrammarTest methodsFor: 'tests - Table'!testTableWithNewLine	self parse: factory tableWithNewLineSample rule: #table! !!PRPillarGrammarTest methodsFor: 'tests - Text'!testText	self parse: factory textSample rule: #text! !!PRPillarGrammarTest methodsFor: 'tests - Text'!testTextWithEscapeAtBeginning	self parse: factory textWithEscapeAtBeginningSample rule: #text! !!PRPillarGrammarTest methodsFor: 'tests - Text'!testTextWithEscapeInTheMiddle	self parse: factory textWithEscapeInTheMiddleSample rule: #text! !!PRPillarGrammarTest methodsFor: 'tests - Text'!testTextWithMultiEscape	self parse: factory textWithMultiEscapeSample rule: #text! !!PRPillarGrammarTest methodsFor: 'tests - Annotation'!testUndefinedAnnotation	self parse: factory undefinedAnnotationSample rule: #annotation! !!PRPillarGrammarTest methodsFor: 'tests - Annotation'!testUndefinedAnnotationWithParameters	self		parse: factory undefinedAnnotationWithParametersSample		rule: #annotation! !!PRPillarGrammarTest methodsFor: 'tests - Format'!testUnderlineFormat	self parse: factory underlineFormatSample rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format'!testUnderlineFormatEmpty	self parse: factory underlineFormatEmptySample rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format'!testUnderlineFormatWithEscaped	self parse: factory underlineFormatWithEscapedSample rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - List'!testUnorderedList	self parse: factory unorderedListSample rule: #unorderedList! !!PRPillarGrammarTest methodsFor: 'tests - List'!testUnorderedListEmpty	self parse: factory unorderedListEmptySample rule: #unorderedList! !!PRPillarGrammarTest methodsFor: 'tests - List'!testUnorderedListMulti	self parse: factory unorderedListMultiSample rule: #unorderedList! !!PRPillarGrammarTest methodsFor: 'tests - List'!testUnorderedListWithSubList	self		parse: factory unorderedListWithSubListSample		rule: #unorderedList! !!PRPillarGrammarTest methodsFor: 'tests - List'!testUnorderedListWithTwoItems	self		parse: factory unorderedListWithTwoItemsSample		rule: #unorderedList! !!PRPillarParserTest methodsFor: 'asserting'!assertStart: aStartInteger stop: aStopIndex	self assert: result isNotNil.	self assert: result start equals: aStartInteger.	self assert: result stop equals: aStopIndex! !!PRPillarParserTest methodsFor: 'asserting'!assertStart: aStartInteger stop: aStopIndex ofNode: aDocumentItem	self		assert: aDocumentItem start		equals: aStartInteger.	self		assert: aDocumentItem stop		equals: aStopIndex.	! !!PRPillarParserTest methodsFor: 'accessing'!parserClass	^ PRPillarParser! !!PRPillarParserTest methodsFor: 'tests - Reference'!testAliasFigure	super testAliasFigure.	self assert: result equals: { PRText content: 'Alias' } asOrderedCollection.	self assertStart: 1 stop: 5 ofNode: result first.! !!PRPillarParserTest methodsFor: 'tests - Reference'!testAliasFigureEscape	super testAliasFigureEscape.	self assert: result equals: { PRText content: 'Alias>' } asOrderedCollection.	self assertStart: 1 stop: 7 ofNode: result first.! !!PRPillarParserTest methodsFor: 'tests - Reference'!testAliasLink	super testAliasLink.	self assert: result equals: { PRText content: 'Alias' } asOrderedCollection.	self assertStart: 1 stop: 5 ofNode: result first.! !!PRPillarParserTest methodsFor: 'tests - Reference'!testAliasLinkEscape	super testAliasLinkEscape.	self assert: result equals: { PRText content: 'Alias>' } asOrderedCollection.	self assertStart: 1 stop: 7 ofNode: result first.! !!PRPillarParserTest methodsFor: 'tests - Anchor'!testAnchor	super testAnchor.	self assert: result equals: (PRAnchor named: 'test')! !!PRPillarParserTest methodsFor: 'tests - Anchor'!testAnchorAreTrimed	super testAnchorAreTrimed.	self assert: result equals: (PRAnchor named: 'test')! !!PRPillarParserTest methodsFor: 'tests - Anchor'!testAnchorWithNewLine	super testAnchorWithNewLine.	self assert: result equals: (PRAnchor named: 'foo')! !!PRPillarParserTest methodsFor: 'tests - Anchor'!testAnchorWithSpaceInside	super testAnchorWithSpaceInside.	self assert: result equals: (PRAnchor named: 'foo bar')! !!PRPillarParserTest methodsFor: 'tests - Paragraph'!testAnnotatedParagraph	super testAnnotatedParagraph.	self 		assert: result 		equals: (PRAnnotatedParagraph withAll: {PRText content: 'Bar'} annotation: 'foo').	self assertStart: 1 stop: 9.	self assertStart: 7 stop: 9 ofNode: result children first.! !!PRPillarParserTest methodsFor: 'tests - Paragraph'!testAnnotatedParagraphEmpty	super testAnnotatedParagraphEmpty.	self		assert: result		equals:			(PRAnnotatedParagraph new				annotation: 'foo';				yourself).	self assertStart: 1 stop: 5.! !!PRPillarParserTest methodsFor: 'tests - Paragraph'!testAnnotatedParagraphEmptyWithNewLine	super testAnnotatedParagraphEmptyWithNewLine.	self		assert: result		equals:			(PRAnnotatedParagraph new				annotation: 'foo';				yourself).	self assertStart: 1 stop: 5.! !!PRPillarParserTest methodsFor: 'tests - Annotation'!testAnnotation	super testAnnotation.	self		assert: result		equals: (PRInputFileAnnotation withParameters: 						(PRParameters withAll: { 							(PRParameter 								keyNode: (PRParameterKey named: #path) 								valueNode: (PRParameterValue value: 'Foo')) })).	self assert: result children size equals: 1.	self assertStart: 1 stop: 22.! !!PRPillarParserTest methodsFor: 'tests - Annotation'!testAnnotationAreTrimedAtTheRight	super testAnnotationAreTrimedAtTheRight.	self		assert: result		equals:			(PRInputFileAnnotation				withParameters:					(PRParameters withAll: { 							(PRParameter 								keyNode: (PRParameterKey named: #path) 								valueNode: (PRParameterValue value: 'Foo')) })).	self assertStart: 1 stop: 22.! !!PRPillarParserTest methodsFor: 'tests - Annotation'!testAnnotationOnlyWithParameterName	| expected |	super testAnnotationOnlyWithParameterName.	expected := PRInputFileAnnotation withParameters: (			PRParameters withAll: { 				(PRParameter 					keyNode: (PRParameterKey named: #path) 					valueNode: (PRParameterValue value: true)) } ).	self assert: result equals: expected! !!PRPillarParserTest methodsFor: 'tests - Annotation'!testAnnotationParameter	super testAnnotationParameter.	self assert: result equals: (PRParameter 		keyNode: (PRParameterKey named: #value) 		valueNode: (PRParameterValue value: 'foo'))! !!PRPillarParserTest methodsFor: 'tests - Annotation'!testAnnotationParameters	| expected |	super testAnnotationParameters.	expected := PRParameters withAll: { 		(PRParameter 			keyNode: (PRParameterKey named: #foo) 			valueNode: (PRParameterValue value: 'bar')).		(PRParameter 			keyNode: (PRParameterKey named: #timo) 			valueNode: (PRParameterValue value: 'leon')) }.	self assert: result equals:  expected.	self assert: result start equals: 2.	self assert: result stop equals: 18.! !!PRPillarParserTest methodsFor: 'tests - Annotation'!testAnnotationParameters2	| expected |	super testAnnotationParameters.	expected := PRParameters withAll: { 		(PRParameter 			keyNode: (PRParameterKey named: #foo) 			valueNode: (PRParameterValue value: 'bar')).		(PRParameter 			keyNode: (PRParameterKey named: #timo) 			valueNode: (PRParameterValue value: 'leon')) }.	self assert: result equals: expected! !!PRPillarParserTest methodsFor: 'tests - Annotation'!testAnnotationTag	super testAnnotationTag.	self assert: result equals: PRMockAnnotation! !!PRPillarParserTest methodsFor: 'tests - Annotation'!testAnnotationWithUnknownKey	self 		should: [ super testAnnotationWithUnknownKey ]		raise: PRSyntaxError.! !!PRPillarParserTest methodsFor: 'tests - Annotation'!testAnnotationWithUnknownKeyAsNode	PRValidation beSilentDuring: [ 		super testAnnotationWithUnknownKey.		self			assert: result			equals: (PRInputFileAnnotation withParameters: 							(PRParameters withAll: { 								(PRParameter 									keyNode: (PRParameterKey named: #path) 									valueNode: (PRParameterValue value: 'Foo')).								(PRParameter 									keyNode: (PRParameterKey named: #unknownKey) 									valueNode: (PRParameterValue value: 'Bar')) })) ].	self assertStart: 1 stop: 37.	self assert: result children first children first isValid.	self deny: result children first children second isValid.	! !!PRPillarParserTest methodsFor: 'tests - Annotation'!testAnnotationWithoutFirstParameterNameAndDefaultValues	| expected |	super testAnnotationWithoutFirstParameterNameAndDefaultValues.	expected := PRDocumentListAnnotation withParameters: ( 			PRParameters withAll: { 				PRParameter 					keyNode: (PRParameterKey named: #path) 					valueNode: (PRParameterValue value: 'Foo').				PRParameter 					keyNode: (PRParameterKey named: #limit) 					valueNode: (PRParameterValue value: true).				PRParameter 					keyNode: (PRParameterKey named: #sort) 					valueNode: (PRParameterValue value: true) } ).	self assert: result equals: expected! !!PRPillarParserTest methodsFor: 'tests - Annotation'!testAnnotationWithoutParameterName	| expected |	super testAnnotationWithoutParameterName.	expected := PRInputFileAnnotation withParameters: ( 			PRParameters withAll: { 				(PRParameter 					keyNode: (PRParameterKey named: #path) 					valueNode: (PRParameterValue value: 'Foo')) } ).	self assert: result equals: expected! !!PRPillarParserTest methodsFor: 'tests - Annotation'!testAnnotationWithoutParameters	self 		should: [ super testAnnotationWithoutParameters ]		raise: PRSyntaxError.! !!PRPillarParserTest methodsFor: 'tests - Annotation'!testAnnotationWithoutParametersAsNode	PRValidation beSilentDuring: [ 		super testAnnotationWithoutParameters.		self			assert: result			equals: (PRInputFileAnnotation withParameters: PRParameters new) ].	self assertStart: 1 stop: 13.	self assert: result children size equals: 1.	self deny: result isValid.! !!PRPillarParserTest methodsFor: 'tests - Format'!testBoldFormat	super testBoldFormat.	self assert: result equals: (PRBoldFormat with: (PRText content: 'Foo')).	self assertStart: 1 stop: 7.	self assertStart: 3 stop: 5 ofNode: result children first.! !!PRPillarParserTest methodsFor: 'tests - Format'!testBoldFormatEmpty	super testBoldFormatEmpty.	self assert: result equals: PRBoldFormat new.	self assertStart: 1 stop: 4.! !!PRPillarParserTest methodsFor: 'tests - Format'!testBoldFormatWithEscaped	super testBoldFormatWithEscaped.	self assert: result equals: (PRBoldFormat with: (PRText content: '""')).	self assertStart: 1 stop: 8.	self assertStart: 3 stop: 6 ofNode: result children first.! !!PRPillarParserTest methodsFor: 'tests - Text'!testCommentedLine	super testCommentedLine.	self assert: result equals: (PRCommentedLine content: 'some text')! !!PRPillarParserTest methodsFor: 'tests - Text'!testCommentedLineWithNewline	super testCommentedLineWithNewline.	self assert: result equals: (PRCommentedLine content: 'some text')! !!PRPillarParserTest methodsFor: 'tests - List'!testDefinitionList	super testDefinitionList.	self		assert: result		equals:			(PRDefinitionList				withAll:					{(PRTermItem with: (PRText content: 'Foo')).					(PRDataItem with: (PRText content: 'Bar'))}).	self assertStart: 1 stop: 9.	self assertStart: 1 stop: 5 ofNode: result children first.	self assertStart: 2 stop: 4 ofNode: result children first children first.	self assertStart: 6 stop: 9 ofNode: result children second.	self assertStart: 7 stop: 9 ofNode: result children second children first.	! !!PRPillarParserTest methodsFor: 'tests - Paragraph'!testEmptyParagraph	super testEmptyParagraph.	self assert: result equals: PREmptyParagraph new.	self assertStart: 1 stop: 1! !!PRPillarParserTest methodsFor: 'tests - Reference'!testFigureFollowedByLinkWithAlias	| paragraph |	super testFigureFollowedByLinkWithAlias.	paragraph := PRParagraph withAll: { 		PRFigure reference: 'file://TeapotWelcome.png'.		(PRExternalLink reference: 'http://localhost')			add: (PRText content: 'Go');			yourself	 }.	self assert: result equals: paragraph.	self assertStart: 1 stop: 47.	self assertStart: 1 stop: 26 ofNode: result children first.	self assertStart: 27 stop: 47 ofNode: result children second.! !!PRPillarParserTest methodsFor: 'tests - Format'!testFormatWithLink	super testFormatWithLink.	self assert: result equals: (PRBoldFormat with: (PRInternalLink reference: 'foo')).	self assertStart: 1 stop: 9.	self assertStart: 3 stop: 7 ofNode: result children first.! !!PRPillarParserTest methodsFor: 'tests - Header'!testHeaderEmpty	super testHeaderEmpty.	self assert: result equals: (PRHeader withAll: Array new level: 1).	self assertStart: 1 stop: 1.! !!PRPillarParserTest methodsFor: 'tests - Header'!testHeaderLevel1	super testHeaderLevel1.	self assert: result equals: (PRHeader withAll: {PRText content: 'Foo'} level: 1).	self assertStart: 1 stop: 4.	self assertStart: 2 stop: 4 ofNode: result children first.! !!PRPillarParserTest methodsFor: 'tests - Header'!testHeaderLevel2	super testHeaderLevel2.	self assert: result equals: (PRHeader withAll: {PRText content: 'Foo'} level: 2).	self assertStart: 1 stop: 5.	self assertStart: 3 stop: 5 ofNode: result children first.! !!PRPillarParserTest methodsFor: 'tests - Header'!testHeaderLevel3	super testHeaderLevel3.	self assert: result equals: (PRHeader withAll: {PRText content: 'Foo'} level: 3).	self assertStart: 1 stop: 6.	self assertStart: 4 stop: 6 ofNode: result children first.! !!PRPillarParserTest methodsFor: 'tests - Header'!testHeaderLevel4	super testHeaderLevel4.	self assert: result equals: (PRHeader withAll: {PRText content: 'Foo'} level: 4).	self assertStart: 1 stop: 7.	self assertStart: 5 stop: 7 ofNode: result children first.! !!PRPillarParserTest methodsFor: 'tests - Header'!testHeaderLevel5	super testHeaderLevel5.	self assert: result equals: (PRHeader withAll: {PRText content: 'Foo'} level: 5).	self assertStart: 1 stop: 8.	self assertStart: 6 stop: 8 ofNode: result children first.! !!PRPillarParserTest methodsFor: 'tests - Header'!testHeaderLevel6	super testHeaderLevel6.	self assert: result equals: (PRHeader withAll: {PRText content: 'Foo'} level: 6).	self assertStart: 1 stop: 9.	self assertStart: 7 stop: 9 ofNode: result children first.! !!PRPillarParserTest methodsFor: 'tests - Header'!testHeaderWithFormat	super testHeaderWithFormat.	self 		assert: result 		equals: (PRHeader withAll: {PRBoldFormat with: (PRText content: 'Foo')} level: 1).	self assertStart: 1 stop: 8.	self assertStart: 2 stop: 8 ofNode: result children first.	self assertStart: 4 stop: 6 ofNode: result children first children first.! !!PRPillarParserTest methodsFor: 'tests - Header'!testHeaderWithFormatAndText	super testHeaderWithFormatAndText.	self		assert: result		equals:			(PRHeader				withAll:					{PRBoldFormat with: (PRText content: 'Foo').					PRText content: ' bar'}				level: 1).	self assertStart: 1 stop: 12.	self assertStart: 2 stop: 8 ofNode: result children first.	self assertStart: 4 stop: 6 ofNode: result children first children first.	self assertStart: 9 stop: 12 ofNode: result children second.! !!PRPillarParserTest methodsFor: 'tests - Header'!testHeaderWithNewLine	super testHeaderWithNewLine.	self assert: result equals: (PRHeader withAll: {PRText content: 'Foo'} level: 1).	self assertStart: 1 stop: 4.	self assertStart: 2 stop: 4 ofNode: result children first.! !!PRPillarParserTest methodsFor: 'tests - HorizontalRule'!testHorizontalRule	super testHorizontalRule.	self assert: result equals: PRHorizontalRule new! !!PRPillarParserTest methodsFor: 'tests - HorizontalRule'!testHorizontalRuleFollowByNewLine	super testHorizontalRuleFollowByNewLine.	self assert: result equals: PRHorizontalRule new! !!PRPillarParserTest methodsFor: 'tests - HorizontalRule'!testHorizontalRuleTrimRight	super testHorizontalRuleTrimRight.	self assert: result equals: PRHorizontalRule new! !!PRPillarParserTest methodsFor: 'tests - Format'!testItalicFormat	super testItalicFormat.	self assert: result equals: (PRItalicFormat with: (PRText content: 'Foo')).	self assertStart: 1 stop: 7.	self assertStart: 3 stop: 5 ofNode: result children first.! !!PRPillarParserTest methodsFor: 'tests - Format'!testItalicFormatEmpty	super testItalicFormatEmpty.	self assert: result equals: PRItalicFormat new.	self assertStart: 1 stop: 4.! !!PRPillarParserTest methodsFor: 'tests - Format'!testItalicFormatWithEscaped	super testItalicFormatWithEscaped.	self assert: result equals: (PRItalicFormat with: (PRText content: '''''')).	self assertStart: 1 stop: 8.	self assertStart: 3 stop: 6 ofNode: result children first.! !!PRPillarParserTest methodsFor: 'tests - Reference'!testLinkFollowedByFigureWithAlias	| paragraph |	super testLinkFollowedByFigureWithAlias.	paragraph := PRParagraph withAll: { 		PRExternalLink reference: 'http://localhost'.		(PRFigure reference: 'file://TeapotWelcome.png')			add: (PRText content: 'Go');			yourself	 }.	self assert: result equals: paragraph.	self assertStart: 1 stop: 47.	self assertStart: 1 stop: 18 ofNode: result children first.	self assertStart: 19 stop: 47 ofNode: result children second.	self flag: 'PRText should have start and stop values set to 20 and 21, but has 1 and 2'.	"self assertStart: 20 stop: 21 ofNode: result children second children first."! !!PRPillarParserTest methodsFor: 'tests - List'!testListMulti	super testListMulti.	self		assert: result		equals:			(PRUnorderedList				withAll:					{(PRListItem						withAll:							{(PRText content: '1').							(PRUnorderedList								withAll:									{(PRListItem										withAll:											{(PRText content: '2').											(PRUnorderedList with: (PRListItem with: (PRText content: '3')))}).									(PRListItem with: (PRText content: '4')).									(PRListItem with: (PRText content: '5')).									(PRListItem with: (PRText content: '6'))})}).					(PRListItem						withAll:							{(PRText content: '7').							(PROrderedList with: (PRListItem with: (PROrderedList with: (PRListItem with: (PRText content: '8')))))})})! !!PRPillarParserTest methodsFor: 'tests - List'!testListWithComment	super testListWithComment.	self		assert: result		equals:			(PROrderedList				withAll:					{PRListItem						withAll:							{PRText content: 'Foo'.							PRCommentedLine content: 'Comment'}.					PRListItem with: (PRText content: 'Bar')})! !!PRPillarParserTest methodsFor: 'tests - Format'!testMonospaceFormat	super testMonospaceFormat.	self assert: result equals: (PRMonospaceFormat with: (PRText content: 'Foo')).	self assertStart: 1 stop: 7.	self assertStart: 3 stop: 5 ofNode: result children first.! !!PRPillarParserTest methodsFor: 'tests - Format'!testMonospaceFormatEmpty	super testMonospaceFormatEmpty.	self assert: result equals: PRMonospaceFormat new.	self assertStart: 1 stop: 4.! !!PRPillarParserTest methodsFor: 'tests - Format'!testMonospaceFormatWithEscaped	super testMonospaceFormatWithEscaped.	self assert: result equals: (PRMonospaceFormat with: (PRText content: '==')).	self assertStart: 1 stop: 8.	self assertStart: 3 stop: 6 ofNode: result children first.! !!PRPillarParserTest methodsFor: 'tests - List'!testOrderedList	super testOrderedList.	self assert: result equals: (PROrderedList with: (PRListItem with: (PRText content: 'Foo'))).	self assertStart: 1 stop: 4.	self assertStart: 1 stop: 4 ofNode: result children first.	self assertStart: 2 stop: 4 ofNode: result children first children first.! !!PRPillarParserTest methodsFor: 'tests - List'!testOrderedListEmpty	super testOrderedListEmpty.	self assert: result equals: (PROrderedList with: PRListItem new).	self assertStart: 1 stop: 1.! !!PRPillarParserTest methodsFor: 'tests - List'!testOrderedListMulti	super testOrderedListMulti.	self		assert: result		equals:			(PROrderedList				withAll:					{(PRListItem						withAll:							{(PRText content: '1').							(PROrderedList								withAll:									{(PRListItem										withAll:											{(PRText content: '2').											(PROrderedList with: (PRListItem with: (PRText content: '3')))}).									(PRListItem with: (PRText content: '4')).									(PRListItem with: (PRText content: '5')).									(PRListItem with: (PRText content: '6'))})}).					(PRListItem						withAll:							{(PRText content: '7').							(PROrderedList with: (PRListItem with: (PROrderedList with: (PRListItem with: (PRText content: '8')))))})}).	self assertStart: 1 stop: 31.	self assertStart: 1 stop: 24 ofNode: result children first.	self assertStart: 2 stop: 2 ofNode: result children first children first.	self flag: 'Because of `self listsParser parse: array fifth` in `PR2PillarParser>>#orderedListItem` (and similar methods) the sub-item possitions are not correct'.	"self assertStart: 4 stop: 12 ofNode: result children first children second."	self assertStart: 25 stop: 31 ofNode: result children second.	self assertStart: 26 stop: 26 ofNode: result children second children first.	! !!PRPillarParserTest methodsFor: 'tests - List'!testOrderedListWithSubList	super testOrderedListWithSubList.	self		assert: result		equals:			(PROrderedList				with:					(PRListItem						withAll:							{PRText content: 'Foo'.							PROrderedList with: (PRListItem with: (PRText content: 'Bar'))}))! !!PRPillarParserTest methodsFor: 'tests - List'!testOrderedListWithTwoItems	super testOrderedListWithTwoItems.	self		assert: result		equals:			(PROrderedList				withAll:					{(PRListItem with: (PRText content: 'Foo')).					(PRListItem with: (PRText content: 'Bar'))})! !!PRPillarParserTest methodsFor: 'tests - Paragraph'!testParagraph	super testParagraph.	self assert: result equals: (PRParagraph new add: (PRText content: 'This is a text'))! !!PRPillarParserTest methodsFor: 'tests - Paragraph'!testParagraphWithFormat	super testParagraphWithFormat.	self		assert: result		equals:			(PRParagraph				withAll:					{(PRText content: 'Foo ').					(PRBoldFormat with: (PRText content: 'Bar'))})! !!PRPillarParserTest methodsFor: 'tests - Parameter'!testParameterKeyUntilNewline	<expectedFailure>	super testParameterKeyUntilNewline.	self assert: result equals: (PRParameterKey named: #parameterName).	self deny: result equals: (PRParameterKey named: #parameterName2).	self assertStart: 1 stop: 13! !!PRPillarParserTest methodsFor: 'tests - Parameter'!testParameterUntilNewline	<expectedFailure>	super testParameterUntilNewline.	self assert: result equals: (PRParameter keyNode: (PRParameterKey named: #foo) valueNode: (PRParameterValue value: 'bar')).	self deny: result equals: (PRParameter keyNode: (PRParameterKey named: #bar) valueNode: (PRParameterValue value: 'foo')).	self assertStart: 1 stop: 7.	self assertStart: 1 stop: 3 ofNode: result keyNode.	self assertStart: 5 stop: 7 ofNode: result valueNode! !!PRPillarParserTest methodsFor: 'tests - Parameter'!testParameterValueUntilNewline	<expectedFailure>	super testParameterValueUntilNewline.	self assert: result equals: (PRParameterValue value: #parameterValue).	self deny: result equals: (PRParameterValue value: #parameterValue2).	self assertStart: 2 stop: 15! !!PRPillarParserTest methodsFor: 'tests - Parameter'!testParametersUntilNewline	<expectedFailure>	super testParametersUntilNewline.	self		assert: result		equals:			(PRParameters				withAll:					{(PRParameter keyNode: (PRParameterKey named: #foo) valueNode: (PRParameterValue value: 'bar')).					(PRParameter keyNode: (PRParameterKey named: #baz) valueNode: (PRParameterValue value: 'true'))}).	self deny: result equals: PRParameters new.	self assertStart: 1 stop: 16.	self assertStart: 1 stop: 7 ofNode: result children first.	self assertStart: 9 stop: 16 ofNode: result children second.	self assertStart: 1 stop: 3 ofNode: result children first keyNode.	self assertStart: 5 stop: 7 ofNode: result children first valueNode.	self assertStart: 9 stop: 11 ofNode: result children second keyNode.	self assertStart: 13 stop: 16 ofNode: result children second valueNode! !!PRPillarParserTest methodsFor: 'tests - Text'!testRaw	super testRaw.	self assert: result equals: (PRRaw content: 'foo' type: 'mock' )! !!PRPillarParserTest methodsFor: 'tests - Text'!testRawEmpty	super testRawEmpty.	self assert: result equals: (PRRaw content: '')! !!PRPillarParserTest methodsFor: 'tests - Text'!testRawMultiLines	super testRawMultiLines.	self assert: result equals: (PRRaw content: 'foobar')! !!PRPillarParserTest methodsFor: 'tests - Reference'!testReference	super testReference. "'*foo>@bar*'"	self		assert: result		equals:			(PRInternalLink new				add: (PRText content: 'foo');				anchor: 'bar';				yourself).	self assertStart: 1 stop: 10.	self assertStart: 2 stop: 4 ofNode: result children first.! !!PRPillarParserTest methodsFor: 'tests - Reference'!testReferenceFigure	super testReferenceFigure.	self assert: result equals: 'file://foo.png'! !!PRPillarParserTest methodsFor: 'tests - Reference'!testReferenceFigureEscape	super testReferenceFigureEscape.	self assert: result equals: 'file://foo+.png'! !!PRPillarParserTest methodsFor: 'tests - Reference'!testReferenceLink	super testReferenceLink.	self assert: result equals: 'file://foo.png'! !!PRPillarParserTest methodsFor: 'tests - Reference'!testReferenceLinkEscape	super testReferenceLinkEscape.	self assert: result equals: 'file://foo*.png'! !!PRPillarParserTest methodsFor: 'tests - Script'!testScript	super testScript.	self assert: result equals: (PRCodeblock content: 'foo').	self assertStart: 1 stop: 11.! !!PRPillarParserTest methodsFor: 'tests - Script'!testScriptParameter	super testScriptParameter.	self assert: result equals: #('value' 'foo')! !!PRPillarParserTest methodsFor: 'tests - Script'!testScriptParameterEndsWithSpace	| script |	super testScriptParameterTrueByDefault.	script := PRCodeblock content: 'bar'.	script parameters at: 'foo' put: true.	self assert: result equals: script.	self assertStart: 1 stop: 14.! !!PRPillarParserTest methodsFor: 'tests - Script'!testScriptParameterEscape	super testScriptParameterEscape.	self assert: result equals: #('value=' 'foo')! !!PRPillarParserTest methodsFor: 'tests - Script'!testScriptParameterTrueByDefault	| script |	super testScriptParameterTrueByDefault.	script := PRCodeblock content: 'bar'.	script parameters at: 'foo' put: true.	self assert: result equals: script.	self assertStart: 1 stop: 14.! !!PRPillarParserTest methodsFor: 'tests - Script'!testScriptParameterValue	super testScriptParameterValue.	self assert: result equals: 'foo'! !!PRPillarParserTest methodsFor: 'tests - Script'!testScriptParameterWithFloat	| script |	super testScriptParameterWithFloat.	script := PRCodeblock content: 'bar'.	script parameters at: 'ratio' put: 0.8.	self assert: result equals: script.	self assertStart: 1 stop: 20.! !!PRPillarParserTest methodsFor: 'tests - Script'!testScriptParameterWithLiteralArray	| script |	super testScriptParameterWithLiteralArray.	script := PRCodeblock content: 'bar'.	script parameters at: 'foo' put: #(1 2 true).	self assert: result equals: script.	self assertStart: 1 stop: 26.	self flag: 'the rest in not supported yet'.	true ifTrue: [ ^ self ].	self assertStart: 4 stop: 18 ofNode: result parameters.	self assertStart: 4 stop: 18 ofNode: (result parameters nodeAt: #foo).	self assertStart: 4 stop: 7 ofNode: (result parameters nodeAt: #foo) keyNode.	self assertStart: 9 stop: 18 ofNode: (result parameters nodeAt: #foo) valueNode.! !!PRPillarParserTest methodsFor: 'tests - Script'!testScriptParameterWithNoValues	| script |	super testScriptParameterWithNoValues.	script := PRCodeblock content: 'bar'.	script parameters at: 'foo' put: ''.	self assert: result equals: script.	self assertStart: 1 stop: 15.! !!PRPillarParserTest methodsFor: 'tests - Script'!testScriptParameterWithSpacesBeforeAndAfter	super testScriptParameterWithSpacesBeforeAndAfter.	self		assert: result		equals:			(OrderedDictionary new				at: 'foo' put: true;				at: 'bar' put: 2;				yourself)! !!PRPillarParserTest methodsFor: 'tests - Script'!testScriptParameterWithoutValue	super testScriptParameterWithoutValue.	self assert: result equals: #('foo'  nil)! !!PRPillarParserTest methodsFor: 'tests - Script'!testScriptParameters	super testScriptParameters.	self		assert: result		equals:			(OrderedDictionary new				at: 'value' put: 'foo';				yourself)! !!PRPillarParserTest methodsFor: 'tests - Script'!testScriptParametersEscape	super testScriptParametersEscape.	self		assert: result		equals:			(OrderedDictionary new				at: 'value' put: 'foo|';				at: 'bar' put: true;				yourself)! !!PRPillarParserTest methodsFor: 'tests - Script'!testScriptParametersMultiple	super testScriptParametersMultiple.	self		assert: result		equals:			(OrderedDictionary new				at: 'value' put: 'foo';				at: 'bar' put: true;				yourself)! !!PRPillarParserTest methodsFor: 'tests - Script'!testScriptSampleWithTrailingBlankOnTheFirstLine	super testScriptSampleWithTrailingBlankOnTheFirstLine.	self assert: result equals: (PRCodeblock content: 'foo').	self assert: result parameters isEmpty.! !!PRPillarParserTest methodsFor: 'tests - Script'!testScriptSampleWithTrailingBlanksOnTheFirstLine	super testScriptSampleWithTrailingBlanksOnTheFirstLine.	self assert: result equals: (PRCodeblock content: 'foo').	self assert: result parameters isEmpty.! !!PRPillarParserTest methodsFor: 'tests - Script'!testScriptSampleWithTrailingTabOnTheFirstLine	super testScriptSampleWithTrailingTabOnTheFirstLine.	self assert: result equals: (PRCodeblock content: 'foo').	self assert: result parameters isEmpty.! !!PRPillarParserTest methodsFor: 'tests - Script'!testScriptTwoParametersNoValue	super testScriptTwoParametersNoValue.	self		assert: result		equals:			(OrderedDictionary new				at: 'foo' put: true;				at: 'bar' put: true;				yourself)! !!PRPillarParserTest methodsFor: 'tests - Script'!testScriptWithLanguage	super testScriptWithLanguage.	self		assert: result		equals:			((PRCodeblock content: 'foo')				language: PRSmalltalkScriptLanguage default;				yourself).	self assertStart: 1 stop: 29.! !!PRPillarParserTest methodsFor: 'tests - Script'!testScriptWithNewLine	super testScriptWithNewLine.	self assert: result equals: (PRCodeblock content: 'foo').	self assertStart: 1 stop: 12.! !!PRPillarParserTest methodsFor: 'tests - Script'!testScriptWithSpaceAtTheEnd	super testScriptWithSpaceAtTheEnd.	self assert: result equals: (PRCodeblock content: 'foo').	self assertStart: 1 stop: 13.! !!PRPillarParserTest methodsFor: 'tests - Script'!testScriptWithSpacedParameters	super testScriptWithSpacedParameters.	self assert: result equals: 					(PRCodeblock content: 'bla'									 parameters: (OrderedDictionary new 															at: 'foo' put: true;															at: 'bar' put: 2;															yourself)).	self assertStart: 1 stop: 33.! !!PRPillarParserTest methodsFor: 'tests - Format'!testStrikethroughFormat	super testStrikethroughFormat.	self assert: result equals: (PRStrikethroughFormat with: (PRText content: 'Foo')).	self assertStart: 1 stop: 7.	self assertStart: 3 stop: 5 ofNode: result children first.! !!PRPillarParserTest methodsFor: 'tests - Format'!testStrikethroughFormatEmpty	super testStrikethroughFormatEmpty.	self assert: result equals: PRStrikethroughFormat new.	self assertStart: 1 stop: 4.! !!PRPillarParserTest methodsFor: 'tests - Format'!testStrikethroughFormatWithEscaped	super testStrikethroughFormatWithEscaped.	self assert: result equals: (PRStrikethroughFormat with: (PRText content: '--')).	self assertStart: 1 stop: 8.	self assertStart: 3 stop: 6 ofNode: result children first.! !!PRPillarParserTest methodsFor: 'tests - Format'!testSubscriptFormat	super testSubscriptFormat.	self assert: result equals: (PRSubscriptFormat with: (PRText content: 'Foo')).	self assertStart: 1 stop: 7.	self assertStart: 3 stop: 5 ofNode: result children first.! !!PRPillarParserTest methodsFor: 'tests - Format'!testSubscriptFormatEmpty	super testSubscriptFormatEmpty.	self assert: result equals: PRSubscriptFormat new.	self assertStart: 1 stop: 4.! !!PRPillarParserTest methodsFor: 'tests - Format'!testSubscriptFormatWithEscaped	super testSubscriptFormatWithEscaped.	self assert: result equals: (PRSubscriptFormat with: (PRText content: '@@')).	self assertStart: 1 stop: 8.	self assertStart: 3 stop: 6 ofNode: result children first.! !!PRPillarParserTest methodsFor: 'tests - Format'!testSuperscriptFormat	super testSuperscriptFormat.	self assert: result equals: (PRSuperscriptFormat with: (PRText content: 'Foo')).	self assertStart: 1 stop: 7.	self assertStart: 3 stop: 5 ofNode: result children first.! !!PRPillarParserTest methodsFor: 'tests - Format'!testSuperscriptFormatEmpty	super testSuperscriptFormatEmpty.	self assert: result equals: PRSuperscriptFormat new.	self assertStart: 1 stop: 4.! !!PRPillarParserTest methodsFor: 'tests - Format'!testSuperscriptFormatWithEscaped	super testSuperscriptFormatWithEscaped.	self assert: result equals: (PRSuperscriptFormat with: (PRText content: '^^')).	self assertStart: 1 stop: 8.	self assertStart: 3 stop: 6 ofNode: result children first.! !!PRPillarParserTest methodsFor: 'tests - Table'!testTable	super testTable.	self		assert: result		equals:			(PRTable new				add:						(PRTableRow new								add: (PRTableCell align: nil heading: true withAll: {PRText content: 'Foo'});								add: (PRTableCell align: nil heading: true withAll: {PRText content: 'Bar'});								yourself);				add:						(PRTableRow new								add: (PRTableCell align: nil heading: false withAll: {PRText content: 'Foo2'});								add: (PRTableCell align: nil heading: false withAll: {PRText content: 'Bar2'});								yourself);				yourself)! !!PRPillarParserTest methodsFor: 'tests - Table'!testTableAlignMarkup	super testTableAlignMarkup.	self assert: result equals: #right! !!PRPillarParserTest methodsFor: 'tests - Table'!testTableCell	super testTableCell.	self assert: result equals: (PRTableCell align: nil heading: false withAll: {PRText content: 'Foo'})! !!PRPillarParserTest methodsFor: 'tests - Table'!testTableCellAreTrimed	super testTableCellAreTrimed.	self assert: result equals: (PRTableCell align: nil heading: false withAll: {PRText content: 'Foo'})! !!PRPillarParserTest methodsFor: 'tests - Table'!testTableCellCenter	super testTableCellCenter.	self assert: result equals: (PRTableCell align: #center heading: false withAll: {PRText content: 'Foo'})! !!PRPillarParserTest methodsFor: 'tests - Table'!testTableCellHeader	super testTableCellHeader.	self assert: result equals: (PRTableCell align: nil heading: true withAll: {PRText content: 'Foo'})! !!PRPillarParserTest methodsFor: 'tests - Table'!testTableCellHeaderCenter	super testTableCellHeaderCenter.	self assert: result equals: (PRTableCell align: #center heading: true withAll: {PRText content: 'Foo'})! !!PRPillarParserTest methodsFor: 'tests - Table'!testTableCellHeaderCenter2	super testTableCellHeaderCenter2.	self assert: result equals: (PRTableCell align: #center heading: true withAll: {PRText content: 'Foo'})! !!PRPillarParserTest methodsFor: 'tests - Table'!testTableCellHeaderLeft	super testTableCellHeaderLeft.	self assert: result equals: (PRTableCell align: #left heading: true withAll: {PRText content: 'Foo'})! !!PRPillarParserTest methodsFor: 'tests - Table'!testTableCellHeaderLeft2	super testTableCellHeaderLeft2.	self assert: result equals: (PRTableCell align: #left heading: true withAll: {PRText content: 'Foo'})! !!PRPillarParserTest methodsFor: 'tests - Table'!testTableCellHeaderRight	super testTableCellHeaderRight.	self assert: result equals: (PRTableCell align: #right heading: true withAll: {PRText content: 'Foo'})! !!PRPillarParserTest methodsFor: 'tests - Table'!testTableCellHeaderRight2	super testTableCellHeaderRight2.	self assert: result equals: (PRTableCell align: #right heading: true withAll: {PRText content: 'Foo'})! !!PRPillarParserTest methodsFor: 'tests - Table'!testTableCellLeft	super testTableCellLeft.	self assert: result equals: (PRTableCell align: #left heading: false withAll: {PRText content: 'Foo'})! !!PRPillarParserTest methodsFor: 'tests - Table'!testTableCellRight	super testTableCellRight.	self assert: result equals: (PRTableCell align: #right heading: false withAll: {PRText content: 'Foo'})! !!PRPillarParserTest methodsFor: 'tests - Table'!testTableCellWithFormat	super testTableCellWithFormat.	self		assert: result		equals: (PRTableCell align: nil heading: false withAll: {PRItalicFormat with: (PRText content: 'Foo')})! !!PRPillarParserTest methodsFor: 'tests - Table'!testTableCenterMarkup	super testTableCenterMarkup.	self assert: result equals: #center! !!PRPillarParserTest methodsFor: 'tests - Table'!testTableHeadingMarkup	super testTableHeadingMarkup.	self assert: result! !!PRPillarParserTest methodsFor: 'tests - Table'!testTableLeftMarkup	super testTableLeftMarkup.	self assert: result equals: #left! !!PRPillarParserTest methodsFor: 'tests - Table'!testTableMarkups	super testTableMarkups.	self		assert: result		equals:			{nil.			false}! !!PRPillarParserTest methodsFor: 'tests - Table'!testTableMarkupsCenter	super testTableMarkupsCenter.	self		assert: result		equals:			{#center.			false}! !!PRPillarParserTest methodsFor: 'tests - Table'!testTableMarkupsHeading	super testTableMarkupsHeading.	self		assert: result		equals:			{nil.			true}! !!PRPillarParserTest methodsFor: 'tests - Table'!testTableMarkupsHeadingAndCenter	super testTableMarkupsHeadingAndCenter.	self		assert: result		equals:			{#center.			true}! !!PRPillarParserTest methodsFor: 'tests - Table'!testTableMarkupsHeadingAndCenter2	super testTableMarkupsHeadingAndCenter2.	self		assert: result		equals:			{#center.			true}! !!PRPillarParserTest methodsFor: 'tests - Table'!testTableRightMarkup	super testTableRightMarkup.	self assert: result equals: #right! !!PRPillarParserTest methodsFor: 'tests - Table'!testTableRow	super testTableRow.	self		assert: result		equals:			(PRTableRow new				add: (PRTableCell align: nil heading: false withAll: {PRText content: 'Foo'});				add: (PRTableCell align: nil heading: false withAll: {PRText content: 'Bar'});				yourself)! !!PRPillarParserTest methodsFor: 'tests - Table'!testTableRowWithEmptyCells	super testTableRowWithEmptyCells.	self		assert: result		equals:			(PRTableRow new				add: PRTableCell new;				add: PRTableCell new;				yourself)! !!PRPillarParserTest methodsFor: 'tests - Table'!testTableRowWithHeading	super testTableRowWithHeading.	self		assert: result		equals:			(PRTableRow new				add: (PRTableCell align: nil heading: true withAll: {PRText content: 'Foo'});				add: (PRTableCell align: nil heading: true withAll: {PRText content: 'Bar'});				yourself)! !!PRPillarParserTest methodsFor: 'tests - Table'!testTableWithComment	super testTableWithComment.	self flag: #todo	"See super."	"self		assert: result		equals:			(PRTable				withAll:					{PRTableRow						with:							(PRTableCell								align: nil								heading: false								withAll:									{PRText content: 'Foo'.									PRCommentedLine content: 'Comment'}).					PRTableRow with: (PRTableCell align: nil heading: false withAll: {PRText content: 'Bar'})})"! !!PRPillarParserTest methodsFor: 'tests - Table'!testTableWithNewLine	super testTableWithNewLine.	self		assert: result		equals:			(PRTable new				add:						(PRTableRow new								add: (PRTableCell align: nil heading: true withAll: {PRText content: 'Foo'});								add: (PRTableCell align: nil heading: true withAll: {PRText content: 'Bar'});								yourself);				add:						(PRTableRow new								add: (PRTableCell align: nil heading: false withAll: {PRText content: 'Foo2'});								add: (PRTableCell align: nil heading: false withAll: {PRText content: 'Bar2'});								yourself);				yourself)! !!PRPillarParserTest methodsFor: 'tests - Anchor'!testText	super testText.	self assert: result equals: (PRText content: 'Foo').	self assertStart: 1 stop: 3.! !!PRPillarParserTest methodsFor: 'tests - Annotation'!testUndefinedAnnotation	self 		should: [ super testUndefinedAnnotation ]		raise: PRSyntaxError.! !!PRPillarParserTest methodsFor: 'tests - Annotation'!testUndefinedAnnotationAsNode	PRValidation beSilentDuring: [ super testUndefinedAnnotation ].	self		assert: result		equals: ((PRUndefinedAnnotation withParameters: PRParameters new)			tag: #undefinedAnnotation).	self assertStart: 1 stop: 23.	self assert: result hadAllKeys.	self assert: result isValid.	self assert: result tag equals: #undefinedAnnotation.! !!PRPillarParserTest methodsFor: 'tests - Annotation'!testUndefinedAnnotationWithParameters	self 		should: [ super testUndefinedAnnotationWithParameters ]		raise: PRSyntaxError.! !!PRPillarParserTest methodsFor: 'tests - Annotation'!testUndefinedAnnotationWithParametersAsNode	PRValidation beSilentDuring: [ 		super testUndefinedAnnotationWithParameters ].	self		assert: result		equals: ((PRUndefinedAnnotation withParameters: (			PRParameters withAll: { 				(PRParameter 					keyNode: (PRParameterKey named: #param1) 					valueNode: (PRParameterValue value: 'a')).				(PRParameter 					keyNode: (PRParameterKey named: #param2) 					valueNode: (PRParameterValue value: 'b')) }))			tag: #undefinedAnnotation).	self assert: result children size equals: 1.	self assertStart: 1 stop: 41.	self assert: result hadAllKeys.! !!PRPillarParserTest methodsFor: 'tests - Format'!testUnderlineFormat	super testUnderlineFormat.	self assert: result equals: (PRUnderlineFormat with: (PRText content: 'Foo')).	self assertStart: 1 stop: 7.	self assertStart: 3 stop: 5 ofNode: result children first.! !!PRPillarParserTest methodsFor: 'tests - Format'!testUnderlineFormatEmpty	super testUnderlineFormatEmpty.	self assert: result equals: PRUnderlineFormat new.	self assertStart: 1 stop: 4.! !!PRPillarParserTest methodsFor: 'tests - Format'!testUnderlineFormatWithEscaped	super testUnderlineFormatWithEscaped.	self assert: result equals: (PRUnderlineFormat with: (PRText content: '__')).	self assertStart: 1 stop: 8.	self assertStart: 3 stop: 6 ofNode: result children first.! !!PRPillarParserTest methodsFor: 'tests - List'!testUnorderedList	super testUnorderedList.	self		assert: result		equals: (PRUnorderedList with: (PRListItem with: (PRText content: 'Foo'))).	self assertStart: 1 stop: 4.	self assertStart: 1 stop: 4 ofNode: result children first.	self assertStart: 2 stop: 4 ofNode: result children first children first.! !!PRPillarParserTest methodsFor: 'tests - List'!testUnorderedListEmpty	super testUnorderedListEmpty.	self assert: result equals: (PRUnorderedList with: PRListItem new).	self assertStart: 1 stop: 1.! !!PRPillarParserTest methodsFor: 'tests - List'!testUnorderedListMulti	super testUnorderedListMulti.	self		assert: result		equals:			(PRUnorderedList				withAll:					{(PRListItem						withAll:							{(PRText content: '1').							(PRUnorderedList								withAll:									{(PRListItem										withAll:											{(PRText content: '2').											(PRUnorderedList with: (PRListItem with: (PRText content: '3')))}).									(PRListItem with: (PRText content: '4')).									(PRListItem with: (PRText content: '5')).									(PRListItem with: (PRText content: '6'))})}).					(PRListItem						withAll:							{(PRText content: '7').							(PRUnorderedList								with:									(PRListItem with: (PRUnorderedList with: (PRListItem with: (PRText content: '8')))))})})! !!PRPillarParserTest methodsFor: 'tests - List'!testUnorderedListWithSubList	super testUnorderedListWithSubList.	self		assert: result		equals:			(PRUnorderedList				with:					(PRListItem						withAll:							{(PRText content: 'Foo').							(PRUnorderedList with: (PRListItem with: (PRText content: 'Bar')))}))! !!PRPillarParserTest methodsFor: 'tests - List'!testUnorderedListWithTwoItems	super testUnorderedListWithTwoItems.	self		assert: result		equals:			(PRUnorderedList				withAll:					{(PRListItem with: (PRText content: 'Foo')).					(PRListItem with: (PRText content: 'Bar'))})! !!PillarSnippetFactory methodsFor: 'sample'!aliasFigureEscapeSample	^ 'Alias\>>'! !!PillarSnippetFactory methodsFor: 'sample'!aliasFigureSample	^ 'Alias>'! !!PillarSnippetFactory methodsFor: 'sample'!aliasLinkEscapeSample	^ 'Alias\>>'! !!PillarSnippetFactory methodsFor: 'sample'!aliasLinkSample	^ 'Alias>'! !!PillarSnippetFactory methodsFor: 'sample'!anchorAreTrimedSample	^ '@  test  '! !!PillarSnippetFactory methodsFor: 'sample'!anchorSample	^ '@test'! !!PillarSnippetFactory methodsFor: 'sample'!anchorWithNewLineSample	^ '@foo'! !!PillarSnippetFactory methodsFor: 'sample'!anchorWithSpaceInsideSample	^ '@foo bar'! !!PillarSnippetFactory methodsFor: 'sample'!annotatedParagraphEmptySample	^ '@@foo'! !!PillarSnippetFactory methodsFor: 'sample'!annotatedParagraphEmptyWithNewLineSample	^ '@@foo'! !!PillarSnippetFactory methodsFor: 'sample'!annotatedParagraphSample	^ '@@foo Bar'! !!PillarSnippetFactory methodsFor: 'sample'!annotationAreTrimedAtTheRightSample	^ '${inputFile:path=Foo}$  '! !!PillarSnippetFactory methodsFor: 'sample'!annotationOnlyWithParameterNameSample	^ '${inputFile:path}$'! !!PillarSnippetFactory methodsFor: 'sample'!annotationParameterSample	^ 'value=foo'! !!PillarSnippetFactory methodsFor: 'sample'!annotationParameters2Sample	^ ':foo=bar|timo=leon'! !!PillarSnippetFactory methodsFor: 'sample'!annotationParametersSample	^ ':foo=bar|timo=leon'! !!PillarSnippetFactory methodsFor: 'sample'!annotationSample	^ '${inputFile:path=Foo}$'! !!PillarSnippetFactory methodsFor: 'sample'!annotationTagSample	^ 'mock'! !!PillarSnippetFactory methodsFor: 'sample'!annotationWithUnknownKeyAsNodeSample	^ '${inputFile:path=Foo|unknownKey=Bar}$'! !!PillarSnippetFactory methodsFor: 'sample'!annotationWithUnknownKeySample	^ '${inputFile:path=Foo|unknownKey=Bar}$'! !!PillarSnippetFactory methodsFor: 'sample'!annotationWithoutFirstParameterNameAndDefaultValuesSample	^ '${docList:Foo|limit|sort}$'! !!PillarSnippetFactory methodsFor: 'sample'!annotationWithoutParameterNameSample	^ '${inputFile:Foo}$'! !!PillarSnippetFactory methodsFor: 'sample'!annotationWithoutParametersAsNodeSample	^ '${inputFile}$'! !!PillarSnippetFactory methodsFor: 'sample'!annotationWithoutParametersSample	^ '${inputFile}$'! !!PillarSnippetFactory methodsFor: 'sample'!boldFormatEmptySample	^ '""""'! !!PillarSnippetFactory methodsFor: 'sample'!boldFormatSample	^ '""Foo""'! !!PillarSnippetFactory methodsFor: 'sample'!boldFormatWithEscapedSample	^ '""\"\"""'! !!PillarSnippetFactory methodsFor: 'tests - Script'!codeBlockSample	^ '[[[foo]]]'! !!PillarSnippetFactory methodsFor: 'sample'!commentedLineSample	^ '%some text'! !!PillarSnippetFactory methodsFor: 'sample'!commentedLineWithNewlineSample	^ '%some text'! !!PillarSnippetFactory methodsFor: 'sample'!definitionListSample	^ ';Foo:Bar'! !!PillarSnippetFactory methodsFor: 'sample'!emptyParagraphSample	^ ''! !!PillarSnippetFactory methodsFor: 'sample'!escapedCharacterSample	^  '\*' ! !!PillarSnippetFactory methodsFor: 'sample'!figureFollowedByLinkWithAliasSample	^ '+file://TeapotWelcome.png+*Go>http://localhost*'! !!PillarSnippetFactory methodsFor: 'sample'!formatWithLinkSample	^ '""*foo*""'! !!PillarSnippetFactory methodsFor: 'sample'!headerEmptySample	^ '!!'! !!PillarSnippetFactory methodsFor: 'sample'!headerLevel1Sample	^ '!!Foo'! !!PillarSnippetFactory methodsFor: 'sample'!headerLevel2Sample	^ '!!!!Foo'! !!PillarSnippetFactory methodsFor: 'sample'!headerLevel3Sample	^ '!!!!!!Foo'! !!PillarSnippetFactory methodsFor: 'sample'!headerLevel4Sample	^ '!!!!!!!!Foo'! !!PillarSnippetFactory methodsFor: 'sample'!headerLevel5Sample	^ '!!!!!!!!!!Foo'! !!PillarSnippetFactory methodsFor: 'sample'!headerLevel6Sample	^ '!!!!!!!!!!!!Foo'! !!PillarSnippetFactory methodsFor: 'sample'!headerWithFormatAndTextSample	^ '!!""Foo"" bar'! !!PillarSnippetFactory methodsFor: 'sample'!headerWithFormatSample	^ '!!""Foo""'! !!PillarSnippetFactory methodsFor: 'sample'!headerWithNewLineSample	^ '!!Foo'! !!PillarSnippetFactory methodsFor: 'sample'!headerWithWithLinkSample	^ '!! Foo *Link*'! !!PillarSnippetFactory methodsFor: 'sample'!horizontalRuleFollowByNewLineSample	^ '_'! !!PillarSnippetFactory methodsFor: 'sample'!horizontalRuleSample	^ '_'! !!PillarSnippetFactory methodsFor: 'sample'!horizontalRuleTrimRightSample	^ '_  '! !!PillarSnippetFactory methodsFor: 'sample'!italicFormatEmptySample	^ '''''''''' ! !!PillarSnippetFactory methodsFor: 'sample'!italicFormatSample	^ '''''Foo''''' ! !!PillarSnippetFactory methodsFor: 'sample'!italicFormatWithEscapedSample	^   '''''\''\''''''' ! !!PillarSnippetFactory methodsFor: 'sample'!lineEndSample	^  ''! !!PillarSnippetFactory methodsFor: 'sample'!lineEndwithNewlineSample	^ String lf! !!PillarSnippetFactory methodsFor: 'sample'!linkFollowedByFigureWithAliasSample	^ '*http://localhost*+Go>file://TeapotWelcome.png+'! !!PillarSnippetFactory methodsFor: 'sample'!listMultiSample	^ '-1--2---3--4--5--6-7-##8'! !!PillarSnippetFactory methodsFor: 'sample'!listWithCommentSample	^ '#Foo%Comment#Bar'! !!PillarSnippetFactory methodsFor: 'sample'!monospaceFormatEmptySample	^ '===='! !!PillarSnippetFactory methodsFor: 'sample'!monospaceFormatSample	^ '==Foo=='! !!PillarSnippetFactory methodsFor: 'sample'!monospaceFormatWithEscapedSample	^ '==\=\==='! !!PillarSnippetFactory methodsFor: 'sample'!newlineCRLFSample	^ String crlf! !!PillarSnippetFactory methodsFor: 'sample'!newlineCRSample	^ String cr! !!PillarSnippetFactory methodsFor: 'sample'!newlineLFSample	^ String lf! !!PillarSnippetFactory methodsFor: 'sample'!newlineSample	^ Smalltalk os lineEnding! !!PillarSnippetFactory methodsFor: 'sample'!orderedListEmptySample	^ '#'! !!PillarSnippetFactory methodsFor: 'sample'!orderedListMultiSample	^ '#1##2###3##4##5##6#7###8'! !!PillarSnippetFactory methodsFor: 'sample'!orderedListSample	^ '#Foo'! !!PillarSnippetFactory methodsFor: 'sample'!orderedListWithSubListSample	^ '#Foo##Bar'! !!PillarSnippetFactory methodsFor: 'sample'!orderedListWithTwoItemsSample	^ '#Foo#Bar'! !!PillarSnippetFactory methodsFor: 'sample'!paragraphSample	^ 'This is a text'! !!PillarSnippetFactory methodsFor: 'sample'!paragraphWithFormatSample	^ 'Foo ""Bar""'! !!PillarSnippetFactory methodsFor: 'sample'!parameterFigureSample	^'value=foo'! !!PillarSnippetFactory methodsFor: 'sample'!parameterKeyUntilNewlineSample	^ 'parameterName'! !!PillarSnippetFactory methodsFor: 'sample'!parameterLinkSample	^  'value=foo' ! !!PillarSnippetFactory methodsFor: 'sample'!parameterUntilNewlineSample	^ 'foo=bar'! !!PillarSnippetFactory methodsFor: 'sample'!parameterValueUntilNewlineSample	^ '=parameterValue'! !!PillarSnippetFactory methodsFor: 'sample'!parametersFigureSample	^ '|foo=bar|timo=leon' ! !!PillarSnippetFactory methodsFor: 'sample'!parametersLinkSample	^ '|foo=bar|timo=leon'! !!PillarSnippetFactory methodsFor: 'sample'!parametersUntilNewlineSample	^ 'foo=bar|baz=true'! !!PillarSnippetFactory methodsFor: 'sample'!preformatedLineSample	^ '= Foo' ! !!PillarSnippetFactory methodsFor: 'sample'!preformatedTextEmptySample	^  '= ' ! !!PillarSnippetFactory methodsFor: 'sample'!preformatedTextSample	^  '= Foo' ! !!PillarSnippetFactory methodsFor: 'sample'!preformatedTextWithMultiLinesSample	^ '= Foo= Bar'		! !!PillarSnippetFactory methodsFor: 'sample'!preformatedTextWithNewlineSample^ '= Foo' ! !!PillarSnippetFactory methodsFor: 'sample'!preformatedTextWithSpacesSample	^ '=    Foo'! !!PillarSnippetFactory methodsFor: 'sample'!preformatedTextWithTabSample	^ '= 	Foo' ! !!PillarSnippetFactory methodsFor: 'sample'!rawEmptySample	^ '{{{}}}'! !!PillarSnippetFactory methodsFor: 'sample'!rawHTMLSample	^ '{{{html:foo}}}' ! !!PillarSnippetFactory methodsFor: 'sample'!rawInvalidSample	^  '{{{invalid:foo}}}'! !!PillarSnippetFactory methodsFor: 'sample'!rawMultiLinesSample	^ '{{{foobar}}}'! !!PillarSnippetFactory methodsFor: 'sample'!rawSample	^ '{{{mock:foo}}}'! !!PillarSnippetFactory methodsFor: 'sample'!referenceFigureEscapeSample	^ 'file://foo\+.png'! !!PillarSnippetFactory methodsFor: 'sample'!referenceFigureSample	^ 'file://foo.png'! !!PillarSnippetFactory methodsFor: 'sample'!referenceLinkEscapeSample	^ 'file://foo\*.png'! !!PillarSnippetFactory methodsFor: 'sample'!referenceLinkSample	^ 'file://foo.png'! !!PillarSnippetFactory methodsFor: 'sample'!referenceSample	^ '*foo>@bar*'! !!PillarSnippetFactory methodsFor: 'sample'!scriptParameterEndsWithSpaceSample	^ '[[[foobar]]]'! !!PillarSnippetFactory methodsFor: 'sample'!scriptParameterEscapeSample	^ 'value\==foo'! !!PillarSnippetFactory methodsFor: 'sample'!scriptParameterSample	^ 'value=foo'! !!PillarSnippetFactory methodsFor: 'sample'!scriptParameterTrueByDefaultSample	^ '[[[foobar]]]'! !!PillarSnippetFactory methodsFor: 'sample'!scriptParameterValueSample	^ '=foo'! !!PillarSnippetFactory methodsFor: 'sample'!scriptParameterWithFloatSample	^ '[[[ratio=0.8bar]]]'! !!PillarSnippetFactory methodsFor: 'sample'!scriptParameterWithLiteralArraySample	^ '[[[foo=#(1 2 true)bar]]]'! !!PillarSnippetFactory methodsFor: 'sample'!scriptParameterWithNoValuesSample	^ '[[[foo=bar]]]'! !!PillarSnippetFactory methodsFor: 'sample'!scriptParameterWithSpacesBeforeAndAfterSample	^ ' foo = true | bar = 2 '! !!PillarSnippetFactory methodsFor: 'sample'!scriptParameterWithoutValueSample	^ 'foo'! !!PillarSnippetFactory methodsFor: 'sample'!scriptParametersEscapeSample	^ 'value=foo\||bar'! !!PillarSnippetFactory methodsFor: 'sample'!scriptParametersMultipleSample	^ 'value=foo|bar'! !!PillarSnippetFactory methodsFor: 'sample'!scriptParametersSample	^ 'value=foo'! !!PillarSnippetFactory methodsFor: 'sample'!scriptSample	^ '[[[foo]]]'! !!PillarSnippetFactory methodsFor: 'sample'!scriptSampleWithTrailingBlankOnTheFirstLine	^ '[[[ foo]]]'! !!PillarSnippetFactory methodsFor: 'sample'!scriptSampleWithTrailingBlanksOnTheFirstLine	^ '[[[   foo]]]'! !!PillarSnippetFactory methodsFor: 'sample'!scriptSampleWithTrailingTabOnTheFirstLine	^ '[[[	 foo]]]'! !!PillarSnippetFactory methodsFor: 'sample'!scriptTwoParametersNoValueSample	^ 'foo|bar'! !!PillarSnippetFactory methodsFor: 'sample'!scriptWithLanguageSample	^ '[[[language=smalltalkfoo]]]'! !!PillarSnippetFactory methodsFor: 'sample'!scriptWithNewLineSample	^ '[[[foo]]]'! !!PillarSnippetFactory methodsFor: 'sample'!scriptWithSpaceAtTheEndSample	^ '[[[foo]]]  '! !!PillarSnippetFactory methodsFor: 'sample'!scriptWithSpacedParametersSample	^ '[[[ foo = true | bar = 2 bla]]]'! !!PillarSnippetFactory methodsFor: 'sample'!strikethroughFormatEmptySample	^ '----'! !!PillarSnippetFactory methodsFor: 'sample'!strikethroughFormatSample	^ '--Foo--'! !!PillarSnippetFactory methodsFor: 'sample'!strikethroughFormatWithEscapedSample	^ '--\-\---'! !!PillarSnippetFactory methodsFor: 'sample'!subscriptFormatEmptySample	^ '@@@@'! !!PillarSnippetFactory methodsFor: 'sample'!subscriptFormatSample	^ '@@Foo@@'! !!PillarSnippetFactory methodsFor: 'sample'!subscriptFormatWithEscapedSample	^ '@@\@\@@@'! !!PillarSnippetFactory methodsFor: 'sample'!superscriptFormatEmptySample	^ '^^^^'! !!PillarSnippetFactory methodsFor: 'sample'!superscriptFormatSample	^ '^^Foo^^'! !!PillarSnippetFactory methodsFor: 'sample'!superscriptFormatWithEscapedSample	^ '^^\^\^^^'! !!PillarSnippetFactory methodsFor: 'sample'!tableAlignMarkupSample	^ '}'! !!PillarSnippetFactory methodsFor: 'sample'!tableCellAreTrimedSample	^ '|   Foo   '! !!PillarSnippetFactory methodsFor: 'sample'!tableCellCenterSample	^ '||Foo'! !!PillarSnippetFactory methodsFor: 'sample'!tableCellHeaderCenter2Sample	^ '||!!Foo'! !!PillarSnippetFactory methodsFor: 'sample'!tableCellHeaderCenterSample	^ '|!!|Foo'! !!PillarSnippetFactory methodsFor: 'sample'!tableCellHeaderLeft2Sample	^ '|{!!Foo'! !!PillarSnippetFactory methodsFor: 'sample'!tableCellHeaderLeftSample	^ '|!!{Foo'! !!PillarSnippetFactory methodsFor: 'sample'!tableCellHeaderRight2Sample	^ '|}!!Foo'! !!PillarSnippetFactory methodsFor: 'sample'!tableCellHeaderRightSample	^ '|!!}Foo'! !!PillarSnippetFactory methodsFor: 'sample'!tableCellHeaderSample	^ '|!!Foo'! !!PillarSnippetFactory methodsFor: 'sample'!tableCellLeftSample	^ '|{Foo'! !!PillarSnippetFactory methodsFor: 'sample'!tableCellRightSample	^ '|}Foo'! !!PillarSnippetFactory methodsFor: 'sample'!tableCellSample	^ '|Foo'! !!PillarSnippetFactory methodsFor: 'sample'!tableCellWithFormatSample	^ '| ''''Foo'''' ' ! !!PillarSnippetFactory methodsFor: 'sample'!tableCenterMarkupSample	^ '|'! !!PillarSnippetFactory methodsFor: 'sample'!tableHeadingMarkupSample	^ '!!'! !!PillarSnippetFactory methodsFor: 'sample'!tableLeftMarkupSample	^ '{'! !!PillarSnippetFactory methodsFor: 'sample'!tableMarkupsCenterSample	^ '||'! !!PillarSnippetFactory methodsFor: 'sample'!tableMarkupsHeadingAndCenter2Sample	^ '||!!'! !!PillarSnippetFactory methodsFor: 'sample'!tableMarkupsHeadingAndCenterSample	^ '|!!|'! !!PillarSnippetFactory methodsFor: 'sample'!tableMarkupsHeadingSample	^ '|!!'! !!PillarSnippetFactory methodsFor: 'sample'!tableMarkupsSample	^ '|'! !!PillarSnippetFactory methodsFor: 'sample'!tableRightMarkupSample	^ '}'! !!PillarSnippetFactory methodsFor: 'sample'!tableRowSample	^ '| Foo | Bar'! !!PillarSnippetFactory methodsFor: 'sample'!tableRowWithEmptyCellsSample	^ '|  | '! !!PillarSnippetFactory methodsFor: 'sample'!tableRowWithHeadingSample	^ '|!! Foo |!! Bar'! !!PillarSnippetFactory methodsFor: 'sample'!tableSample	^ '|!! Foo |!! Bar| Foo2 | Bar2'! !!PillarSnippetFactory methodsFor: 'sample'!tableWithNewLineSample	^ '|!! Foo |!! Bar| Foo2 | Bar2'! !!PillarSnippetFactory methodsFor: 'sample'!textSample	^ 'Foo'! !!PillarSnippetFactory methodsFor: 'sample'!textWithEscapeAtBeginningSample	^ '\*Foo'! !!PillarSnippetFactory methodsFor: 'sample'!textWithEscapeInTheMiddleSample	^ 'Foo \* Bar' ! !!PillarSnippetFactory methodsFor: 'sample'!textWithMultiEscapeSample	^ '\*Foo\*' ! !!PillarSnippetFactory methodsFor: 'sample'!undefinedAnnotationAsNodeSample	^ '${undefinedAnnotation}$'! !!PillarSnippetFactory methodsFor: 'sample'!undefinedAnnotationSample	^ '${undefinedAnnotation}$'! !!PillarSnippetFactory methodsFor: 'sample'!undefinedAnnotationWithParametersAsNodeSample	^ '${undefinedAnnotation:param1=a|param2=b}$'! !!PillarSnippetFactory methodsFor: 'sample'!undefinedAnnotationWithParametersSample	^ '${undefinedAnnotation:param1=a|param2=b}$'! !!PillarSnippetFactory methodsFor: 'sample'!underlineFormatEmptySample	^ '____'! !!PillarSnippetFactory methodsFor: 'sample'!underlineFormatSample	^ '__Foo__'! !!PillarSnippetFactory methodsFor: 'sample'!underlineFormatWithEscapedSample	^ '__\_\___'! !!PillarSnippetFactory methodsFor: 'sample'!unorderedListEmptySample	^ '-'! !!PillarSnippetFactory methodsFor: 'sample'!unorderedListMultiSample	^ '-1--2---3--4--5--6-7---8'! !!PillarSnippetFactory methodsFor: 'sample'!unorderedListSample	^ '-Foo'! !!PillarSnippetFactory methodsFor: 'sample'!unorderedListWithSubListSample	^ '-Foo--Bar'! !!PillarSnippetFactory methodsFor: 'sample'!unorderedListWithTwoItemsSample	^ '-Foo-Bar'! !!PRParseAbstractAnnotationTest class methodsFor: 'testing'!isAbstract	^ self = PRParseAbstractAnnotationTest! !!PRParseAbstractAnnotationTest methodsFor: 'helpers'!actualClass	^ self subclassResponsibility! !!PRParseAbstractAnnotationTest methodsFor: 'helpers'!annoteName	^ self actualClass tag! !!PRParseAbstractAnnotationTest methodsFor: 'helpers'!referenceParameters	self subclassResponsibility! !!PRParseAbstractAnnotationTest methodsFor: 'helpers'!referenceString	"Pay attention to order the parameters according to sorted"	self		subclassResponsibility! !!PRParseAbstractAnnotationTest methodsFor: 'tests'!testParse	| wiki tree |	wiki := '${' , self referenceString , '}$'.	tree := PRDocument new		add:			(PRParagraph new				add: (self actualClass withParameters: self referenceParameters);				yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseAbstractAnnotationTest methodsFor: 'tests'!testParsedHadAllKeys	self assert: (self parser parse:  '${' , self referenceString , '}$') children first children first hadAllKeys! !!PRParseBeginEnvironmentAnnotationTest methodsFor: 'helpers'!actualClass	^ PRBeginEnvironmentAnnotation! !!PRParseBeginEnvironmentAnnotationTest methodsFor: 'helpers'!referenceParameters	^ PRParameters withAll: { 		PRParameter 			keyNode: (PRParameterKey named: 'name')			valueNode: (PRParameterValue value: 'card').		PRParameter 			keyNode: (PRParameterKey named: 'number')			valueNode: (PRParameterValue value: 10).		PRParameter 			keyNode: (PRParameterKey named: 'string')			valueNode: (PRParameterValue value: 'a string').		PRParameter 			keyNode: (PRParameterKey named: 'boolean')			valueNode: (PRParameterValue value: true).		}! !!PRParseBeginEnvironmentAnnotationTest methodsFor: 'helpers'!referenceString	^ 'begin:name=card|number=10|string=a string|boolean=true'! !!PRParseEndEnvironmentAnnotationTest methodsFor: 'helpers'!actualClass	^ PREndEnvironmentAnnotation! !!PRParseEndEnvironmentAnnotationTest methodsFor: 'helpers'!referenceParameters	^ PRParameters withAll: { 		PRParameter 			keyNode: (PRParameterKey named: 'name')			valueNode: (PRParameterValue value: 'card').		PRParameter 			keyNode: (PRParameterKey named: 'number')			valueNode: (PRParameterValue value: 10).		PRParameter 			keyNode: (PRParameterKey named: 'string')			valueNode: (PRParameterValue value: 'a string').		PRParameter 			keyNode: (PRParameterKey named: 'boolean')			valueNode: (PRParameterValue value: true).		}! !!PRParseEndEnvironmentAnnotationTest methodsFor: 'helpers'!referenceString	^ 'end:name=card|number=10|string=a string|boolean=true'! !!PRParseAnchorTest class methodsFor: 'testing'!isAbstract	^ false! !!PRParseAnchorTest methodsFor: 'private'!actualClass	^ PRAnchor! !!PRParseAnchorTest methodsFor: 'tests-parsing'!testBasic	| wiki tree |	wiki := '@name'.	tree := PRDocument new add: (PRAnchor named: 'name'); yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseAnchorTest methodsFor: 'tests-parsing'!testMultiple	| wiki tree nLine |	nLine := self lineEnding.	wiki := '@one' , nLine , '@two' , nLine , nLine , '@tree'.	tree := PRDocument new		        add: (PRAnchor named: 'one');		        add: (PRAnchor named: 'two');		        add: PREmptyParagraph new;		        add: (PRAnchor named: 'tree');		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseAnchorTest methodsFor: 'tests-parsing'!testSpaces	| wiki tree |	wiki := '@one two'.	tree := PRDocument new add: (PRAnchor named: 'one two'); yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseAnnotatedParagraphTest class methodsFor: 'testing'!isAbstract	^ false! !!PRParseAnnotatedParagraphTest methodsFor: 'private'!actualClass	^ PRAnnotatedParagraph! !!PRParseAnnotatedParagraphTest methodsFor: 'tests-parsing'!testParseBasic	| wiki tree |	wiki := '@@foo bar zork'.	tree := PRDocument new		add: (PRAnnotatedParagraph new			annotation: 'foo';			add: (PRText content: 'bar zork');			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseAnnotatedParagraphTest methodsFor: 'tests-parsing'!testParseEmptyFollowedByPreformatted	| wiki tree nLine |	nLine := self lineEnding.	wiki := '@@foo' , nLine , '= bar'.	tree := PRDocument new		        add: (PRAnnotatedParagraph new				         annotation: 'foo';				         yourself);		        add: (PRPreformatted new				         add: (PRText content: 'bar');				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseAnnotatedParagraphTest methodsFor: 'tests-parsing'!testParseOnlyAnnotation	| wiki tree |	wiki := '@@foo'.	tree := PRDocument new		add: (PRAnnotatedParagraph new			annotation: 'foo';			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseAnnotatedParagraphTest methodsFor: 'tests-parsing'!testParseOnlyNothing	| wiki tree |	wiki := '@@'.	tree := PRDocument new		add: (PRAnnotatedParagraph new			annotation: '';			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseAnnotatedParagraphTest methodsFor: 'tests-parsing'!testParseOnlyText	| wiki tree |	wiki := '@@ foo bar'.	tree := PRDocument new		add: (PRAnnotatedParagraph new			add: (PRText content: 'foo bar');			annotation: '';			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseDocumentGroupTest methodsFor: 'private'!actualClass	^ PRDocumentGroup! !!PRParseDocumentTest class methodsFor: 'testing'!isAbstract	^ false! !!PRParseDocumentTest methodsFor: 'private'!actualClass	^ PRDocument! !!PRParseDocumentTest methodsFor: 'tests-parsing'!testParseEmpty	| wiki tree |	wiki := String new.	tree := PRDocument new.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseDocumentTest methodsFor: 'tests-parsing'!testParseMultipleProperties	| wiki tree document|	wiki := '{''title'':''The title'',''authors'':''Someone else and me''}'.	tree := PRDocument new		propertyAt: 'title' put: 'The title';		propertyAt: 'authors' put: 'Someone else and me';		yourself.	self parserAssertWiki: wiki equalsTree: tree.	document := self parser parse: wiki.	self assert: document properties equals: tree properties! !!PRParseDocumentTest methodsFor: 'tests-parsing'!testParseProperties	| wiki  tree document |	wiki := '{''title'':''The title''}'.	tree := PRDocument new		propertyAt: 'title' put: 'The title';		yourself.	self parserAssertWiki: wiki equalsTree: tree.	document := self parser parse: wiki.	self assert: document properties equals: tree properties! !!PRParseDocumentTest methodsFor: 'tests-parsing'!testParsePropertiesWithText	| wiki tree document |	wiki := '{''title'':''The title''}' , self lineEnding , 'foobar'.	tree := PRDocument new		        propertyAt: 'title' put: 'The title';		        add: (PRParagraph new				         add: (PRText content: 'foobar');				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree.	document := self parser parse: wiki.	self assert: document properties equals: tree properties! !!PRParseFormatTest class methodsFor: 'testing'!isAbstract	^ false! !!PRParseFormatTest class methodsFor: 'testing'!testParameters	^ (ParametrizedTestMatrix new			forSelector: #actualClass addOptions: PRFormat subclasses )! !!PRParseFormatTest methodsFor: 'private'!actualClass	^ actualClass! !!PRParseFormatTest methodsFor: 'private'!actualClass: aClass	actualClass := aClass! !!PRParseFormatTest methodsFor: 'tests-parsing'!escapeMarkup:  aMarkup	^ String streamContents: [ :str | aMarkup do: [ :each | str nextPut: $\; nextPut: each ] ]! !!PRParseFormatTest methodsFor: 'accessing'!otherClass	^ otherClass ifNil: [ otherClass := PRFormat allSubclasses detect: [ :each | self actualClass ~= each ] ]! !!PRParseFormatTest methodsFor: 'running'!setUp	super setUp.	markup := PRPillarGrammar markups at: self actualClass! !!PRParseFormatTest methodsFor: 'tests-parsing'!testParseBasic	| wiki tree |	wiki := '1' , markup , '2' , markup , '3'.	tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: '1');				add: (self actualClass with: (PRText content: '2'));				add: (PRText content: '3');				yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseFormatTest methodsFor: 'tests-parsing'!testParseEnd	| wiki tree |	wiki := '1' , markup , '2' , markup.		tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: '1');				add: (self actualClass with: (PRText content: '2'));				yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseFormatTest methodsFor: 'tests-parsing'!testParseEscaped	| wiki tree |	wiki := ' ' , (self escapeMarkup: markup) , (self escapeMarkup: markup).	tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: ' ' , markup , markup);				yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseFormatTest methodsFor: 'tests-parsing'!testParseIncomplete	| wiki1 wiki2 tree |	wiki1 := '1' , markup , '2'.	wiki2 := '1' , (self escapeMarkup: markup) , '2'.		tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: '1' , markup , '2');				yourself);		yourself.	self parserAssertWiki: wiki1 equalsTree: tree.	self parserAssertWiki: wiki2 equalsTree: tree.! !!PRParseFormatTest methodsFor: 'tests-parsing'!testParseMany	| wiki tree |	wiki := '1' , markup , '2' , markup , '3' , markup , '4' , markup , '5'.		tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: '1');				add: (self actualClass with: (PRText content: '2'));				add: (PRText content: '3');				add: (self actualClass with: (PRText content: '4'));				add: (PRText content: '5');				yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseFormatTest methodsFor: 'tests-parsing'!testParseNested	| wiki tree |	wiki := '1' , markup , '2' , (PRPillarGrammar markups at: self otherClass) , '3'		, (PRPillarGrammar markups at: self otherClass) , '4' , markup , '5'.		tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: '1');				add:					(self actualClass new						add: (PRText content: '2');						add:							(self otherClass new								add: (PRText content: '3');								yourself);						add: (PRText content: '4');						yourself);				add: (PRText content: '5');				yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseFormatTest methodsFor: 'tests-parsing'!testParseNestedTight	| wiki tree |	wiki := ' ' , markup , (PRPillarGrammar markups at: self otherClass)		, (PRPillarGrammar markups at: self otherClass) , markup.	tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: ' ');				add: (self actualClass new add: self otherClass new yourself);				yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseFormatTest methodsFor: 'tests-parsing'!testParseWithNewLine	| wiki tree |	wiki := '1' , markup , '2' , self lineEnding , '3' , markup , '4'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: '1');				         add:					         (self actualClass with:							          (PRText content: '2' , self lineEnding , '3'));				         add: (PRText content: '4');				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseFormatTest methodsFor: 'tests-parsing'!testParseWithSpace	| wiki tree |	wiki := '1' , markup , '2 3' , markup , '4'.	tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: '1');				add: (self actualClass with: (PRText content: '2 3'));				add: (PRText content: '4');				yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseListTest methodsFor: 'private'!actualClass	^ PRList! !!PRParseListTest methodsFor: 'private'!listItemClass	^ PRListItem! !!PRParseListTest methodsFor: 'private'!listItemWithText: aString	^ self listItemClass new		add: (PRText content: aString);		yourself! !!PRParseListTest methodsFor: 'tests-parsing'!testParseEmpty	| wiki tree |	wiki := self wikiString.	tree := PRDocument new		add: (self actualClass new			add: self listItemClass new;			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseListTest methodsFor: 'tests-parsing'!testParseFlat	| wiki tree nLine |	nLine := self lineEnding.	wiki := self wikiString , '1st' , nLine , self wikiString , '2nd'	        , nLine , self wikiString , '3rd'.	tree := PRDocument new		        add: (self actualClass new				         add: (self listItemWithText: '1st');				         add: (self listItemWithText: '2nd');				         add: (self listItemWithText: '3rd');				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseListTest methodsFor: 'tests-parsing'!testParseMultiple	| wiki tree nLine |	nLine := self lineEnding.	wiki := self wikiString , '1st' , nLine , self wikiString , '2nd'	        , nLine , nLine , self wikiString , '3rd'.	tree := PRDocument new		        add: (self actualClass new				         add: (self listItemWithText: '1st');				         add: (self listItemWithText: '2nd');				         yourself);		        add: PREmptyParagraph new;		        add: (self actualClass new				         add: (self listItemWithText: '3rd');				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseListTest methodsFor: 'tests-parsing'!testParseWithTrailingSpaces	| wiki tree |	wiki := self wikiString , ' 1st'.	tree := PRDocument new		add:			(self actualClass new				add: (self listItemWithText: '1st');				yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseListTest methodsFor: 'private'!wikiString	self subclassResponsibility! !!PRParseOrderedListTest class methodsFor: 'testing'!isAbstract	^ false! !!PRParseOrderedListTest methodsFor: 'private'!actualClass	^ PROrderedList! !!PRParseOrderedListTest methodsFor: 'tests-parsing'!testParseMixed	| wiki tree nLine |	nLine := self lineEnding.	wiki := '#1' , nLine , '#2' , nLine , '-3'.	tree := PRDocument new		        add: (PROrderedList new				         add: (self listItemWithText: '1');				         add: (self listItemWithText: '2');				         yourself);		        add: (PRUnorderedList new				         add: (self listItemWithText: '3');				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseOrderedListTest methodsFor: 'tests-parsing'!testParseNested	| wiki tree nLine |	nLine := self lineEnding.	wiki := self wikiString , '1' , nLine , self wikiString	        , self wikiString , '1.1' , nLine , self wikiString	        , self wikiString , '1.2'.	tree := PRDocument new		        add: (self actualClass new				         add: (PRListItem new						          add: (PRText content: '1');						          add: (self actualClass new								           add: (self listItemWithText: '1.1');								           add: (self listItemWithText: '1.2');								           yourself);						          yourself);				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseOrderedListTest methodsFor: 'private'!wikiString	^ '#'! !!PRParseUnorderedListTest class methodsFor: 'testing'!isAbstract	^ false! !!PRParseUnorderedListTest methodsFor: 'private'!actualClass	^ PRUnorderedList! !!PRParseUnorderedListTest methodsFor: 'tests-parsing'!testParseMixed	| wiki tree nLine |	nLine := self lineEnding.	wiki := '#1' , nLine , '##2' , nLine , '###3' , nLine , '#-4' , nLine	        , '#-5' , nLine , '##6' , nLine , '#7'.	tree := PRDocument new		        add: (PROrderedList new				         add: (PRListItem new						          add: (PRText content: '1');						          add: (PROrderedList new								           add: (PRListItem new										            add: (PRText content: '2');										            add: (PROrderedList new												             add: (self listItemWithText: '3');												             yourself);										            yourself);								           yourself);						          add: (PRUnorderedList new								           add: (self listItemWithText: '4');								           add: (self listItemWithText: '5');								           yourself);						          add: (PROrderedList new								           add: (self listItemWithText: '6');								           yourself);						          yourself);				         add: (self listItemWithText: '7');				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseUnorderedListTest methodsFor: 'tests-parsing'!testParseNested	| wiki tree nLine |	nLine := self lineEnding.	wiki := self wikiString , '1' , nLine , self wikiString	        , self wikiString , '1.1' , nLine , self wikiString	        , self wikiString , self wikiString , '1.1.1'.	tree := PRDocument new		        add: (self actualClass new				         add: (PRListItem new						          add: (PRText content: '1');						          add: (self actualClass new								           add: (PRListItem new										            add: (PRText content: '1.1');										            add: (self actualClass new												             add: (self listItemWithText: '1.1.1');												             yourself);										            yourself);								           yourself);						          yourself);				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseUnorderedListTest methodsFor: 'private'!wikiString	^ '-'! !!PRParseEmptyParagraphTest methodsFor: 'private'!actualClass	^ PREmptyParagraph! !!PRParseEmptyParagraphTest methodsFor: 'tests'!testParseEmptyParagraphAtBeginning	| wiki tree content |	content := 'Lorem ipsum dolor sit amet.'.	wiki := self lineEnding , content.	tree := PRDocument new		        add: PREmptyParagraph new;		        add: (PRParagraph new				         add: (PRText content: content);				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseEmptyParagraphTest methodsFor: 'tests'!testParseEmptyParagraphInTheMiddle	| wiki tree content nLine |	nLine := self lineEnding.	content := 'Lorem ipsum dolor sit amet.'.	wiki := content , nLine , nLine , content.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: content);				         yourself);		        add: PREmptyParagraph new;		        add: (PRParagraph new				         add: (PRText content: content);				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseParagraphTest class methodsFor: 'testing'!isAbstract	^ false! !!PRParseParagraphTest methodsFor: 'private'!actualClass	^ PRParagraph! !!PRParseParagraphTest methodsFor: 'tests-parsing'!testParseEmptyLineAtBeginning	| wiki tree |	wiki := '' , self lineEnding , 'Lorem ipsum dolor sit amet.'.	tree := PRDocument new		        add: PREmptyParagraph new;		        add: (PRParagraph new				         add: (PRText content: 'Lorem ipsum dolor sit amet.');				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseParagraphTest methodsFor: 'tests-parsing'!testParseOneLine	| wiki tree |	wiki := 'Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Nulla quis urna.'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText content: wiki);			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseParagraphTest methodsFor: 'tests-parsing'!testParseThreeEmptyLines	| wiki tree nLine |	nLine := self lineEnding.	wiki := 'Lorem ipsum dolor sit amet.' , nLine , nLine , nLine	        , 'Nulla mattis elementum nulla.'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: 'Lorem ipsum dolor sit amet.');				         yourself);		        add: PREmptyParagraph new;		        add: PREmptyParagraph new;		        add: (PRParagraph new				         add: (PRText content: 'Nulla mattis elementum nulla.');				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseParagraphTest methodsFor: 'tests-parsing'!testParseTwoConsecutiveNonTextLines	| wiki tree sentence title nLine |	nLine := self lineEnding.	sentence := 'sentence'.	title := 'title'.	wiki := sentence , nLine , '!!' , title.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: sentence);				         yourself);		        add: (PRHeader new				         level: 1;				         add: (PRText content: title);				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseParagraphTest methodsFor: 'tests-parsing'!testParseTwoEmptyLines	| wiki tree nLine |	nLine := self lineEnding.	wiki := 'Lorem ipsum dolor sit amet.' , nLine , nLine	        , 'Nulla mattis elementum nulla.'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: 'Lorem ipsum dolor sit amet.');				         yourself);		        add: PREmptyParagraph new;		        add: (PRParagraph new				         add: (PRText content: 'Nulla mattis elementum nulla.');				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseDocumentItemTest methodsFor: 'private'!actualClass	^ PRDocumentItem! !!PRParseDocumentItemTest methodsFor: 'utilities'!addText: aString to: aDocumentItem	^ aDocumentItem		add: (PRText content: aString);		yourself! !!PRParseDocumentItemTest methodsFor: 'private'!barInstance	^ PRText content: 'bar'! !!PRParseDocumentItemTest methodsFor: 'private'!fooInstance	^ PRText content: 'foo'! !!PRParseDocumentItemTest methodsFor: 'private'!foobarInstances	^ Array with: self fooInstance with: self barInstance! !!PRParseDocumentItemTest methodsFor: 'helper'!parser	^ PRDocument parser! !!PRParseDocumentItemTest methodsFor: 'utilities'!parserAssertWiki: aString equalsTree: aDocument	"Assert that parsing aString results in aDocument."	self		assert: (self parser parse: aString) = aDocument		description: aString resumable: true! !"Pillar-Tests-PetitPillar"!!PRScriptTest commentStamp: '' prior: 0!A PRRawTest is xxxxxxxxx.!!PRTocTest commentStamp: '' prior: 0!Test hash properties!!PRMockAnnotation commentStamp: '' prior: 0!I am a Mock to test the annotations.!!PRAbstractScriptLanguageTest commentStamp: '' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State the name of the class with one line description: For example, I'm xxx the root of the hierarchy of visitor objects.For the Responsibility part: Three sentences about my main responsibility, what I'm doing, what services do I offer.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - what is the way to create instances is a plus.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!PRMockForParameters commentStamp: '' prior: 0!I'm a Mock needed in order to test PRTParametrizable!!PRCitationTest class methodsFor: 'as yet unclassified'!isAbstract	^false! !!PRCitationTest methodsFor: 'private'!actualClass	^ PRCitation ! !!PRCitationTest methodsFor: 'tests'!testHaveRef	|citation|	citation := self actualClass ref: 'foo'.	self assert: citation ref equals: 'foo'! !!PRHorizontalRuleTest class methodsFor: 'testing'!isAbstract	^ false! !!PRHorizontalRuleTest methodsFor: 'private'!actualClass	^ PRHorizontalRule! !!PRHorizontalRuleTest methodsFor: 'private'!textString	^ String new: 40 withAll: $-! !!PRLineBreakTest class methodsFor: 'testing'!isAbstract	^ false! !!PRLineBreakTest methodsFor: 'private'!actualClass	^ PRLineBreak! !!PRCommentedLineTest methodsFor: 'private'!actualClass	^ PRCommentedLine! !!PRRawTest methodsFor: 'private'!actualClass	^ PRRaw! !!PRRawTest methodsFor: 'tests-accessing'!testType	self instance type: 'html'.	self assert: self instance type equals: 'html'! !!PRScriptTest methodsFor: 'private'!actualClass	^ PRCodeblock! !!PRScriptTest methodsFor: 'tests'!testEqualScript	self assert: (self actualClass content: 'foo')  ~= (self actualClass content: 'bar').	self assert: (self actualClass content: 'foo') equals: (self actualClass content: 'foo')! !!PRScriptTest methodsFor: 'tests'!testEqualScriptWithLanguage	| param1 param2 |	param1 := SmallDictionary new		at: 'language' put: 'smalltalk';		yourself.	param2 := SmallDictionary new		at: 'language' put: 'html';		yourself.	self		assert: (self actualClass content: 'foo' parameters: param1) ~= (self actualClass content: 'foo' parameters: param2).	self		assert:			(self actualClass content: 'foo' parameters: param1)				equals: (self actualClass content: 'foo' parameters: param1)! !!PRScriptTest methodsFor: 'tests-comparing'!testHash	| a b |	a := self actualClass content: 'foo'.	b := self actualClass content: 'foo'.	self assert: a hash equals: a copy hash.	self assert: a hash equals: b hash! !!PRScriptTest methodsFor: 'tests'!testIsStructure	| ston nLine script |	self flag: #toRemove. "we do not support structure anymore dow e?"	nLine := self lineEnding.	ston := '[[[structure=Test' , nLine , 'Foo' , nLine , ']]]'.	script := (self parser parse: ston) children first.	self assert: script isStructure! !!PRScriptTest methodsFor: 'tests'!testStructureName	| ston nLine script |	self flag: #toRemove. "we do not support structure anymore dow e?"	nLine := self lineEnding.	ston := '[[[structure=Test' , nLine , 'Foo' , nLine , ']]]'.	script := (self parser parse: ston) children first.	self assert: script structureName equals: 'Test'! !!PRTextTest class methodsFor: 'testing'!isAbstract	^ false! !!PRTextTest methodsFor: 'private'!actualClass	^ PRText! !!PRTextTest methodsFor: 'tests-instantiation'!testContent	instance := self actualClass content: 'zork'.	self assert: self instance text equals: 'zork'! !!PRTextTest methodsFor: 'tests-comparing'!testEqualText	self deny: (self actualClass content: 'foo') equals: (self actualClass content: 'bar')! !!PRTextTest methodsFor: 'tests-printing'!testPrinting	| text |	text := PRText content: 'abcdef'.	'*abcdef*' match: text printString! !!PRTextTest methodsFor: 'tests-accessing'!testText	self instance text: 'zork'.	self assert: self instance text equals: 'zork'! !!PRTocTest class methodsFor: 'testing'!isAbstract	^ false! !!PRTocTest methodsFor: 'private'!actualClass	^ PRToc! !!PRTocTest methodsFor: 'tests'!testDifferentTocsHaveDifferentHashValue	| toc1 toc2 |	toc1 := PRToc new		name: 'test5';		level: 1;		addChildren:			(PRToc new				name: 'test2';				level: 2).	toc2 := PRToc new		name: 'test1';		level: 1;		addChildren:			(PRToc new				name: 'test2';				level: 2).	self deny: toc1 equals: toc2.	self deny: toc1 hash equals: toc2 hash! !!PRTocTest methodsFor: 'tests'!testSameTocsHaveSameHashValue	| toc1 toc2 |	toc1 := PRToc new		name: 'test1';		level: 1;		addChildren:			(PRToc new				name: 'test2';				level: 2).	toc2 := PRToc new		name: 'test1';		level: 1;		addChildren:			(PRToc new				name: 'test2';				level: 2).	self assert: toc1 equals: toc2.	self assert: toc1 hash equals: toc2 hash! !!PRCitationAnnotationTest methodsFor: 'helpers'!actualClass	^PRCitationAnnotation! !!PRCitationAnnotationTest methodsFor: 'helpers'!referenceParameters	^ PRParameters withAll: { 		PRParameter 			keyNode: (PRParameterKey named: 'ref')			valueNode: (PRParameterValue value: 'hello') }! !!PRCitationAnnotationTest methodsFor: 'helpers'!referenceString	^ 'cite:ref=hello'! !!PRColumnAnnotationTest methodsFor: 'helpers'!actualClass	^ PRColumnAnnotation! !!PRColumnAnnotationTest methodsFor: 'helpers'!referenceParameters	^ PRParameters withAll: { 		PRParameter 			keyNode: (PRParameterKey named: 'width')			valueNode: (PRParameterValue value: 50) }! !!PRColumnAnnotationTest methodsFor: 'helpers'!referenceString	^ 'column:width=50'! !!PRColumnsAnnotationTest methodsFor: 'helpers'!actualClass	^ PRBeginColumnsAnnotation! !!PRColumnsAnnotationTest methodsFor: 'helpers'!referenceParameters	^ PRParameters new! !!PRColumnsAnnotationTest methodsFor: 'helpers'!referenceString	^ 'columns'! !!PRDocumentListAnnotationTest methodsFor: 'helpers'!actualClass	^ PRDocumentListAnnotation! !!PRDocumentListAnnotationTest methodsFor: 'helpers'!referenceParameters	^ PRParameters withAll: { 		PRParameter 			keyNode: (PRParameterKey named: 'path')			valueNode: (PRParameterValue value: 'blogs').		PRParameter 			keyNode: (PRParameterKey named: 'limit')			valueNode: (PRParameterValue value: 10).		PRParameter 			keyNode: (PRParameterKey named: 'sort')			valueNode: (PRParameterValue value: 'date').		PRParameter 			keyNode: (PRParameterKey named: 'templates')			valueNode: (PRParameterValue value: #('templates/docArticle.mustache')).		PRParameter			keyNode: (PRParameterKey named: 'summaryMaxSize')			valueNode: (PRParameterValue value: 500) }! !!PRDocumentListAnnotationTest methodsFor: 'helpers'!referenceString	^ 'docList:path=blogs|limit=10|sort=date|templates=#(''templates/docArticle.mustache'')|summaryMaxSize=500'! !!PREndColumnsAnnotationTest methodsFor: 'helpers'!actualClass	^ PREndColumnsAnnotation! !!PREndColumnsAnnotationTest methodsFor: 'helpers'!referenceParameters	^ PRParameters new! !!PREndColumnsAnnotationTest methodsFor: 'helpers'!referenceString	^ 'endColumns'! !!PRIndexAnnotationTest class methodsFor: 'testing'!isAbstract	^ true "TODO The class is not finish. When the class will be finish put a false."! !!PRIndexAnnotationTest methodsFor: 'helpers'!actualClass	^ PRIndexAnnotation! !!PRInputFileAnnotationTest methodsFor: 'helpers'!actualClass	^ PRInputFileAnnotation! !!PRInputFileAnnotationTest methodsFor: 'helpers'!referenceParameters	^ PRParameters withAll: { 		PRParameter 			keyNode: (PRParameterKey named: 'path')			valueNode: (PRParameterValue value: 'foo/myFile.pillar') }! !!PRInputFileAnnotationTest methodsFor: 'helpers'!referenceString	^ 'inputFile:path=foo/myFile.pillar'! !!PRMockAnnotationTest methodsFor: 'helpers'!actualClass	^ PRMockAnnotation! !!PRMockAnnotationTest methodsFor: 'helpers'!referenceParameters	^ PRParameters withAll: { 		PRParameter 			keyNode: (PRParameterKey named: 'value')			valueNode: (PRParameterValue value: 'Foo').		PRParameter 			keyNode: (PRParameterKey named: 'number')			valueNode: (PRParameterValue value: 5) }! !!PRMockAnnotationTest methodsFor: 'helpers'!referenceString	^ 'mock:value=Foo|number=5'! !!PRSlideTitleAnnotationTest methodsFor: 'helpers'!actualClass	^ PRSlideTitleAnnotation! !!PRSlideTitleAnnotationTest methodsFor: 'helpers'!referenceParameters	^ PRParameters withAll: { 		PRParameter 			keyNode: (PRParameterKey named: 'title')			valueNode: (PRParameterValue value: 'Foo').		PRParameter 			keyNode: (PRParameterKey named: 'label')			valueNode: (PRParameterValue value: 'Tintin') }! !!PRSlideTitleAnnotationTest methodsFor: 'helpers'!referenceString	^ 'slide:title=Foo|label=Tintin'! !!PRTocAnnotationTest methodsFor: 'helpers'!actualClass	^ PRTocAnnotation! !!PRTocAnnotationTest methodsFor: 'helpers'!referenceParameters	^ PRParameters withAll: { 		PRParameter 			keyNode: (PRParameterKey named: 'depthLevel')			valueNode: (PRParameterValue value: 2).		PRParameter 			keyNode: (PRParameterKey named: 'level')			valueNode: (PRParameterValue value: 3) }! !!PRTocAnnotationTest methodsFor: 'helpers'!referenceString	^ 'toc:depthLevel=2|level=3'! !!PRDefinitionDataTest class methodsFor: 'testing'!isAbstract	^ false! !!PRDefinitionDataTest methodsFor: 'private'!actualClass	^ PRDefinitionList! !!PRDefinitionDataTest methodsFor: 'private'!listItemClass	^ PRDataItem! !!PRDefinitionDataTest methodsFor: 'private'!textString: anObject level: anInteger	^ (super textString: anObject level: anInteger) , '  '! !!PRDefinitionDataTest methodsFor: 'private'!wikiString	^ ':'! !!PRDefinitionTermTest class methodsFor: 'testing'!isAbstract	^ false! !!PRDefinitionTermTest methodsFor: 'private'!actualClass	^ PRDefinitionList! !!PRDefinitionTermTest methodsFor: 'private'!listItemClass	^ PRTermItem! !!PRDefinitionTermTest methodsFor: 'private'!textString: anObject level: anInteger	^ (super textString: anObject level: anInteger) , '- '! !!PRDefinitionTermTest methodsFor: 'private'!wikiString	^ ';'! !!PRFileDependenciesTest methodsFor: 'private'!actualClass	^ PRFileDependencies ! !!PRFileDependenciesTest methodsFor: 'tests'!testDocumentWithFigure	| item set |	item := PRDocument new		add:			(PRFigure new				reference: 'file://foo.png';				yourself);		yourself.	set := Set new.	self		assert: (self actualInstance start: item)		equals: set! !!PRFileDependenciesTest methodsFor: 'tests'!testDocumentWithFile	| item set |	item := PRDocument new		add:			(PRInternalLink new				reference: 'file://foo.pillar';				yourself);		yourself.	set := Set with: 'foo.pillar'.	self		assert: (self actualInstance start: item)		equals: set! !!PRImageDependenciesTest methodsFor: 'private'!actualClass	^ PRImageDependencies ! !!PRImageDependenciesTest methodsFor: 'tests'!testDocumentWithFigure	| item set |	item := PRDocument new		add:			(PRFigure new				reference: 'file://picture.png';				parameterAt: 'label' put: 'foo';				yourself);		yourself.	set := Set with: 'picture.png'.	self		assert: (self actualInstance start: item)		equals: set! !!PRVisitorTest class methodsFor: 'testing'!isAbstract	"Override to true if a TestCase subclass is Abstract and should not have	TestCase instances built from it"	^self = PRVisitorTest! !!PRVisitorTest methodsFor: 'private'!actualClass	^ PRVisitor! !!PRVisitorTest methodsFor: 'helpers'!addText: aString to: aDocumentItem	^ aDocumentItem		add: (PRText content: aString);		yourself! !!PRScriptLanguageTest methodsFor: 'tests'!testEquals	self assert: (PRAbstractScriptLanguage for: 'smalltalk') equals: (PRAbstractScriptLanguage for: 'smalltalk')! !!PRScriptLanguageTest methodsFor: 'tests'!testFinding	self assert: (PRAbstractScriptLanguage concreteClassFor: '') equals: PRNoScriptLanguage.	self assert: (PRAbstractScriptLanguage concreteClassFor: '') default isSpecified.	self assert: (PRAbstractScriptLanguage concreteClassFor: 'no language') equals: PRNoScriptLanguage.	self assert: (PRAbstractScriptLanguage concreteClassFor: 'no language') default isSpecified.	self assert: (PRAbstractScriptLanguage concreteClassFor: nil) equals: PRUnspecifiedScriptLanguage.	self deny: (PRAbstractScriptLanguage concreteClassFor: nil) default isSpecified.	self assert: (PRAbstractScriptLanguage concreteClassFor: 'smalltalk') equals: PRSmalltalkScriptLanguage.	self assert: (PRAbstractScriptLanguage concreteClassFor: 'smalltalk') default isSpecified.	self assert: (PRAbstractScriptLanguage concreteClassFor: 'html') equals: PRHTMLScriptLanguage.	self assert: (PRAbstractScriptLanguage concreteClassFor: 'html') default isSpecified.	self assert: (PRAbstractScriptLanguage concreteClassFor: 'HTML') equals: PRHTMLScriptLanguage.	self assert: (PRAbstractScriptLanguage concreteClassFor: 'HTML') default isSpecified.	self assert: (PRAbstractScriptLanguage concreteClassFor: 'non existing language foobar') equals: PRUnsupportedScriptLanguage.	self deny: (PRAbstractScriptLanguage concreteClassFor: 'non existing language foobar') new isSpecified! !!PRMockAnnotation class methodsFor: 'instance creation'!possibleParameters	^ #(value number)! !!PRMockAnnotation class methodsFor: 'protected'!tag	^ #mock! !!PRMockAnnotation class methodsFor: 'instance creation'!validateParameters: parameters	super validateParameters: parameters.	parameters		at: 'number'		ifPresent: [ :v | parameters at: 'number' put: v asNumber ]	! !!PRMockAnnotation class methodsFor: 'instance creation'!validateParameters: aPRParameters dictionary: parametersDictionary in: anAnnotation	super		validateParameters: aPRParameters		dictionary: parametersDictionary		in: anAnnotation.	parametersDictionary		at: 'number'		ifPresent: [ :v | parametersDictionary at: 'number' put: v asNumber ]! !!PRMockAnnotation methodsFor: 'printing'!asPillarParametersOn: aStream	self parameters keys		do: [ :each | self asPillarKey: each value:  (self parameters at: each asString) asString on: aStream ]		separatedBy: [ aStream nextPut: self class parameterSeparator ]! !!PRColumnTest class methodsFor: 'testing'!isAbstract	^ false! !!PRColumnTest methodsFor: 'private'!actualClass	^ PRColumn! !!PRColumnsTest class methodsFor: 'testing'!isAbstract	^ false! !!PRColumnsTest methodsFor: 'private'!actualClass	^ PRColumnEnvironment! !!PRHeaderTest class methodsFor: 'testing'!isAbstract	^ false! !!PRHeaderTest methodsFor: 'private'!actualClass	^ PRHeader! !!PRHeaderTest methodsFor: 'tests-comparing'!testEqualLevel	self deny: (self actualClass new level: 1) equals: (self actualClass new level: 2)! !!PRHeaderTest methodsFor: 'tests'!testIsHeader	self assert: self actualInstance isHeader! !!PRHeaderTest methodsFor: 'tests-accessing'!testName	self instance level: 3.	self assert: self instance level equals: 3! !!PRHeaderTest methodsFor: 'tests-instantiation'!testWithAllLevel	instance := self actualClass withAll: self foobarInstances level: 3.	self assert: self instance children size equals: 2.	self assert: self instance children first equals: self fooInstance.	self assert: self instance children second equals: self barInstance.	self assert: self instance level equals: 3! !!PRListItemTest class methodsFor: 'testing'!isAbstract	^ false! !!PRListItemTest methodsFor: 'private'!actualClass	^ PRListItem! !!PRPreformattedTest class methodsFor: 'testing'!isAbstract	^ false! !!PRPreformattedTest methodsFor: 'private'!actualClass	^ PRPreformatted! !!PRPreformattedTest methodsFor: 'tests-parsing'!testText	self instance addAll: self foobarInstances.	self assert: self instance text equals: 'foobar'"This test is redefined because for formatted!!!!!!!! = Pre merging lines to not make sense!!It got unnoticed because we do not use preformatted."! !!PRFigureTest class methodsFor: 'testing'!isAbstract	^ false! !!PRFigureTest methodsFor: 'private'!actualClass	^ PRFigure! !!PRFigureTest methodsFor: 'private'!referenceString	^ 'file://test.png'! !!PRFigureTest methodsFor: 'tests'!testHasCaption	self deny: PRFigure new hasCaption.	self assert: (self addText: 'foo' to: PRFigure new) hasCaption! !!PRExternalLinkTest class methodsFor: 'testing'!isAbstract	^ false! !!PRExternalLinkTest methodsFor: 'private'!actualClass	^ PRExternalLink! !!PRExternalLinkTest methodsFor: 'private'!referenceString	^ 'http://www.lukas-renggli.ch'! !!PRExternalLinkTest methodsFor: 'tests'!testIsExternal	self assert: self instance isExternal! !!PRExternalLinkTest methodsFor: 'tests-accessing'!testTitle	self instance reference: 'http://www.lukas-renggli.ch'.	self assert: self instance title equals: 'http://www.lukas-renggli.ch'! !!PRExternalLinkTest methodsFor: 'tests-accessing'!testUrl	self instance reference: 'http://www.lukas-renggli.ch'.	self assert: self instance url equals: 'http://www.lukas-renggli.ch'! !!PRMailLinkTest methodsFor: 'private'!actualClass	^ PRMailLink! !!PRMailLinkTest methodsFor: 'private'!referenceString	^ 'renggli@gmail.com'! !!PRMailLinkTest methodsFor: 'tests-accessing'!testTitle	super testTitle.	self instance reference: self referenceString.	self assert: self instance title equals: self referenceString! !!PRMailLinkTest methodsFor: 'tests-accessing'!testUrl	self instance reference: self referenceString.	self assert: (self instance url beginsWith: 'mailto:').	self assert: self instance url ~= ('mailto:' , self referenceString).	self assert: self instance scrambledUrl ~= ('mailto:' , self referenceString).	self assert: self instance unscrambledUrl equals: 'mailto:' , self referenceString! !!PRInternalLinkTest class methodsFor: 'testing'!isAbstract	^ false! !!PRInternalLinkTest methodsFor: 'private'!actualClass	^ PRInternalLink! !!PRInternalLinkTest methodsFor: 'private'!referenceString	^ 'Page'! !!PRInternalLinkTest methodsFor: 'tests-accessing'!testAnchor	self instance anchor: 'zork'.	self assert: self instance anchor equals: 'zork'.	self assert: self instance hasAnchor! !!PRInternalLinkTest methodsFor: 'tests-comparing'!testEqualAnchor	self		deny:			(self actualClass new				anchor: 'foo';				yourself)		equals:			(self actualClass new				anchor: 'bar';				yourself)! !!PRInternalLinkTest methodsFor: 'tests'!testIsInternal	self assert: self instance isInternal! !!PRInternalLinkTest methodsFor: 'tests-accessing'!testTitle	super testTitle.	self instance reference: 'page'.	self assert: self instance title equals: 'page'! !!PRLinkTest methodsFor: 'private'!actualClass	^ PRLink! !!PRLinkTest methodsFor: 'tests'!testIsBroken	self assert: (self instance isBroken or: [ self instance isBroken not ])! !!PRLinkTest methodsFor: 'tests'!testIsExternal	self deny: self instance isExternal! !!PRLinkTest methodsFor: 'tests'!testIsInternal	self deny: self instance isInternal! !!PRLinkTest methodsFor: 'tests'!testIsLink	self assert: self instance isLink! !!PRReferenceTest methodsFor: 'private'!actualClass	^ PRReference! !!PRReferenceTest methodsFor: 'private'!markup	^ self subclassResponsibility! !!PRReferenceTest methodsFor: 'private'!referenceString	self subclassResponsibility! !!PRReferenceTest methodsFor: 'tests'!testAlias	self deny: self instance hasAlias.	self instance add: self fooInstance.	self assert: self instance hasAlias.	self assert: self instance alias equals: 'foo'.	self instance add: self barInstance.	self assert: self instance hasAlias.	self assert: self instance alias equals: 'foobar'! !!PRReferenceTest methodsFor: 'tests-accessing'!testAnchor	self deny: self instance hasAnchor! !!PRReferenceTest methodsFor: 'tests-comparing'!testEqualReference	self		deny:			(self actualClass new				reference: 'foo';				yourself)		equals:			(self actualClass new				reference: 'bar';				yourself)! !!PRReferenceTest methodsFor: 'tests-parameters'!testHasParameter	self instance parameters: (Dictionary with: 'foo' -> 'zork' with: 'bar' -> nil).	self assert: (self instance hasParameter: 'foo').	self assert: (self instance hasParameter: 'bar').	self deny: (self instance hasParameter: 'zork')! !!PRReferenceTest methodsFor: 'tests-parameters'!testParameterAt	self instance parameters: (Dictionary with: 'foo' -> 'bar').	self assert: (self instance parameters at: 'foo' ifAbsent: [ nil ]) equals: 'bar'.	self assert: (self instance parameters at: 'bar' ifAbsent: [ nil ]) isNil! !!PRReferenceTest methodsFor: 'tests-parameters'!testParameterAtIfAbsent	self instance parameters: (Dictionary with: 'foo' -> 'bar').	self assert: (self instance parameters at: 'foo' ifAbsent: [ 'zork' ]) equals: 'bar'.	self assert: (self instance parameters at: 'bar' ifAbsent: [ 'zork' ]) equals: 'zork'! !!PRReferenceTest methodsFor: 'tests-parameters'!testParameterAtIfPresent	self instance parameters: (Dictionary with: 'foo' -> 'bar').	self assert: (self instance parameters at: 'foo' ifPresent: [ :value | '!!' , value ]) equals: '!!bar'.	self assert: (self instance parameters at: 'bar' ifPresent: [ :value | '!!' , value ]) isNil! !!PRReferenceTest methodsFor: 'tests-parameters'!testParameterAtPut	self assert: (self instance parameters at: 'foo' put: 'bar') equals: 'bar'.	self assert: self instance parameters size equals: 1.	self assert: self instance parameters keys first equals: 'foo'.	self assert: self instance parameters values first equals: 'bar'.	self assert: (self instance parameters at: 'foo' put: 'zork') equals: 'zork'.	self assert: self instance parameters size equals: 1.	self assert: self instance parameters keys first equals: 'foo'.	self assert: self instance parameters values first equals: 'zork'! !!PRReferenceTest methodsFor: 'tests-parameters'!testParameterCopy	| copy |	self instance parameters at: 'class' put: 'active'.	copy := self instance copy.	copy parameters at: 'class' put: 'inactive'.	copy parameters at: 'foo' put: 'bar'.	self assert: (self instance parameters at: 'class') equals: 'active'.	self deny: (self instance hasParameter: 'foo').	self assert: (copy parameters at: 'class') equals: 'inactive'.	self assert: (copy parameters at: 'foo') equals: 'bar'! !!PRReferenceTest methodsFor: 'tests-parameters'!testParameters	self assertEmpty: self instance parameters.	self instance parameters: (Array with: 'foo' -> 'bar').	self assert: self instance parameters size equals: 1! !!PRReferenceTest methodsFor: 'tests-accessing'!testReference	self instance reference: 'zork'.	self assert: self instance reference equals: 'zork'! !!PRReferenceTest methodsFor: 'tests-accessing'!testTitle	self deny: self instance title isNotNil! !!PRSlideTest class methodsFor: 'testing'!isAbstract	^ false! !!PRSlideTest methodsFor: 'private'!actualClass	^ PRSlide! !!PRSlideTest methodsFor: 'tests'!testHaveTitle	| slide |	slide := self actualClass titled: 'Foo'.	self assert: slide title equals: 'Foo'! !!PRTableCellTest class methodsFor: 'testing'!isAbstract	^ false! !!PRTableCellTest methodsFor: 'private'!actualClass	^ PRTableCell! !!PRTableCellTest methodsFor: 'tests-accessing'!testAlign	self instance align: #right.	self assert: self instance align equals: #right! !!PRTableCellTest methodsFor: 'tests-accessing'!testBeAlignedCenter	self instance beAlignedCenter.	self assert: self instance align equals: #center.	self assert: self instance isAlignedCenter.	self deny: self instance isAlignedLeft.	self deny: self instance isAlignedRight! !!PRTableCellTest methodsFor: 'tests-accessing'!testBeAlignedLeft	self instance beAlignedLeft.	self assert: self instance align equals: #left.	self deny: self instance isAlignedCenter.	self assert: self instance isAlignedLeft.	self deny: self instance isAlignedRight! !!PRTableCellTest methodsFor: 'tests-accessing'!testBeAlignedRight	self instance beAlignedRight.	self assert: self instance align equals: #right.	self deny: self instance isAlignedCenter.	self deny: self instance isAlignedLeft.	self assert: self instance isAlignedRight! !!PRTableCellTest methodsFor: 'tests-comparing'!testEqualAlign	self deny: self actualClass new beAlignedRight equals: self actualClass new beAlignedCenter.	self deny: self actualClass new beAlignedCenter equals: self actualClass new beAlignedLeft! !!PRTableCellTest methodsFor: 'tests-accessing'!testHeading	self deny: self instance heading.	self deny: self instance isHeading.		self instance heading: true.	self assert: self instance heading.	self assert: self instance isHeading.		self instance heading: false.	self deny: self instance heading.	self deny: self instance isHeading! !!PRTableRowTest class methodsFor: 'testing'!isAbstract	^ false! !!PRTableRowTest methodsFor: 'private'!actualClass	^ PRTableRow! !!PRTableRowTest methodsFor: 'tests-accessing'!testCount	self instance add: PRTableCell new.	self assert: self instance columnCount equals: 1.	self instance add: PRTableCell new.	self assert: self instance columnCount equals: 2! !!PRTableRowTest methodsFor: 'tests-accessing'!testRowWithHeadingCellIsHeading	self instance		add:			(self				addText: 'foo'				to:					(PRTableCell new						beHeading;						yourself)).	self assert: self instance isHeading! !!PRTableRowTest methodsFor: 'tests-accessing'!testRowWithHeadingCellsAndOneEmptyCellIsHeading	self instance		add:				(self						addText: 'foo'						to:							(PRTableCell new								beHeading;								yourself));		add: PRTableCell new.	self assert: self instance isHeading! !!PRTableRowTest methodsFor: 'tests-accessing'!testRowWithOnlyEmptyCellIsNotHeading	self instance		add: PRTableCell new;		add: PRTableCell new.	self deny: self instance isHeading! !!PRTableTest class methodsFor: 'testing'!isAbstract	^ false! !!PRTableTest methodsFor: 'private'!actualClass	^ PRTable! !!PRTableTest methodsFor: 'tests-accessing'!testCount	self instance		add:			(PRTableRow new				add: PRTableCell new;				yourself).	self		assert: self instance rowCount equals: 1;		assert: self instance columnCount equals: 1.	self instance		add:			(PRTableRow new				add: PRTableCell new;				add: PRTableCell new;				yourself).	self		assert: self instance rowCount equals: 2;		assert: self instance columnCount equals: 2.	self instance		add:			(PRTableRow new				add: PRTableCell new;				yourself).	self		assert: self instance rowCount equals: 3;		assert: self instance columnCount equals: 2! !!PRAbstractScriptLanguageTest methodsFor: 'private'!actualClass	^ PRAbstractScriptLanguage! !!PRAbstractScriptLanguageTest methodsFor: 'tests'!testEqual	self assert: self instance equals: self instance.	self assert: self instance equals: self actualInstance! !!PRAbstractScriptLanguageTest methodsFor: 'tests'!testHash	self assert: self instance hash equals: self instance copy hash! !!PRBashScriptLanguageTest class methodsFor: 'testing'!isAbstract	^ false! !!PRBashScriptLanguageTest methodsFor: 'private'!actualClass	^ PRBashScriptLanguage ! !!PRCSSScriptLanguageTest class methodsFor: 'testing'!isAbstract	^ false! !!PRCSSScriptLanguageTest methodsFor: 'private'!actualClass	^ PRCSSScriptLanguage! !!PRHTMLScriptLanguageTest class methodsFor: 'testing'!isAbstract	^ false! !!PRHTMLScriptLanguageTest methodsFor: 'private'!actualClass	^ PRHTMLScriptLanguage ! !!PRHTTPScriptLanguageTest class methodsFor: 'testing'!isAbstract	^ false! !!PRHTTPScriptLanguageTest methodsFor: 'private'!actualClass	^ PRHTTPScriptLanguage ! !!PRJSONScriptLanguageTest class methodsFor: 'testing'!isAbstract	^ false! !!PRJSONScriptLanguageTest methodsFor: 'private'!actualClass	^ PRJSONScriptLanguage ! !!PRJavaScriptScriptLanguageTest class methodsFor: 'testing'!isAbstract	^ false! !!PRJavaScriptScriptLanguageTest methodsFor: 'private'!actualClass	^ PRJavaScriptScriptLanguage ! !!PRNoScriptLanguageTest class methodsFor: 'testing'!isAbstract	^ false! !!PRNoScriptLanguageTest methodsFor: 'private'!actualClass	^ PRNoScriptLanguage! !!PRSQLScriptLanguageTest class methodsFor: 'testing'!isAbstract	^ false! !!PRSQLScriptLanguageTest methodsFor: 'private'!actualClass	^ PRSQLScriptLanguage ! !!PRSTONScriptLanguageTest class methodsFor: 'testing'!isAbstract	^ false! !!PRSTONScriptLanguageTest methodsFor: 'private'!actualClass	^ PRSTONScriptLanguage ! !!PRShellCommandsScriptLanguageTest class methodsFor: 'testing'!isAbstract	^ false! !!PRShellCommandsScriptLanguageTest methodsFor: 'private'!actualClass	^ PRShellCommandsScriptLanguage ! !!PRSmalltalkScriptLanguageTest class methodsFor: 'testing'!isAbstract	^ false! !!PRSmalltalkScriptLanguageTest methodsFor: 'private'!actualClass	^PRSmalltalkScriptLanguage ! !!PRUnspecifiedScriptLanguageTest class methodsFor: 'testing'!isAbstract	^ false! !!PRUnspecifiedScriptLanguageTest methodsFor: 'private'!actualClass	^ PRUnspecifiedScriptLanguage! !!PRUnsupportedScriptLanguageTest class methodsFor: 'testing'!isAbstract	^ false! !!PRUnsupportedScriptLanguageTest methodsFor: 'private'!actualClass	^ PRUnsupportedScriptLanguage ! !!PRMockForParameters methodsFor: 'accessing-parameters' prior: 35492629!parameters	^ parameters! !!PRMockForParameters methodsFor: 'accessing'!parameters: aCollection	parameters := aCollection! !"Pillar-Tests-Model"!!PRParserMockAnnotationTest methodsFor: 'helpers'!actualClass	^ PRMockAnnotation! !!PRParserMockAnnotationTest methodsFor: 'helpers'!referenceParameters	^ PRParameters withAll: { 		PRParameter 			keyNode: (PRParameterKey named: 'value')			valueNode: (PRParameterValue value: 'Foo').		PRParameter 			keyNode: (PRParameterKey named: 'number')			valueNode: (PRParameterValue value: 5) }! !!PRParserMockAnnotationTest methodsFor: 'helpers'!referenceString	^ 'mock:value=Foo|number=5'! !!PRParserMockAnnotationTest methodsFor: 'tests'!testParseUndclaredParametersShouldRaiseAnError	| input |	input := '${mock:Foo|option=bar}$'.	self should: [ self parser parse: input ] raise: PRError.	input := '${mock:Foo|option=bar|toto=4}$'.	self should: [ self parser parse: input ] raise: PRError.	input := '${mock|option=bar}$'.	self should: [ self parser parse: input ] raise: PRError! !!PRParserMockAnnotationTest methodsFor: 'tests'!testParseWithBadInterpretation	| input |	input := '${mock:Foo|number=cinq}$'.	self should: [ self parser parse: input ] raise: Error! !!PRParserMockAnnotationTest methodsFor: 'tests'!testParseWithInterpretation	| input expected |	input := '${mock:value=Foo|number=5}$'.	expected := PRMockAnnotation withParameters: (		PRParameters withAll: { 			PRParameter 				keyNode: (PRParameterKey named: 'value')				valueNode: (PRParameterValue value: 'Foo').			PRParameter 				keyNode: (PRParameterKey named: 'number')				valueNode: (PRParameterValue value: 5) }).	self		assert:			(self parser parse: input startingAt: #annotation)		equals: expected! !!PRParserMockAnnotationTest methodsFor: 'tests'!testParseWithoutARequiredParameter	| input |	input := '${mock}$'.	self should: [ self parser parse: input ] raise: PRError! !!PRParserMockAnnotationTest methodsFor: 'tests'!testParseWithoutFirstKey	"an annotation can have a default parameter name that the user does not have to be forced to specify.	 ${mock:Foo|number=5}$ means  ${mock:value=Foo|number=5}$ since mock defines defaultParameterName as 'value'.	"	| input expected |	input := '${mock:value=Foo}$'.	expected := PRMockAnnotation withParameters: (		PRParameters withAll: { 			PRParameter 				keyNode: (PRParameterKey named: 'value')				valueNode: (PRParameterValue value: 'Foo') }).	expected hadAllKeys: false.	self assert: (self parser parse: input startingAt: #annotation) equals: expected! !!PRParseDocumentListAnnotationTest methodsFor: 'helpers'!actualClass	^ PRDocumentListAnnotation! !!PRParseDocumentListAnnotationTest methodsFor: 'helpers'!referenceParameters	^ PRParameters withAll: { 		PRParameter 			keyNode: (PRParameterKey named: 'path')			valueNode: (PRParameterValue value: 'blogs').		PRParameter 			keyNode: (PRParameterKey named: 'limit')			valueNode: (PRParameterValue value: 10).		PRParameter 			keyNode: (PRParameterKey named: 'sort')			valueNode: (PRParameterValue value: 'date').		PRParameter 			keyNode: (PRParameterKey named: 'templates')			valueNode: (PRParameterValue value: #('templates/docArticle.mustache')).		PRParameter			keyNode: (PRParameterKey named: 'summaryMaxSize')			valueNode: (PRParameterValue value: 500) }! !!PRParseDocumentListAnnotationTest methodsFor: 'helpers'!referenceString	^ 'docList:path=blogs|limit=10|sort=date|templates=#(''templates/docArticle.mustache'')|summaryMaxSize=500'! !!PRParseDocumentListAnnotationTest methodsFor: 'helpers'!testParsedHadAllKeys	| annotation |	annotation :=  (self parser parse:  '${' , self referenceString , '}$') children first children first.	self assert: annotation path equals: 'blogs'.	self assert: annotation limit equals: 10.	self assert: annotation sort equals: 'date'.	self assert: annotation templates equals: #('templates/docArticle.mustache').! !!PRParseHeaderTest class methodsFor: 'testing'!isAbstract	^ false! !!PRParseHeaderTest methodsFor: 'private'!actualClass	^ PRHeader! !!PRParseHeaderTest methodsFor: 'tests-parsing'!testParseEmpty	| wiki tree |	wiki := '!!'.	tree := PRDocument new		add: (PRHeader new			level: 1;			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseHeaderTest methodsFor: 'tests-parsing'!testParseLevel1	| wiki tree |	wiki := '!!foo'.	tree := PRDocument new		add: (PRHeader new			level: 1;			add: (PRText content: 'foo');			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseHeaderTest methodsFor: 'tests-parsing'!testParseLevel2	| wiki tree |	wiki := '!!!!foo'.	tree := PRDocument new		add: (PRHeader new			level: 2;			add: (PRText content: 'foo');			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseHeaderTest methodsFor: 'tests-parsing'!testParseLevel3	| wiki tree |	wiki := '!!!!!!foo'.	tree := PRDocument new		add: (PRHeader new			level: 3;			add: (PRText content: 'foo');			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseHeaderTest methodsFor: 'tests-parsing'!testParseLevel4	| wiki tree |	wiki := '!!!!!!!!foo'.	tree := PRDocument new		add: (PRHeader new			level: 4;			add: (PRText content: 'foo');			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseHeaderTest methodsFor: 'tests-parsing'!testParseLevel5	| wiki tree |	wiki := '!!!!!!!!!!foo'.	tree := PRDocument new		add: (PRHeader new			level: 5;			add: (PRText content: 'foo');			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseHeaderTest methodsFor: 'tests-parsing'!testParseLevel6	| wiki tree |	wiki := '!!!!!!!!!!!!foo'.	tree := PRDocument new		add: (PRHeader new			level: 6;			add: (PRText content: 'foo');			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseHeaderTest methodsFor: 'tests-parsing'!testParseMultiline	| wiki tree nLine |	nLine := self lineEnding.	wiki := '!!!!Hello ""This is' , nLine , 'bold"" end' , nLine , 'new'.	tree := PRDocument new		        add: (PRHeader new				         level: 2;				         add: (PRText content: 'Hello ');				         add:					         (self						          addText: 'This is' , nLine , 'bold'						          to: PRBoldFormat new);				         add: (PRText content: ' end');				         yourself);		        add: (self addText: 'new' to: PRParagraph new);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseHeaderTest methodsFor: 'tests-parsing'!testParseNested	| wiki tree |	wiki := '!!!!Hello *Link*'.	tree := PRDocument new		add: (PRHeader new			level: 2;			add: (PRText content: 'Hello ');			add: (PRInternalLink new				reference: 'Link';				yourself);			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseHeaderTest methodsFor: 'tests-parsing'!testParseWithTrailingSpaces	| wiki text tree |	wiki := '!!  foo'.	tree := PRDocument new		add: (PRHeader new			level: 1;			add: (PRText content: 'foo');			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParsePreformattedTest class methodsFor: 'testing'!isAbstract	^ false! !!PRParsePreformattedTest methodsFor: 'private'!actualClass	^ PRPreformatted! !!PRParsePreformattedTest methodsFor: 'tests-parsing'!testParseBasic	| wiki tree |	wiki := '= Line'.	tree := PRDocument new		add: (PRPreformatted new			add: (PRText content: 'Line');			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParsePreformattedTest methodsFor: 'tests-parsing'!testParseEmpty	| wiki  tree |	wiki := '= '.	tree := PRDocument new		add: (PRPreformatted new			add: (PRText content: '');			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParsePreformattedTest methodsFor: 'tests-parsing'!testParseMultiple	| wiki tree nLine |	nLine := self lineEnding.	wiki := '= line 1.1' , nLine , '= line 1.2' , nLine , nLine	        , '= line 2.1'.	tree := PRDocument new		        add: (PRPreformatted new				         add: (PRText content: 'line 1.1');				         add: (PRText content: 'line 1.2');				         yourself);		        add: PREmptyParagraph new;		        add: (PRPreformatted new				         add: (PRText content: 'line 2.1');				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParsePreformattedTest methodsFor: 'tests-parsing'!testParseSpaces	| wiki tree nLine |	nLine := self lineEnding.	wiki := '=    A line with 3 spaces' , nLine , '= 	A line with a tab'.	tree := PRDocument new		        add: (PRPreformatted new				         add: (PRText content: '   A line with 3 spaces');				         add: (PRText content: '	A line with a tab');				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParsePreformattedTest methodsFor: 'tests-parsing'!testParseSpecials	| wiki tree |	wiki := '= |, {, }, *, *, [, ||, |{, |}, +, +'.	tree := PRDocument new		add: (PRPreformatted new			add: (PRText content: '|, {, }, *, *, [, ||, |{, |}, +, +');			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseExternalLinkTest class methodsFor: 'testing'!isAbstract	^ false! !!PRParseExternalLinkTest methodsFor: 'private'!actualClass	^ PRExternalLink! !!PRParseExternalLinkTest methodsFor: 'private'!referenceString	^ 'http://www.lukas-renggli.ch'! !!PRParseExternalLinkTest methodsFor: 'tests'!testLinkToAFigureIsExternalLink	| wiki tree |	wiki := '*file://foo.png*'.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				reference: 'file://foo.png';				yourself);			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseMailLinkTest methodsFor: 'private'!actualClass	^ PRMailLink! !!PRParseMailLinkTest methodsFor: 'private'!referenceString	^ 'renggli@gmail.com'! !!PRParseMailLinkTest methodsFor: 'as yet unclassified'!testLinkToAFigureIsExternalLink	"This test has no meaning in PRMailLinkTest."! !!PRParseMailLinkTest methodsFor: 'tests-parsing'!testParseBogus	| wiki tree |	wiki := '*ab12@x.com*'.		tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				reference: 'ab12@x.com';				yourself);			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseInternalLinkTest class methodsFor: 'testing'!isAbstract	^ false! !!PRParseInternalLinkTest methodsFor: 'private'!actualClass	^ PRInternalLink! !!PRParseInternalLinkTest methodsFor: 'private'!referenceString	^ 'Page'! !!PRParseInternalLinkTest methodsFor: 'tests-parsing'!testParseAnchored	| wiki tree |	wiki := '*' , self referenceString , '@Anchor*'.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				reference: self referenceString;				anchor: 'Anchor';				yourself);			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseInternalLinkTest methodsFor: 'tests-parsing'!testParseEverything	| wiki tree |	wiki := '*Alias>' , self referenceString , '@Anchor*'.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				add: (PRText content: 'Alias');				reference: self referenceString;				anchor: 'Anchor';				yourself);			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseLinkTest methodsFor: 'private'!actualClass	^ PRLink! !!PRParseLinkTest methodsFor: 'private'!markup	^ PRPillarParser markups at: PRLink! !!PRParseLinkTest methodsFor: 'tests-parsing'!testParseAliased	| wiki tree |	wiki := '*Alias>' , self referenceString , '*'.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				add: (PRText content: 'Alias');				reference: self referenceString;				yourself);			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseLinkTest methodsFor: 'tests-parsing'!testParseAliasedEmpty	| wiki tree |	wiki := '*>' , self referenceString , '*'.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				add: (PRText content: '');				reference: self referenceString;				yourself);			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseLinkTest methodsFor: 'tests-parsing'!testParseBasic	| wiki tree |	wiki := '*' , self referenceString , '*'.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				reference: self referenceString;				yourself);			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseLinkTest methodsFor: 'tests-parsing'!testParseParameters	| wiki tree |	wiki := '*Alias>' , self referenceString , '|a=1|b=2|c=true*'.	tree := PRDocument new		add:				(PRParagraph new						add:								(self actualClass new										add: (PRText content: 'Alias');										reference: self referenceString;										parameters:												(OrderedDictionary new														add: 'a' -> 1;														add: 'b' -> 2;														add: 'c' -> true;														yourself);										yourself);						yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseLinkTest methodsFor: 'tests-parsing'!testParseParametersEmpty	| wiki tree |	wiki := '*Alias>' , self referenceString , '|a||b|*'.		tree := PRDocument new		add:				(PRParagraph new						add:								(self actualClass new										add: (PRText content: 'Alias');										reference: self referenceString;										parameters:												(OrderedDictionary new														add: 'a' -> true;														add: 'b' -> true;														yourself);										yourself);						yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseLinkTest methodsFor: 'tests-parsing'!testParseParametersEscaped	| wiki tree |	wiki := '*Alias>' , self referenceString , '|2=\|\=|\|\==1*'.	tree := PRDocument new		add:				(PRParagraph new						add:								(self actualClass new										add: (PRText content: 'Alias');										reference: self referenceString;										parameters:												(OrderedDictionary new														add: '2' -> '|=';														add: '|=' -> 1;														yourself);										yourself);						yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseReferenceTest methodsFor: 'private'!actualClass	^ PRReference! !!PRParseReferenceTest methodsFor: 'private'!markup	^ self subclassResponsibility! !!PRParseReferenceTest methodsFor: 'private'!referenceString	self subclassResponsibility! !!PRParseReferenceTest methodsFor: 'tests'!testNonTextAlias	| wiki tree |	wiki := self markup , 'foo ""Alias"">' , self referenceString , self markup.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				add: (PRText content: 'foo ');				add: (self addText: 'Alias' to: PRBoldFormat new);				reference: self referenceString;				yourself);			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseReferenceTest methodsFor: 'tests-parsing'!testParseAliased	| wiki tree |	wiki := self markup , 'Alias>' , self referenceString , self markup.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				add: (PRText content: 'Alias');				reference: self referenceString;				yourself);			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseReferenceTest methodsFor: 'tests-parsing'!testParseAliasedEmpty	| wiki tree |	wiki := self markup , '>' , self referenceString , self markup.	tree := PRDocument new		add:			(PRParagraph new				add:					(self actualClass new						add: (PRText content: '');						reference: self referenceString;						yourself);				yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseReferenceTest methodsFor: 'tests-parsing'!testParseBasic	| wiki tree |	wiki := self markup  , self referenceString , self markup .	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				reference: self referenceString;				yourself);			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseReferenceTest methodsFor: 'tests-parsing'!testParseEasyness	| wiki1 wiki2 tree |	wiki1 := self markup , self lineEnding , self markup	         , self referenceString.	wiki2 := '\' , self markup , self lineEnding , '\' , self markup	         , self referenceString.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: self markup);				         add: PRLineBreak new;				         add: (PRText content: self markup , self referenceString);				         yourself);		        yourself.	self parserAssertWiki: wiki1 equalsTree: tree.	self parserAssertWiki: wiki2 equalsTree: tree! !!PRParseReferenceTest methodsFor: 'tests-parsing'!testParseEmpty	| wiki1 wiki2 tree |	wiki1 := self markup , self markup.	wiki2 := '\' , self markup , '\' , self markup.	tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: self markup , self markup);				yourself);		yourself.	self parserAssertWiki: wiki1 equalsTree: tree.	self parserAssertWiki: wiki2 equalsTree: tree.	! !!PRParseReferenceTest methodsFor: 'tests-parsing'!testParseEscaped	| wiki tree |	wiki := 'Star \*' , self referenceString , '\*' , self lineEnding	        , 'Cross \+' , self referenceString , '\+'.	tree := PRDocument new		        add: (PRParagraph new				         add:					         (PRText content: 'Star *' , self referenceString , '*');				         add: PRLineBreak new;				         add:					         (PRText content: 'Cross +' , self referenceString , '+');				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseReferenceTest methodsFor: 'tests-parsing'!testParseParameters	| wiki tree |	wiki := self markup , 'Alias>' , self referenceString , '|a=1|b=2|c=true' , self markup .	tree := PRDocument new		add:				(PRParagraph new						add:								(self actualClass new										add: (PRText content: 'Alias');										reference: self referenceString;										parameters:												(OrderedDictionary new														add: 'a' -> 1;														add: 'b' -> 2;														add: 'c' -> true;														yourself);										yourself);						yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseReferenceTest methodsFor: 'tests-parsing'!testParseParametersEmpty	| wiki tree |	wiki := self markup , 'Alias>' , self referenceString , '|a||b|' , self markup  .	tree := PRDocument new		add:				(PRParagraph new						add:								(self actualClass new										add: (PRText content: 'Alias');										reference: self referenceString;										parameters:												(OrderedDictionary new														add: 'a' -> true;														add: 'b' -> true;														yourself);										yourself);						yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseReferenceTest methodsFor: 'tests-parsing'!testParseParametersEscaped	| wiki tree |	wiki := self markup , 'Alias>' , self referenceString , '|2=\|\=|\|\==1' , self markup .	tree := PRDocument new		add:				(PRParagraph new						add:								(self actualClass new										add: (PRText content: 'Alias');										reference: self referenceString;										parameters:												(OrderedDictionary new														add: '2' -> '|=';														add: '|=' -> 1;														yourself);										yourself);						yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseTableCellTest class methodsFor: 'testing'!isAbstract	^ false! !!PRParseTableCellTest methodsFor: 'private'!actualClass	^ PRTableCell! !!PRParseTableCellTest methodsFor: 'tests-parsing'!testParseAlign1	| wiki tree |	wiki := '|{left||center|}right'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					beAlignedLeft;					add: (PRText content: 'left');					yourself);				add: (PRTableCell new					beAlignedCenter;					add: (PRText content: 'center');					yourself);				add: (PRTableCell new					beAlignedRight;					add: (PRText content: 'right');					yourself);				yourself);			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseTableCellTest methodsFor: 'tests-parsing'!testParseAlign2	| wiki tree |	wiki := '|}right|none|{left|none'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					beAlignedRight;					add: (PRText content: 'right');					yourself);				add: (PRTableCell new					add: (PRText content: 'none');					yourself);				add: (PRTableCell new					beAlignedLeft;					add: (PRText content: 'left');					yourself);				add: (PRTableCell new					add: (PRText content: 'none');					yourself);				yourself);			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseTableCellTest methodsFor: 'tests-parsing'!testParseEncoding	| wiki tree |	wiki := '|*link*|+file://embedded.png+|foo{}'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					add: (PRInternalLink new						reference: 'link';						yourself);					yourself);				add: (PRTableCell new					add: (PRFigure new						reference: 'file://embedded.png';						yourself);					yourself);				add: (PRTableCell new					add: (PRText content: 'foo{}');					yourself);				yourself);			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseTableCellTest methodsFor: 'tests-parsing'!testParseHeading1	| wiki tree |	wiki := '|!!head|{!!left||!!center|}!!right'.		tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					beHeading;					add: (PRText content: 'head');					yourself);				add: (PRTableCell new					beHeading;					beAlignedLeft;					add: (PRText content: 'left');					yourself);				add: (PRTableCell new					beHeading;					beAlignedCenter;					add: (PRText content: 'center');					yourself);				add: (PRTableCell new					beHeading;					beAlignedRight;					add: (PRText content: 'right');					yourself);				yourself);			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseTableCellTest methodsFor: 'tests-parsing'!testParseHeading2	| wiki1 tree |	wiki1 := '|!!head|!!{left|!!|center|!!}right'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					beHeading;					add: (PRText content: 'head');					yourself);				add: (PRTableCell new					beHeading;					beAlignedLeft;					add: (PRText content: 'left');					yourself);				add: (PRTableCell new					beHeading;					beAlignedCenter;					add: (PRText content: 'center');					yourself);				add: (PRTableCell new					beHeading;					beAlignedRight;					add: (PRText content: 'right');					yourself);				yourself);			yourself);		yourself.	self parserAssertWiki: wiki1 equalsTree: tree.	! !!PRParseTableTest class methodsFor: 'testing'!isAbstract	^ false! !!PRParseTableTest methodsFor: 'private'!actualClass	^ PRTable! !!PRParseTableTest methodsFor: 'tests-parsing'!testParseBasic	| wiki tree |	wiki := '|cell'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					add: (PRText content: 'cell');					yourself);				yourself);			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseTableTest methodsFor: 'tests-parsing'!testParseSquare	| wiki tree nLine |	nLine := self lineEnding.	wiki := '|a11|a12' , nLine , '|a21|a22'.	tree := PRDocument new		        add: (PRTable new				         add: (PRTableRow new						          add: (PRTableCell new								           add: (PRText content: 'a11');								           yourself);						          add: (PRTableCell new								           add: (PRText content: 'a12');								           yourself);						          yourself);				         add: (PRTableRow new						          add: (PRTableCell new								           add: (PRText content: 'a21');								           yourself);						          add: (PRTableCell new								           add: (PRText content: 'a22');								           yourself);						          yourself);				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseTableTest methodsFor: 'tests-parsing'!testParseTriangle	| wiki tree nLine |	nLine := self lineEnding.	wiki := '|a11' , nLine , '|a21|a22' , nLine , '|a31|a32|a33'.	tree := PRDocument new		        add: (PRTable new				         add: (PRTableRow new						          add: (PRTableCell new								           add: (PRText content: 'a11');								           yourself);						          yourself);				         add: (PRTableRow new						          add: (PRTableCell new								           add: (PRText content: 'a21');								           yourself);						          add: (PRTableCell new								           add: (PRText content: 'a22');								           yourself);						          yourself);				         add: (PRTableRow new						          add: (PRTableCell new								           add: (PRText content: 'a31');								           yourself);						          add: (PRTableCell new								           add: (PRText content: 'a32');								           yourself);						          add: (PRTableCell new								           add: (PRText content: 'a33');								           yourself);						          yourself);				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseTableTest methodsFor: 'tests-parsing'!testParseWithPreformattedAndLinkWithParameters	| wiki tree |	wiki := '|==\+link\|a\+==|'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					add: (PRMonospaceFormat new						add: (PRText content: '+link|a+');						yourself);					yourself);				add: (PRTableCell new					yourself);				yourself);			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseTableTest methodsFor: 'tests-parsing'!testParseWithPreformattedAndProtectedPipe	| wiki tree |	wiki := '|==\|==|'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new				  					add: (PRMonospaceFormat new						add: (PRText content: '|');						yourself);								yourself);				add: (PRTableCell new					yourself);				yourself);			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseDefinitionDataTest class methodsFor: 'testing'!isAbstract	^ false! !!PRParseDefinitionDataTest methodsFor: 'private'!actualClass	^ PRDefinitionList! !!PRParseDefinitionDataTest methodsFor: 'private'!listItemClass	^ PRDataItem! !!PRParseDefinitionDataTest methodsFor: 'tests'!testParseBug	| wiki1 wiki2 tree nLine |	nLine := self lineEnding.	wiki1 := '::1' , nLine , '::-2'.	wiki2 := ':' , nLine , '::1' , nLine , '::-2'.	tree := PRDocument new		        add: (PRDefinitionList new				         add: (PRDataItem new						          add: (PRDefinitionList new								           add: (PRDataItem new										            add: (PRText content: '1');										            add: (PRUnorderedList new												             add: (PRListItem new														              add: (PRText content: '2');														              yourself);												             yourself);										            yourself);								           yourself);						          yourself);				         yourself);		        yourself.	self parserAssertWiki: wiki1 equalsTree: tree.	self parserAssertWiki: wiki2 equalsTree: tree! !!PRParseDefinitionDataTest methodsFor: 'tests'!testParseMixed	| wiki tree |	wiki := ';1' , self lineEnding , ':2'.	tree := PRDocument new		        add: (PRDefinitionList new				         add: (PRTermItem new						          add: (PRText content: '1');						          yourself);				         add: (PRDataItem new						          add: (PRText content: '2');						          yourself);				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseDefinitionDataTest methodsFor: 'private'!textString: anObject level: anInteger	^ (super textString: anObject level: anInteger) , '  '! !!PRParseDefinitionDataTest methodsFor: 'private'!wikiString	^ ':'! !!PRParseDefinitionTermTest class methodsFor: 'testing'!isAbstract	^ false! !!PRParseDefinitionTermTest methodsFor: 'private'!actualClass	^ PRDefinitionList! !!PRParseDefinitionTermTest methodsFor: 'private'!listItemClass	^ PRTermItem! !!PRParseDefinitionTermTest methodsFor: 'tests'!testParseMixed	| wiki tree nLine |	nLine := self lineEnding.	wiki := ';1' , nLine , ';2' , nLine , ':3' , nLine , ':4'.	tree := PRDocument new		        add: (PRDefinitionList new				         add: (PRTermItem new						          add: (PRText content: '1');						          yourself);				         add: (PRTermItem new						          add: (PRText content: '2');						          yourself);				         add: (PRDataItem new						          add: (PRText content: '3');						          yourself);				         add: (PRDataItem new						          add: (PRText content: '4');						          yourself);				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseDefinitionTermTest methodsFor: 'private'!textString: anObject level: anInteger	^ (super textString: anObject level: anInteger) , '- '! !!PRParseDefinitionTermTest methodsFor: 'private'!wikiString	^ ';'! !!PRParseHorizontalRuleTest class methodsFor: 'testing'!isAbstract	^ false! !!PRParseHorizontalRuleTest methodsFor: 'private'!actualClass	^ PRHorizontalRule! !!PRParseHorizontalRuleTest methodsFor: 'tests-parsing'!testParseBasic	| wiki tree |	wiki := '_'.	tree := PRDocument new		add: PRHorizontalRule new;		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseHorizontalRuleTest methodsFor: 'tests-parsing'!testParseLink	| wiki1 wiki2 tree |	wiki1 := '_ *link*'.	wiki2 := '\_ *link*'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText content: '_ ');			add: (PRInternalLink new				reference: 'link';				yourself);			yourself);		yourself.	self parserAssertWiki: wiki1 equalsTree: tree.	self parserAssertWiki: wiki2 equalsTree: tree.	! !!PRParseHorizontalRuleTest methodsFor: 'tests-parsing'!testParseMultiple	| wiki tree nLine |	nLine := self lineEnding.	wiki := '_' , nLine , '_' , nLine , nLine , '_'.	tree := PRDocument new		        add: PRHorizontalRule new;		        add: PRHorizontalRule new;		        add: PREmptyParagraph new;		        add: PRHorizontalRule new;		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseHorizontalRuleTest methodsFor: 'tests-parsing'!testParseParagraph	| wiki tree |	wiki := '\_ is parsed as paragraph'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText content: '_ is parsed as paragraph');			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseHorizontalRuleTest methodsFor: 'tests-parsing'!testParseSpaces	| wiki text tree |	wiki := '_       '.	tree := PRDocument new		add: PRHorizontalRule new;		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseHorizontalRuleTest methodsFor: 'private'!textString	^ String new: 40 withAll: $-! !!PRParseLineBreakTest class methodsFor: 'testing'!isAbstract	^ false! !!PRParseLineBreakTest methodsFor: 'private'!actualClass	^ PRLineBreak! !!PRParseLineBreakTest methodsFor: 'tests-parsing'!testParseOneEmptyLine	| wiki tree nLine |	nLine := self lineEnding.	wiki := 'Lorem ipsum dolor sit amet.' , nLine , nLine	        , 'Nulla quis urna.'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: 'Lorem ipsum dolor sit amet.');				         yourself);		        add: PREmptyParagraph new;		        add:		        (PRParagraph new add:			         (PRText content: 'Nulla quis urna.') yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseLineBreakTest methodsFor: 'tests-parsing'!testParseTreeLines	| wiki tree nLine |	nLine := self lineEnding.	wiki := 'Lorem ipsum dolor sit amet.' , nLine , 'Nulla quis urna.'	        , nLine , 'Vestibulum turpis.'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: 'Lorem ipsum dolor sit amet.');				         add: PRLineBreak new;				         add: (PRText content: 'Nulla quis urna.');				         add: PRLineBreak new;				         add: (PRText content: 'Vestibulum turpis.');				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseLineBreakTest methodsFor: 'tests-parsing'!testParseTwoEmptyLines	| wiki tree nLine |	nLine := self lineEnding.	wiki := 'Lorem ipsum dolor sit amet.' , nLine , nLine , nLine	        , 'Nulla quis urna.'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: 'Lorem ipsum dolor sit amet.');				         yourself);		        add: PREmptyParagraph new;		        add: PREmptyParagraph new;		        add:		        (PRParagraph new add:			         (PRText content: 'Nulla quis urna.') yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseLineBreakTest methodsFor: 'tests-parsing'!testParseTwoLines	| wiki tree |	wiki := 'Lorem ipsum dolor sit amet.' , self lineEnding	        , 'Nulla quis urna.'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: 'Lorem ipsum dolor sit amet.');				         add: PRLineBreak new;				         add: (PRText content: 'Nulla quis urna.') yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseCommentedLineTest methodsFor: 'private'!actualClass	^ PRCommentedLine! !!PRParseCommentedLineTest methodsFor: 'tests-parsing'!testParseBasic	| wiki tree |	wiki := '%some comment'.	tree := PRDocument new		add: (PRCommentedLine content: 'some comment');		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseCommentedLineTest methodsFor: 'tests-parsing'!testParseDontInterruptLists	| wiki tree nLine |	nLine := self lineEnding.	wiki := '#item one' , nLine , '##item one-point-one' , nLine	        , '%comment' , nLine , '##item one-point-two'.	tree := PRDocument new		        add: (PROrderedList new				         add: (PRListItem new						          add: (PRText content: 'item one');						          add: (PROrderedList new								           add: (PRListItem new										            add: (PRText content: 'item one-point-one');										            add: (PRCommentedLine content: 'comment');										            yourself);								           add: (PRListItem new										            add: (PRText content: 'item one-point-two');										            yourself);								           yourself);						          yourself);				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseCommentedLineTest methodsFor: 'tests-parsing'!testParseDontParseContent	| wiki tree |	wiki := '%some *comment*'.	tree := PRDocument new		add: (PRCommentedLine content: 'some *comment*');		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseRawTest methodsFor: 'private'!actualClass	^ PRRaw! !!PRParseRawTest methodsFor: 'tests-parsing'!testParseBasic	| wiki tree |	wiki := '{{{abc}}}'.	tree := PRDocument new		add: (PRParagraph new			add: (PRRaw content: 'abc');			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseRawTest methodsFor: 'tests-parsing'!testParseEmpty	| wiki tree |	wiki := '{{{}}}'.	tree := PRDocument new		add: (PRParagraph new			add: (PRRaw content: '');			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseRawTest methodsFor: 'tests-parsing'!testParseMultiline	| wiki tree nLine |	nLine := self lineEnding.	wiki := '{{{a' , nLine , 'b}}}'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRRaw content: 'a' , nLine , 'b');				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseRawTest methodsFor: 'tests-parsing'!testParseMultiple	| wiki tree |	wiki := '{{{a}}}b{{{c}}}'.	tree := PRDocument new		add: (PRParagraph new			add: (PRRaw content: 'a');			add: (PRText content: 'b');			add: (PRRaw content: 'c');			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseRawTest methodsFor: 'tests-parsing'!testParseMultipleMultiline	| wiki tree nLine |	nLine := self lineEnding.	wiki := '{{{a' , nLine , 'b}}}c{{{d' , nLine , 'e}}}'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRRaw content: 'a' , nLine , 'b');				         add: (PRText content: 'c');				         add: (PRRaw content: 'd' , nLine , 'e');				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseRawTest methodsFor: 'tests-parsing'!testParseStrange	| wiki tree |	wiki := '{{{a{{||}}b}}}'.	tree := PRDocument new		add: (PRParagraph new			add: (PRRaw content: 'a{{||}}b');			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseRawTest methodsFor: 'tests-parsing'!testParseTypeHtml	| wiki tree |	wiki := '{{{html:abc}}}'.	tree := PRDocument new		add: (PRParagraph new			add: (PRRaw content: 'abc' type: 'html');			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseRawTest methodsFor: 'tests-parsing'!testParseTypeLatex	| wiki tree |	wiki := '{{{latex:abc}}}'.	tree := PRDocument new		add: (PRParagraph new			add: (PRRaw content: 'abc' type: 'latex');			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseRawTest methodsFor: 'tests-parsing'!testParseTypeText	| wiki tree |	wiki := '{{{text:abc}}}'.	tree := PRDocument new		add: (PRParagraph new			add: (PRRaw content: 'abc' type: 'text');			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseScriptTest methodsFor: 'private'!actualClass	^ PRCodeblock! !!PRParseScriptTest methodsFor: 'tests'!testIsStructure	| ston nLine script |	self flag: #toRemove.	"we do not support structure?"	nLine := self lineEnding.	ston := '[[[structure=Test' , nLine , 'Foo' , nLine , ']]]'.	script := (self parser parse: ston) children first.	self assert: script isStructure! !!PRParseScriptTest methodsFor: 'tests-parsing'!testParseEscape	| wiki tree nLine |	nLine := self lineEnding.	wiki := '[[[language=foo\|' , nLine , 'foo' , nLine , ']]]'.	tree := PRDocument new		        add: ((PRCodeblock content: 'foo')				         language: 'foo|';				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseScriptTest methodsFor: 'tests-parsing'!testParseRealLanguage	| wiki tree nLine |	nLine := self lineEnding.	wiki := '[[[language=smalltalk' , nLine , 'foo' , nLine , ']]]'.	tree := PRDocument new		        add: ((PRCodeblock content: 'foo')				         language: PRSmalltalkScriptLanguage default;				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseScriptTest methodsFor: 'tests-parsing'!testParseSimple	| wiki tree nLine |	nLine := self lineEnding.	wiki := '[[[' , nLine , 'foo' , nLine , ']]]'.	tree := PRDocument new		        add: (PRCodeblock content: 'foo');		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseScriptTest methodsFor: 'tests-parsing'!testParseSimpleOn1Line	"This test does *not* specify a valid usage of script. This test is here to ensure that there is a sensible default when writing invalid Pillar text."	| wiki tree |	wiki := '[[[foo]]]'.	tree := PRDocument new		add: (self addText: '[[[foo]]]' to: PRParagraph new);		yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseScriptTest methodsFor: 'tests-parsing'!testParseWithSimpleCaption	| wiki tree nLine |	nLine := self lineEnding.	wiki := '[[[caption=foo' , nLine , 'foo' , nLine , ']]]'.	tree := PRDocument new		        add: ((PRCodeblock content: 'foo')				         caption: 'foo';				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseScriptTest methodsFor: 'tests'!testStructureName	| ston nLine script |	self flag: #toRemove.	"we do not support structure?"	nLine := self lineEnding.	ston := '[[[structure=Test' , nLine , 'Foo' , nLine , ']]]'.	script := (self parser parse: ston) children first.	self assert: script structureName equals: 'Test'! !!PRParseTextTest class methodsFor: 'testing'!isAbstract	^ false! !!PRParseTextTest methodsFor: 'private'!actualClass	^ PRText! !!PRParseTextTest methodsFor: 'tests-parsing'!testEscapeCpp	| wiki tree |	wiki := 'Text: \+\+'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText content: 'Text: ++');			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseTextTest methodsFor: 'tests-parsing'!testEscapeFirst	| wiki tree nLine |	nLine := self lineEnding.	wiki := '\* text' , nLine , '\+ text' , nLine , '\= text' , nLine	        , '\@ text' , nLine , '\!! text' , nLine , '\| text' , nLine	        , '\# text' , nLine , '\- text'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: '* text');				         add: PRLineBreak new;				         add: (PRText content: '+ text');				         add: PRLineBreak new;				         add: (PRText content: '= text');				         add: PRLineBreak new;				         add: (PRText content: '@ text');				         add: PRLineBreak new;				         add: (PRText content: '!! text');				         add: PRLineBreak new;				         add: (PRText content: '| text');				         add: PRLineBreak new;				         add: (PRText content: '# text');				         add: PRLineBreak new;				         add: (PRText content: '- text');				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseTextTest methodsFor: 'tests-parsing'!testEscapeStrange	| wiki tree |	wiki := '< text' , self lineEnding , '> text'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: '< text');				         add: PRLineBreak new;				         add: (PRText content: '> text');				         yourself);		        yourself.	self parserAssertWiki: wiki equalsTree: tree! !!PRParseTextTest methodsFor: 'tests-parsing'!testEscapeText	| wiki tree |	wiki := 'Text: \*\+'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText content: 'Text: *+');			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseTextTest methodsFor: 'tests-parsing'!testEscapeWiki	| wiki tree |	wiki := 'Wiki: =, |, !!, #, {, }, |{, ||, |}, [, ] and -'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText content: 'Wiki: =, |, !!, #, {, }, |{, ||, |}, [, ] and -');			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseTextTest methodsFor: 'tests-parsing'!testParseBasic	| wiki tree |	wiki := 'abcdefghijklmnopqrstuvwxyz... ABCDEFGHIJKLMNOPQRSTUVWXYZ... 0123456789...'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText content: 'abcdefghijklmnopqrstuvwxyz... ABCDEFGHIJKLMNOPQRSTUVWXYZ... 0123456789...');			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseTextTest methodsFor: 'tests-parsing'!testParseHtml	| wiki tree |	wiki := '<strong>strong <emph>strong, emph</emph></strong>'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText content: '<strong>strong <emph>strong, emph</emph></strong>');			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseTextTest methodsFor: 'tests-parsing'!testParseLatex	| wiki text tree |	wiki := '\\begin{foo}[bar]$zork$\\end{foo}'.	text := '\begin{foo}[bar]$zork$\end{foo}'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText content: '\begin{foo}[bar]$zork$\end{foo}');			yourself);		yourself.	self parserAssertWiki: wiki equalsTree: tree.! !!PRParseTextTest methodsFor: 'tests-parsing'!testParseSpecial	| wiki tree |	wiki := '????????????¬å???????????????¬ú??¬ü¬¬°¬¢¬£¬§¬·?¬ß?¬©¬¬´¬¨?¬Æ¬Ø¬¬±???¬µ¬¬??¬¬ª???¬ø¦Ä¦Å¦Ç¦É¦Ñ¦Ö¦Ü¦á¦à¦â¦ä¦ã¦å¦ç¦é¦è?¦ë¦í¦ì¦î¦ï¦ñ?¦ò¦ô¦ö¦õ¦ú??¦ü¦¦°¦¢¦£¦§¦·¦¶¦ß¦®¦©¦¦´¦¨¦¦Æ¦Ø?¦±¦¦¦¥¦µ¦¦¦¦¦¦ª¦º??'.	tree := (PRDocument new)				add: ((PRParagraph new)							add: (PRText										content: '????????????¬å???????????????¬ú??¬ü¬¬°¬¢¬£¬§¬·?¬ß?¬©¬¬´¬¨?¬Æ¬Ø¬¬±???¬µ¬¬??¬¬ª???¬ø¦Ä¦Å¦Ç¦É¦Ñ¦Ö¦Ü¦á¦à¦â¦ä¦ã¦å¦ç¦é¦è?¦ë¦í¦ì¦î¦ï¦ñ?¦ò¦ô¦ö¦õ¦ú??¦ü¦¦°¦¢¦£¦§¦·¦¶¦ß¦®¦©¦¦´¦¨¦¦Æ¦Ø?¦±¦¦¦¥¦µ¦¦¦¦¦¦ª¦º??');							yourself);				yourself.	self parserAssertWiki: wiki equalsTree: tree.	! !!PRParseTextTest methodsFor: 'tests-parsing'!testParseWiki	| wiki tree |	wiki := ' !!_#-|=]@:<>\*'.	tree := (PRDocument new)				add: ((PRParagraph new)							add: (PRText content: ' !!_#-|=]@:<>*');							yourself);				yourself.	self parserAssertWiki: wiki equalsTree: tree.! !"Pillar-Tests-Model-PetitPillar"!!PRTSliderWriterTest commentStamp: '' prior: 0!I am a class of trait used to test different exporter of slide. (e.g. Beamer exporter, DeckJS exporter etc...)!!PRCascadingCounterTest commentStamp: '' prior: 0!I test the PRCascadingCounter class.!!PRDocumentWriterTest commentStamp: '' prior: 0!I provide abstract tests and helper methods to test the subclasses of PRDocumentWriter.!!PRNodeTransformerTest commentStamp: '' prior: 0!Abstract class that should be subclassed for all subclasses of PRNodeTransformer.!!PRDocumentListTransformerTest commentStamp: '' prior: 0!Test class for docList Transformer!!ManifestPillarTestsExporterCore commentStamp: '' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!PRTSliderWriterTest methodsFor: 'private'!actualClass	^ self explicitRequirement! !!PRTSliderWriterTest methodsFor: 'requirements'!endSlideTag	^ self explicitRequirement! !!PRTSliderWriterTest methodsFor: 'requirements'!headerInSlide	"I return one string that define a header rendering in a slide."	^ self explicitRequirement! !!PRTSliderWriterTest methodsFor: 'requirements'!representationOfAnchor	"I return a string which reprensent an anchor in the slider format."	^ self explicitRequirement! !!PRTSliderWriterTest methodsFor: 'requirements'!slideRepresentation	^ self explicitRequirement! !!PRTSliderWriterTest methodsFor: 'requirements'!slideTitle	"I return a collection with an explicite rendering of a slide title."	^ self explicitRequirement! !!PRTSliderWriterTest methodsFor: 'tests'!testExport1SimpleSlide	"self debug: #testExportSlideTitle"	| item |	item := PRDocument new		add: (PRSlide titled: 'Slide title');		add: (PRText content: 'Presentation text');		yourself.	self		assertWriting: item		includesTexts: self slideRepresentation.! !!PRTSliderWriterTest methodsFor: 'tests'!testExport2SlidesCloseAllFrames	"self debug: #testExportSlideTitle"	| item resultString index |	item := PRDocument new		add: (PRSlide titled: 'Slide 1');		add: (PRSlide titled: 'Slide 2');		yourself.	resultString := self write: item.	index := resultString findString: self endSlideTag startingAt: 0.	self assert: index > 0.	index := resultString findString: self endSlideTag startingAt: index + 1.	self assert: index > 0! !!PRTSliderWriterTest methodsFor: 'tests'!testRenderStructureAsSlide	| item |	item := PRDocument new		add:				(PRHeader new						level: 1;						add: (PRText content: 'Foo');						yourself);		add: (PRSlide titled: 'Slide');		yourself.	self configuration renderStructureAsSlide: true.	self assertWriting: item includesTexts: {(self headerInSlide)}.	self configuration renderStructureAsSlide: false.	self deny: [ (self write: item) includesSubstring: self headerInSlide ]! !!PRTSliderWriterTest methodsFor: 'tests'!testTitleOfSlide	"self debug: #testExportSlideTitle"	| item |	item := PRDocument new		add: (PRSlide titled: 'Slide title');		yourself.	self		assertWriting: item		includesTexts: self slideTitle.! !!PRTSliderWriterTest methodsFor: 'tests'!testslideWithLabel	"self debug: #testExportSlideTitle"	| item |	item := PRDocument new		add:				((PRSlide titled: 'Slide title')						label: 'Foo';						yourself);		yourself.	self assertWriting: item includesTexts: {(self representationOfAnchor)}! !!MicTransformDocumentTest methodsFor: 'running'!generateFilesystemExample	| file |	(filesystem workingDirectory / 'Chapters') createDirectory.	(filesystem workingDirectory / 'Chapters' / 'Chapter1') createDirectory.	file := filesystem workingDirectory / 'Chapters' / 'Chapter1' / 'chapter1.md'.	file writeStreamDo: [ :stream | stream nextPutAll: 'Pharo is cool!![](figures/f.png)' ].    ! !!MicTransformDocumentTest methodsFor: 'initialization'!setUp	super setUp.	filesystem := FileSystem memory.	self generateFilesystemExample.	project := PRProject new baseDirectory: filesystem. 	file := filesystem / 'Chapters' / 'Chapter1' / 'chapter1.md'.	aPRPDFDocument := PRPDFDocument new project: project; 		file: (MicMicrodownInputDocument new					project: project;					file:  file) ; 		target: PRPdfOutput new.! !!MicTransformDocumentTest methodsFor: 'initialization'!testTransformDocumentFor		| parsedDocument transformedDocument |	parsedDocument := MicrodownParser parse: file readStream contents.	transformedDocument := parsedDocument transformDocumentFor: aPRPDFDocument.		self assert: transformedDocument children second children first reference path equals:  '/Chapters/Chapter1/figures/f.png'! !!PRBuildRootMainStrategyTest methodsFor: 'tests'!testFilesToBuildOnCorrect	| outputProject |	outputProject := PRBuildRootMainStrategy new filesToBuildOn: project.	self assert: outputProject first class equals: PRPillarInputDocument.	self assert: outputProject first file path equals: Path / 'index.pillar'! !!PRBuildRootMainStrategyTest methodsFor: 'tests'!testFilesToBuildOnErrorNoFile	project baseDirectory: ((project baseDirectory / 'index.pillar') delete; parent).	self should: [ PRBuildRootMainStrategy new filesToBuildOn: project ] raise: Error! !!PRBuildRootMainStrategyTest methodsFor: 'tests'!testFilesToBuildOnErrorSeveralFiles	project baseDirectory: ((project baseDirectory / 'chap3.pillar') ensureCreateFile; parent).	self should: [ PRBuildRootMainStrategy new filesToBuildOn: project ] raise: Error! !!PRBuildStrategyTest methodsFor: 'data'!chap1Content	^	'!!!!CompilationWelcome to Pillar s little user-guide !!!!To write a book, you can create chapters and include them into book.pillaror directly edit the file.If you do not know Pillar, check its documentation at *http://github.com/pillar-markup/pillar*.'! !!PRBuildStrategyTest methodsFor: 'data'!chap2Content	^'!!!!Edition and TemplatesThere is also a template system, you can find template in the folder _support/template.Some template are already written, but if you want to have your own, you had two solutions:-edit the existing template related to the format you want to change (recommanded)-create your own template with its own name'! !!PRBuildStrategyTest methodsFor: 'data'!configContent	^ '{  "base_url": "",  "site_name": "Pharo Book",  "title": "The Pillar Super Book Archetype",  "attribution": "The Pillar team",  "series": "Square Bracket tutorials",  "keywords": "project template, Pillar, Pharo, Smalltalk",  "language": "en-UK",  "latexWriter" : #latex}'! !!PRBuildStrategyTest methodsFor: 'data'!indexContent	^	'!!My First book		${inputFile:path=Chapters/Chapter1/chapter1.pillar}$		${inputFile:path=Chapters/Chapter2/chapter2.pillar}$		${inputFile:path=Chapters/Chapter2/chapter2.mic}$		'! !!PRBuildStrategyTest methodsFor: 'running'!setUp	"Create a setup project with: index.pillar, a conf, and Chapters with Chap1 and Chap2"	| fileSystem |	super setUp.	fileSystem := FileSystem memory root.	fileSystem / 'index.pillar' writeStreamDo: [ :st | st nextPutAll: self indexContent ].	fileSystem / 'pillar.conf' writeStreamDo: [ :st | st nextPutAll: self configContent ].	(fileSystem / 'Chapters' / 'Chapter1') ensureCreateDirectory / 'chapter1.pillar' writeStreamDo: [ :st | st nextPutAll: self chap1Content ].	(fileSystem / 'Chapters' / 'Chapter2') ensureCreateDirectory / 'chapter2.pillar' writeStreamDo: [ :st | st nextPutAll: self chap2Content ].	(fileSystem / 'Chapters' / 'Chapter2') ensureCreateDirectory / 'chapter2.mic' writeStreamDo: [ :st | st nextPutAll: self chap2Content ].	project := PRProject new baseDirectory: fileSystem! !!PRBuildStrategyTest methodsFor: 'tests'!testPRBuildAllStrategy	| f fsorted|	f := PRBuildAllStrategy new filesToBuildOn: project.	fsorted := (SortedCollection new sortBlock: [ :a :b | a basename < b basename ]) addAll: f.	self assert: fsorted size equals: 4.	self		assert: fsorted first file fullName		equals: '/Chapters/Chapter1/chapter1.pillar'.	self		assert: fsorted second file fullName		equals: '/Chapters/Chapter2/chapter2.mic'.	self		assert: fsorted third file fullName		equals: '/Chapters/Chapter2/chapter2.pillar'.	self assert: f fourth file fullName equals: '/index.pillar'! !!PRBuildStrategyTest methodsFor: 'tests'!testPRBuildListStrategy	| f |	f := PRBuildListStrategy new		files: {'index.pillar' . 'chapter1.pillar'}.	f := f filesToBuildOn: project.	self assert: f size equals: 2.	self assert: ((f collect: [:each | each fullName]) 							includesAll: #('/index.pillar' '/chapter1.pillar')).! !!PRBuildStrategyTest methodsFor: 'tests'!testPRBuildListStrategyDoubleEntry	| f |	f := PRBuildListStrategy new		files: {'chapter1.pillar' . 'chapter1.pillar'}.	f := f filesToBuildOn: project.	self assert: f size equals: 1.	self assert: f anyOne file fullName equals: '/chapter1.pillar'! !!PRBuildStrategyTest methodsFor: 'tests'!testPRBuildRootMainStrategy	| f |	f := PRBuildRootMainStrategy new filesToBuildOn: project.	self assert: f size equals: 1.	self assert: f first file fullName equals: '/index.pillar'	! !!PRCascadingCounterTest methodsFor: 'accessing'!packageNamesUnderTest	^ #('Pillar-ExporterCore')! !!PRCascadingCounterTest methodsFor: 'tests'!testElementsForNonSimpleCounter	| counter |	counter := PRCascadingCounter maxLevel: 5.	self assert: counter elements equals: { 0 }.	counter incrementAt: 2.	self assert: counter elements equals: { 0 . 1 }! !!PRCascadingCounterTest methodsFor: 'tests'!testElementsForSimpleCounter	| counter |	counter := PRCascadingCounter maxLevel: 5.	self assert: counter elements equals: { 0 }.	counter incrementAt: 1.	self assert: counter elements equals: { 1 }! !!PRCascadingCounterTest methodsFor: 'tests'!testIsValidCounter	self assert: (PRCascadingCounter maxLevel: 5) isValidCounter.	self deny: (PRNotFoundCounter maxLevel: 5) isValidCounter! !!PRAbstractOutputDocumentTest methodsFor: 'tests'!testParseInput	| doc |	doc := PRAbstractOutputDocument new parseInputFile: (PRPillarInputDocument new file: memoryFileSystem / 'input1.pillar').	self assert: doc class equals: PRDocument.! !!PRInputDocumentTest methodsFor: 'tests'!testBasic		| input |	input := (PRPillarInputDocument new file: memoryFileSystem / 'input1.pillar').	self 		assert:  input parserClass 		equals: PRDocument parser.	self 		assert:  input basename 		equals: 'input1.pillar'.! !!PRInputDocumentTest methodsFor: 'tests'!testBasicNoInput		| input |	input := (PRNoInputDocument new file: memoryFileSystem / 'input1.pillar').	self should: [ input parserClass ] raise: Error. 	! !!PRInputDocumentTest methodsFor: 'tests'!testBasicPillarInputDocument		| input |	input := (PRPillarInputDocument new file: memoryFileSystem / 'input1.pillar').	self 		assert:  input parserClass 		equals: PRDocument parser.	self 		assert:  input basename 		equals: 'input1.pillar'.! !!PRInputDocumentTest methodsFor: 'tests'!testParsedDocument		| doc |	doc := ((PRInputDocument inputClassForFile: memoryFileSystem / 'input1.pillar') new 					file:  memoryFileSystem / 'input1.pillar') parsedDocument.	self 		assert: doc class		equals: PRDocument! !!PRInputDocumentTest methodsFor: 'tests'!testParsedDocument2		| doc |	doc := (PRInputDocument forFile: memoryFileSystem / 'input1.pillar') parsedDocument.	self 		assert: doc class		equals: PRDocument! !!PRInputDocumentTest methodsFor: 'tests'!testRegistration		| inputClass |	inputClass := (PRInputDocument inputClassForFile: memoryFileSystem / 'input1.pillar').	self 		assert: inputClass 		equals: PRPillarInputDocument! !!PRInputDocumentTest methodsFor: 'tests'!testRegistrationNoCandidate		| inputClass |	inputClass := (PRInputDocument inputClassForFile: memoryFileSystem / 'input1.Zork').	self 		assert: inputClass 		equals: PRNoInputDocument! !!PRInputDocumentTest methodsFor: 'tests'!testRegistrationNoCandidate2		| inputClass |	inputClass := (PRInputDocument forFile: memoryFileSystem / 'input1.Zork') class.	self 		assert: inputClass 		equals: PRNoInputDocument! !!PRTestWithMemoryFileSystem methodsFor: 'tests'!createMicrodownFile1 	(memoryFileSystem / 'input1.md') writeStreamDo: [ :stream |		stream nextPutAll: '### TestFile11```some code here```### TestFile12Hey you ...### TestFile13You can compile just one chapter with the command `pillar build pdf book-result/chapterPathAndName.format`### TestFile14What are you thinking about !!!!!!??'		 ]! !!PRTestWithMemoryFileSystem methodsFor: 'tests'!createPillarFile1 	(memoryFileSystem / 'input1.pillar') writeStreamDo: [ :stream |		stream nextPutAll: '!!!!!! TestFile11+Pillar logo>figures/pillar.png|width=30+If you don''t know ''Pillar'', its documentation is *here>https://ci.inria.fr/pharo-contribution/job/EnterprisePharoBook/lastSuccessfulBuild/artifact/book-result/PillarChap/Pillar.html*!!!!!! TestFile12Hey you ...!!!!!! TestFile13The book is generated directly in HTML and LaTeX with the command ==make book==You can compile just one chapter with the command ==make book-result/chapterPathAndName.format==For example, for the first chapter in LaTeX: ==make book-result/Chapters/Chapter1/chapter1.tex==!!!!!! TestFile14What are you thinking about !!!!!!??!!!!!! TestFile15Where are you !!!!'		 ]! !!PRTestWithMemoryFileSystem methodsFor: 'tests'!setUp	super setUp.	memoryFileSystem := FileSystem memory.	self createPillarFile1.	self createMicrodownFile1.! !!PRLevelLetterPrinterTest methodsFor: 'requirement'!actualClass	^ PRLevelLetterPrinter! !!PRLevelLetterPrinterTest methodsFor: 'requirement'!representationOf26	^ 'z'! !!PRLevelLetterPrinterTest methodsFor: 'requirement'!representationOf27	^ 'a'''! !!PRLevelLetterPrinterTest methodsFor: 'requirement'!representationOfOne	^ 'a'! !!PRLevelNumberPrinterTest methodsFor: 'requirement'!actualClass	^ PRLevelNumberPrinter! !!PRLevelNumberPrinterTest methodsFor: 'requirement'!representationOf26	^ '26'! !!PRLevelNumberPrinterTest methodsFor: 'requirement'!representationOf27	^ '27'! !!PRLevelNumberPrinterTest methodsFor: 'requirement'!representationOfOne	^ '1'! !!PRLevelRomanPrinterTest methodsFor: 'requirement'!actualClass	^ PRLevelRomanPrinter! !!PRLevelRomanPrinterTest methodsFor: 'requirement'!representationOf26	^ 'XXVI'! !!PRLevelRomanPrinterTest methodsFor: 'requirement'!representationOf27	^ 'XXVII'! !!PRLevelRomanPrinterTest methodsFor: 'requirement'!representationOfOne	^ 'I'! !!PRLevelUpperLetterPrinterTest methodsFor: 'requirement'!actualClass	^ PRLevelUpperLetterPrinter! !!PRLevelUpperLetterPrinterTest methodsFor: 'requirement'!representationOf26	^ 'Z'! !!PRLevelUpperLetterPrinterTest methodsFor: 'requirement'!representationOf27	^ 'A'''! !!PRLevelUpperLetterPrinterTest methodsFor: 'requirement'!representationOfOne	^ 'A'! !!PRTitlePrinterTest class methodsFor: 'testing'!isAbstract	^ self = PRTitlePrinterTest! !!PRTitlePrinterTest methodsFor: 'requirement'!actualClass	^ PRTitlePrinterSpecification! !!PRTitlePrinterTest methodsFor: 'tests'!configurationClass 	^ ConfigurationForPillar! !!PRTitlePrinterTest methodsFor: 'helpers'!counterLevel3	^ Array with: 1 with: -1 with: 3! !!PRTitlePrinterTest methodsFor: 'helpers'!defaultDictionary	^ Dictionary with: 'numbering' -> true with: 'size' -> 1 with: 'renderAs' -> 'roman'! !!PRTitlePrinterTest methodsFor: 'helpers'!newDefaultConfiguration	^ self actualClass with: self defaultDictionary! !!PRTitlePrinterTest methodsFor: 'requirement'!representationOf26	^ self subclassResponsibility! !!PRTitlePrinterTest methodsFor: 'requirement'!representationOf27	^ self subclassResponsibility! !!PRTitlePrinterTest methodsFor: 'requirement'!representationOfOne	^ self subclassResponsibility! !!PRTitlePrinterTest methodsFor: 'tests'!testCounter	| printer spec |	printer := PRTitlePrinter new.	spec := printer printerSpecFor: 'roman' .	spec size: 1.	printer level1: spec. 		spec := printer printerSpecFor: 'letter' .	spec size: 2.	printer level2: spec. 		spec := printer printerSpecFor: 'letter' .	spec size: 3.	printer level3: spec. 	self assert: (printer level3 printCounter: self counterLevel3) equals: 'I.c'! !!PRTitlePrinterTest methodsFor: 'tests'!testFillFrom	| specTarget specSource |	specTarget := PRTitlePrinterSpecification new.	specSource := PRTitlePrinterSpecification new.	specSource level: 3.	specSource size: 55.	specSource renderAs: 'roman'.	specSource numbering: true.	specSource capitalization: 'capitalize english'.	specTarget fillFromAnother: specSource.	self assert: specTarget level equals: 3.	self assert: specTarget size equals: 55.	self assert: specTarget renderAs equals: 'roman'.	self assert: specTarget numbering.	self assert: specTarget capitalization equals: 'capitalize english'! !!PRTitlePrinterTest methodsFor: 'tests'!testPrintElement	| printer |	printer := self newDefaultConfiguration.	self assert:  (String streamContents: [:s | (printer printElement: -1 on: s)]) equals: ''.	self assert:  (String streamContents: [:s | (printer printElement: 1 on: s)]) equals: self representationOfOne.	self assert: (String streamContents: [:s | (printer printElement: 26 on: s)])equals: self representationOf26.	self assert: (String streamContents: [:s | (printer printElement: 27 on: s)]) equals: self representationOf27.! !!PRTitlePrinterTest methodsFor: 'tests'!testSize	| printer spec |	printer := PRTitlePrinter new.	spec := printer printerSpecFor: 'roman' .	spec size: 1.	printer level1: spec. 		spec := printer printerSpecFor: 'number' .		spec size: 0.	printer level2: spec. 		spec := printer printerSpecFor: 'letter' .	spec size: 3.	printer level3: spec. 	self assert: (printer level3 printCounter: #(1 -1 1)) equals: 'I.a'.	printer level2 size: 2.		self assert: (printer level3 printCounter: #(1 1 1)) equals: 'I.1.a'	! !!PRTitlePrinterTest methodsFor: 'tests'!testSizeHigherThanThePossible		| printer spec |	printer := PRTitlePrinter new.	spec := printer printerSpecFor: 'roman'.	spec size: 1.	printer level1: spec. 				spec := printer printerSpecFor: 'number' .	spec size: 2.	printer level1: spec. 				self assert: (printer level2 printCounter: #(-1 1)) equals: '1'! !!PRTitlePrinterTest methodsFor: 'tests'!testSizeIsNotTheFullSizePossible		| printer spec |	printer := PRTitlePrinter new.	spec := printer printerSpecFor: 'roman'.	spec size: 1.	printer level1: spec. 				spec := printer printerSpecFor: 'number' .	spec size: 1.	printer level2: spec. 				self assert: (printer level1 printCounter: #(1)) equals: 'I'.	self assert: (printer level2 printCounter: #(1 1)) equals: '1'! !!PRTitlePrinterTest methodsFor: 'tests'!testSizeWhenNumeratingIsFalse	| printer |	printer := PRTitlePrinterSpecification with: ( Dictionary with: 'numbering' -> false with: 'size' -> 0).	self assert: (printer size) equals: 0.		printer := PRTitlePrinterSpecification with: ( Dictionary with: 'numbering' -> false with: 'size' -> 3).	self assert: (printer size) equals: 0! !!PRDocumentWriterTest class methodsFor: 'testing'!isAbstract	"Override to true if a TestCase subclass is Abstract and should not have	TestCase instances built from it"	^self name = #PRDocumentWriterTest! !!PRDocumentWriterTest methodsFor: 'private'!actualClass	^ PRDocumentWriter! !!PRDocumentWriterTest methodsFor: 'private'!actualInstance	^  self createWriterOn: String new! !!PRDocumentWriterTest methodsFor: 'tests'!annotation		^ self shouldBeImplemented.  ! !!PRDocumentWriterTest methodsFor: 'asserting'!assert: result includesSubstring: expected	expected ifEmpty: [ ^ self ].	self assert: (result includesSubstring: expected) description: ('''{1}'' not in ''{2}''' format: {expected . result})! !!PRDocumentWriterTest methodsFor: 'asserting'!assertWriting: aDocumentItem includesText: aString	| result |	result := self write: aDocumentItem.	self assert: result includesSubstring: aString! !!PRDocumentWriterTest methodsFor: 'asserting'!assertWriting: aDocumentItem includesTexts: aCollection	| resultString |	resultString := self write: aDocumentItem.	aCollection do: [ :testString | self assert: resultString includesSubstring: testString ]! !!PRDocumentWriterTest methodsFor: 'requirements'!boldFoo	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'helpers'!configuration	^ configuration ifNil: [ configuration := self configurationClass new ]! !!PRDocumentWriterTest methodsFor: 'helpers'!configurationClass	^ ConfigurationForPillar! !!PRDocumentWriterTest methodsFor: 'helpers'!createWriterOn: aWriteStream 	^ (self actualClass on: aWriteStream)		configuration: self configuration;		yourself! !!PRDocumentWriterTest methodsFor: 'helpers'!createWriterWithSeparateOutputFilesOn: aWriteStream	^ (self actualClass on: aWriteStream)		configuration:				(self configurationClass new						separateOutputFiles: true;						yourself);		yourself! !!PRDocumentWriterTest methodsFor: 'requirements'!dataItemWithBar	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements'!definitionListBegin	self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements'!emailToFoo	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements'!figureAnchorForPierLogo	^ self subclassResponsibility ! !!PRDocumentWriterTest methodsFor: 'requirements'!figureBegin	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'data'!foo	^ 'foo'! !!PRDocumentWriterTest methodsFor: 'requirements'!footnoteBar	^ ''! !!PRDocumentWriterTest methodsFor: 'requirements'!horizontalRule	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements'!italicFoo	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements'!level1HeaderBegin	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements'!level1HeaderWithFoo	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements'!level2HeaderBegin	^ self subclassResponsibility ! !!PRDocumentWriterTest methodsFor: 'requirements'!listItemWith1	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements'!monospaceFoo	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements'!orderedListBegin	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements'!packageNamesUnderTest	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements'!paragraphFoo	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'helpers'!parser	^ PRPillarParserMain! !!PRDocumentWriterTest methodsFor: 'requirements'!preformattedFooBegin	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements'!preformattedTextFoo	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements'!rawText	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements'!referenceToFigurePierLogo	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirement-InternalLinks'!resultWithRefWithAnchorWithSeparateOutputFiles	self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirement-InternalLinks'!resultWithRefWithAnchorWithoutSeparateOutputFiles	self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirement-InternalLinks'!resultWithRefWithoutAnchorWithSeparateOutputFiles	self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirement-InternalLinks'!resultWithRefWithoutAnchorWithoutSeparateOutputFiles	self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirement-InternalLinks'!resultWithoutAliasWithRefWithAnchorWithoutSeparateOutputFiles	self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirement-InternalLinks'!resultWithoutAliasWithoutRefWithAnchorWithSeparateOutputFiles	self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirement-InternalLinks'!resultWithoutAliasWithoutRefWithAnchorWithoutSeparateOutputFiles	self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirement-InternalLinks'!resultWithoutRefWithAnchorWithSeparateOutputFiles	self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirement-InternalLinks'!resultWithoutRefWithAnchorWithoutSeparateOutputFiles	self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements'!scriptAnchorForMyScript	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements'!scriptWithCaptionBegin	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements'!scriptWithoutCaptionBegin	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements'!strikethroughFoo	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements'!subscriptFoo	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements'!superscriptFoo	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'tests'!supportSyntaxHighlighting	^ true! !!PRDocumentWriterTest methodsFor: 'requirements'!tableBegin	^ self subclassResponsibility ! !!PRDocumentWriterTest methodsFor: 'requirements'!tableCellWithFoo	^ self subclassResponsibility ! !!PRDocumentWriterTest methodsFor: 'requirements'!tableCellWithHeadingFoo	^ self subclassResponsibility ! !!PRDocumentWriterTest methodsFor: 'requirements'!tableRow	^ self subclassResponsibility ! !!PRDocumentWriterTest methodsFor: 'requirements'!termItemWithFoo	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'tests'!testAnnotation	| item |	{ 'note' . 'dothis' } do:	[	:annotation |			item := PRAnnotatedParagraph new			annotation: annotation;			add: (PRText content: 'foo');			yourself.		self 			assertWriting: item			includesTexts: 				{self annotationBegin: annotation . 'foo'}. 	].! !!PRDocumentWriterTest methodsFor: 'tests'!testBibFileIsCorrectlyTransformed		"Here we see that the configuration is holding a real object so taking its value blindly and pasting it in the template will not work."	self assert: self configuration bibFile pathString equals: 'book.bib'.		"the following test shows how the value of configuration is correctly transformed into a string that can be 	used in a Mustache template."	self assert: ((MustacheToken new token: 'bibFile') valueInContext: self configuration) asString equals: 'book.bib'! !!PRDocumentWriterTest methodsFor: 'tests'!testBoldFormat	| item |	item := self addText: 'foo' to: PRBoldFormat new.	self		assertWriting: item		includesTexts:			{self boldFoo}! !!PRDocumentWriterTest methodsFor: 'tests'!testCommentedLineNotVisibleInOutput	| item result |	item := PRCommentedLine content: 'some comment'.	result := self write: item.	self assertEmpty: result! !!PRDocumentWriterTest methodsFor: 'tests'!testConsecutiveTextsInAParagraphAreSeparatedByWhitespace	| item |	item := PRParagraph new		add: (PRText content: 'foo');		add: (PRLineBreak new);		add: (PRText content: 'bar');		yourself.	self assertWriting: item includesText: 'foo', self configuration newLine, 'bar'! !!PRDocumentWriterTest methodsFor: 'tests'!testDefinitionList	| item |	item := PRDefinitionList new		add: (self addText: 'foo' to: PRTermItem new);		add: (self addText: 'bar' to: PRDataItem new);		yourself.	self		assertWriting: item		includesTexts:			{self definitionListBegin.			self termItemWithFoo.			self dataItemWithBar}! !!PRDocumentWriterTest methodsFor: 'tests'!testFigure	| item |	item := PRFigure new		reference: 'file://picture.png';		yourself.	self		assertWriting: item		includesText:			'picture.png'! !!PRDocumentWriterTest methodsFor: 'tests'!testFigureLabelGenerateAnchor	| item |	item := PRFigure new		reference: 'file://picture.png';		parameterAt: 'label' put: 'pierLogo';		yourself.	self		assertWriting: item		includesTexts:			{(self figureAnchorForPierLogo).			'pierLogo'}! !!PRDocumentWriterTest methodsFor: 'tests'!testFigureReference	| item resultString indexOfReference referenceString |	item := PRParagraph new		add:				(PRFigure new						reference: 'file://picture.png';						parameterAt: 'label' put: 'pierLogo';						counter: ((PRCascadingCounter maxLevel: 5) incrementAt: 2 );						yourself);		add: (PRText content: 'See figure ');		add: ((PRInternalLink reference: '@pierLogo') counter: ((PRCascadingCounter maxLevel: 5) incrementAt: 2 ));		yourself.		resultString := self write: item.	indexOfReference := resultString indexOfSubCollection: 'See figure ' startingAt: 1 ifAbsent: [ self fail: 'The string ''See figure '' should have been found' ].	referenceString := resultString allButFirst: indexOfReference - 1.	self assert: referenceString includesSubstring: self referenceToFigurePierLogo! !!PRDocumentWriterTest methodsFor: 'tests'!testFigureWithLabelAndWithCaptionAreExportedWithEnvironment	| item |	item := PRFigure new		reference: 'file://picture.png';		add: (PRText content: 'caption');		label: 'label';		yourself.	self assertWriting: item includesText: self figureBegin! !!PRDocumentWriterTest methodsFor: 'tests'!testFigureWithLabelAndWithoutCaptionAreExportedWithEnvironment	| item |	item := PRFigure new		reference: 'file://picture.png';		label: 'label';		yourself.	self assertWriting: item includesText: self figureBegin! !!PRDocumentWriterTest methodsFor: 'tests'!testFigureWithWidth	| item width |	width := '50'.	item := PRFigure new		reference: 'file://picture.png';		parameterAt: 'width' put: width;		yourself.	self assertWriting: item includesText: self widthFor50percents! !!PRDocumentWriterTest methodsFor: 'tests'!testFigureWithoutLabelAndWithCaptionAreExportedWithEnvironment	| item |	item := PRFigure new		reference: 'file://picture.png';		add: (PRText content: 'caption');		yourself.	self assertWriting: item includesText: self figureBegin! !!PRDocumentWriterTest methodsFor: 'tests'!testFigureWithoutLabelAndWithoutCaptionAreExportedWithoutEnvironment	| item result |	item := PRFigure new		reference: 'file://picture.png';		yourself.	result := self write: item.	self figureBegin ifNotEmpty: [ self deny: (result includesSubstring: self figureBegin) ]! !!PRDocumentWriterTest methodsFor: 'tests'!testFiguresHaveACaption	| item caption filename |	caption := 'A description'.	filename := 'picture.png'.	item := PRFigure new		reference: 'file://' , filename;		label: 'picture';		add: (PRText content: caption);		yourself.	self		assertWriting: item		includesTexts:			{(self figureBegin).			filename.			caption}! !!PRDocumentWriterTest methodsFor: 'tests'!testFileExtension	| fileExtension |	fileExtension := self instance fileExtension.	self assert: fileExtension isNotNil.	self assert: fileExtension isString! !!PRDocumentWriterTest methodsFor: 'tests-internalLinks'!testFootnote	| item |	item := PRParagraph new		add: (PRText content: 'timo');		add: (PRFootnote noted: 'Bar');		add: (PRText content: 'leon');		yourself.	self assertWriting: item includesText: self footnoteBar! !!PRDocumentWriterTest methodsFor: 'tests'!testHasName	self denyEmpty: self actualClass writerName! !!PRDocumentWriterTest methodsFor: 'tests'!testHeader	| item |	item := PRHeader new		level: 1;		add: (PRText content: 'foo');		yourself.	self assertWriting: item includesTexts: {self level1HeaderWithFoo}.! !!PRDocumentWriterTest methodsFor: 'tests'!testHorizontalRule	| item  |	item := PRHorizontalRule new.	self assertWriting: item includesText: self horizontalRule! !!PRDocumentWriterTest methodsFor: 'tests-internalLinks'!testInternalLinkWithAliasWithRefWithAncorWithSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:				((PRInternalLink reference: 'ref.pillar@foo')						addAll: {(PRText content: 'Alias')};						yourself);		yourself.	resultString := self writeWithSeparateOutputFiles: item.	self resultWithRefWithAnchorWithSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithRefWithAnchorWithSeparateOutputFiles) ].	self assert: (resultString includesSubstring: 'Alias')! !!PRDocumentWriterTest methodsFor: 'tests-internalLinks'!testInternalLinkWithAliasWithReferenceWithoutAnchorWithSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:				((PRInternalLink reference: 'ref.pillar')						addAll: {(PRText content: 'Alias')};						yourself);		yourself.	resultString := self writeWithSeparateOutputFiles: item.	self resultWithRefWithoutAnchorWithSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithRefWithoutAnchorWithSeparateOutputFiles) ].	self assert: (resultString includesSubstring: 'Alias')! !!PRDocumentWriterTest methodsFor: 'tests-internalLinks'!testInternalLinkWithAliasWithoutReferenceWithAnchorWithSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:				((PRInternalLink reference: '@foo')						addAll: {(PRText content: 'Alias')};						yourself);		yourself.	resultString := self writeWithSeparateOutputFiles: item.	self resultWithoutRefWithAnchorWithSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithoutRefWithAnchorWithSeparateOutputFiles) ].	self assert: (resultString includesSubstring: 'Alias')! !!PRDocumentWriterTest methodsFor: 'tests-internalLinks'!testInternalLinkWithoutAliasWithRefWithAncorWithSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add: (PRInternalLink reference: 'ref.pillar@foo');		yourself.	resultString := self writeWithSeparateOutputFiles: item.	self resultWithRefWithAnchorWithSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithRefWithAnchorWithSeparateOutputFiles) ]! !!PRDocumentWriterTest methodsFor: 'tests-internalLinks'!testInternalLinkWithoutAliasWithReferenceWithoutAnchorWithSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add: (PRInternalLink reference: 'ref.pillar');		yourself.	resultString := self writeWithSeparateOutputFiles: item.	self resultWithRefWithoutAnchorWithSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithRefWithoutAnchorWithSeparateOutputFiles) ]! !!PRDocumentWriterTest methodsFor: 'tests-internalLinks'!testInternalLinkWithoutAliasWithoutReferenceWithAnchorWithSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:				((PRInternalLink reference: '@foo')						yourself);		yourself.	resultString := self writeWithSeparateOutputFiles: item.	self resultWithoutAliasWithoutRefWithAnchorWithSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithoutAliasWithoutRefWithAnchorWithSeparateOutputFiles) ]! !!PRDocumentWriterTest methodsFor: 'tests'!testItalicFormat	| item |	item := self addText: 'foo' to: PRItalicFormat new.	self		assertWriting: item		includesTexts:			{self italicFoo}! !!PRDocumentWriterTest methodsFor: 'tests'!testLanguageForScript	| item smalltalk writer http |	writer := self instance.	item := PRCodeblock content: 'foo'.		self assert: (writer languageForScript: item) class equals: PRUnspecifiedScriptLanguage. 			smalltalk := PRSmalltalkScriptLanguage new.	self configuration defaultScriptLanguage: smalltalk.	self assert: (writer languageForScript: item) equals: smalltalk.		http := PRHTTPScriptLanguage new.	item := (PRCodeblock content: 'foo') language: http.	self assert: (writer languageForScript: item) equals: http! !!PRDocumentWriterTest methodsFor: 'tests'!testLanguageForScript2	"This test documents how to map values to script languages"		self assert: (PRRealScriptLanguage for: nil) class equals: PRUnspecifiedScriptLanguage.	self assert: (PRRealScriptLanguage for: 'nil') class equals:  PRUnsupportedScriptLanguage.	self assert: (PRRealScriptLanguage for: '') class equals:  PRUnsupportedScriptLanguage.	self assert: (PRRealScriptLanguage for: 'smalltalk') class equals:  PRSmalltalkScriptLanguage.! !!PRDocumentWriterTest methodsFor: 'tests'!testMailLink	| item |	configuration propertyAt: #scrambledEmailAddresses put: false.	item := self addText: 'Foo Bar' to: (PRMailLink reference: 'foo@bar.com').	self		assertWriting: item		includesTexts:			{self emailToFoo . 'Foo Bar'}! !!PRDocumentWriterTest methodsFor: 'tests'!testMarkupType	| markupType |	markupType := self instance markupType.	self assert: markupType isNotNil.	self assert: markupType isSymbol! !!PRDocumentWriterTest methodsFor: 'tests'!testMonospaceFormat	| item |	item := self addText: 'foo' to: PRMonospaceFormat new.	self		assertWriting: item		includesTexts:			{self monospaceFoo}! !!PRDocumentWriterTest methodsFor: 'tests'!testOrderedList	| item |	item := PROrderedList new		add: (self addText: '1' to: PRListItem new);		yourself.	self		assertWriting: item		includesTexts:			{(self orderedListBegin).			(self listItemWith1)}! !!PRDocumentWriterTest methodsFor: 'tests'!testParagraph	| item |	item := self addText: 'foo' to: PRParagraph new.	self assertWriting: item includesText: self paragraphFoo! !!PRDocumentWriterTest methodsFor: 'tests'!testPreformatted	| item |	item := self addText: 'foo' to: PRPreformatted new.	self assertWriting: item includesTexts: {self preformattedFooBegin . self preformattedTextFoo}! !!PRDocumentWriterTest methodsFor: 'tests'!testPreformattedWithMultipleLines	| item |	item := PRPreformatted new		add: (PRText content: 'foo');		add: (PRText content: 'bar');		yourself.	self assertWriting: item includesText: 'foo' , self configuration newLine! !!PRDocumentWriterTest methodsFor: 'tests'!testRaw	| item |	item := PRRaw content: self rawText.	self		assertWriting: item		includesText:			self rawText! !!PRDocumentWriterTest methodsFor: 'tests'!testScript	| item |	item := PRCodeblock content: 'foo'.	self assertWriting: item includesTexts: {self scriptWithoutCaptionBegin . self foo}! !!PRDocumentWriterTest methodsFor: 'tests'!testScriptDefaultLanguage	| item |	self supportSyntaxHighlighting		ifFalse: [ self skip ].	item := PRCodeblock content: 'foo'.	configuration defaultScriptLanguage: PRHTMLScriptLanguage default.	self assertWriting: item includesTexts: {PRHTMLScriptLanguage standardName}! !!PRDocumentWriterTest methodsFor: 'tests'!testScriptLabelGenerateAnchor	| item |	item := (PRCodeblock content: 'foo')		label: 'myScript';		yourself.	self		assertWriting: item		includesTexts:			{(self scriptAnchorForMyScript).			'myScript'}! !!PRDocumentWriterTest methodsFor: 'tests'!testScriptLanguage	| item |	self supportSyntaxHighlighting ifFalse: [ self skip ].	item := (PRCodeblock content: 'foo')		language: 'html';		yourself.	self assertWriting: item includesTexts: {(PRHTMLScriptLanguage standardName)}! !!PRDocumentWriterTest methodsFor: 'tests'!testScriptWithFormattedCaption	| item |	item := (PRCodeblock content: 'bar')		caption: '""foo""';		yourself.	self assertWriting: item includesText: self boldFoo! !!PRDocumentWriterTest methodsFor: 'tests'!testScriptWithProblematicEval	| item nonExistingMethod |	nonExistingMethod := 'FooBarDoesNotExistX'.	item := (PRCodeblock content: 'Object ' , nonExistingMethod)		eval: true;		yourself.	self assert: item isEvaluated.	self assertWriting: item includesText: nonExistingMethod! !!PRDocumentWriterTest methodsFor: 'tests'!testScriptsHaveACaption	| item caption |	caption := 'A description'.	item := (PRCodeblock content: 'foo')		caption:  caption;		yourself.	self		assertWriting: item		includesTexts:			{(self scriptWithCaptionBegin).			caption}! !!PRDocumentWriterTest methodsFor: 'tests'!testSpecifyPackageNamesUnderTest	self assert: self packageNamesUnderTest isCollection.	self denyEmpty: self packageNamesUnderTest.	self packageNamesUnderTest do: [ :packageName | self denyEmpty: (RPackage organizer packageNamed: packageName) methods ]! !!PRDocumentWriterTest methodsFor: 'tests'!testStrikethroughFormat	| item |	item := self addText: 'foo' to: PRStrikethroughFormat new.	self		assertWriting: item		includesTexts:			{self strikethroughFoo}! !!PRDocumentWriterTest methodsFor: 'tests'!testSubscriptFormat	| item |	item := self addText: 'foo' to: PRSubscriptFormat new.	self		assertWriting: item		includesTexts:			{self subscriptFoo}! !!PRDocumentWriterTest methodsFor: 'tests'!testSuperscriptFormat	| item |	item := self addText: 'foo' to: PRSuperscriptFormat new.	self		assertWriting: item		includesTexts:			{self superscriptFoo}! !!PRDocumentWriterTest methodsFor: 'tests'!testTable	| item |	item := PRTable new		add:				(PRTableRow new						add: (self addText: 'foo' to: PRTableCell new);						yourself);		yourself.	self		assertWriting: item		includesTexts:			{(self tableBegin).			(self tableRow).			(self tableCellWithFoo)}! !!PRDocumentWriterTest methodsFor: 'tests'!testTableWith2CellsInARow	| item |	item := PRTable new		add:				(PRTableRow new						add: (self addText: 'foo' to: PRTableCell new);						add: (self addText: 'foo' to: PRTableCell new);						yourself);		yourself.	self		assertWriting: item		includesTexts:			{(self tableBegin).			(self tableRow).			(self tableCellWithFoo)}.	^ item! !!PRDocumentWriterTest methodsFor: 'tests'!testTableWithHeading	| item |	item := PRTable new		add:				(PRTableRow new						add:								(self										addText: 'foo'										to:											(PRTableCell new												beHeading;												yourself));						yourself);		yourself.	self		assertWriting: item		includesTexts:			{(self tableBegin).			(self tableRow).			(self tableCellWithHeadingFoo)}! !!PRDocumentWriterTest methodsFor: 'tests'!testUnderlineFormat	| item |	item := self addText: 'foo' to: PRUnderlineFormat new.	self		assertWriting: item		includesTexts:			{self underlineFoo}! !!PRDocumentWriterTest methodsFor: 'tests'!testUnorderedList	| item |	item := PRUnorderedList new		add: (self addText: '1' to: PRListItem new);		yourself.	self		assertWriting: item		includesTexts:			{(self unorderedListBegin).			(self listItemWith1)}! !!PRDocumentWriterTest methodsFor: 'tests'!testWritersAreNotResponsibleForHeadingLevelOffset	| item |	item := PRHeader new		level: 1;		add: (PRText content: 'foo');		yourself.	self assertWriting: item includesTexts: {self level1HeaderWithFoo}.	self configuration headingLevelOffset: 2.	"Writers should *not* take care of headingLevelOffset:"	self assertWriting: item includesTexts: {self level1HeaderWithFoo}! !!PRDocumentWriterTest methodsFor: 'requirements'!underlineFoo	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements'!unorderedListBegin	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements'!widthFor50percents	^ '50'! !!PRDocumentWriterTest methodsFor: 'helpers'!write: aDocumentItem	^ String		streamContents: [ :stream | 			| writer |			writer := self createWriterOn: stream.			writer start: aDocumentItem ]! !!PRDocumentWriterTest methodsFor: 'helpers'!writeWithSeparateOutputFiles: aDocumentItem	| writer |	^ String		streamContents: [ :stream | 			writer := self createWriterWithSeparateOutputFilesOn: stream.			writer start: aDocumentItem ]! !!PRManualNumberingWriterTest class methodsFor: 'testing'!isAbstract	"Override to true if a TestCase subclass is Abstract and should not have	TestCase instances built from it"	^self name = #PRManualNumberingWriterTest! !!PRManualNumberingWriterTest methodsFor: 'requirements'!counter11DefinitionString	^ '1.1. '! !!PRManualNumberingWriterTest methodsFor: 'requirements'!counter11ReferenceString	^ '1.1'! !!PRManualNumberingWriterTest methodsFor: 'requirements'!counter1DefinitionString	^ '1. '! !!PRManualNumberingWriterTest methodsFor: 'requirements'!counter1ReferenceString	^ '1'! !!PRManualNumberingWriterTest methodsFor: 'requirements'!counter2DefinitionString	^ '2. '! !!PRManualNumberingWriterTest methodsFor: 'requirements'!level1HeaderWith1Foo	^ self level1HeaderBegin , self counter1DefinitionString , self foo! !!PRManualNumberingWriterTest methodsFor: 'requirements'!level2HeaderWith11Foo	^ self level2HeaderBegin , self counter11DefinitionString , self foo! !!PRManualNumberingWriterTest methodsFor: 'requirements'!level2HeaderWith1Foo	^ self level2HeaderBegin , self counter1DefinitionString , self foo! !!PRManualNumberingWriterTest methodsFor: 'requirements'!level2HeaderWithFoo	^ self level2HeaderBegin , self foo! !!PRManualNumberingWriterTest methodsFor: 'requirements'!referenceToFigurePierLogo	^ '0.1'! !!PRManualNumberingWriterTest methodsFor: 'tests'!testHeadersAreNumbered	| item |	item := PRDocument new		add:				(PRHeader new						level: 1;						add: (PRText content: 'foo');						counter: ((PRCascadingCounter maxLevel: 5) incrementAt: 1);						yourself);		add:				(PRHeader new						level: 1;						add: (PRText content: 'foo');						counter:								((PRCascadingCounter maxLevel: 5)										incrementAt: 1;										incrementAt: 1);						yourself);		yourself.		self configuration printer level1: (PRLevelNumberPrinter new level: 1 ; headerSize: 1; yourself).		self		assertWriting: item		includesTexts:			{self counter1DefinitionString.			self counter2DefinitionString}! !!PRManualNumberingWriterTest methodsFor: 'tests'!testReferenceToFigureAnchor	| item resultString indexOfReference referenceString |	item := PRDocument new		add:				(PRHeader new						level: 1;						add: (PRText content: 'foo');						counter: ((PRCascadingCounter maxLevel: 5) incrementAt: 1);						yourself);		add:				(PRParagraph new						add:								(PRFigure new										reference: 'file://picture.png';										parameterAt: 'label' put: 'fig:picture';										counter:												((PRCascadingCounter maxLevel: 5)														incrementAt: 1;														incrementAt: 2);										yourself);						add: (PRText content: 'See Figure ');						add:								((PRInternalLink reference: 'fig:picture')										counter:												((PRCascadingCounter maxLevel: 5)														incrementAt: 1;														incrementAt: 2);										yourself);						yourself).	[resultString := self write: item] on: PRLinkWarning do: [:w | w resume ].	indexOfReference := resultString		indexOfSubCollection: 'See Figure '		startingAt: 1		ifAbsent: [ self fail: 'The string ''See Figure '' should have been found' ].	referenceString := resultString allButFirst: indexOfReference - 1.	self assert: referenceString includesSubstring: self counter11ReferenceString! !!PRManualNumberingWriterTest methodsFor: 'tests'!testReferenceToHeaderAnchor	| item resultString indexOfReference referenceString |	item := PRDocument new		add:				(PRHeader new						level: 1;						add: (PRText content: 'foo');						counter: ((PRCascadingCounter maxLevel: 5) incrementAt: 1);						yourself);		add: (PRAnchor named: 'chap:foo');		add:				(PRParagraph new						add: (PRText content: 'See Chapter ');						add:								((PRInternalLink reference: 'chap:foo')										counter: ((PRCascadingCounter maxLevel: 5) incrementAt: 1);										yourself);						yourself);		yourself.	[resultString := self write: item] on: PRLinkWarning do: [:w | w resume ].	indexOfReference := resultString		indexOfSubCollection: 'See Chapter '		startingAt: 1		ifAbsent: [ self fail: 'The string ''See Chapter '' should have been found' ].	referenceString := resultString allButFirst: indexOfReference - 1.	self assert: referenceString includesSubstring: self counter1ReferenceString! !!PRManualNumberingWriterTest methodsFor: 'tests'!testSubHeadersAreNumbered	| item |	item := PRDocument new		add:				(PRHeader new						level: 1;						add: (PRText content: 'foo');						counter: ((PRCascadingCounter maxLevel: 5) incrementAt: 1);						yourself);		add:				(PRHeader new						level: 2;						add: (PRText content: 'foo');						counter:								((PRCascadingCounter maxLevel: 5)										incrementAt: 1;										incrementAt: 2);						yourself);		yourself.	self configuration printer  level1: (PRLevelNumberPrinter new headerSize: 1; level: 1; yourself). 	self		assertWriting: item		includesTexts:			{self counter1DefinitionString.			self counter11DefinitionString}! !!PRDocumentWriterTest2 class methodsFor: 'testing'!isAbstract	"Override to true if a TestCase subclass is Abstract and should not have	TestCase instances built from it"	^self name = #PRDocumentWriterTest2! !!PRDocumentWriterTest2 methodsFor: 'private'!actualClass	^ PRDocumentWriter! !!PRDocumentWriterTest2 methodsFor: 'private'!actualInstance	^  self createWriterOn: String new! !!PRDocumentWriterTest2 methodsFor: 'tests'!annotation		^ self shouldBeImplemented.  ! !!PRDocumentWriterTest2 methodsFor: 'asserting'!assert: result includesSubstring: expected	expected ifEmpty: [ ^ self ].	self assert: (result includesSubstring: expected) description: ('''{1}'' not in ''{2}''' format: {expected . result})! !!PRDocumentWriterTest2 methodsFor: 'asserting'!assertWriting: aDocumentItem includesText: aString	| result |	result := self write: aDocumentItem.	self assert: result includesSubstring: aString! !!PRDocumentWriterTest2 methodsFor: 'asserting'!assertWriting: aDocumentItem includesTexts: aCollection	| resultString |	resultString := self write: aDocumentItem.	aCollection do: [ :testString | self assert: resultString includesSubstring: testString ]! !!PRDocumentWriterTest2 methodsFor: 'requirements'!boldFoo	^ self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'helpers'!configuration	^ configuration ifNil: [ configuration := self configurationClass new ]! !!PRDocumentWriterTest2 methodsFor: 'helpers'!configurationClass	^ ConfigurationForPillar! !!PRDocumentWriterTest2 methodsFor: 'helpers'!createWriterOn: aWriteStream 	^ (self actualClass on: aWriteStream)		configuration: self configuration;		yourself! !!PRDocumentWriterTest2 methodsFor: 'helpers'!createWriterWithSeparateOutputFilesOn: aWriteStream	^ (self actualClass on: aWriteStream)		configuration:				(self configurationClass new						separateOutputFiles: true;						yourself);		yourself! !!PRDocumentWriterTest2 methodsFor: 'requirements'!dataItemWithBar	^ self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirements'!definitionListBegin	self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirements'!emailToFoo	^ self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirements'!figureAnchorForPierLogo	^ self subclassResponsibility ! !!PRDocumentWriterTest2 methodsFor: 'requirements'!figureBegin	^ self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'data'!foo	^ 'foo'! !!PRDocumentWriterTest2 methodsFor: 'requirements'!footnoteBar	^ ''! !!PRDocumentWriterTest2 methodsFor: 'requirements'!horizontalRule	^ self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirements'!italicFoo	^ self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirements'!level1HeaderBegin	^ self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirements'!level1HeaderWithFoo	^ self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirements'!level2HeaderBegin	^ self subclassResponsibility ! !!PRDocumentWriterTest2 methodsFor: 'requirements'!listItemWith1	^ self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirements'!monospaceFoo	^ self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirements'!orderedListBegin	^ self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirements'!packageNamesUnderTest	^ self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirements'!paragraphFoo	^ self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'helpers'!parser	^ PRPillarParserMain! !!PRDocumentWriterTest2 methodsFor: 'requirements'!preformattedFooBegin	^ self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirements'!preformattedTextFoo	^ self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirements'!rawText	^ self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirements'!referenceToFigurePierLogo	^ self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirement-InternalLinks'!resultWithRefWithAnchorWithSeparateOutputFiles	self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirement-InternalLinks'!resultWithRefWithAnchorWithoutSeparateOutputFiles	self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirement-InternalLinks'!resultWithRefWithoutAnchorWithSeparateOutputFiles	self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirement-InternalLinks'!resultWithRefWithoutAnchorWithoutSeparateOutputFiles	self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirement-InternalLinks'!resultWithoutAliasWithRefWithAnchorWithoutSeparateOutputFiles	self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirement-InternalLinks'!resultWithoutAliasWithoutRefWithAnchorWithSeparateOutputFiles	self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirement-InternalLinks'!resultWithoutAliasWithoutRefWithAnchorWithoutSeparateOutputFiles	self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirement-InternalLinks'!resultWithoutRefWithAnchorWithSeparateOutputFiles	self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirement-InternalLinks'!resultWithoutRefWithAnchorWithoutSeparateOutputFiles	self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirements'!scriptAnchorForMyScript	^ self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirements'!scriptWithCaptionBegin	^ self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirements'!scriptWithoutCaptionBegin	^ self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirements'!strikethroughFoo	^ self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirements'!subscriptFoo	^ self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirements'!superscriptFoo	^ self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'tests'!supportSyntaxHighlighting	^ true! !!PRDocumentWriterTest2 methodsFor: 'requirements'!tableBegin	^ self subclassResponsibility ! !!PRDocumentWriterTest2 methodsFor: 'requirements'!tableCellWithFoo	^ self subclassResponsibility ! !!PRDocumentWriterTest2 methodsFor: 'requirements'!tableCellWithHeadingFoo	^ self subclassResponsibility ! !!PRDocumentWriterTest2 methodsFor: 'requirements'!tableRow	^ self subclassResponsibility ! !!PRDocumentWriterTest2 methodsFor: 'requirements'!termItemWithFoo	^ self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'tests'!testAnnotation	| item |	{ 'note' . 'dothis' } do:	[	:annotation |			item := PRAnnotatedParagraph new			annotation: annotation;			add: (PRText content: 'foo');			yourself.		self 			assertWriting: item			includesTexts: 				{self annotationBegin: annotation . 'foo'}. 	].! !!PRDocumentWriterTest2 methodsFor: 'tests'!testBoldFormat	| item |	item := self addText: 'foo' to: PRBoldFormat new.	self		assertWriting: item		includesTexts:			{self boldFoo}! !!PRDocumentWriterTest2 methodsFor: 'tests'!testCommentedLineNotVisibleInOutput	| item result |	item := PRCommentedLine content: 'some comment'.	result := self write: item.	self assertEmpty: result! !!PRDocumentWriterTest2 methodsFor: 'tests'!testConsecutiveTextsInAParagraphAreSeparatedByWhitespace	| item |	item := PRParagraph new		add: (PRText content: 'foo');		add: (PRLineBreak new);		add: (PRText content: 'bar');		yourself.	self assertWriting: item includesText: 'foo', self configuration newLine, 'bar'! !!PRDocumentWriterTest2 methodsFor: 'tests'!testDefinitionList	| item |	item := PRDefinitionList new		add: (self addText: 'foo' to: PRTermItem new);		add: (self addText: 'bar' to: PRDataItem new);		yourself.	self		assertWriting: item		includesTexts:			{self definitionListBegin.			self termItemWithFoo.			self dataItemWithBar}! !!PRDocumentWriterTest2 methodsFor: 'tests'!testFigure	| item |	item := PRFigure new		reference: 'file://picture.png';		yourself.	self		assertWriting: item		includesText:			'picture.png'! !!PRDocumentWriterTest2 methodsFor: 'tests'!testFigureLabelGenerateAnchor	| item |	item := PRFigure new		reference: 'file://picture.png';		parameterAt: 'label' put: 'pierLogo';		yourself.	self		assertWriting: item		includesTexts:			{(self figureAnchorForPierLogo).			'pierLogo'}! !!PRDocumentWriterTest2 methodsFor: 'tests'!testFigureReference	| item resultString indexOfReference referenceString |	item := PRParagraph new		add:				(PRFigure new						reference: 'file://picture.png';						parameterAt: 'label' put: 'pierLogo';						counter: ((PRCascadingCounter maxLevel: 5) incrementAt: 2 );						yourself);		add: (PRText content: 'See figure ');		add: ((PRInternalLink reference: '@pierLogo') counter: ((PRCascadingCounter maxLevel: 5) incrementAt: 2 ));		yourself.		resultString := self write: item.	indexOfReference := resultString indexOfSubCollection: 'See figure ' startingAt: 1 ifAbsent: [ self fail: 'The string ''See figure '' should have been found' ].	referenceString := resultString allButFirst: indexOfReference - 1.	self assert: referenceString includesSubstring: self referenceToFigurePierLogo! !!PRDocumentWriterTest2 methodsFor: 'tests'!testFigureWithLabelAndWithCaptionAreExportedWithEnvironment	| item |	item := PRFigure new		reference: 'file://picture.png';		add: (PRText content: 'caption');		label: 'label';		yourself.	self assertWriting: item includesText: self figureBegin! !!PRDocumentWriterTest2 methodsFor: 'tests'!testFigureWithLabelAndWithoutCaptionAreExportedWithEnvironment	| item |	item := PRFigure new		reference: 'file://picture.png';		label: 'label';		yourself.	self assertWriting: item includesText: self figureBegin! !!PRDocumentWriterTest2 methodsFor: 'tests'!testFigureWithWidth	| item width |	width := '50'.	item := PRFigure new		reference: 'file://picture.png';		parameterAt: 'width' put: width;		yourself.	self assertWriting: item includesText: self widthFor50percents! !!PRDocumentWriterTest2 methodsFor: 'tests'!testFigureWithoutLabelAndWithCaptionAreExportedWithEnvironment	| item |	item := PRFigure new		reference: 'file://picture.png';		add: (PRText content: 'caption');		yourself.	self assertWriting: item includesText: self figureBegin! !!PRDocumentWriterTest2 methodsFor: 'tests'!testFigureWithoutLabelAndWithoutCaptionAreExportedWithoutEnvironment	| item result |	item := PRFigure new		reference: 'file://picture.png';		yourself.	result := self write: item.	self figureBegin ifNotEmpty: [ self deny: (result includesSubstring: self figureBegin) ]! !!PRDocumentWriterTest2 methodsFor: 'tests'!testFiguresHaveACaption	| item caption filename |	caption := 'A description'.	filename := 'picture.png'.	item := PRFigure new		reference: 'file://' , filename;		label: 'picture';		add: (PRText content: caption);		yourself.	self		assertWriting: item		includesTexts:			{(self figureBegin).			filename.			caption}! !!PRDocumentWriterTest2 methodsFor: 'tests'!testFileExtension	| fileExtension |	fileExtension := self instance fileExtension.	self assert: fileExtension isNotNil.	self assert: fileExtension isString! !!PRDocumentWriterTest2 methodsFor: 'tests-internalLinks'!testFootnote	| item |	item := PRParagraph new		add: (PRText content: 'timo');		add: (PRFootnote noted: 'Bar');		add: (PRText content: 'leon');		yourself.	self assertWriting: item includesText: self footnoteBar! !!PRDocumentWriterTest2 methodsFor: 'tests'!testHasName	self denyEmpty: self actualClass writerName! !!PRDocumentWriterTest2 methodsFor: 'tests'!testHeader	| item |	item := PRHeader new		level: 1;		add: (PRText content: 'foo');		yourself.	self assertWriting: item includesTexts: {self level1HeaderWithFoo}.! !!PRDocumentWriterTest2 methodsFor: 'tests'!testHorizontalRule	| item  |	item := PRHorizontalRule new.	self assertWriting: item includesText: self horizontalRule! !!PRDocumentWriterTest2 methodsFor: 'tests-internalLinks'!testInternalLinkWithAliasWithRefWithAncorWithSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:				((PRInternalLink reference: 'ref.pillar@foo')						addAll: {(PRText content: 'Alias')};						yourself);		yourself.	resultString := self writeWithSeparateOutputFiles: item.	self resultWithRefWithAnchorWithSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithRefWithAnchorWithSeparateOutputFiles) ].	self assert: (resultString includesSubstring: 'Alias')! !!PRDocumentWriterTest2 methodsFor: 'tests-internalLinks'!testInternalLinkWithAliasWithRefWithAncorWithoutSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:				((PRInternalLink reference: 'ref.pillar@foo')						addAll: {(PRText content: 'Alias')};						yourself);		yourself.	resultString := self write: item.	self resultWithRefWithAnchorWithoutSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithRefWithAnchorWithoutSeparateOutputFiles) ].	self assert: (resultString includesSubstring: 'Alias')! !!PRDocumentWriterTest2 methodsFor: 'tests-internalLinks'!testInternalLinkWithAliasWithReferenceWithoutAnchorWithSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:				((PRInternalLink reference: 'ref.pillar')						addAll: {(PRText content: 'Alias')};						yourself);		yourself.	resultString := self writeWithSeparateOutputFiles: item.	self resultWithRefWithoutAnchorWithSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithRefWithoutAnchorWithSeparateOutputFiles) ].	self assert: (resultString includesSubstring: 'Alias')! !!PRDocumentWriterTest2 methodsFor: 'tests-internalLinks'!testInternalLinkWithAliasWithReferenceWithoutAnchorWithoutSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:				((PRInternalLink reference: 'ref.pillar')						addAll: {(PRText content: 'Alias')};						yourself);		yourself.	resultString := self write: item.	self resultWithRefWithoutAnchorWithoutSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithRefWithoutAnchorWithoutSeparateOutputFiles) ].	self assert: (resultString includesSubstring: 'Alias')! !!PRDocumentWriterTest2 methodsFor: 'tests-internalLinks'!testInternalLinkWithAliasWithoutReferenceWithAnchorWithSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:				((PRInternalLink reference: '@foo')						addAll: {(PRText content: 'Alias')};						yourself);		yourself.	resultString := self writeWithSeparateOutputFiles: item.	self resultWithoutRefWithAnchorWithSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithoutRefWithAnchorWithSeparateOutputFiles) ].	self assert: (resultString includesSubstring: 'Alias')! !!PRDocumentWriterTest2 methodsFor: 'tests-internalLinks'!testInternalLinkWithAliasWithoutReferenceWithAnchorWithoutSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:				((PRInternalLink reference: '@foo')						addAll: {(PRText content: 'Alias')};						yourself);		yourself.	resultString := self write: item.	self resultWithoutRefWithAnchorWithoutSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithoutRefWithAnchorWithoutSeparateOutputFiles) ].	self assert: (resultString includesSubstring: 'Alias')! !!PRDocumentWriterTest2 methodsFor: 'tests-internalLinks'!testInternalLinkWithoutAliasWithRefWithAncorWithSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add: (PRInternalLink reference: 'ref.pillar@foo');		yourself.	resultString := self writeWithSeparateOutputFiles: item.	self resultWithRefWithAnchorWithSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithRefWithAnchorWithSeparateOutputFiles) ]! !!PRDocumentWriterTest2 methodsFor: 'tests-internalLinks'!testInternalLinkWithoutAliasWithRefWithAncorWithoutSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add: (PRInternalLink reference: 'ref.pillar@foo');		yourself.	resultString := self write: item.	self resultWithoutAliasWithRefWithAnchorWithoutSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithoutAliasWithRefWithAnchorWithoutSeparateOutputFiles) ]! !!PRDocumentWriterTest2 methodsFor: 'tests-internalLinks'!testInternalLinkWithoutAliasWithReferenceWithoutAnchorWithSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add: (PRInternalLink reference: 'ref.pillar');		yourself.	resultString := self writeWithSeparateOutputFiles: item.	self resultWithRefWithoutAnchorWithSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithRefWithoutAnchorWithSeparateOutputFiles) ]! !!PRDocumentWriterTest2 methodsFor: 'tests-internalLinks'!testInternalLinkWithoutAliasWithReferenceWithoutAnchorWithoutSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:				((PRInternalLink reference: 'ref.pillar')						yourself);		yourself.	resultString := self write: item.	self resultWithRefWithoutAnchorWithoutSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithRefWithoutAnchorWithoutSeparateOutputFiles) ].! !!PRDocumentWriterTest2 methodsFor: 'tests-internalLinks'!testInternalLinkWithoutAliasWithoutReferenceWithAnchorWithSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:				((PRInternalLink reference: '@foo')						yourself);		yourself.	resultString := self writeWithSeparateOutputFiles: item.	self resultWithoutAliasWithoutRefWithAnchorWithSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithoutAliasWithoutRefWithAnchorWithSeparateOutputFiles) ]! !!PRDocumentWriterTest2 methodsFor: 'tests-internalLinks'!testInternalLinkWithoutAliasWithoutReferenceWithAnchorWithoutSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:				((PRInternalLink reference: '@foo')						yourself);		yourself.	resultString := self write: item.	self resultWithoutAliasWithoutRefWithAnchorWithoutSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithoutAliasWithoutRefWithAnchorWithoutSeparateOutputFiles) ]! !!PRDocumentWriterTest2 methodsFor: 'tests'!testItalicFormat	| item |	item := self addText: 'foo' to: PRItalicFormat new.	self		assertWriting: item		includesTexts:			{self italicFoo}! !!PRDocumentWriterTest2 methodsFor: 'tests'!testLanguageForScript	| item smalltalk writer http |	writer := self instance.	item := PRCodeblock content: 'foo'.		self assert: (writer languageForScript: item) class equals: PRUnspecifiedScriptLanguage. 			smalltalk := PRSmalltalkScriptLanguage new.	self configuration defaultScriptLanguage: smalltalk.	self assert: (writer languageForScript: item) equals: smalltalk.		http := PRHTTPScriptLanguage new.	item := (PRCodeblock content: 'foo') language: http.	self assert: (writer languageForScript: item) equals: http! !!PRDocumentWriterTest2 methodsFor: 'tests'!testLanguageForScript2	"This test documents how to map values to script languages"		self assert: (PRRealScriptLanguage for: nil) class equals: PRUnspecifiedScriptLanguage.	self assert: (PRRealScriptLanguage for: 'nil') class equals:  PRUnsupportedScriptLanguage.	self assert: (PRRealScriptLanguage for: '') class equals:  PRUnsupportedScriptLanguage.	self assert: (PRRealScriptLanguage for: 'smalltalk') class equals:  PRSmalltalkScriptLanguage.! !!PRDocumentWriterTest2 methodsFor: 'tests'!testMailLink	| item |	configuration propertyAt: #scrambledEmailAddresses put: false.	item := self addText: 'Foo Bar' to: (PRMailLink reference: 'foo@bar.com').	self		assertWriting: item		includesTexts:			{self emailToFoo . 'Foo Bar'}! !!PRDocumentWriterTest2 methodsFor: 'tests'!testMarkupType	| markupType |	markupType := self instance markupType.	self assert: markupType isNotNil.	self assert: markupType isSymbol! !!PRDocumentWriterTest2 methodsFor: 'tests'!testMonospaceFormat	| item |	item := self addText: 'foo' to: PRMonospaceFormat new.	self		assertWriting: item		includesTexts:			{self monospaceFoo}! !!PRDocumentWriterTest2 methodsFor: 'tests'!testOrderedList	| item |	item := PROrderedList new		add: (self addText: '1' to: PRListItem new);		yourself.	self		assertWriting: item		includesTexts:			{(self orderedListBegin).			(self listItemWith1)}! !!PRDocumentWriterTest2 methodsFor: 'tests'!testParagraph	| item |	item := self addText: 'foo' to: PRParagraph new.	self assertWriting: item includesText: self paragraphFoo! !!PRDocumentWriterTest2 methodsFor: 'tests'!testPreformatted	| item |	item := self addText: 'foo' to: PRPreformatted new.	self assertWriting: item includesTexts: {self preformattedFooBegin . self preformattedTextFoo}! !!PRDocumentWriterTest2 methodsFor: 'tests'!testPreformattedWithMultipleLines	| item |	item := PRPreformatted new		add: (PRText content: 'foo');		add: (PRText content: 'bar');		yourself.	self assertWriting: item includesText: 'foo' , self configuration newLine! !!PRDocumentWriterTest2 methodsFor: 'tests'!testRaw	| item |	item := PRRaw content: self rawText.	self		assertWriting: item		includesText:			self rawText! !!PRDocumentWriterTest2 methodsFor: 'tests'!testScript	| item |	item := PRCodeblock content: 'foo'.	self assertWriting: item includesTexts: {self scriptWithoutCaptionBegin . self foo}! !!PRDocumentWriterTest2 methodsFor: 'tests'!testScriptDefaultLanguage	| item |	self supportSyntaxHighlighting		ifFalse: [ self skip ].	item := PRCodeblock content: 'foo'.	configuration defaultScriptLanguage: PRHTMLScriptLanguage default.	self assertWriting: item includesTexts: {PRHTMLScriptLanguage standardName}! !!PRDocumentWriterTest2 methodsFor: 'tests'!testScriptLabelGenerateAnchor	| item |	item := (PRCodeblock content: 'foo')		label: 'myScript';		yourself.	self		assertWriting: item		includesTexts:			{(self scriptAnchorForMyScript).			'myScript'}! !!PRDocumentWriterTest2 methodsFor: 'tests'!testScriptLanguage	| item |	self supportSyntaxHighlighting ifFalse: [ self skip ].	item := (PRCodeblock content: 'foo')		language: 'html';		yourself.	self assertWriting: item includesTexts: {(PRHTMLScriptLanguage standardName)}! !!PRDocumentWriterTest2 methodsFor: 'tests'!testScriptWithFormattedCaption	| item |	item := (PRCodeblock content: 'bar')		caption: '""foo""';		yourself.	self assertWriting: item includesText: self boldFoo! !!PRDocumentWriterTest2 methodsFor: 'tests'!testScriptWithProblematicEval	| item nonExistingMethod |	nonExistingMethod := 'FooBarDoesNotExistX'.	item := (PRCodeblock content: 'Object ' , nonExistingMethod)		eval: true;		yourself.	self assert: item isEvaluated.	self assertWriting: item includesText: nonExistingMethod! !!PRDocumentWriterTest2 methodsFor: 'tests'!testScriptsHaveACaption	| item caption |	caption := 'A description'.	item := (PRCodeblock content: 'foo')		caption:  caption;		yourself.	self		assertWriting: item		includesTexts:			{(self scriptWithCaptionBegin).			caption}! !!PRDocumentWriterTest2 methodsFor: 'tests'!testSpecifyPackageNamesUnderTest	self assert: self packageNamesUnderTest isCollection.	self denyEmpty: self packageNamesUnderTest.	self packageNamesUnderTest do: [ :packageName | self denyEmpty: (RPackage organizer packageNamed: packageName) methodReferences ]! !!PRDocumentWriterTest2 methodsFor: 'tests'!testStrikethroughFormat	| item |	item := self addText: 'foo' to: PRStrikethroughFormat new.	self		assertWriting: item		includesTexts:			{self strikethroughFoo}! !!PRDocumentWriterTest2 methodsFor: 'tests'!testSubscriptFormat	| item |	item := self addText: 'foo' to: PRSubscriptFormat new.	self		assertWriting: item		includesTexts:			{self subscriptFoo}! !!PRDocumentWriterTest2 methodsFor: 'tests'!testSuperscriptFormat	| item |	item := self addText: 'foo' to: PRSuperscriptFormat new.	self		assertWriting: item		includesTexts:			{self superscriptFoo}! !!PRDocumentWriterTest2 methodsFor: 'tests'!testTable	| item |	item := PRTable new		add:				(PRTableRow new						add: (self addText: 'foo' to: PRTableCell new);						yourself);		yourself.	self		assertWriting: item		includesTexts:			{(self tableBegin).			(self tableRow).			(self tableCellWithFoo)}! !!PRDocumentWriterTest2 methodsFor: 'tests'!testTableWith2CellsInARow	| item |	item := PRTable new		add:				(PRTableRow new						add: (self addText: 'foo' to: PRTableCell new);						add: (self addText: 'foo' to: PRTableCell new);						yourself);		yourself.	self		assertWriting: item		includesTexts:			{(self tableBegin).			(self tableRow).			(self tableCellWithFoo)}.	^ item! !!PRDocumentWriterTest2 methodsFor: 'tests'!testTableWithHeading	| item |	item := PRTable new		add:				(PRTableRow new						add:								(self										addText: 'foo'										to:											(PRTableCell new												beHeading;												yourself));						yourself);		yourself.	self		assertWriting: item		includesTexts:			{(self tableBegin).			(self tableRow).			(self tableCellWithHeadingFoo)}! !!PRDocumentWriterTest2 methodsFor: 'tests'!testUnderlineFormat	| item |	item := self addText: 'foo' to: PRUnderlineFormat new.	self		assertWriting: item		includesTexts:			{self underlineFoo}! !!PRDocumentWriterTest2 methodsFor: 'tests'!testUnorderedList	| item |	item := PRUnorderedList new		add: (self addText: '1' to: PRListItem new);		yourself.	self		assertWriting: item		includesTexts:			{(self unorderedListBegin).			(self listItemWith1)}! !!PRDocumentWriterTest2 methodsFor: 'tests'!testWritersAreNotResponsibleForHeadingLevelOffset	| item |	item := PRHeader new		level: 1;		add: (PRText content: 'foo');		yourself.	self assertWriting: item includesTexts: {self level1HeaderWithFoo}.	self configuration headingLevelOffset: 2.	"Writers should *not* take care of headingLevelOffset:"	self assertWriting: item includesTexts: {self level1HeaderWithFoo}! !!PRDocumentWriterTest2 methodsFor: 'requirements'!underlineFoo	^ self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirements'!unorderedListBegin	^ self subclassResponsibility! !!PRDocumentWriterTest2 methodsFor: 'requirements'!widthFor50percents	^ '50'! !!PRDocumentWriterTest2 methodsFor: 'helpers'!write: aDocumentItem		^ String		streamContents: [ :stream | 			| writer |			writer := self createWriterOn: stream.			writer start: aDocumentItem ]! !!PRDocumentWriterTest2 methodsFor: 'helpers'!writeWithSeparateOutputFiles: aDocumentItem	| writer |	^ String		streamContents: [ :stream | 			writer := self createWriterWithSeparateOutputFilesOn: stream.			writer start: aDocumentItem ]! !!PRAnchorOfSectionTest methodsFor: 'private'!actualClass	^ PRAnchorOfSection! !!PRAnchorOfSectionTest methodsFor: 'tests'!testAnchorWithSimpleTitle	| input expected config |	config := self configuration.	config printer level2 autoAnchor: true. 		input := PRDocument new		add: (PRHeader new level: 2; add: (PRText content: 'foo'));		yourself.	expected := PRDocument new		add: (PRHeader new level: 2; add: (PRText content: 'foo'));		add: (PRAnchor named: 'foo@1');		yourself.	self assert: (self executePhase: input with: config) equals: expected! !!PRAnchorOfSectionTest methodsFor: 'tests'!testAnchorWithSimpleTitleAndAnchorNumberName	| input expected config |	config := self configuration.	config printer level2 autoAnchor: true. 	input := PRDocument new		add:				(PRHeader new	level: 2;						add: (PRText content: '42'));						add: (PRAnchor named: '42') yourself..		expected := PRDocument new		add:				(PRHeader new						level: 2;						add: (PRText content: '42'));		add: (PRAnchor named: '42@1');		add: (PRAnchor named: '42') yourself.	self assert: (self executePhase: input with: config) equals: expected! !!PRAnchorOfSectionTest methodsFor: 'tests'!testAnchorWithSimpleTitleAndAnchorWithSameName	| input expected config |	config := self configuration.	config printer level2 autoAnchor: true. 		input := PRDocument new		add:				(PRHeader new	level: 2;						add: (PRText content: 'foo'));						add: (PRAnchor named: 'foo@41') yourself.		expected := PRDocument new		add:				(PRHeader new						level: 2;						add: (PRText content: 'foo'));		add: (PRAnchor named: 'foo@42');		add: (PRAnchor named: 'foo@41') yourself.	self assert: (self executePhase: input with: config) equals: expected! !!PRAnchorOfSectionTest methodsFor: 'tests'!testAnchorWithTwoSameTitle	| input expected config |	config := self configuration.	config printer level2 autoAnchor: true. 		input := PRDocument new		add: (PRHeader new	level: 2; add: (PRText content: 'foo'));		add: (PRHeader new	level: 2; add: (PRText content: 'foo'));		yourself.	expected := PRDocument new		add: (PRHeader new level: 2; add: (PRText content: 'foo'));		add: (PRAnchor named: 'foo@1');		add: (PRHeader new level: 2; add: (PRText content: 'foo'));		add: (PRAnchor named: 'foo@2') yourself.	self assert: (self executePhase: input with: config) equals: expected! !!PRAnchorOfSectionTest methodsFor: 'tests'!testAnchorWithoutTitle	| input config |	config := self configuration.	input := PRDocument new		add: (PRText content: 'foo');		yourself.	self assert: (self executePhase: input with: config) equals: input! !!PRCitationTransformerTest methodsFor: 'private'!actualClass	^PRCitationTransformer! !!PRCitationTransformerTest methodsFor: 'tests'!testTransformWithAnnotationAndText	| input expected |	input := PRDocument new		add:			(PRParagraph new				add: (PRText new text: 'hello');				add: PRCitationAnnotation new;				add: (PRText new text: 'hello');				yourself).	expected := PRDocument new		add:			(PRParagraph new				add: (PRText new text: 'hello');				add: (PRCitation new);				add: (PRText new text: 'hello');				yourself).	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRCitationTransformerTest methodsFor: 'tests'!testTransformWithListInList	| input expected |	input := PRDocument new		add:			(PROrderedList new				add:					(PRUnorderedList new						add: PRCitationAnnotation new;						yourself);				yourself).	expected := PRDocument new		add:			(PROrderedList new				add:					(PRUnorderedList new						add: PRCitation new;						yourself);				yourself).	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRCitationTransformerTest methodsFor: 'tests'!testTransformWithOneAnnotation	| input expected |	input := PRDocument new		add: PRCitationAnnotation new;		yourself.	expected := PRDocument new add: PRCitation new.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRCitationTransformerTest methodsFor: 'tests'!testTransformWithOneAnnotationithRef	| input expected |	input := PRDocument new		add:			(PRCitationAnnotation new				parameterAt: 'ref' put: 'foo';				yourself).	expected := PRDocument new add: (PRCitation ref: 'foo').	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRCleanAnnotationInParagraphTransfomerTest methodsFor: 'private'!actualClass	^ PRCleanAnnotationInParagraphTransformer! !!PRCleanAnnotationInParagraphTransfomerTest methodsFor: 'helpers'!exampleAnnotation	^ PRFootnoteAnnotation new		parameterAt: 'note' put: 'Foo';		yourself! !!PRCleanAnnotationInParagraphTransfomerTest methodsFor: 'helpers'!exampleMisc	^ PRText content: 'foo'! !!PRCleanAnnotationInParagraphTransfomerTest methodsFor: 'tests'!testShouldNotBreakWithEmptyParagraph	| document |	document := PRDocument with: PREmptyParagraph new.	self executePhase: document! !!PRCleanAnnotationInParagraphTransfomerTest methodsFor: 'tests'!testShouldNotRemoveWhenSomethingElseFollowsTheAnnotationInParagraph	| document misc annotation |	annotation := self exampleAnnotation.	misc := self exampleMisc.	document := PRDocument with: (PRParagraph withAll: {annotation . misc}).	self assert: (document children first isKindOf: PRParagraph).	self deny: document children first equals: annotation.	self executePhase: document.	self assert: (document children first isKindOf: PRParagraph).	self deny: document children first equals: annotation! !!PRCleanAnnotationInParagraphTransfomerTest methodsFor: 'tests'!testShouldNotRemoveWhenSomethingElseThanAnnotationInParagraph	| document misc |	misc := self exampleMisc.	document := PRDocument with: (PRParagraph with: misc).	self assert: (document children first isKindOf: PRParagraph).	self deny: document children first equals: misc.	self executePhase: document.	self assert: (document children first isKindOf: PRParagraph).	self deny: document children first equals: misc! !!PRCleanAnnotationInParagraphTransfomerTest methodsFor: 'tests'!testShouldRemoveWhenAnnotationAloneInParagraph	| document annotation |	annotation := self exampleAnnotation.	document := PRDocument with: (PRParagraph with: annotation).	self assert: (document children first isKindOf: PRParagraph).	self deny: document children first equals: annotation.	self executePhase: document.	self deny: (document children first isKindOf: PRParagraph).	self assert: document children first equals: annotation! !!PRCleanAnnotationInParagraphTransfomerTest methodsFor: 'tests'!testShouldRemoveWhenAnnotationAloneWithLineBreakInParagraph	| document misc annotation |	annotation := self exampleAnnotation.	misc := PRLineBreak new.	document := PRDocument with: (PRParagraph withAll: {annotation . misc}).	self assert: (document children first isKindOf: PRParagraph).	self deny: document children first equals: annotation.	self executePhase: document.	self deny: (document children first isKindOf: PRParagraph).	self assert: document children first equals: annotation.	self assert: document children size equals: 1! !!PRColumnsTransformerTest methodsFor: 'private'!actualClass	^ PRColumnsTransformer! !!PRColumnsTransformerTest methodsFor: 'tests'!testTransformationBeginningColumnsWithoutEnding	| input |	input := PRDocument		withAll:			{PRBeginColumnsAnnotation new.			(PRColumnAnnotation				withParameters: (					PRParameters withAll: { 						PRParameter 							keyNode: (PRParameterKey named: 'width')							valueNode: (PRParameterValue value: 100) })).			(PRText content: 'Foo')}.	self should: [ self executePhase: input ] raise: PRError whoseDescriptionIncludes: 'Missing end' description: 'Code must detect the absence of end annotation'! !!PRColumnsTransformerTest methodsFor: 'tests'!testTransformationEndColumnsWithoutBeginning	| input |	input := PRDocument with: PREndColumnsAnnotation new.	self should: [ (self executePhase: input with: self configuration) ] raise: PRError whoseDescriptionIncludes: 'out of a column environment' description: 'Code should detect a missing annotation'! !!PRColumnsTransformerTest methodsFor: 'tests'!testTransformationOnColumn	| input expected |	input := PRDocument new		add:				PRBeginColumnsAnnotation new;		add:				(PRColumnAnnotation withParameters: (					PRParameters withAll: { 						PRParameter 							keyNode: (PRParameterKey named: 'width')							valueNode: (PRParameterValue value: '100') }));		add:	(PRParagraph new						add: (PRText content: 'Foo');						yourself);		add:				PREndColumnsAnnotation new;		yourself.	expected := PRDocument new		add:				(PRColumnEnvironment new						add:							((PRColumn width: '100')								add:										(PRParagraph new												add: (PRText content: 'Foo');												yourself);								yourself));		yourself.	self assert: (self executePhase: input) equals: expected! !!PRColumnsTransformerTest methodsFor: 'tests'!testTransformationTwoColumns	| input expected |	input := PRDocument new		add: PRBeginColumnsAnnotation new;		add:			(PRColumnAnnotation				withParameters: (					PRParameters withAll: { 						PRParameter 							keyNode: (PRParameterKey named: 'width')							valueNode: (PRParameterValue value: '50') }));		add:			(PRParagraph new				add: (PRText content: 'Foo');				yourself);		add:			(PRColumnAnnotation				withParameters: (					PRParameters withAll: { 						PRParameter 							keyNode: (PRParameterKey named: 'width')							valueNode: (PRParameterValue value: '50') }) yourself);		add:			(PRParagraph new				add: (PRText content: 'Bar');				yourself);		add: PREndColumnsAnnotation new;		yourself.	expected := PRDocument new		add:			(PRColumnEnvironment new				add:					((PRColumn width: '50')						add:							(PRParagraph new								add: (PRText content: 'Foo');								yourself));				add:					((PRColumn width: '50')						add:							(PRParagraph new								add: (PRText content: 'Bar');								yourself);						yourself));		yourself.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRColumnsTransformerTest methodsFor: 'tests'!testTransformationWithColumnWithoutColumns	| input |	input := PRDocument new		add: PRColumnAnnotation new;		add:			(PRParagraph new				add: (PRText content: 'Foo');				yourself);		add: PREndColumnsAnnotation new;		yourself.	self		should: [ self executePhase: input ]		raise: PRError		whoseDescriptionIncludes: 'not inside a column environment'		description: 'Code is missing a check'! !!PRColumnsTransformerTest methodsFor: 'tests'!testTransformationWithColumnsInColumns	| input |	input := PRDocument new		add:				PRBeginColumnsAnnotation new;		add:				PRBeginColumnsAnnotation new;		add:				PREndColumnsAnnotation new;		add:				PREndColumnsAnnotation new;		yourself.	self should: [ self executePhase: input ] raise: PRError whoseDescriptionIncludes: 'close a columns environment' description: 'Code is missing a check'! !!PRColumnsTransformerTest methodsFor: 'tests'!testTransformationWithContentInsideColumnsBeforeColumn	| input expected |	input := PRDocument new		add:				PRBeginColumnsAnnotation new;		add: (PRParagraph with: (PRText content: 'Foo') yourself);		add:				(PRColumnAnnotation withParameters: (					PRParameters withAll: { 						PRParameter 							keyNode: (PRParameterKey named: 'width')							valueNode: (PRParameterValue value: '100') }));		add: (PRParagraph with: (PRText content: 'Bar') yourself);		add:				PREndColumnsAnnotation new;		yourself.	expected := PRDocument new		add:				(PRColumnEnvironment new						add: (PRParagraph with: (PRText content: 'Foo') yourself);						add: ((PRColumn width: '100') add: (PRParagraph with: (PRText content: 'Bar') yourself) yourself);						yourself);		yourself.	self assert: (self executePhase: input) equals: expected! !!PRColumnsTransformerTest methodsFor: 'tests'!testTransformationWithNonGroupItemAtTopLevel	| input expected |	"This test makes sure that a document item which is not a document group can be a direct child of a column"	input := PRDocument new		add: PRBeginColumnsAnnotation new;		add:			(PRColumnAnnotation				withParameters: (					PRParameters withAll: { 						PRParameter 							keyNode: (PRParameterKey named: 'width')							valueNode: (PRParameterValue value: '100') }));		add: PRHorizontalRule new;		add: PREndColumnsAnnotation new;		yourself.	expected := PRDocument new		add:			(PRColumnEnvironment new				add:					((PRColumn width: '100')						add: PRHorizontalRule new;						yourself));		yourself.	self assert: (self executePhase: input) equals: expected! !!PRColumnsTransformerTest methodsFor: 'tests'!testTransformationWithoutColumns	| input |	input := PRDocument new		add:				(PRParagraph new						add: (PRText content: 'Foo');						yourself);		add: (PRParagraph with: (PRText content: 'Bar') yourself);		yourself.	self assert: (self executePhase: input with: self configuration) equals: input! !!PRCustomTagTransformerTest methodsFor: 'private'!actualClass	^PRCitationTransformer! !!PRCustomTagTransformerTest methodsFor: 'tests'!testTransformWithAnnotationAndText	| input expected |	input := PRDocument new		add:			(PRParagraph new				add: (PRText new text: 'hello');				add: PRCitationAnnotation new;				add: (PRText new text: 'hello');				yourself).	expected := PRDocument new		add:			(PRParagraph new				add: (PRText new text: 'hello');				add: (PRCitation new);				add: (PRText new text: 'hello');				yourself).	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRCustomTagTransformerTest methodsFor: 'tests'!testTransformWithListInList	| input expected |	input := PRDocument new		add:			(PROrderedList new				add:					(PRUnorderedList new						add: PRCitationAnnotation new;						yourself);				yourself).	expected := PRDocument new		add:			(PROrderedList new				add:					(PRUnorderedList new						add: PRCitation new;						yourself);				yourself).	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRCustomTagTransformerTest methodsFor: 'tests'!testTransformWithOneAnnotation	| input expected |	input := PRDocument new		add: PRCitationAnnotation new;		yourself.	expected := PRDocument new add: PRCitation new.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRCustomTagTransformerTest methodsFor: 'tests'!testTransformWithOneAnnotationithRef	| input expected |	input := PRDocument new		add:			(PRCitationAnnotation new				parameterAt: 'ref' put: 'foo';				yourself).	expected := PRDocument new add: (PRCitation ref: 'foo').	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRDocumentListTransformerTest class methodsFor: 'as yet unclassified'!directoryNameForTest	^ 'blogs'! !!PRDocumentListTransformerTest class methodsFor: 'private'!fileContentsOne	^ '!!!! OkayWe gonna test annotations'! !!PRDocumentListTransformerTest class methodsFor: 'private'!fileContentsThree	^ '!!!! And the thirdone for testing annotations'! !!PRDocumentListTransformerTest class methodsFor: 'private'!fileContentsTwo	^ '!!!! That''s the secondone for testing annotations'! !!PRDocumentListTransformerTest class methodsFor: 'private'!fileNameOne	^ 'blog1.pillar'! !!PRDocumentListTransformerTest class methodsFor: 'private'!fileNameThree	^ 'blog3.pillar'! !!PRDocumentListTransformerTest class methodsFor: 'private'!fileNameTwo	^ 'blog2.pillar'! !!PRDocumentListTransformerTest class methodsFor: 'private'!templateFileContents	^ '<div>  <p>{{{content}}}</p></div>'! !!PRDocumentListTransformerTest methodsFor: 'private'!actualClass	^ PRDocumentListTransformer! !!PRDocumentListTransformerTest methodsFor: 'private'!createFilesIn: aDirectory	(aDirectory / PRDocumentListTransformerTest fileNameOne)		writeStreamDo: [ :stream |			stream nextPutAll: PRDocumentListTransformerTest fileContentsOne ].			(aDirectory / PRDocumentListTransformerTest fileNameTwo)		writeStreamDo: [ :stream |			stream nextPutAll: PRDocumentListTransformerTest fileContentsTwo ].			(aDirectory / PRDocumentListTransformerTest fileNameThree)		writeStreamDo: [ :stream |			stream nextPutAll: PRDocumentListTransformerTest fileContentsThree ]! !!PRDocumentListTransformerTest methodsFor: 'private'!createTemplateFile	| dir templateFile |	dir := (testingFileSystem / 'templates') ensureCreateDirectory.	templateFile := (dir / 'docArticle.mustache') ensureCreateFile.	templateFile writeStreamDo: [ :stream |			stream nextPutAll: self class templateFileContents ].! !!PRDocumentListTransformerTest methodsFor: 'private'!setUp		| workingDirectory |	super setUp.	testingFileSystem := FileSystem memory workingDirectory.	workingDirectory := (testingFileSystem / PRDocumentListTransformerTest directoryNameForTest) ensureCreateDirectory.	self createFilesIn: workingDirectory.! !!PRDocumentListTransformerTest methodsFor: 'private'!testAnnotationCreateGoodLinks	| doc documentGroup sections |	"${docList:path=blogs|limit=3|sort=name}$"	doc := PRDocument new 				add: 				(PRText new 					text: 'You');				add:				(PRDocumentListAnnotation new 					parameterAt: 'path' put: 'blogs';					parameterAt: 'limit' put: '3';					parameterAt: 'sort' put: 'name';					yourself);				yourself.									((PRDocumentListTransformer withContext: (PRProject on: testingFileSystem)) start: doc).		documentGroup := doc children second.		sections := documentGroup children.	self assert: sections size equals: 6.	self assert: (sections at: 2) reference  equals: 'blogs/blog1.pillar'.	self assert: (sections at: 6) reference  equals: 'blogs/blog3.pillar'.! !!PRDocumentListTransformerTest methodsFor: 'private'!testAnnotationIsReplacedByFilesContents	| doc documentGroup sections |	"${docList:path=blogs|limit=3}$"	doc := PRDocument new 				add: 				(PRText new 					text: 'You');				add:				(PRDocumentListAnnotation new 					parameterAt: 'path' put: 'blogs';					parameterAt: 'limit' put: '3';					yourself);				yourself.									((PRDocumentListTransformer withContext: (PRProject on: testingFileSystem)) start: doc).		documentGroup := doc children second.		sections := documentGroup children.	self assert: sections size equals: 6.		self assert: sections first text equals: 'OkayWe gonna test annotations'.! !!PRDocumentListTransformerTest methodsFor: 'private'!testAnnotationWithEmptyMultipleMustacheTemplateShouldNotContainsRaw	| doc |	"${docList:path=blogs}$"	self createTemplateFile.	doc := PRDocument new 				add: 				(PRText new 					text: 'You');				add:				(PRDocumentListAnnotation new 					parameterAt: 'path' put: 'blogs';					yourself);				yourself.									((PRDocumentListTransformer withContext: (PRProject on: testingFileSystem)) start: doc).		self deny: (doc children allSatisfy: [ :each | each class = PRRaw ])! !!PRDocumentListTransformerTest methodsFor: 'private'!testAnnotationWithLowLimitShouldOnlyTakeLimitNumberOfFilesInPath	| doc documentGroup links |	"${docList:path=blogs|limit=2}$"	doc := PRDocument new		add: (PRText new text: 'You');		add:			(PRDocumentListAnnotation new				parameterAt: 'path' put: 'blogs';				parameterAt: 'limit' put: '2';				yourself);		yourself.	(PRDocumentListTransformer withContext: (PRProject on: testingFileSystem)) start: doc.	documentGroup := doc children second.	links := documentGroup children select: [ :each | each class = PRInternalLink ].	self deny: links size equals: 3.	self assert: links size equals: 2! !!PRDocumentListTransformerTest methodsFor: 'private'!testAnnotationWithMultipleMustacheTemplateShouldContainsRaw	| doc |	"${docList:path=blogs|sort=name|limit=3|templates=#('templates/docArticle.mustache' 'templates/me.mustache')}$"	self createTemplateFile.	doc := PRDocument new 				add: 				(PRText new 					text: 'You');				add:				(PRDocumentListAnnotation new 					parameterAt: 'path' put: 'blogs';					parameterAt: 'sort' put: 'name';					parameterAt: 'limit' put: '3';					parameterAt: 'templates' put: #('templates/docArticle.mustache' 'templates/me.mustache');					yourself);				yourself.									((PRDocumentListTransformer withContext: (PRProject on: testingFileSystem)) start: doc).		self assert: (doc children anySatisfy: [ :each | each class = PRRaw ])! !!PRDocumentListTransformerTest methodsFor: 'private'!testAnnotationWithTooHighLimitShouldOnlyTakeNumberOfFilesInPath	| doc documentGroup links |	"${docList:path=blogs|limit=5}$"	doc := PRDocument new		add: (PRText new text: 'You');		add:			(PRDocumentListAnnotation new				parameterAt: 'path' put: 'blogs';				parameterAt: 'limit' put: '5';				yourself);		yourself.	(PRDocumentListTransformer withContext: (PRProject on: testingFileSystem)) start: doc.	documentGroup := doc children second.	links := documentGroup children select: [ :each | each class = PRInternalLink ].	self deny: links size equals: 5.	"blogs is containing 3 files"	self assert: links size equals: 3! !!PRDocumentListTransformerTest methodsFor: 'private'!testAnnotationWithWrongPathShouldReturnEmptyDocumentGroup	| doc documentGroup sections |	"${docList:path=wrongDirectory|limit=3|sort=name}$"	doc := PRDocument new		add: (PRText new text: 'You');		add:			(PRDocumentListAnnotation new				parameterAt: 'path' put: 'wrongDirectory';				parameterAt: 'limit' put: '3';				parameterAt: 'sort' put: 'name';				yourself);		yourself.	(PRDocumentListTransformer withContext: (PRProject on: testingFileSystem)) start: doc.	documentGroup := doc children second.	sections := documentGroup children.	self assertEmpty: sections! !!PRDocumentListTransformerTest methodsFor: 'private'!testAnnotationWithWrongTemplateExtensionShouldNotContainsRaw	| doc |	"${docList:path=blogs|sort=name|limit=3|templates=#('templates/docArticle.avi')}$"	self createTemplateFile.	doc := PRDocument new 				add: 				(PRText new 					text: 'You');				add:				(PRDocumentListAnnotation new 					parameterAt: 'path' put: 'blogs';					parameterAt: 'sort' put: 'name';					parameterAt: 'limit' put: '3';					parameterAt: 'templates' put: #('templates/docArticle.avi');					yourself);				yourself.									((PRDocumentListTransformer withContext: (PRProject on: testingFileSystem)) start: doc).		self deny: (doc children allSatisfy: [ :each | each class = PRRaw ])! !!PRDocumentListTransformerTest methodsFor: 'private'!testAnnotationWithoutLimitParameterShouldTakeDefaultLimitValue	| doc documentGroup sections links |	"${docList:path=blogs|sort=name}$"	doc := PRDocument new 				add: 				(PRText new 					text: 'You');				add:				(PRDocumentListAnnotation new 					parameterAt: 'path' put: 'blogs';					parameterAt: 'sort' put: 'name';					yourself);				yourself.									((PRDocumentListTransformer withContext: (PRProject on: testingFileSystem)) start: doc).		documentGroup := doc children second.		sections := documentGroup children.	links := sections select: [ :each | each class = PRInternalLink ].	self assert: sections size equals: 6.		self assert: sections first text equals: 'OkayWe gonna test annotations'.	"default value of limit 3"	self assert: links size equals: 3! !!PRDocumentListTransformerTest methodsFor: 'private'!testAnnotationWithoutSortParameterShouldListFilesInArbitraryOrder	| doc documentGroup sections |	"${docList:path=blogs|limit=2}$"	doc := PRDocument new 				add: 				(PRText new 					text: 'You');				add:				(PRDocumentListAnnotation new 					parameterAt: 'path' put: 'blogs';					parameterAt: 'limit' put: '2';					yourself);				yourself.									((PRDocumentListTransformer withContext: (PRProject on: testingFileSystem)) start: doc).		documentGroup := doc children second.	sections := documentGroup children.		self assert: sections size equals: 4.	self assert: sections first text equals: 'OkayWe gonna test annotations'.! !!PRDocumentListTransformerTest methodsFor: 'private'!testAnnotationWithoutSpecifyingPathShouldRaiseError	| doc |	"${docList:sort=name|limit=5}$"	doc := PRDocument new 				add: 				(PRText new 					text: 'You');				add:				(PRDocumentListAnnotation new 					parameterAt: 'limit' put: '5';					parameterAt: 'sort' put: 'name';					yourself);				yourself.									self should: [((PRDocumentListTransformer withContext: (PRProject on: testingFileSystem)) start: doc)] raise: Error! !!PRDocumentListTransformerTest methodsFor: 'private'!testFilesAreSortedByBaseName	| doc documentGroup sections |	"${docList:path=blogs|sort=name|limit=3}$"	doc := PRDocument new 				add: 				(PRText new 					text: 'You');				add:				(PRDocumentListAnnotation new 					parameterAt: 'path' put: 'blogs';					parameterAt: 'limit' put: '3';					parameterAt: 'sort' put: 'name';					yourself);				yourself.									((PRDocumentListTransformer withContext: (PRProject on: testingFileSystem)) start: doc).		documentGroup := doc children second.		sections := documentGroup children.	self assert: sections size equals: 6.		self assert: (sections at: 1) text equals: 'OkayWe gonna test annotations'.	self assert: (sections at: 3) text equals: 'That''s the secondone for testing annotations'.	self assert: (sections at: 5) text equals: 'And the thirdone for testing annotations'.! !!PRDocumentListTransformerTest methodsFor: 'private'!testFilesAreSortedByModificationDate	| doc documentGroup sections |	"${docList:path=blogs|limit=3|sort=date}$"	doc := PRDocument new 				add: 				(PRText new 					text: 'You');				add:				(PRDocumentListAnnotation new 					parameterAt: 'path' put: 'blogs';					parameterAt: 'limit' put: '3';					parameterAt: 'sort' put: 'date';					yourself);				yourself.									((PRDocumentListTransformer withContext: (PRProject on: testingFileSystem)) start: doc).		documentGroup := doc children second.		sections := documentGroup children.	self assert: sections size equals: 6.		self assert: (sections at: 1) text equals: 'And the thirdone for testing annotations'.	self assert: (sections at: 3) text equals: 'That''s the secondone for testing annotations'.	self assert: (sections at: 5) text equals: 'OkayWe gonna test annotations'.! !!PREnvironmentTransformerTest methodsFor: 'private'!actualClass	^ PREnvironmentTransformer! !!PREnvironmentTransformerTest methodsFor: 'tests environment'!testAbsenceOfEnvironment	"there is not environment so nothing happens."	| input |	input := PRDocument new		add: (PRParagraph new						add: (PRText content: 'Foo');						yourself);		add: (PRParagraph with: (PRText content: 'Bar') yourself);		yourself.	self assert: (self executePhase: input with: self configuration) equals: input! !!PREnvironmentTransformerTest methodsFor: 'tests environment'!testBasicTextInsideAnEnvironment	| input expected |	input := PRDocument new		add: (PRBeginEnvironmentAnnotation named: 'card');		add: (PRParagraph with: (PRText content: 'First paragraph inside environment') yourself);		add: (PRParagraph with: (PRText content: 'Second paragraph inside environment') yourself);		add: (PREndEnvironmentAnnotation named: 'card');		yourself.	expected := PRDocument new		add: ((PREnvironment named: 'card')						add: (PRParagraph with: (PRText content: 'First paragraph inside environment') yourself);						add: (PRParagraph with: (PRText content: 'Second paragraph inside environment') yourself);						yourself);		yourself.	self assert: (self executePhase: input) equals: expected! !!PREnvironmentTransformerTest methodsFor: 'tests environment'!testBeginEnvironmentWithoutEnd	| input |	input := PRDocument		withAll: {			PRBeginEnvironmentAnnotation named: 'card'.			(PRParagraph with: (PRText content: 'First paragraph inside environment') yourself) }.	self		should: [ self executePhase: input ]		raise: PRError		whoseDescriptionIncludes: 'Missing end of environment ''card'''		description: 'Missing end of environment ''card'''! !!PREnvironmentTransformerTest methodsFor: 'tests environment'!testEndEnvironmentWithoutBegin	| input |	input := PRDocument with: (PREndEnvironmentAnnotation named: 'card').	self		should: [ (self executePhase: input with: self configuration) ]		raise: PRError		whoseDescriptionIncludes: 'Missing begin of environment ''card'''		description: 'Missing begin environment'! !!PREnvironmentTransformerTest methodsFor: 'tests environment'!testEndEnvironmentWithoutBeginAfterCorrectEnvironment	| input |	input := PRDocument new		add: (PRBeginEnvironmentAnnotation named: 'card');		add: (PREndEnvironmentAnnotation named: 'card');		add: (PREndEnvironmentAnnotation named: 'anotherCard');		yourself.	self		should: [ (self executePhase: input with: self configuration) ]		raise: PRError		whoseDescriptionIncludes: 'Missing begin of environment ''anotherCard'''		description: 'Missing begin environment'! !!PREnvironmentTransformerTest methodsFor: 'tests environment'!testEnvironmentHasBeginAnnotationProperties	| input node |	input := PRDocument new		add: ((PRBeginEnvironmentAnnotation named: 'cards')			parameterAt: 'boolean' put: true;			parameterAt: 'string' put: 'a string';			yourself);		add: (PREndEnvironmentAnnotation named: 'cards');		yourself.			node := self executePhase: input.		self assert: (node children first propertyAt: 'boolean').	self assert: (node children first propertyAt: 'string') equals: 'a string'.! !!PREnvironmentTransformerTest methodsFor: 'tests environment'!testEnvironmentWithManyNestedEnvironments	| input expected |	input := PRDocument new		add: (PRBeginEnvironmentAnnotation named: 'cards');		add: (PRBeginEnvironmentAnnotation named: 'card');		add: (PRParagraph with: (PRText content: 'First paragraph inside environment') yourself);		add: (PREndEnvironmentAnnotation named: 'card');		add: (PRBeginEnvironmentAnnotation named: 'card');		add: (PRParagraph with: (PRText content: 'Second paragraph inside environment') yourself);		add: (PREndEnvironmentAnnotation named: 'card');		add: (PREndEnvironmentAnnotation named: 'cards');		yourself.	expected := PRDocument new		add: ((PREnvironment named: 'cards')			add: ((PREnvironment named: 'card')				add: (PRParagraph with: (PRText content: 'First paragraph inside environment'));				yourself);			add: ((PREnvironment named: 'card')				add: (PRParagraph with: (PRText content: 'Second paragraph inside environment'));				yourself);			yourself);		yourself.	self assert: (self executePhase: input) equals: expected! !!PREnvironmentTransformerTest methodsFor: 'tests environment'!testMismatchEnvironments	| input |	input := PRDocument new		add: (PRBeginEnvironmentAnnotation named: 'card');		add: (PRParagraph with: (PRText content: 'First paragraph inside environment') yourself);		add: (PRParagraph with: (PRText content: 'Second paragraph inside environment') yourself);		add: (PREndEnvironmentAnnotation named: 'magic');		yourself.		self		should: [ (self executePhase: input with: self configuration) ]		raise: PRError		whoseDescriptionIncludes: 'Mismatching environments: closing ''magic'' while ''card'' environment is open'		description: 'Mismatch Environments'! !!PREnvironmentTransformerTest methodsFor: 'tests environment'!testMissingNameInBeginAnnotationFails	| input |	input := PRDocument new		add: (PRBeginEnvironmentAnnotation new);		add: (PRParagraph with: (PRText content: 'First paragraph inside environment') yourself);		add: (PRParagraph with: (PRText content: 'Second paragraph inside environment') yourself);		add: (PREndEnvironmentAnnotation named: 'card');		yourself.	self should: [ self executePhase: input ] raise: PREnvironmentMissedNamed! !!PREnvironmentTransformerTest methodsFor: 'tests environment'!testMissingNameInEndAnnotationFails	| input |	input := PRDocument new		add: (PRBeginEnvironmentAnnotation named: 'card');		add: (PRParagraph with: (PRText content: 'First paragraph inside environment') yourself);		add: (PRParagraph with: (PRText content: 'Second paragraph inside environment') yourself);		add: (PREndEnvironmentAnnotation new);		yourself.	self should: [ self executePhase: input ] raise: PREnvironmentMissedNamed! !!PREnvironmentTransformerTest methodsFor: 'tests environment'!testMixedEnvironments	| input |	input := PRDocument new		add: (PRBeginEnvironmentAnnotation named: 'card');		add: (PRBeginEnvironmentAnnotation named: 'anotherCard');		add: (PREndEnvironmentAnnotation named: 'card');		add: (PREndEnvironmentAnnotation named: 'anotherCard');		yourself.	self		should: [ (self executePhase: input with: self configuration) ]		raise: PRError		whoseDescriptionIncludes: 'Mismatching environments: closing ''card'' while ''anotherCard'' environment is open'		description: 'Mismatch Environments'! !!PREnvironmentTransformerTest methodsFor: 'tests environment'!testNestedEnvironments	| input expected |	input := PRDocument new		add: (PRBeginEnvironmentAnnotation named: 'cards');		add: (PRBeginEnvironmentAnnotation named: 'card');		add: (PREndEnvironmentAnnotation named: 'card');		add: (PREndEnvironmentAnnotation named: 'cards');		yourself.			expected := PRDocument new		add: ((PREnvironment named: 'cards')			add: (PREnvironment named: 'card');			yourself).				self assert: (self executePhase: input) equals: expected! !!PREnvironmentTransformerTest methodsFor: 'tests environment'!testNestedEnvironmentsWithTextInsideDeepest	| input expected |	input := PRDocument new		add: (PRBeginEnvironmentAnnotation named: 'cards');		add: (PRBeginEnvironmentAnnotation named: 'card');		add: (PRParagraph with: (PRText content: 'First paragraph inside environment') yourself);		add: (PREndEnvironmentAnnotation named: 'card');		add: (PREndEnvironmentAnnotation named: 'cards');		yourself.			expected := PRDocument new		add: ((PREnvironment named: 'cards')			add: ((PREnvironment named: 'card')				add: (PRParagraph with: (PRText content: 'First paragraph inside environment'));				yourself);			yourself);		yourself.	self assert: (self executePhase: input) equals: expected! !!PREnvironmentTransformerTest methodsFor: 'tests environment'!testNestedEnvironmentsWithTextSiblingOfEnvironment	| input expected |	input := PRDocument new		add: (PRBeginEnvironmentAnnotation named: 'cards');		add: (PRParagraph with: (PRText content: 'First paragraph inside environment') yourself);		add: (PRBeginEnvironmentAnnotation named: 'card');		add: (PREndEnvironmentAnnotation named: 'card');		add: (PRParagraph with: (PRText content: 'Second paragraph inside environment') yourself);		add: (PREndEnvironmentAnnotation named: 'cards');		yourself.			expected := PRDocument new		add: ((PREnvironment named: 'cards')			add: (PRParagraph with: (PRText content: 'First paragraph inside environment'));			add: (PREnvironment named: 'card');			add: (PRParagraph with: (PRText content: 'Second paragraph inside environment'));			yourself);		yourself.	self assert: (self executePhase: input) equals: expected! !!PRFootnoteTransformerTest methodsFor: 'private'!actualClass	^ PRFootnoteTransformer! !!PRFootnoteTransformerTest methodsFor: 'tests'!testTransformationFootnoteWithList	| input expected |	input := PRDocument new		add:			(PROrderedList new				add:					(PRListItem new						add: (PRText content: 'Timo');						add:							(PRFootnoteAnnotation new								parameterAt: 'note' put: 'Foo';								yourself);						add: (PRText content: 'Leon');						yourself);				yourself);		yourself.	expected := PRDocument new		add:			(PROrderedList new				add:					(PRListItem new						add: (PRText content: 'Timo');						add: (PRFootnote noted: 'Foo');						add: (PRText content: 'Leon');						yourself);				yourself);		yourself.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRFootnoteTransformerTest methodsFor: 'tests'!testTransformationFootnoteWithParagraph	| input expected |	input := PRDocument new		add:			(PRParagraph new				add: (PRText content: 'Timo');				add:					(PRFootnoteAnnotation new						parameterAt: 'note' put: 'Foo';						yourself);				add: (PRText content: 'Leon');				yourself);		yourself.	expected := PRDocument new		add:			(PRParagraph new				add: (PRText content: 'Timo');				add: (PRFootnote noted: 'Foo');				add: (PRText content: 'Leon');				yourself);		yourself.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRHeaderCapitalizationTransformerTest methodsFor: 'private'!actualClass	^ PRHeaderCapitalizationTransformer! !!PRHeaderCapitalizationTransformerTest methodsFor: 'tests'!testCapitalizeCapitalization	self testTemplateForCapitalizationHeader: 'capitalize' text: 'i am a header' expected: 'I Am A Header'.	self testTemplateForCapitalizationHeaderWithBold: 'capitalize' text: 'i am a header' expected: 'I Am A Header'.! !!PRHeaderCapitalizationTransformerTest methodsFor: 'tests'!testCapitalizeEnglish	self assert: (self actualClass new capitalizeEnglish: 'i am a header') equals: 'I Am a Header'.	self assert: (self actualClass new capitalizeEnglish: 'i am a header of level 1') equals: 'I Am a Header of Level 1'.	self assert: (self actualClass new capitalizeEnglish: 'i like to code in Pharo for a long time') equals: 'I Like to Code in Pharo for a Long Time'.! !!PRHeaderCapitalizationTransformerTest methodsFor: 'tests'!testCapitalizeEnglishCapitalization	self testTemplateForCapitalizationHeader: 'capitalize english' text: 'i am a header' expected: 'I Am a Header'.	self testTemplateForCapitalizationHeaderWithBold: 'capitalize english' text: 'i like to code in Pharo for a long time' expected: 'I Like to Code in Pharo for a Long Time'.! !!PRHeaderCapitalizationTransformerTest methodsFor: 'tests'!testCapitalizeHeader	self assert: (self actualClass new capitalizeHeader: 'i am a header') equals: 'I Am A Header'.	self assert: (self actualClass new capitalizeHeader: 'i am a header of level 1') equals: 'I Am A Header Of Level 1'! !!PRHeaderCapitalizationTransformerTest methodsFor: 'tests'!testCapitalizeHeaderShouldntCapitalizeAllText	| input printer spec  expected configuration |	configuration := self configuration. 	printer := configuration printer.	spec := printer printerSpecFor: 'roman'.	spec capitalization: 'upper case'.	printer level2: spec.		input := PRDocument new		add: (PRParagraph new add: (PRText content: 'should not be capitalized'));		add:			(PRHeader new				level: 2;				add: (PRText content: 'Header'));		add: (PRParagraph new add: (PRText content: 'should not be capitalized'));		yourself.			expected := PRDocument new		add: (PRParagraph new add: (PRText content: 'should not be capitalized'));		add:			(PRHeader new				level: 2;				add: (PRText content: 'HEADER'));		add: (PRParagraph new add: (PRText content: 'should not be capitalized'));		yourself.			self assert: (self executePhase: input with: configuration) equals: expected.! !!PRHeaderCapitalizationTransformerTest methodsFor: 'tests'!testDefaultValueForCapitalization	self testTemplateForDefaultValueForCapitalization: 'i am a header'.	self testTemplateForDefaultValueForCapitalization: 'I am A hEader'! !!PRHeaderCapitalizationTransformerTest methodsFor: 'tests'!testLowerCaseCapitalization	self testTemplateForCapitalizationHeader: 'lower case' text: 'I AM A HEADER' expected: 'i am a header'.	self testTemplateForCapitalizationHeaderWithBold: 'lower case' text: 'I AM A HEADER' expected: 'i am a header'.! !!PRHeaderCapitalizationTransformerTest methodsFor: 'tests'!testNotUnderstandCapitalizationType	self testTemplateForCapitalizationHeader: 'hello' text: 'i aM A HeaDer' expected: 'i aM A HeaDer'.	self testTemplateForCapitalizationHeaderWithBold: 'hello' text: 'i aM A HeaDer' expected: 'i aM A HeaDer'.! !!PRHeaderCapitalizationTransformerTest methodsFor: 'helpers'!testTemplateForCapitalizationHeader: aType text: aString expected: anotherString	| input printer spec expected configuration |	configuration := self configuration.	printer := configuration printer.	spec := printer printerSpecFor: 'roman'.	spec capitalization: aType.	printer level2: spec.		input := PRDocument new		add:			(PRHeader new				level: 2;				add: (PRText content: aString));		yourself.	expected := PRDocument new		add:			(PRHeader new				level: 2;				add: (PRText content: anotherString));		yourself.	self assert: (self executePhase: input with: configuration) equals: expected.	! !!PRHeaderCapitalizationTransformerTest methodsFor: 'helpers'!testTemplateForCapitalizationHeaderWithBold: aType text: aString expected: anotherString	| input printer spec expected configuration |	configuration := self configuration. 	printer := configuration printer.	spec := printer printerSpecFor: 'roman'.	spec capitalization: aType.	printer level2: spec.		input := PRDocument new		add:			(PRHeader new				level: 2;				add: (PRBoldFormat new add: (PRText content: aString)));		yourself.	expected := PRDocument new		add:			(PRHeader new				level: 2;				add: (PRBoldFormat new add: (PRText content: anotherString)));		yourself.			self assert: (self executePhase: input with: configuration) equals: expected! !!PRHeaderCapitalizationTransformerTest methodsFor: 'helpers'!testTemplateForDefaultValueForCapitalization: aString	| input printer spec configuration |	configuration := self configuration.	printer := configuration printer. 	spec := printer printerSpecFor: 'roman' .	printer level2: spec. 		input := PRDocument new		add:			(PRHeader new				level: 2;				add: (PRText content: aString));		yourself.	self assert: (self executePhase: input with: configuration) equals: input! !!PRHeaderCapitalizationTransformerTest methodsFor: 'tests'!testUpperCaseCapitalization	self testTemplateForCapitalizationHeader: 'upper case' text: 'i am a header' expected: 'I AM A HEADER'.	self testTemplateForCapitalizationHeaderWithBold: 'upper case' text: 'i am a header' expected: 'I AM A HEADER'.! !!PRHeadingLevelOffsetTest methodsFor: 'private'!actualClass	^ PRHeadingLevelOffsetTransformer! !!PRHeadingLevelOffsetTest methodsFor: 'tests'!checkWithOffset: offset	| result input configuration |	configuration := self configuration.	configuration headingLevelOffset: offset.	input := PRHeader new		level: 3;		add: (PRText content: 'a title');		yourself.	result := self executePhase: input with: configuration.	self assert: result level equals: offset + 3! !!PRHeadingLevelOffsetTest methodsFor: 'tests'!testPositiveOffset	self checkWithOffset: 2! !!PRHeadingLevelOffsetTest methodsFor: 'tests'!testZeroOffset	self checkWithOffset: 0! !!PRNodeTransformerTest class methodsFor: 'testing'!isAbstract	^ self = PRNodeTransformerTest ! !!PRNodeTransformerTest methodsFor: 'private'!actualClass	^ PRNodeTransformer! !!PRNodeTransformerTest methodsFor: 'accessing'!configuration	^ self configurationClass new! !!PRNodeTransformerTest methodsFor: 'accessing'!configurationClass	^ ConfigurationForPillar! !!PRNodeTransformerTest methodsFor: 'transformation'!executePhase: anInput	^ self executePhase: anInput with: self configuration! !!PRNodeTransformerTest methodsFor: 'transformation'!executePhase: anInput with: aConfig	^ (self actualClass		executeOn:			(PRCompilationContext withDocument: anInput withConfiguration: aConfig))		input! !!PRRemoveHideableScriptsTest methodsFor: 'as yet unclassified'!actualClass	^ PRRemoveHideableScripts ! !!PRRemoveHideableScriptsTest methodsFor: 'tests'!testScriptWhenHideable	| input expected |	input := PRDocument new 		add: ((PRCodeblock content: 'Object') 					hideable: true;					yourself);				yourself.	expected := PRDocument new.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRRemoveHideableScriptsTest methodsFor: 'tests'!testScriptWhenNotHideable	| input |	input := PRDocument new 		add: ((PRCodeblock content: 'Object') 					hideable: false;					yourself);				yourself.	self assert: (self executePhase: input with: self configuration) equals: input! !!PRRemoveHideableScriptsTest methodsFor: 'tests'!testScriptWithoutHideableParameter	| input |	input := PRDocument new 		add: ((PRCodeblock content: 'Object') 					yourself);				yourself.	self assert: (self executePhase: input with: self configuration) equals: input! !!PRScriptEvaluatorTest methodsFor: 'private'!actualClass	^ PRScriptEvaluator ! !!PRScriptEvaluatorTest methodsFor: 'tests'!testScriptWithEvalThatDoesntReturnAParagraph	| input expected |	input := PRDocument new		add:			(PRParagraph new				add:						((PRCodeblock content: 'stream nextPutAll: ''-test''')								eval: true; 								yourself);				yourself) yourself.	expected := PRDocument new		add:			(PRParagraph new				add: (PRUnorderedList new add: (PRListItem new add: (PRText content: 'test')));				yourself) yourself.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRScriptEvaluatorTest methodsFor: 'tests'!testScriptWithProblematicEval	| input |	input := PRDocument new		add:				((PRCodeblock content: 'Object SomethingThatIsNotAMethod')						eval: true;						yourself);		yourself.	self assert: (self executePhase: input with: self configuration) equals: input! !!PRScriptEvaluatorTest methodsFor: 'tests'!testScriptWithoutEval	| input expected |	input := PRDocument new		add:				((PRCodeblock content: 'stream nextPut: $h; nextPut: $e; nextPut: $l; nextPutAll: ''lo''')						eval: false;						yourself);		yourself.	expected := PRDocument new		add:				((PRCodeblock content: 'stream nextPut: $h; nextPut: $e; nextPut: $l; nextPutAll: ''lo''')						eval: false;						yourself);		yourself.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRScriptFromFileTest methodsFor: 'helpers'!aCode	| code |	code := String new writeStream.	code		nextPutAll: self headingCode;		nextPutAll: self middleCode;		nextPutAll: self endingCode.	^ code contents! !!PRScriptFromFileTest methodsFor: 'private'!actualClass	^ PRScriptFromFile! !!PRScriptFromFileTest methodsFor: 'as yet unclassified'!baseDirectory	^ baseDirectory! !!PRScriptFromFileTest methodsFor: 'as yet unclassified'!configuration	^ super configuration		baseDirectory: baseDirectory;		newLine: Smalltalk os lineEnding;		yourself.! !!PRScriptFromFileTest methodsFor: 'actions'!createFile: aName With: text In: aDirectory	| stream |	stream := (aDirectory / aName) writeStream.	stream nextPutAll: text.	stream close! !!PRScriptFromFileTest methodsFor: 'helpers'!endingCode	| code |	code := String new writeStream.	code nextPutAll: Smalltalk os lineEnding.	code nextPut: Character tab.	^ code contents! !!PRScriptFromFileTest methodsFor: 'helpers'!firstLine	^ 5! !!PRScriptFromFileTest methodsFor: 'helpers'!headingCode	| code |	code := String new writeStream.	self firstLine timesRepeat: [ code nextPutAll: Smalltalk os lineEnding ].	^ code contents! !!PRScriptFromFileTest methodsFor: 'helpers'!middleCode	| code |	code := String new writeStream.	code		nextPutAll: '|test|';		nextPutAll: Smalltalk os lineEnding;		nextPutAll: 'test := 1.';		nextPutAll: Smalltalk os lineEnding;		nextPutAll: 'test := 1+1'.	^ code contents! !!PRScriptFromFileTest methodsFor: 'running'!setUp	super setUp.	baseDirectory := FileSystem memory root.	self		createFile: 'code.st'		With: self aCode		In: baseDirectory! !!PRScriptFromFileTest methodsFor: 'tests'!testCanGetFileInsideAnOtherDirectory	| input expected |	(baseDirectory / 'foo') ensureCreateDirectory.	self createFile: 'code.st' With: self aCode In: baseDirectory / 'foo'.	input := PRDocument new		add: ((PRCodeblock content: '') fromFile: 'foo/code.st' yourself);		yourself.	expected := PRDocument new		add:			((PRCodeblock content: self aCode)				fromFile: 'foo/code.st';				yourself);		yourself.	self		assert: (self executePhase: input with: self configuration)		equals: expected! !!PRScriptFromFileTest methodsFor: 'tests'!testFirstAndLastLineDefine	| input expected |	input := PRDocument new		add:				((PRCodeblock content: '')						fromFile: 'code.st';						firstLine: self firstLine +1;						lastLine: self firstLine + 3 yourself);		yourself.	expected := PRDocument new		add:				((PRCodeblock content: self middleCode)						fromFile: 'code.st';						firstLine: self firstLine +1;						lastLine: self firstLine + 3 yourself);		yourself.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRScriptFromFileTest methodsFor: 'tests'!testFirstLineDefine	| input expected |	input := PRDocument new		add:				((PRCodeblock content: '')						fromFile: 'code.st';						firstLine: self firstLine + 1 yourself);		yourself.	expected := PRDocument new		add:				((PRCodeblock content: self middleCode , self endingCode)						fromFile: 'code.st';						firstLine: self firstLine + 1 yourself);		yourself.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRScriptFromFileTest methodsFor: 'tests'!testFirstLineOutOfBounds	| input |	input := PRDocument new		add:				((PRCodeblock content: '')						fromFile: 'code.st';						firstLine: 500 yourself);		yourself.	self should: [ self executePhase: input with: self configuration ] raise: PRPropertyError! !!PRScriptFromFileTest methodsFor: 'tests'!testHasFileFrom	| input expected |	input := PRDocument new		add: ((PRCodeblock content: '') fromFile: 'code.st' yourself);		yourself.	expected := PRDocument new		add:				((PRCodeblock content: self aCode)						fromFile: 'code.st';						yourself);		yourself.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRScriptFromFileTest methodsFor: 'tests'!testHasWrongFileFrom	| input |	input := PRDocument new		add: ((PRCodeblock content: '') fromFile: 'wrong.st' yourself);		yourself.	self should: [ self executePhase: input with: self configuration ] raise: PRInputFileError ! !!PRScriptFromFileTest methodsFor: 'tests'!testLastLineDefine	| input expected |	input := PRDocument new		add:				((PRCodeblock content: '')						fromFile: 'code.st';						lastLine: self firstLine + 3 yourself);		yourself.	expected := PRDocument new		add:				((PRCodeblock content: self headingCode , self middleCode)						fromFile: 'code.st';						lastLine: self firstLine + 3 yourself);		yourself.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRScriptFromFileTest methodsFor: 'tests'!testLastLineLowestThanFirstLine	| input |	input := PRDocument new		add:				((PRCodeblock content: '')						fromFile: 'code.st';						firstLine: 5;						lastLine: 0 yourself);		yourself.	self should: [ self executePhase: input with: self configuration ] raise: PRPropertyError! !!PRScriptFromFileTest methodsFor: 'tests'!testLastLineOutOfBounds	| input |	input := PRDocument new		add:				((PRCodeblock content: '')						fromFile: 'code.st';						lastLine: 500 yourself);		yourself.	self should: [ self executePhase: input with: self configuration ] raise: PRPropertyError! !!PRScriptFromFileTest methodsFor: 'tests'!testWarningWhenScriptNotEmpty	| input  |	input := PRDocument new		add: ((PRCodeblock content: 'foo') fromFile: 'code.st' yourself);		yourself.	self should: [ self executePhase: input with: self configuration ] raise: PRWarning! !!PRScriptFromFileTest methodsFor: 'tests'!testtestFirstLineIsNotANumber	| input |	input := PRDocument new		add:				((PRCodeblock content: '')						fromFile: 'code.st';						firstLine: 'foo' yourself);		yourself.	self should: [ self executePhase: input with: self configuration ] raise: PRPropertyError! !!PRScriptLineNumberTest methodsFor: 'private'!actualClass	^ PRScriptLineNumber ! !!PRScriptLineNumberTest methodsFor: 'tests'!testScriptWithLineNumber	| input expected |	input := PRDocument new		add:				((PRCodeblock content: 'stream nextPut: $h; nextPut: $e; nextPut: $l; nextPutAll: ''lo''')						lineNumber: true;						eval: false;						yourself);		yourself.	expected := PRDocument new		add:				((PRCodeblock content: '1	stream nextPut: $h; nextPut: $e; nextPut: $l; nextPutAll: ''lo''')						lineNumber: true;						eval: false;						yourself);		yourself.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRScriptLineNumberTest methodsFor: 'tests'!testScriptWithLineNumberFalse	| input expected |	input := PRDocument new		add:				((PRCodeblock content: 'stream nextPut: $h; nextPut: $e; nextPut: $l; nextPutAll: ''lo''')						lineNumber: false;						eval: false;						yourself);		yourself.	expected := PRDocument new		add:				((PRCodeblock content: 'stream nextPut: $h; nextPut: $e; nextPut: $l; nextPutAll: ''lo''')						lineNumber: false;						eval: false;						yourself);		yourself.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRScriptLineNumberTest methodsFor: 'tests'!testScriptWithSeveralLineNumbers		| input expected |	self skip.	input := PRDocument new		add:				((PRCodeblock content: 'stream nextPut: $h; nextPut: $e; nextPut: $l; nextPutAll: ''lo'' world !!')						lineNumber: true;						eval: false;						yourself);		yourself.	expected := PRDocument new		add:				((PRCodeblock content: '1	stream nextPut: $h; nextPut: $e; nextPut: $l; nextPutAll: ''lo''2	world3 	!!')						lineNumber: true;						eval: false;						yourself);		yourself.	self assert: (self executePhase: input with: self configuration) children first text  equals: expected children first text ! !!PRScriptLineNumberTest methodsFor: 'tests'!testScriptWithoutParameter	| input expected |	input := PRDocument new		add:				((PRCodeblock content: 'stream nextPut: $h; nextPut: $e; nextPut: $l; nextPutAll: ''lo''')						yourself);		yourself.	expected := PRDocument new		add:				((PRCodeblock content: 'stream nextPut: $h; nextPut: $e; nextPut: $l; nextPutAll: ''lo''')						yourself);		yourself.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRSectionTransformerTest methodsFor: 'private'!actualClass	^ PRSectionTransformer! !!PRSectionTransformerTest methodsFor: 'tests'!testTransformWithChangedMaxDepthLevel	| input expected |	input := PRDocument new		add:			(PRHeader new				level: 1;				add: (PRText content: 'Bar') yourself);		add: (PRParagraph with: (PRText content: 'Foo') yourself);		add:			(PRHeader new				level: 2;				add: (PRText content: 'Bar2') yourself);		add: (PRParagraph with: (PRText content: 'Foo2') yourself);		yourself.	expected := PRDocument new		add:			(PRSection new				add:					(PRHeader new						level: 1;						add: (PRText content: 'Bar') yourself);				add: (PRParagraph with: (PRText content: 'Foo') yourself);				add:					(PRHeader new						level: 2;						add: (PRText content: 'Bar2') yourself);				add: (PRParagraph with: (PRText content: 'Foo2') yourself);				yourself) yourself.	self actualClass maxDepthLevel: 1.	self		assert: (self executePhase: input with: self configuration)		equals: expected.	"After the test we reinitialize the PRSectionTransformer to get the normal MaxDepthLevel"	self actualClass initialize! !!PRSectionTransformerTest methodsFor: 'tests'!testTransformWithOneSection	| input expected |	input := PRDocument new		add:				(PRHeader new						level: 1;						add: (PRText content: 'Bar') yourself);		add: (PRParagraph with: (PRText content: 'Foo!!') yourself);		yourself.	expected := PRDocument new		add:			(PRSection new				add:						(PRHeader new								level: 1;								add: (PRText content: 'Bar') yourself);				add: (PRParagraph with: (PRText content: 'Foo!!') yourself);				yourself) yourself.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRSectionTransformerTest methodsFor: 'tests'!testTransformWithParagraphBeforeSection	| input expected |	input := PRDocument new		add: (PRParagraph with: (PRText content: 'Hello World') yourself);		add:				(PRHeader new						level: 1;						add: (PRText content: 'Bar') yourself);		add: (PRParagraph with: (PRText content: 'Foo') yourself);		yourself.	expected := PRDocument new		add: (PRParagraph with: (PRText content: 'Hello World') yourself);		add:				(PRSection new						add:								(PRHeader new										level: 1;										add: (PRText content: 'Bar') yourself);						add: (PRParagraph with: (PRText content: 'Foo') yourself);						yourself) yourself.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRSectionTransformerTest methodsFor: 'tests'!testTransformWithTwoSections	| input expected |	input := PRDocument new		add:				(PRHeader new						level: 1;						add: (PRText content: 'Bar');						yourself);		add: (PRParagraph with: (PRText content: 'Foo') yourself);		add:				(PRHeader new						level: 1;						add: (PRText content: 'Bar2');						yourself);		add: (PRParagraph with: (PRText content: 'Foo2') yourself);		yourself.	expected := PRDocument new		add:				(PRSection new						add:								(PRHeader new										level: 1;										add: (PRText content: 'Bar');										yourself);						add: (PRParagraph with: (PRText content: 'Foo') yourself);						yourself);		add:				(PRSection new						add:								(PRHeader new										level: 1;										add: (PRText content: 'Bar2');										yourself);						add: (PRParagraph with: (PRText content: 'Foo2') yourself);						yourself) yourself.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRSectionTransformerTest methodsFor: 'tests'!testTransformWithoutSection	| input |	input := PRDocument new		add: (PRParagraph with: (PRText content: 'Foo!!') yourself);		yourself.	self assert: (self executePhase: input with: self configuration) equals: input! !!PRSlideTransformerTest methodsFor: 'private'!actualClass	^ PRSlideTransformer! !!PRSlideTransformerTest methodsFor: 'tests'!testTransformAnnotationStopAtTitle	| input expected |	input := PRDocument new		add:				PRSlideTitleAnnotation new;		add: (PRParagraph with: (PRText content: 'Foo!!') yourself);		add:				(PRHeader new						level: 1;						add: (PRText content: 'Foo');						yourself);		yourself.	expected := PRDocument new		add:				(PRSlide new						add: (PRParagraph with: (PRText content: 'Foo!!') yourself);						yourself);		add:				(PRHeader new						level: 1;						add: (PRText content: 'Foo');						yourself);		yourself.	self assert: (self executePhase: input) equals: expected! !!PRSlideTransformerTest methodsFor: 'tests'!testTransformWithOneAnnotation	| input expected |	input := PRDocument new		add:				PRSlideTitleAnnotation new;		add: (PRParagraph with: (PRText content: 'Foo!!') yourself);		yourself.	expected := PRDocument new		add:			(PRSlide new				add: (PRParagraph with: (PRText content: 'Foo!!') yourself);				yourself) yourself.	self assert: (self executePhase: input) equals: expected! !!PRSlideTransformerTest methodsFor: 'tests'!testTransformWithTwoAnnotation	| input expected |	input := PRDocument new		add:				PRSlideTitleAnnotation new;		add: (PRParagraph with: (PRText content: 'Foo!!') yourself);		add:				PRSlideTitleAnnotation new;		add: (PRParagraph with: (PRText content: 'Bar') yourself);		yourself.	expected := PRDocument new		add:				(PRSlide new						add: (PRParagraph with: (PRText content: 'Foo!!') yourself);						yourself);		add:				(PRSlide new						add: (PRParagraph with: (PRText content: 'Bar') yourself);						yourself);		yourself.	self assert: (self executePhase: input) equals: expected! !!PRSlideTransformerTest methodsFor: 'tests'!testTransformationKeepSameContent	| input |	input := PRDocument new		add:			(PRHeader new				level: 1;				add: (PRText content: 'Bar');				yourself);		add: (PRParagraph with: (PRText content: 'Foo') yourself);		add: PRSlideTitleAnnotation new;		add: (PRParagraph with: (PRText content: 'Foo2') yourself);		yourself.	self assert: (self executePhase: input) equals: input! !!PRSlideTransformerTest methodsFor: 'tests'!testTransformationWithNonGroupItemAtTopLevel	| input expected |	"This test makes sure that a document item which is not a document group can be a direct child of a slide"	input := PRDocument new		add: PRSlideTitleAnnotation new;		add: PRHorizontalRule new;		yourself.	expected := PRDocument new		add:			(PRSlide new				add: PRHorizontalRule new;				yourself);		yourself.	self assert: (self executePhase: input) equals: expected! !!PRTocBuilderVisitorTest methodsFor: 'private'!actualClass	^ PRTocBuilderVisitor ! !!PRTocBuilderVisitorTest methodsFor: 'tests'!createCyclicPillarFile1	| pillarFile |	pillarFile := 'cyclic1.pillar' asFileReference.		pillarFile writeStreamDo: [ :stream |		stream nextPutAll: '!!!! TestCyclicFile1${inputFile:path=cyclic1.pillar}$Look at my eyes'		 ]! !!PRTocBuilderVisitorTest methodsFor: 'tests'!createPillarFile1	| pillarFile |	pillarFile := 'input1.pillar' asFileReference.		pillarFile writeStreamDo: [ :stream |		stream nextPutAll: '!!!!!! TestFile11+Pillar logo>figures/pillar.png|width=30+If you don''t know ''Pillar'', its documentation is *here>https://ci.inria.fr/pharo-contribution/job/EnterprisePharoBook/lastSuccessfulBuild/artifact/book-result/PillarChap/Pillar.html*!!!!!! TestFile12!!!!!! TestFile13The book is generated directly in HTML and LaTeX with the command ==make book==You can compile just one chapter with the command ==make book-result/chapterPathAndName.format==For example, for the first chapter in LaTeX: ==make book-result/Chapters/Chapter1/chapter1.tex==!!!!!! TestFile14${inputFile:path=input3.pillar}$!!!!!! TestFile15'		 ]! !!PRTocBuilderVisitorTest methodsFor: 'tests'!createPillarFile2	| pillarFile |	pillarFile := 'input2.pillar' asFileReference.		pillarFile writeStreamDo: [ :stream |		stream nextPutAll: '!!!! TestFile21There is also a template system, you can find template in the folder ''_support/template''.Some template are already written, but if you want to have your own, you had two solutions:-edit the existing template related to the format you want to change (recommanded)-create your own template with its own name and change used template in the Makefile'		 ]! !!PRTocBuilderVisitorTest methodsFor: 'tests'!createPillarFile3	| pillarFile |	pillarFile := 'input3.pillar' asFileReference.		pillarFile writeStreamDo: [ :stream |		stream nextPutAll: '!!!! TestFile31Look at my eyes'		 ]! !!PRTocBuilderVisitorTest methodsFor: 'initialization'!setUp	super setUp.	builder := PRTocBuilderVisitor new.	simpleDocument := PRPillarParser		parse:			'!! test1!! test2'.	inputDocument := PRPillarParser		parse:			'!! test1!! test2${inputFile:path=input1.pillar}$${inputFile:path=input2.pillar}$'.	advancedDocument := PRPillarParser		parse:			'!! test1!! test2!! test3${inputFile:path=input2.pillar}$!! test4${inputFile:path=input1.pillar}$'.	complexToc := PRPillarParser		parse:			'!!!! Test1!!!!!! Test11!!!!!!!! Test111!!!!!! Test12!!!!!!!!!! Test121!!!!!!!! Test122!!!! Test2!! Test3'.	self createPillarFile1.	self createPillarFile2.	self createPillarFile3.	self createCyclicPillarFile1.! !!PRTocBuilderVisitorTest methodsFor: 'running'!tearDown	(FileSystem workingDirectory / 'input1.pillar') delete.	(FileSystem workingDirectory / 'input2.pillar') delete.	(FileSystem workingDirectory / 'input3.pillar') delete.	(FileSystem workingDirectory / 'cyclic1.pillar') delete.	super tearDown! !!PRTocBuilderVisitorTest methodsFor: 'tests'!testDocumentWithCyclicInputShouldRaiseError	| document |	document := PRPillarParser		parse:			'!! Test1!!!! Test2${inputFile:path=cyclic1.pillar}$!!!! Test3'.	builder		documentSource: FileSystem workingDirectory / 'document.pillar';		currentFile: 'document.pillar';		inProcessFiles: (Array with: FileSystem workingDirectory / 'document.pillar').			self should: [ builder visit: document ] raise: PRCyclicFileInclusionError! !!PRTocBuilderVisitorTest methodsFor: 'tests'!testDocumentWithInputAnnotationAndTitle	| document expectedToc |	document := PRPillarParser		parse:			'!! Test1!!!! Test2${inputFile:path=input1.pillar}$!!!! Test3'.	expectedToc := PRToc new		level: 0;		addChildren:			(PRToc new				name: 'Test1';				level: 1;				addChildren:					(PRToc new						name: 'Test2';						level: 2;						addChildren:							(PRToc new								name: 'TestFile11';								level: 3;								fileReference: 'input1.pillar');						addChildren:							(PRToc new								name: 'TestFile12';								level: 3;								fileReference: 'input1.pillar');						addChildren:							(PRToc new								name: 'TestFile13';								level: 3;								fileReference: 'input1.pillar');						addChildren:							(PRToc new								name: 'TestFile14';								level: 3;								fileReference: 'input1.pillar'));				addChildren:					(PRToc new						name: 'TestFile31';						level: 2;						fileReference: 'input3.pillar';						addChildren:							(PRToc new								name: 'TestFile15';								level: 3;								fileReference: 'input1.pillar'));				addChildren:					(PRToc new						name: 'Test3';						level: 2)).	builder		documentSource: FileSystem workingDirectory / 'document.pillar';		currentFile: 'document.pillar';		inProcessFiles: (Array with: FileSystem workingDirectory / 'document.pillar');		visit: document.	self assert: builder tableOfContents children size equals: 1.	self assert: builder tableOfContents equals: expectedToc! !!PRTocBuilderVisitorTest methodsFor: 'tests'!testDocumentWithInputAnnotationContainsMultipleTocs	| expectedToc |	expectedToc := PRToc new		level: 0;		addChildren:			(PRToc new				name: 'test1';				level: 1);		addChildren:			(PRToc new				name: 'test2';				level: 1);		addChildren:			(PRToc new				name: 'test3';				level: 1;				addChildren:					(PRToc new						name: 'TestFile21';						level: 2;						fileReference: 'input2.pillar'));		addChildren:			(PRToc new				name: 'test4';				level: 1;				addChildren:					(PRToc new						name: 'TestFile11';						level: 3;						fileReference: 'input1.pillar');				addChildren:					(PRToc new						name: 'TestFile12';						level: 3;						fileReference: 'input1.pillar');				addChildren:					(PRToc new						name: 'TestFile13';						level: 3;						fileReference: 'input1.pillar');				addChildren:					(PRToc new						name: 'TestFile14';						level: 3;						fileReference: 'input1.pillar');				addChildren:					(PRToc new						name: 'TestFile31';						level: 2;						fileReference: 'input3.pillar';						addChildren:							(PRToc new								name: 'TestFile15';								level: 3;								fileReference: 'input1.pillar'))).	builder		documentSource: FileSystem workingDirectory / 'document.pillar';		currentFile: 'document.pillar';		inProcessFiles: (Array with: FileSystem workingDirectory / 'document.pillar');		visit: advancedDocument.	self assert: builder tableOfContents equals: expectedToc! !!PRTocBuilderVisitorTest methodsFor: 'tests'!testDocumentWithInputAnnotationHasTocs	| expectedToc |	expectedToc := PRToc new		level: 0;		addChildren:			(PRToc new				name: 'test1';				level: 1);		addChildren:			(PRToc new				name: 'test2';				level: 1;				addChildren:					(PRToc new						name: 'TestFile11';						level: 3;						fileReference: 'input1.pillar');				addChildren:					(PRToc new						name: 'TestFile12';						level: 3;						fileReference: 'input1.pillar');				addChildren:					(PRToc new						name: 'TestFile13';						level: 3;						fileReference: 'input1.pillar');				addChildren:					(PRToc new						name: 'TestFile14';						level: 3;						fileReference: 'input1.pillar');				addChildren:					(PRToc new						name: 'TestFile31';						level: 2;						fileReference: 'input3.pillar';						addChildren:							(PRToc new								name: 'TestFile15';								level: 3;								fileReference: 'input1.pillar'));				addChildren:					(PRToc new						name: 'TestFile21';						level: 2;						fileReference: 'input2.pillar')).	builder		documentSource: FileSystem workingDirectory / 'document.pillar';		currentFile: 'document.pillar';		inProcessFiles: (Array with: FileSystem workingDirectory / 'document.pillar');		visit: inputDocument.	self assert: builder tableOfContents equals: expectedToc! !!PRTocBuilderVisitorTest methodsFor: 'tests'!testDocumentWithOnlyInputAnnotation	| document expectedToc |	document := PRPillarParser parse: '${inputFile:path=input2.pillar}$'.	expectedToc := PRToc new		level: 0;		addChildren:			(PRToc new				name: 'TestFile21';				level: 2;				fileReference: 'input2.pillar').	builder		documentSource: FileSystem workingDirectory / 'document.pillar';		currentFile: 'document.pillar';		inProcessFiles: (Array with: FileSystem workingDirectory / 'document.pillar');		visit: document.	self assert: builder tableOfContents equals: expectedToc! !!PRTocBuilderVisitorTest methodsFor: 'tests'!testDocumentWithoutInputAnnotationOnlyContainsTitles	| expectedToc |	expectedToc := PRToc new		level: 0;		addChildren:			(PRToc new				name: 'test1';				level: 1);		addChildren:			(PRToc new				name: 'test2';				level: 1).	builder visit: simpleDocument.	self assert: builder tableOfContents equals: expectedToc! !!PRTocBuilderVisitorTest methodsFor: 'tests'!testTitlesHaveGoodFileRefs	| document expectedToc |	document := PRPillarParser		parse:			'!!!! Test1!!!!!! Test2${inputFile:path=input1.pillar}$!!!! Test3!! Test4'.	expectedToc := PRToc new		level: 0;		addChildren:			(PRToc new				name: 'Test1';				level: 2;				fileReference: nil;				addChildren:					(PRToc new						name: 'Test2';						level: 3;						fileReference: nil);				addChildren:					(PRToc new						name: 'TestFile11';						level: 3;						fileReference: 'input1.pillar');				addChildren:					(PRToc new						name: 'TestFile12';						level: 3;						fileReference: 'input1.pillar');				addChildren:					(PRToc new						name: 'TestFile13';						level: 3;						fileReference: 'input1.pillar');				addChildren:					(PRToc new						name: 'TestFile14';						level: 3;						fileReference: 'input1.pillar'));		addChildren:			(PRToc new				name: 'TestFile31';				level: 2;				fileReference: 'input3.pillar';				addChildren:					(PRToc new						name: 'TestFile15';						level: 3;						fileReference: 'input1.pillar'));		addChildren:			(PRToc new				name: 'Test3';				level: 2;				fileReference: nil);		addChildren:			(PRToc new				name: 'Test4';				level: 1;				fileReference: nil).	builder		documentSource: FileSystem workingDirectory / 'document.pillar';		currentFile: 'document.pillar';		inProcessFiles: (Array with: FileSystem workingDirectory / 'document.pillar');		visit: document.	self assert: builder tableOfContents equals: expectedToc! !!PRTocBuilderVisitorTest methodsFor: 'tests'!testTocChildrenHasTheSameLevel	| document expectedToc |	document := PRPillarParser		parse:			'!!!! Test1!!!! Test2'.	expectedToc := PRToc new		level: 0;		addChildren:			(PRToc new				name: 'Test1';				level: 2);		addChildren:			(PRToc new				name: 'Test2';				level: 2).	builder visit: document.	self assert: builder tableOfContents equals: expectedToc! !!PRTocBuilderVisitorTest methodsFor: 'tests'!testTocHasGoodLevelOfChildren	| document expectedToc |	document := PRPillarParser		parse:			'!!!! Test1!!!!!! Test2!!!! Test3!! Test4'.	expectedToc := PRToc new		level: 0;		addChildren:			(PRToc new				name: 'Test1';				level: 2;				addChildren:					(PRToc new						name: 'Test2';						level: 3));		addChildren:			(PRToc new				name: 'Test3';				level: 2);		addChildren:			(PRToc new				name: 'Test4';				level: 1).	builder visit: document.	self assert: builder tableOfContents equals: expectedToc! !!PRTocBuilderVisitorTest methodsFor: 'tests'!testTocHasOneChildren	| document expectedToc |	document := PRPillarParser		parse:			'!! Test1!!!! Test2'.	expectedToc := PRToc new		level: 0;		addChildren:			(PRToc new				name: 'Test1';				level: 1;				addChildren:					(PRToc new						name: 'Test2';						level: 2)).	builder visit: document.	self assert: builder tableOfContents equals: expectedToc! !!PRTocBuilderVisitorTest methodsFor: 'tests'!testTocIsEmpty	| document expectedToc |	document := PRPillarParser parse: 'Test1'.	builder visit: document.	expectedToc := PRToc new level: 0.	self assert: builder tableOfContents equals: expectedToc! !!PRTocBuilderVisitorTest methodsFor: 'tests'!testTocOnlyContainsTocs	| document expectedToc |	document := PRPillarParser		parse:			'!!!! Test1!!!!!! Test2!!!!!! Test3!!!! Test4!!!!!!!! Test5!! Test6!!!! Test7'.	expectedToc := PRToc new		level: 0;		addChildren:			(PRToc new				name: 'Test1';				level: 2;				addChildren:					(PRToc new						name: 'Test2';						level: 3);				addChildren:					(PRToc new						name: 'Test3';						level: 3));		addChildren:			(PRToc new				name: 'Test4';				level: 2;				addChildren:					(PRToc new						name: 'Test5';						level: 4));		addChildren:			(PRToc new				name: 'Test6';				level: 1;				addChildren:					(PRToc new						name: 'Test7';						level: 2)).	builder visit: document.	self assert: builder tableOfContents equals: expectedToc! !!PRUpdateFileInclusionReferenceTest methodsFor: 'private'!actualClass	^PRUpdateFileInclusionReference ! !!PRUpdateFileInclusionReferenceTest methodsFor: 'private'!testNewReferenceFor	|figure result expected |	figure := PRFigure new reference: 'file://foo.pillar'.	result := self actualClass start: figure with: 'bar'.	expected := PRFigure new reference: 'file://bar/foo.pillar'.		self assert: result equals: expected! !"Pillar-Tests-ExporterCore"!!PRAsciiDocWriterTest methodsFor: 'private'!actualClass	^ PRAsciiDocWriter! !!PRAsciiDocWriterTest methodsFor: 'requirements'!boldFoo	^ '*foo*'! !!PRAsciiDocWriterTest methodsFor: 'requirements'!dataItemWithBar	^ ':: bar'! !!PRAsciiDocWriterTest methodsFor: 'requirements'!definitionListBegin	^''! !!PRAsciiDocWriterTest methodsFor: 'requirements'!emailToFoo	^'foo@bar.com'! !!PRAsciiDocWriterTest methodsFor: 'requirements'!figureAnchorForPierLogo	^ '[[pierLogo]]'! !!PRAsciiDocWriterTest methodsFor: 'requirements'!figureBegin	^ 'image::'! !!PRAsciiDocWriterTest methodsFor: 'requirements'!footnoteBar	^ 'footnote:[Bar]'! !!PRAsciiDocWriterTest methodsFor: 'requirements'!horizontalRule	^ ''''''''! !!PRAsciiDocWriterTest methodsFor: 'requirements'!italicFoo	^ '''foo'''! !!PRAsciiDocWriterTest methodsFor: 'requirements'!level1HeaderWithFoo	^ '= foo'! !!PRAsciiDocWriterTest methodsFor: 'requirements'!listItemWith1	^'1'! !!PRAsciiDocWriterTest methodsFor: 'requirements'!monospaceFoo	^ '+foo+'! !!PRAsciiDocWriterTest methodsFor: 'requirements'!orderedListBegin	^ '. '! !!PRAsciiDocWriterTest methodsFor: 'requirements'!packageNamesUnderTest	^ #('Pillar-ExporterAsciiDoc')! !!PRAsciiDocWriterTest methodsFor: 'requirements'!paragraphFoo	^'foo'! !!PRAsciiDocWriterTest methodsFor: 'requirements'!preformattedFooBegin	^ ' '! !!PRAsciiDocWriterTest methodsFor: 'requirements'!preformattedTextFoo	^ 'foo'! !!PRAsciiDocWriterTest methodsFor: 'requirements'!rawText	^ '[underline]''*foo*'''! !!PRAsciiDocWriterTest methodsFor: 'requirements'!referenceToFigurePierLogo	^ '<<pierLogo>>'! !!PRAsciiDocWriterTest methodsFor: 'requirements'!resultForCaution	^ 'CAUTION:'! !!PRAsciiDocWriterTest methodsFor: 'requirements'!resultForImportant	^ 'IMPORTANT:'! !!PRAsciiDocWriterTest methodsFor: 'requirements'!resultForNotRecognizedPatterns	^ ''! !!PRAsciiDocWriterTest methodsFor: 'requirements'!resultForNote	^ 'NOTE:'! !!PRAsciiDocWriterTest methodsFor: 'requirements'!resultForTip	^ 'TIP:'! !!PRAsciiDocWriterTest methodsFor: 'requirements'!resultForWarning	^ 'WARNING:'! !!PRAsciiDocWriterTest methodsFor: 'requirements'!scriptAnchorForMyScript	^ '[[myScript]]'! !!PRAsciiDocWriterTest methodsFor: 'requirements'!scriptWithCaptionBegin	^'----'		"TODO: Test does not run"! !!PRAsciiDocWriterTest methodsFor: 'requirements'!scriptWithoutCaptionBegin	^'----'! !!PRAsciiDocWriterTest methodsFor: 'requirements'!strikethroughFoo	^ '[line-through]foo'! !!PRAsciiDocWriterTest methodsFor: 'requirements'!subscriptFoo	^ '~foo~'! !!PRAsciiDocWriterTest methodsFor: 'requirements'!superscriptFoo	^ '^foo^'! !!PRAsciiDocWriterTest methodsFor: 'requirements'!tableBegin	^ '|==='! !!PRAsciiDocWriterTest methodsFor: 'requirements'!tableCellWithFoo	^ '|foo'! !!PRAsciiDocWriterTest methodsFor: 'requirements'!tableCellWithHeadingFoo	^'|foo'! !!PRAsciiDocWriterTest methodsFor: 'requirements'!tableRow	^''! !!PRAsciiDocWriterTest methodsFor: 'requirements'!termItemWithFoo	^'foo'! !!PRAsciiDocWriterTest methodsFor: 'requirements'!testAnnotation	| note tip warning caution important nonRecognized text |	text := PRText content: 'foo'.	note := PRAnnotatedParagraph new		annotation: 'note';		add: text.	tip := PRAnnotatedParagraph new		annotation: 'tip';		add: text.	warning := PRAnnotatedParagraph new		annotation: 'warning';		add: text.	caution := PRAnnotatedParagraph new		annotation: 'caution';		add: text.	important := PRAnnotatedParagraph new		annotation: 'todo';		add: text.	nonRecognized := PRAnnotatedParagraph new		annotation: 'toto';		add: text.	self assertWriting: note includesText: self resultForNote.	self assertWriting: tip includesText: self resultForTip.	self assertWriting: warning includesText: self resultForWarning.	self assertWriting: caution includesText: self resultForCaution.	self assertWriting: important includesText: self resultForImportant.	self assert: (self write: nonRecognized) trimRight equals: (self resultForNotRecognizedPatterns, text text).! !!PRAsciiDocWriterTest methodsFor: 'requirements'!testFigureWithoutLabelAndWithoutCaptionAreExportedWithoutEnvironment	self skip: 'no figure environment in asciidoc'! !!PRAsciiDocWriterTest methodsFor: 'as yet unclassified'!testInternalLinkWithAliasWithRefWithAncorWithSeparateOutputFiles	self flag: 'TODO: check if this is important after large refactoring'! !!PRAsciiDocWriterTest methodsFor: 'as yet unclassified'!testInternalLinkWithAliasWithReferenceWithoutAnchorWithSeparateOutputFiles	self flag: 'TODO: check if this is important after large refactoring'! !!PRAsciiDocWriterTest methodsFor: 'as yet unclassified'!testInternalLinkWithAliasWithoutReferenceWithAnchorWithSeparateOutputFiles	self flag: 'TODO: check if this is important after large refactoring'! !!PRAsciiDocWriterTest methodsFor: 'as yet unclassified'!testInternalLinkWithoutAliasWithRefWithAncorWithSeparateOutputFiles	self flag: 'TODO: check if this is important after large refactoring'! !!PRAsciiDocWriterTest methodsFor: 'as yet unclassified'!testInternalLinkWithoutAliasWithReferenceWithoutAnchorWithSeparateOutputFiles	self flag: 'TODO: check if this is important after large refactoring'! !!PRAsciiDocWriterTest methodsFor: 'as yet unclassified'!testInternalLinkWithoutAliasWithoutReferenceWithAnchorWithSeparateOutputFiles	self flag: 'TODO: check if this is important after large refactoring'! !!PRAsciiDocWriterTest methodsFor: 'requirements'!underlineFoo	^ '[underline]foo'! !!PRAsciiDocWriterTest methodsFor: 'requirements'!unorderedListBegin	^ '* '! !"Pillar-Tests-ExporterAsciiDoc"!!ManifestPillarMicrodown commentStamp: '' prior: 0!I contain microdown extension that are only relevant when the full pillar is loaded. By default we do not load environment and annotation. !!MicInlineParserTest methodsFor: '*Pillar-Microdown'!testAnnotationAsPillar	| res |	res := self splitter pillarFrom: 'abc{!!cite|a=2&b=5!!}def'.	self assert: res second class equals: PRCitationAnnotation.	self assert: (res second parameters at: 'a') equals: '2'.	self assert: (res second parameters at: 'b') equals: '5'.! !!PRMicrodownInputDocumentTest methodsFor: 'tests'!testParsedDocument		| doc |	doc := ((PRInputDocument inputClassForFile: memoryFileSystem / 'input1.md') new 					file:  memoryFileSystem / 'input1.md') parsedDocument.	self 		assert: doc class		equals: MicRootBlock! !!PRMicrodownInputDocumentTest methodsFor: 'tests'!testParsedDocument2		| doc |	doc := (PRInputDocument forFile: memoryFileSystem / 'input1.md') parsedDocument.	self 		assert: doc class		equals: MicRootBlock! !!PRMicrodownInputDocumentTest methodsFor: 'tests'!testParserClass		| input |	input := (PRInputDocument inputClassForFile: memoryFileSystem / 'input1.md') new.	self 		assert: input parserClass 		equals: MicrodownParser! !!PRMicrodownInputDocumentTest methodsFor: 'tests'!testParserClass2		| input |	input := PRInputDocument forFile: memoryFileSystem / 'input1.md'.	self 		assert: input parserClass 		equals: MicrodownParser! !!PRMicrodownInputDocumentTest methodsFor: 'tests'!testRegistration		| inputClass |	inputClass := (PRInputDocument inputClassForFile: memoryFileSystem / 'input1.md').	self 		assert: inputClass 		equals: MicMicrodownInputDocument! !!PRMicrodownInputDocumentTest methodsFor: 'tests'!testRegistration2		| inputClass |	inputClass := (PRInputDocument forFile: memoryFileSystem / 'input1.md') class.	self 		assert: inputClass 		equals: MicMicrodownInputDocument! !!PRMicrodownInputDocument class methodsFor: 'registration'!doesHandleExtension: anExtension	^ anExtension asLowercase= 'md'! !!PRMicrodownInputDocument methodsFor: 'accessing'!parsedDocument1halt.	^ (self parserClass parse: file contents) asPillar! !!PRMicrodownInputDocument methodsFor: 'accessing'!parserClass	^ MicrodownParser! !"Pillar-Microdown"!!PRHtmlDocumentTest methodsFor: 'tests'!createMustacheTemplateFile	| mustacheTemplate |	mustacheTemplate := memoryFileSystem / 'html.mustache'.		mustacheTemplate writeStreamDo: [ :stream |		stream nextPutAll: '<!!DOCTYPE html><html>	<head>		<title>{{site_name}}</title>	</head>	<body>		<div class="row">			<div class="col-xs-12 col-md-4 section-heading">				{{# toc}}					{{name}} 						{{#children}}							<h1>{{name}}</h1>						{{/children}}				{{/ toc}}			</div>						<div class="col-xs-12 col-md-8">				{{{content}}}			</div>		</div>	</body></html>'		 ]! !!PRHtmlDocumentTest methodsFor: 'tests'!createPillarConfFile	| pillarConf |	pillarConf := memoryFileSystem / 'pillar.conf'.		pillarConf writeStreamDo: [ :stream |		stream nextPutAll: '{  "title": "The Pillar Super Book Archetype",  "attribution": "The Pillar team",  "series": "Square Bracket tutorials",  "keywords": "project template, Pillar, Pharo, Smalltalk",  "language": "en-UK",  "epub-id": "urn:uuid:A1B0D67E-2E81-4DF5-9E67-A64CBE366809",    "latexTemplate": "main.latex.mustache",  "htmlTemplate": "html.mustache",  "latexWriter" : #''latex:sbabook'',  "htmlWriter": #html}'		 ]! !!PRHtmlDocumentTest methodsFor: 'tests'!createPillarFile1	| pillarFile |	pillarFile := memoryFileSystem / 'input1.pillar'.		pillarFile writeStreamDo: [ :stream |		stream nextPutAll: '!!!!!! TestFile11+Pillar logo>figures/pillar.png|width=30+If you don''t know ''Pillar'', its documentation is *here>https://ci.inria.fr/pharo-contribution/job/EnterprisePharoBook/lastSuccessfulBuild/artifact/book-result/PillarChap/Pillar.html*!!!!!! TestFile12Hey you ...!!!!!! TestFile13The book is generated directly in HTML and LaTeX with the command ==make book==You can compile just one chapter with the command ==make book-result/chapterPathAndName.format==For example, for the first chapter in LaTeX: ==make book-result/Chapters/Chapter1/chapter1.tex==!!!!!! TestFile14What are you thinking about !!!!!!??!!!!!! TestFile15Where are you !!!!'		 ]! !!PRHtmlDocumentTest methodsFor: 'initialization'!setUp	super setUp.	memoryFileSystem := FileSystem memory.	self createPillarFile1.	self createMustacheTemplateFile.	self createPillarConfFile.	project := PRProject new baseDirectory: memoryFileSystem workingDirectory! !!PRHtmlDocumentTest methodsFor: 'tests'!testMustacheTemplateWithHtmlOutputContainsTocAnnotation		| htmlDocument |	htmlDocument := PRHtmlDocument new 		project: project; 		file: (memoryFileSystem / 'input1.pillar'); 		target: PRHtmlOutput new.	self assert: ((htmlDocument getMustacheTemplateValuesFromDocument: (PRPillarParser parse: (memoryFileSystem / 'input1.pillar') contents)) includesKey: #toc)! !!PRHtmlDocumentTest methodsFor: 'tests'!testMustacheTemplateWithPdfOutputDontContainsTocAnnotation	| htmlDocument |	htmlDocument := PRPDFDocument new project: project; 		file: memoryFileSystem / 'input1.pillar'; 		target: PRPdfOutput new.		self deny: ((htmlDocument getMustacheTemplateValuesFromDocument: (PRPillarParser parse: (memoryFileSystem / 'input1.pillar') contents)) includesKey: #toc)! !!PRHTMLWriterTest class methodsFor: 'testing'!isAbstract	^ false! !!PRHTMLWriterTest methodsFor: 'private'!actualClass	^ PRHTMLWriter! !!PRHTMLWriterTest methodsFor: 'requirements'!annotationBegin: annotationString	^'<p class="' , annotationString, '">' ! !!PRHTMLWriterTest methodsFor: 'requirements'!boldFoo	^ '<strong>foo</strong>'! !!PRHTMLWriterTest methodsFor: 'requirements'!dataItemWithBar	^ '<dd>bar</dd>'! !!PRHTMLWriterTest methodsFor: 'requirements'!definitionListBegin	^ '<dl>'! !!PRHTMLWriterTest methodsFor: 'requirements'!emailToFoo	^ '<a href="mailto:foo@bar.com">'! !!PRHTMLWriterTest methodsFor: 'requirements'!figureAnchorForPierLogo	^ '<a id="pierLogo">'! !!PRHTMLWriterTest methodsFor: 'requirements'!figureBegin	^ '<figure>'! !!PRHTMLWriterTest methodsFor: 'private'!footnoteBar	^ '<sup><a href="#footnote1">[1]</a></sup>'! !!PRHTMLWriterTest methodsFor: 'requirements'!horizontalRule	^ '<hr>'! !!PRHTMLWriterTest methodsFor: 'requirements'!italicFoo	^ '<em>foo</em>'! !!PRHTMLWriterTest methodsFor: 'requirements'!level1HeaderBegin	^ '<h1>'! !!PRHTMLWriterTest methodsFor: 'requirements'!level1HeaderWithFoo	^ '<h1>foo</h1>'! !!PRHTMLWriterTest methodsFor: 'requirements'!level2HeaderBegin	^ '<h2>'! !!PRHTMLWriterTest methodsFor: 'requirements'!level3HeaderBegin	^ '<h3>'! !!PRHTMLWriterTest methodsFor: 'requirements'!listItemWith1	^ '<li>1</li>'! !!PRHTMLWriterTest methodsFor: 'requirements'!monospaceFoo	^ '<code>foo</code>'! !!PRHTMLWriterTest methodsFor: 'requirements'!orderedListBegin	^ '<ol>'! !!PRHTMLWriterTest methodsFor: 'accessing'!packageNamesUnderTest	^ #('Pillar-ExporterHTML')! !!PRHTMLWriterTest methodsFor: 'requirements'!paragraphFoo	^ '<p>' , Smalltalk os lineEnding , 'foo' , Smalltalk os lineEnding , '</p>'! !!PRHTMLWriterTest methodsFor: 'requirements'!preformattedFooBegin	^ '<pre>'! !!PRHTMLWriterTest methodsFor: 'requirements'!preformattedTextFoo	^ 'foo'! !!PRHTMLWriterTest methodsFor: 'requirements'!rawText	^ '<img>'! !!PRHTMLWriterTest methodsFor: 'requirement-InternalLinks'!resultWithRefWithAnchorWithSeparateOutputFiles	^ 'href="ref.html#foo"'! !!PRHTMLWriterTest methodsFor: 'requirement-InternalLinks'!resultWithRefWithoutAnchorWithSeparateOutputFiles	^ 'href="ref.html"'! !!PRHTMLWriterTest methodsFor: 'requirement-InternalLinks'!resultWithoutAliasWithoutRefWithAnchorWithSeparateOutputFiles	^ 'href="#foo"'! !!PRHTMLWriterTest methodsFor: 'requirement-InternalLinks'!resultWithoutRefWithAnchorWithSeparateOutputFiles	^ 'href="#foo"'! !!PRHTMLWriterTest methodsFor: 'requirements'!scriptAnchorForMyScript	^ '<a id="myScript">'! !!PRHTMLWriterTest methodsFor: 'requirements'!scriptWithCaptionBegin	^ '<pre><code'! !!PRHTMLWriterTest methodsFor: 'requirements'!scriptWithoutCaptionBegin	^ '<pre><code'! !!PRHTMLWriterTest methodsFor: 'requirements'!strikethroughFoo	^ '<s>foo</s>'! !!PRHTMLWriterTest methodsFor: 'requirements'!subscriptFoo	^ '<sub>foo</sub>'! !!PRHTMLWriterTest methodsFor: 'requirements'!superscriptFoo	^ '<sup>foo</sup>'! !!PRHTMLWriterTest methodsFor: 'requirements'!tableBegin	^ '<table'! !!PRHTMLWriterTest methodsFor: 'requirements'!tableCellWithFoo	^ '<td>foo</td>'! !!PRHTMLWriterTest methodsFor: 'requirements'!tableCellWithHeadingFoo	^ '<th>foo</th>'! !!PRHTMLWriterTest methodsFor: 'requirements'!tableRow	^ '<tr>'! !!PRHTMLWriterTest methodsFor: 'requirements'!termItemWithFoo	^ '<dt>foo</dt>'! !!PRHTMLWriterTest methodsFor: 'tests'!testAnchor	| item |	item := PRAnchor new name: 'foo'.	self assertWriting: item includesText: 'id="foo"'! !!PRHTMLWriterTest methodsFor: 'tests'!testExportingIsolatedRaw	"The idea is that you don''t want the <p> when using a Raw that potentially displays a <div>, because this is not HTML compliant"	| item |	item := PRDocument new		add:				(PRParagraph new						add: (PRRaw content: '<div>foo</div>');						yourself);		yourself.	self assert: (self write: item) equals: '<div>foo</div>'! !!PRHTMLWriterTest methodsFor: 'tests'!testFootnoteAtEnd	| item |	item := PRFootnote new note: 'foo'.	self assertWriting: item includesText: '<sup id="footnote1">[1] foo</sup>'! !!PRHTMLWriterTest methodsFor: 'tests'!testHeaderOne	| aNode aContents |	aNode := PRHeader new 		level: 1;		add: (PRText new text: 'Header One').	aContents := (FileReference newTempFilePrefix: 'a' suffix: 'b')		writeStreamDo: [ :writeStream | 			PRHTMLWriter new write: aNode to: writeStream ];		contents.			self assert: aContents trimBoth equals: '<h1>Header One</h1>' trimBoth! !!PRHTMLWriterTest methodsFor: 'requirements'!underlineFoo	^ '<u>foo</u>'! !!PRHTMLWriterTest methodsFor: 'requirements'!unorderedListBegin	^ '<ul>'! !!PRHTMLWriterTest methodsFor: 'requirements'!widthFor50percents	^ '50%'! !!PRInternalLinkTest methodsFor: '*Pillar-Tests-ExporterHTML'!testReferenceAsHTML	| link |	link := PRInternalLink reference: 'foo.pillar'.	self assert: link referenceAsHTML equals: 'foo.html'.	link := PRInternalLink reference: 'foo.pilla'.	self should: [ link referenceAsHTML ] raise: PRLinkWarning! !"Pillar-Tests-ExporterHTML"!!PRDeckJSWriterTest methodsFor: 'private' prior: 36229827!actualClass	^ PRDeckJSWriter! !!PRDeckJSWriterTest methodsFor: 'requirements' prior: 36229919!endSlideTag	^ '</div>'! !!PRDeckJSWriterTest methodsFor: 'requirements' prior: 36230011!headerInSlide	"I return one string that define a header rendering in a slide."	^ '<h1>'! !!PRDeckJSWriterTest methodsFor: 'accessing'!packageNamesUnderTest	^ #('Pillar-ExporterDeckJS')! !!PRDeckJSWriterTest methodsFor: 'requirements' prior: 36230172!representationOfAnchor	"I return a string which reprensent an anchor in the slider format."	^ '<a id="'! !!PRDeckJSWriterTest methodsFor: 'results'!resultWithRefWithAnchorWithSeparateOutputFiles	^ '#slide-0'! !!PRDeckJSWriterTest methodsFor: 'results'!resultWithoutAliasWithoutRefWithAnchorWithSeparateOutputFiles	^ '#slide-0'! !!PRDeckJSWriterTest methodsFor: 'results'!resultWithoutRefWithAnchorWithSeparateOutputFiles	^ '#slide-0'! !!PRDeckJSWriterTest methodsFor: 'requirements' prior: 36230346!slideRepresentation	^ {'<div'.	'class'.	'slide'.	'</div>'}! !!PRDeckJSWriterTest methodsFor: 'requirements' prior: 36230446!slideTitle	"I return a collection with an explicite rendering of a slide title."	^ {'<h2>'.	'Slide title'.	'</h2>'}! !!PRDeckJSWriterTest methodsFor: 'tests'!testAnchor	"Anchors define by the user in deck.js doesn't work so we don't need to render them."	| item |	item := PRAnchor new name: 'foo'.	self deny: ((self write: item) includesSubstring: 'id="foo"')! !!PRAssociateAnchorToSlideNumberTest methodsFor: 'private'!actualClass	^ PRAssociateAnchorToSlideNumber! !!PRAssociateAnchorToSlideNumberTest methodsFor: 'tests'!configurationClass	^ ConfigurationForPillar! !!PRAssociateAnchorToSlideNumberTest methodsFor: 'tests'!testVisitDocumentWithFigure	| item dictionary config |	item := PRDocument new		add:			(PRFigure new				reference: 'file://picture.png';				parameterAt: 'label' put: 'foo';				yourself);		yourself.	dictionary := Dictionary with: 'foo' -> 1.	config := self configurationClass new		renderStructureAsSlide: false;		yourself.	self		assert:			(self actualInstance				configuration: config;				start: item)		equals: dictionary! !!PRAssociateAnchorToSlideNumberTest methodsFor: 'tests'!testVisitDocumentWithScript	| item dictionary config |	item := PRDocument new		add:			((PRCodeblock content: '|test| test := test')				label: 'foo';				yourself);		yourself.	dictionary := Dictionary with: 'foo' -> 1.	config := self configurationClass new		renderStructureAsSlide: false;		yourself.	self		assert:			(self actualInstance				configuration: config;				start: item)		equals: dictionary! !!PRAssociateAnchorToSlideNumberTest methodsFor: 'tests'!testVisitDocumentWithSlideWithLabel	| item dictionary config |	item := PRDocument new		add: (PRSlide new label: 'foo');		yourself.	dictionary := Dictionary with: 'foo' -> 2.	config := self configurationClass new		renderStructureAsSlide: false;		yourself.	self		assert:			(self actualInstance				configuration: config;				start: item)		equals: dictionary! !!PRAssociateAnchorToSlideNumberTest methodsFor: 'tests'!testVisitWithSlideInTemplate	| item dictionary config |	item := PRDocument new		add:			(PRHeader new				level: 1;				add: (PRText content: 'Foo'));		add: (PRAnchor named: 'Bar');		add:			(PRSlide new				add: (PRAnchor named: 'bar');				yourself) yourself.	dictionary := Dictionary with: 'Bar' -> 3 with: 'bar' -> 4.	config := self configurationClass new		renderStructureAsSlide: true;		slideInTemplateForDeckJS: 2;		yourself.	self		assert:			(self actualInstance				configuration: config;				start: item)		equals: dictionary! !!PRAssociateAnchorToSlideNumberTest methodsFor: 'tests'!testVisitWithSlideWithHeaderRendering	| item dictionary config |	item := PRDocument new		add:			(PRHeader new				level: 1;				add: (PRText content: 'Foo'));		add: (PRAnchor named: 'Bar');		add:			(PRSlide new				add: (PRAnchor named: 'bar');				yourself) yourself.	dictionary := Dictionary with: 'Bar' -> 2 with: 'bar' -> 3.	config := self configurationClass new		renderStructureAsSlide: true;		yourself.	self		assert:			(self actualInstance				configuration: config;				start: item)		equals: dictionary! !!PRAssociateAnchorToSlideNumberTest methodsFor: 'tests'!testVisitWithSlideWithoutHeaderRendering	| item dictionary config |	item := PRDocument new		add:			(PRHeader new				level: 1;				add: (PRText content: 'Foo'));		add: (PRAnchor named: 'Bar');		add:			(PRSlide new				add: (PRAnchor named: 'bar');				yourself) yourself.	dictionary := Dictionary with: 'Bar' -> 1 with: 'bar' -> 2.	config := self configurationClass new		renderStructureAsSlide: false;		yourself.	self		assert:			(self actualInstance				configuration: config;				start: item)		equals: dictionary! !!PRAssociateAnchorToSlideNumberTest methodsFor: 'tests'!testVisitWithoutSlideWithHeaderRendering	| item dictionary config |	item := PRDocument new		add:			(PRHeader new				level: 1;				add: (PRText content: 'Foo'));		add: (PRAnchor named: 'Bar');		yourself.	dictionary := Dictionary with: 'Bar' -> 2.	config := self configurationClass new		renderStructureAsSlide: true;		yourself.	self		assert:			(self actualInstance				configuration: config;				start: item)		equals: dictionary! !!PRAssociateAnchorToSlideNumberTest methodsFor: 'tests'!testVisitWithoutSlideWithoutHeaderRendering	| item dictionary config |	item := PRDocument new		add:			(PRHeader new				level: 1;				add: (PRText content: 'Foo'));		add: (PRAnchor named: 'Bar');		yourself.	dictionary := Dictionary with: 'Bar' -> 1.	config := self configurationClass new		renderStructureAsSlide: false;		yourself.	self		assert:			(self actualInstance				configuration: config;				start: item)		equals: dictionary! !"Pillar-Tests-ExporterDeckJS"!!PREPubNavigationMenuWriterTest methodsFor: 'private'!actualClass	^PREPubNavigationMenuWriter ! !!PREPubNavigationMenuWriterTest methodsFor: 'requirements'!level1HeaderWithFoo	^'<li><a href="contents.xhtml#foo">foo'! !!PREPubNavigationMenuWriterTest methodsFor: 'requirements'!packageNamesUnderTest	^ #('Pillar-ExporterEPub')! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testAnnotation	| item |	{'note' . 'dothis'}		do: [ :annotation | 			item := PRAnnotatedParagraph new				annotation: annotation;				add: (PRText content: 'foo');				yourself.			self assertEmpty: (self write: item) ]! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testConsecutiveTextsInAParagraphAreSeparatedByWhitespace	| item |	item := PRParagraph new		add: (PRText content: 'foo');		add: PRLineBreak new;		add: (PRText content: 'bar');		yourself.	self assertEmpty: (self write: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testDefinitionList	| item |	item := PRDefinitionList new		add: (self addText: 'foo' to: PRTermItem new);		add: (self addText: 'bar' to: PRDataItem new);		yourself.	self assertEmpty: (self write: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testExportingIsolatedRaw	"The idea is that you don''t want the <p> when using a Raw that potentially displays a <div>, because this is not HTML compliant"	| item |	item := PRDocument new		add:			(PRParagraph new				add: (PRRaw content: '<div>foo</div>');				yourself);		yourself.	self assertEmpty: (self write: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testFigure	| item |	item := PRFigure new		reference: 'file://picture.png';		yourself.	self assertEmpty: (self write: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testFigureLabelGenerateAnchor	| item |	item := PRFigure new		reference: 'file://picture.png';		parameterAt: 'label' put: 'pierLogo';		yourself.	self assertEmpty: (self write: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testFigureReference	| item |	item := PRParagraph new		add:			(PRFigure new				reference: 'file://picture.png';				parameterAt: 'label' put: 'pierLogo';				counter: ((PRCascadingCounter maxLevel: 5) incrementAt: 2);				yourself);		add: (PRText content: 'See figure ');		add: ((PRInternalLink reference: '@pierLogo') counter: ((PRCascadingCounter maxLevel: 5) incrementAt: 2));		yourself.	self write: item.	self assertEmpty: (self write: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testFigureWithLabelAndWithCaptionAreExportedWithEnvironment	| item |	item := PRFigure new		reference: 'file://picture.png';		add: (PRText content: 'caption');		label: 'label';		yourself.	self assertEmpty: (self write: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testFigureWithLabelAndWithoutCaptionAreExportedWithEnvironment	| item |	item := PRFigure new		reference: 'file://picture.png';		label: 'label';		yourself.	self assertEmpty: (self write: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testFigureWithWidth	| item width |	width := '50'.	item := PRFigure new		reference: 'file://picture.png';		parameterAt: 'width' put: width;		yourself.	self assertEmpty: (self write: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testFigureWithoutLabelAndWithCaptionAreExportedWithEnvironment	| item |	item := PRFigure new		reference: 'file://picture.png';		add: (PRText content: 'caption');		yourself.	self assertEmpty: (self write: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testFiguresHaveACaption	| item caption filename |	caption := 'A description'.	filename := 'picture.png'.	item := PRFigure new		reference: 'file://' , filename;		label: 'picture';		add: (PRText content: caption);		yourself.	self assertEmpty: (self write: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testFootnote	| item |	item := PRParagraph new		add: (PRText content: 'timo');		add: (PRFootnote noted: 'Bar');		add: (PRText content: 'leon');		yourself.	self assertEmpty: (self write: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testHeadersAreNumbered	self skip: 'Headers are not numbered in navigation menu'! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testInternalLinkWithAliasWithRefWithAncorWithSeparateOutputFiles	| item |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:			((PRInternalLink reference: 'ref.pillar@foo')				addAll: {(PRText content: 'Alias')};				yourself);		yourself.	self assertEmpty: (self writeWithSeparateOutputFiles: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testInternalLinkWithAliasWithRefWithAncorWithoutSeparateOutputFiles	| item |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:			((PRInternalLink reference: 'ref.pillar@foo')				addAll: {(PRText content: 'Alias')};				yourself);		yourself.	self assertEmpty: (self write: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testInternalLinkWithAliasWithReferenceWithoutAnchorWithSeparateOutputFiles	| item |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:			((PRInternalLink reference: 'ref.pillar')				addAll: {(PRText content: 'Alias')};				yourself);		yourself.	self assertEmpty: (self writeWithSeparateOutputFiles: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testInternalLinkWithAliasWithReferenceWithoutAnchorWithoutSeparateOutputFiles	| item |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:			((PRInternalLink reference: 'ref')				addAll: {(PRText content: 'Alias')};				yourself);		yourself.	self assertEmpty: (self write: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testInternalLinkWithAliasWithoutReferenceWithAnchorWithSeparateOutputFiles	| item |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:			((PRInternalLink reference: '@foo')				addAll: {(PRText content: 'Alias')};				yourself);		yourself.	self assertEmpty: (self writeWithSeparateOutputFiles: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testInternalLinkWithAliasWithoutReferenceWithAnchorWithoutSeparateOutputFiles	| item |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:			((PRInternalLink reference: '@foo')				addAll: {(PRText content: 'Alias')};				yourself);		yourself.	self assertEmpty: (self write: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testInternalLinkWithoutAliasWithRefWithAncorWithSeparateOutputFiles	| item |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add: (PRInternalLink reference: 'ref.pillar@foo');		yourself.	self assertEmpty: (self writeWithSeparateOutputFiles: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testInternalLinkWithoutAliasWithRefWithAncorWithoutSeparateOutputFiles	| item |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add: (PRInternalLink reference: 'ref.pillar@foo');		yourself.	self assertEmpty: (self write: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testInternalLinkWithoutAliasWithReferenceWithoutAnchorWithSeparateOutputFiles	| item |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add: (PRInternalLink reference: 'ref.pillar');		yourself.	self assertEmpty: (self writeWithSeparateOutputFiles: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testInternalLinkWithoutAliasWithReferenceWithoutAnchorWithoutSeparateOutputFiles	| item |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:			((PRInternalLink reference: 'ref')				addAll: {(PRText content: 'Alias')};				yourself);		yourself.	self assertEmpty: (self write: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testInternalLinkWithoutAliasWithoutReferenceWithAnchorWithSeparateOutputFiles	| item |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add: (PRInternalLink reference: '@foo') yourself;		yourself.	self assertEmpty: (self writeWithSeparateOutputFiles: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testInternalLinkWithoutAliasWithoutReferenceWithAnchorWithoutSeparateOutputFiles	| item |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add: (PRInternalLink reference: '@foo') yourself;		yourself.	self assertEmpty: (self write: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testOrderedList	| item |	item := PROrderedList new		add: (self addText: '1' to: PRListItem new);		yourself.	self assertEmpty: (self write: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testParagraph	| item |	item := self addText: 'foo' to: PRParagraph new.	self assertEmpty: (self write: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testReferenceToFigureAnchor	| item resultString |	item := PRDocument new		add:				(PRHeader new						level: 1;						add: (PRText content: 'foo');						counter: ((PRCascadingCounter maxLevel: 5) incrementAt: 1);						yourself);		add:				(PRParagraph new						add:								(PRFigure new										reference: 'file://picture.png';										parameterAt: 'label' put: 'fig:picture';										counter:												((PRCascadingCounter maxLevel: 5)														incrementAt: 1;														incrementAt: 2);										yourself);						add: (PRText content: 'See Figure ');						add:								((PRInternalLink reference: 'fig:picture')										counter:												((PRCascadingCounter maxLevel: 5)														incrementAt: 1;														incrementAt: 2);										yourself);						yourself).	resultString := self write: item.	self assert: resultString includesSubstring: self level1HeaderWithFoo! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testReferenceToHeaderAnchor	| item resultString |	item := PRDocument new		add:				(PRHeader new						level: 1;						add: (PRText content: 'foo');						counter: ((PRCascadingCounter maxLevel: 5) incrementAt: 1);						yourself);		add: (PRAnchor named: 'chap:foo');		add:				(PRParagraph new						add: (PRText content: 'See Chapter ');						add:								((PRInternalLink reference: 'chap:foo')										counter: ((PRCascadingCounter maxLevel: 5) incrementAt: 1);										yourself);						yourself);		yourself.	resultString := self write: item.	self assert: resultString includesSubstring: self level1HeaderWithFoo! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testScript	| item |	item := PRCodeblock content: 'foo'.	self assertEmpty: (self write: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testScriptDefaultLanguage	| item |	self supportSyntaxHighlighting ifFalse: [ self skip ].	item := PRCodeblock content: 'foo'.	self assertEmpty: (self write: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testScriptLabelGenerateAnchor	| item |	item := (PRCodeblock content: 'foo')		label: 'myScript';		yourself.	self assertEmpty: (self write: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testScriptLanguage	| item |	self supportSyntaxHighlighting ifFalse: [ self skip ].	item := (PRCodeblock content: 'foo')		language: 'html';		yourself.	self assertEmpty: (self writeWithSeparateOutputFiles: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testScriptWithFormattedCaption	| item |	item := (PRCodeblock content: 'bar')		caption: '""foo""';		yourself.	self assertEmpty: (self write: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testScriptWithProblematicEval	| item nonExistingMethod |	nonExistingMethod := 'FooBarDoesNotExistX'.	item := (PRCodeblock content: 'Object ' , nonExistingMethod)		eval: true;		yourself.	self assertEmpty: (self write: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testScriptsHaveACaption	| item caption |	caption := 'A description'.	item := (PRCodeblock content: 'foo')		caption: caption;		yourself.	self assertEmpty: (self write: item)! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testSubHeadersAreNumbered	self skip: 'Headers are not numbered in navigation menu'! !!PREPubNavigationMenuWriterTest methodsFor: 'tests'!testUnorderedList	| item |	item := PRUnorderedList new		add: (self addText: '1' to: PRListItem new);		yourself.	self assertEmpty: (self write: item)! !!PREPubTocMenuWriterTest methodsFor: 'as yet unclassified'!actualClass	^PREPubTocMenuWriter ! !!PREPubTocMenuWriterTest methodsFor: 'as yet unclassified'!level1HeaderWithFoo	^'<navLabel><text>foo</text></navLabel>'! !!PREPubTocMenuWriterTest methodsFor: 'as yet unclassified'!packageNamesUnderTest	^ #('Pillar-ExporterEPub')! !!PREPubTocMenuWriterTest methodsFor: 'as yet unclassified'!testHeadersAreNumbered	self skip: 'Headers are not numbered in toc menu'! !!PREPubTocMenuWriterTest methodsFor: 'as yet unclassified'!testSubHeadersAreNumbered	self skip: 'Headers are not numbered in toc menu'! !!PRXHTMLWriterTest methodsFor: 'private'!actualClass	^PRXHTMLWriter ! !!PRXHTMLWriterTest methodsFor: 'private'!figureAnchorForPierLogo	^ '<img src="picture.png" id="pierLogo" alt=""/>'! !!PRXHTMLWriterTest methodsFor: 'private'!figureBegin	^ '<img'! !!PRXHTMLWriterTest methodsFor: 'requirements'!level1HeaderWithFoo	^ '<div id="foo"><h1>foo</h1>'! !!PRXHTMLWriterTest methodsFor: 'private'!strikethroughFoo	^ '<span class="striked">foo</span>'! !!PRXHTMLWriterTest methodsFor: 'tests'!testFigureWithoutLabelAndWithoutCaptionAreExportedWithoutEnvironment	| item result |	item := PRFigure new		reference: 'file://picture.png';		yourself.	result := self write: item.	self assert: (result includesSubstring: self figureBegin)! !!PRXHTMLWriterTest methodsFor: 'private'!underlineFoo	^ '<span class="underline">foo</span>'! !!PREPubMenuJustHeaderTransformerTest2 methodsFor: 'private'!actualClass	^ PREPubMenuJustHeaderTransformer! !!PREPubMenuJustHeaderTransformerTest2 methodsFor: 'private'!actualWriterClass	^ PREPubTocMenuWriter! !!PREPubMenuJustHeaderTransformerTest2 methodsFor: 'tests'!expected: expected withInput: input	self		assert:			(self				executePhase: input				with:					(self configuration						propertyAt: #_outputFormat put: self actualWriterClass new;						yourself))		equals: expected! !!PREPubMenuJustHeaderTransformerTest2 methodsFor: 'tests'!testKeepHeaderWithOneHeader	| input expected |	input := PRDocument new		add:			(PRHeader new				level: 1;				add: (PRText content: 'foo');				yourself);		yourself.	expected := PRDocument new		add:			(PRSection new				add:					(PRHeader new						level: 1;						add: (PRText content: 'foo');						yourself);				yourself);		yourself.	self expected: expected withInput: input! !!PREPubMenuJustHeaderTransformerTest2 methodsFor: 'tests'!testKeepHeaderWithParagraph	| input expected |	input := PRDocument new		add:			(PRHeader new				level: 1;				add: (PRText content: 'foo');				yourself);		add: (PRParagraph new add: (PRText content: 'bar'));		yourself.	expected := PRDocument new		add:			(PRSection new				add:					(PRHeader new						level: 1;						add: (PRText content: 'foo');						yourself)).	self expected: expected withInput: input! !!PREPubMenuJustHeaderTransformerTest2 methodsFor: 'tests'!testKeepHeaderWithParagraph2	| input expected |	input := PRDocument new		add: (PRParagraph new add: (PRText content: 'bar'));		add:			(PRHeader new				level: 1;				add: (PRText content: 'foo');				yourself);		yourself.	expected := PRDocument new		add:			(PRSection new				add:					(PRHeader new						level: 1;						add: (PRText content: 'foo');						yourself)).	self expected: expected withInput: input! !!PREPubMenuJustHeaderTransformerTest2 methodsFor: 'tests'!testKeepHeaderWithScript	| input expected |	input := PRDocument new		add: (PRCodeblock content: 'hello');		add:			(PRHeader new				level: 1;				add: (PRText content: 'foo');				yourself);		yourself.	expected := PRDocument new		add:			(PRSection new				add:					(PRHeader new						level: 1;						add: (PRText content: 'foo');						yourself)).	self expected: expected withInput: input! !!PREPubMenuJustHeaderTransformerTest2 methodsFor: 'tests'!testTransformWith2Headers	| input expected |	input := PRDocument new		add:			(PRHeader new				level: 1;				add: (PRText content: 'Bar') yourself);		add: (PRParagraph with: (PRText content: 'Foo') yourself);		add:			(PRHeader new				level: 2;				add: (PRText content: 'Bar2') yourself);		add: (PRParagraph with: (PRText content: 'Foo2') yourself);		yourself.	expected := PRDocument new		add:			(PRSection new				add:					(PRHeader new						level: 1;						add: (PRText content: 'Bar') yourself);				add:					(PRSection new						add:							(PRHeader new								level: 2;								add: (PRText content: 'Bar2') yourself))) yourself.	self expected: expected withInput: input! !!PREPubMenuJustHeaderTransformerTest2 methodsFor: 'tests'!testTransformWith3Headers	| input expected |	input := PRDocument new		add:			(PRHeader new				level: 1;				add: (PRText content: 'Bar') yourself);		add: (PRParagraph with: (PRText content: 'Foo') yourself);		add:			(PRHeader new				level: 2;				add: (PRText content: 'Bar2') yourself);		yourself;		add:			(PRHeader new				level: 2;				add: (PRText content: 'Bar2b') yourself);		add: (PRParagraph with: (PRText content: 'Foo2') yourself);		yourself.	expected := PRDocument new		add:			(PRSection new				add:					(PRHeader new						level: 1;						add: (PRText content: 'Bar') yourself);				add:					(PRSection new						add:							(PRHeader new								level: 2;								add: (PRText content: 'Bar2') yourself));				add:					(PRSection new						add:							(PRHeader new								level: 2;								add: (PRText content: 'Bar2b')))) yourself.	self expected: expected withInput: input! !!PREPubMenuJustHeaderTransformerTest2 methodsFor: 'tests'!testTransformWithOneSection	| input expected |	input := PRDocument new		add:			(PRHeader new				level: 1;				add: (PRText content: 'Bar') yourself);		add: (PRParagraph with: (PRText content: 'Foo!!') yourself);		yourself.	expected := PRDocument new		add:			(PRSection new				add:					(PRHeader new						level: 1;						add: (PRText content: 'Bar') yourself);				yourself) yourself.	self expected: expected withInput: input! !"Pillar-Tests-ExporterEPub"!!PRGithubMarkdownWriterTest methodsFor: 'private'!actualClass	^ PRGithubMarkdownWriter ! !!PRGithubMarkdownWriterTest methodsFor: 'requirements'!strikethroughFoo	^ '~foo~'! !!PRGithubMarkdownWriterTest methodsFor: 'requirements'!tableBegin	^ '| '! !!PRGithubMarkdownWriterTest methodsFor: 'requirements'!tableCellWithFoo	^ '| foo'! !!PRGithubMarkdownWriterTest methodsFor: 'requirements'!tableCellWithHeadingFoo	^ '| foo'! !!PRGithubMarkdownWriterTest methodsFor: 'requirements'!tableRow	^ '| '! !!PRGithubMarkdownWriterTest methodsFor: 'tests'!testTableCenterAligned	| item alignment |	alignment := #center.	item := PRDocument new		add:			(PRTable new				add:					(PRTableRow new						add: (PRTableCell align: alignment heading: true withAll: {PRText content: 'foo'}))).	self assertWriting: item includesText: '| :---: |'! !!PRGithubMarkdownWriterTest methodsFor: 'tests'!testTableLeftAligned	| item alignment |	alignment := #left.	item := PRDocument new		add:			(PRTable new				add:					(PRTableRow new						add: (PRTableCell align: alignment heading: true withAll: {PRText content: 'foo'}))).	self assertWriting: item includesText: '| :--- |'! !!PRGithubMarkdownWriterTest methodsFor: 'tests'!testTableNotAligned	| item alignment |	alignment := nil.	item := PRDocument new		add:			(PRTable new				add:					(PRTableRow new						add: (PRTableCell align: alignment heading: true withAll: {PRText content: 'foo'}))).	self assertWriting: item includesText: '| --- |'! !!PRGithubMarkdownWriterTest methodsFor: 'tests'!testTableRightAligned	| item alignment |	alignment := #right.	item := PRDocument new		add:			(PRTable new				add:					(PRTableRow new						add: (PRTableCell align: alignment heading: true withAll: {PRText content: 'foo'}))).	self assertWriting: item includesText: '| ---: |'! !!PRGithubMarkdownWriterTest methodsFor: 'tests'!testTableWithHeader	| item |	item := PRDocument new		add:			(PRTable new				add:					(PRTableRow new						add: (PRTableCell align: nil heading: false withAll: {PRText content: 'foo'}))).	self assertWriting: item includesText: '| foo |'.	self assertWriting: item includesText: '| --- |'! !!PRGitlabMarkdownWriterTest methodsFor: 'private'!actualClass	^ PRGitlabMarkdownWriter ! !!PRGitlabMarkdownWriterTest methodsFor: 'requirements'!strikethroughFoo	^ '~~foo~~'! !!PRGitlabMarkdownWriterTest methodsFor: 'requirements'!tableBegin	^ '| '! !!PRGitlabMarkdownWriterTest methodsFor: 'requirements'!tableCellWithFoo	^ '| foo'! !!PRGitlabMarkdownWriterTest methodsFor: 'requirements'!tableCellWithHeadingFoo	^ '| foo'! !!PRGitlabMarkdownWriterTest methodsFor: 'requirements'!tableRow	^ '| '! !!PRGitlabMarkdownWriterTest methodsFor: 'tests'!testTableCenterAligned	| item alignment |	alignment := #center.	item := PRDocument new		add:			(PRTable new				add:					(PRTableRow new						add: (PRTableCell align: alignment heading: true withAll: {PRText content: 'foo'}))).	self assertWriting: item includesText: '| :---: |'! !!PRGitlabMarkdownWriterTest methodsFor: 'tests'!testTableLeftAligned	| item alignment |	alignment := #left.	item := PRDocument new		add:			(PRTable new				add:					(PRTableRow new						add: (PRTableCell align: alignment heading: true withAll: {PRText content: 'foo'}))).	self assertWriting: item includesText: '| :--- |'! !!PRGitlabMarkdownWriterTest methodsFor: 'tests'!testTableNotAligned	| item alignment |	alignment := nil.	item := PRDocument new		add:			(PRTable new				add:					(PRTableRow new						add: (PRTableCell align: alignment heading: true withAll: {PRText content: 'foo'}))).	self assertWriting: item includesText: '| --- |'! !!PRGitlabMarkdownWriterTest methodsFor: 'tests'!testTableRightAligned	| item alignment |	alignment := #right.	item := PRDocument new		add:			(PRTable new				add:					(PRTableRow new						add: (PRTableCell align: alignment heading: true withAll: {PRText content: 'foo'}))).	self assertWriting: item includesText: '| ---: |'! !!PRGitlabMarkdownWriterTest methodsFor: 'tests'!testTableWithHeader	| item |	item := PRDocument new		add:			(PRTable new				add:					(PRTableRow new						add: (PRTableCell align: nil heading: false withAll: {PRText content: 'foo'}))).	self assertWriting: item includesText: '| foo |'.	self assertWriting: item includesText: '| --- |'! !!PRMarkdownWriterTest methodsFor: 'private'!actualClass	^ PRMarkdownWriter! !!PRMarkdownWriterTest methodsFor: 'requirements'!boldFoo	^ '**foo**'! !!PRMarkdownWriterTest methodsFor: 'requirements'!dataItemWithBar	^ 'bar'! !!PRMarkdownWriterTest methodsFor: 'requirements'!definitionListBegin	^''! !!PRMarkdownWriterTest methodsFor: 'asserting'!deny: result includesSubstring: expected	expected ifEmpty: [ ^ self ].	self deny: (result includesSubstring: expected) description: ('''{1}'' is in ''{2}''' format: {expected . result})! !!PRMarkdownWriterTest methodsFor: 'asserting'!denyWriting: aDocumentItem includesText: aString	| result |	result := self write: aDocumentItem.	self deny: result includesSubstring: aString! !!PRMarkdownWriterTest methodsFor: 'requirements'!emailToFoo	^ 'foo@bar.com'! !!PRMarkdownWriterTest methodsFor: 'requirements'!figureAnchorForPierLogo	^ '[pierLogo]'! !!PRMarkdownWriterTest methodsFor: 'requirements'!figureBegin	^ '!!['! !!PRMarkdownWriterTest methodsFor: 'requirements'!horizontalRule	^ '---'! !!PRMarkdownWriterTest methodsFor: 'requirements'!italicFoo	^ '*foo*'! !!PRMarkdownWriterTest methodsFor: 'requirements'!level1HeaderBegin	^ '#'! !!PRMarkdownWriterTest methodsFor: 'requirements'!level1HeaderWithFoo	^ '# foo'! !!PRMarkdownWriterTest methodsFor: 'requirements'!level2HeaderBegin	^ '##'! !!PRMarkdownWriterTest methodsFor: 'requirements'!level3HeaderBegin	^ '### '! !!PRMarkdownWriterTest methodsFor: 'requirements'!listItemWith1	^ '1'! !!PRMarkdownWriterTest methodsFor: 'requirements'!monospaceFoo	^ '`foo`'! !!PRMarkdownWriterTest methodsFor: 'requirements'!orderedListBegin	^ '1. '! !!PRMarkdownWriterTest methodsFor: 'requirements'!packageNamesUnderTest	^ #('Pillar-ExporterMarkdown')! !!PRMarkdownWriterTest methodsFor: 'requirements'!paragraphFoo	^ 'foo'! !!PRMarkdownWriterTest methodsFor: 'requirements'!preformattedFooBegin		^ ''! !!PRMarkdownWriterTest methodsFor: 'requirements'!preformattedTextFoo		^ ''! !!PRMarkdownWriterTest methodsFor: 'requirements'!rawText		^ 'raw text'! !!PRMarkdownWriterTest methodsFor: 'requirements'!referenceToFigurePierLogo	^ '(#pierLogo)'! !!PRMarkdownWriterTest methodsFor: 'as yet unclassified'!resultForCaution	^ '> **caution**:'! !!PRMarkdownWriterTest methodsFor: 'as yet unclassified'!resultForImportant	^ '> **todo**:'! !!PRMarkdownWriterTest methodsFor: 'as yet unclassified'!resultForNotRecognizedPatterns	^ '> **toto**: '! !!PRMarkdownWriterTest methodsFor: 'as yet unclassified'!resultForNote	^ '> **note**:'! !!PRMarkdownWriterTest methodsFor: 'as yet unclassified'!resultForTip		^ '> **tip**:'! !!PRMarkdownWriterTest methodsFor: 'as yet unclassified'!resultForWarning	^ '> **warning**:'! !!PRMarkdownWriterTest methodsFor: 'requirements'!resultWithRefWithAnchorWithSeparateOutputFiles	^ '(ref.html#foo)'! !!PRMarkdownWriterTest methodsFor: 'requirements'!resultWithRefWithoutAnchorWithSeparateOutputFiles	^ '(ref.html)'! !!PRMarkdownWriterTest methodsFor: 'requirement-InternalLinks'!resultWithRefWithoutAnchorWithoutSeparateOutputFiles		^ ''! !!PRMarkdownWriterTest methodsFor: 'requirements'!resultWithoutAliasWithoutRefWithAnchorWithSeparateOutputFiles	^ '(#foo)'! !!PRMarkdownWriterTest methodsFor: 'requirements'!resultWithoutRefWithAnchorWithSeparateOutputFiles	^ '(#foo)'! !!PRMarkdownWriterTest methodsFor: 'requirements'!scriptAnchorForMyScript	^ self configuration newLine		,			'```myscript```'! !!PRMarkdownWriterTest methodsFor: 'requirements'!scriptWithCaptionBegin	^ self configuration newLine , '```'! !!PRMarkdownWriterTest methodsFor: 'requirements'!scriptWithoutCaptionBegin	^ self configuration newLine , '```'! !!PRMarkdownWriterTest methodsFor: 'requirements'!strikethroughFoo		"Markdown does not implement underlyning, so it ignores it"	^ 'foo'! !!PRMarkdownWriterTest methodsFor: 'requirements'!tableBegin		"Markdown does not provide tables by default"	^ ''! !!PRMarkdownWriterTest methodsFor: 'requirements'!tableCellWithFoo		^ 'foo'! !!PRMarkdownWriterTest methodsFor: 'requirements'!tableCellWithHeadingFoo	"Markdown does not provide tables by default"	^ 'foo'! !!PRMarkdownWriterTest methodsFor: 'requirements'!tableRow		"Markdown does not provide tables by default"	^ ''! !!PRMarkdownWriterTest methodsFor: 'requirements'!termItemWithFoo	^ '- **foo**.'! !!PRMarkdownWriterTest methodsFor: 'tests'!testAnnotation	| note tip warning caution important nonRecognized text |	text := PRText content: 'foo'.	note := PRAnnotatedParagraph new		annotation: 'note';		add: text.	tip := PRAnnotatedParagraph new		annotation: 'tip';		add: text.	warning := PRAnnotatedParagraph new		annotation: 'warning';		add: text.	caution := PRAnnotatedParagraph new		annotation: 'caution';		add: text.	important := PRAnnotatedParagraph new		annotation: 'todo';		add: text.	nonRecognized := PRAnnotatedParagraph new		annotation: 'toto';		add: text.	self assertWriting: note includesText: self resultForNote.	self assertWriting: tip includesText: self resultForTip.	self assertWriting: warning includesText: self resultForWarning.	self assertWriting: caution includesText: self resultForCaution.	self assertWriting: important includesText: self resultForImportant.	self assert: (self write: nonRecognized) trimRight equals: (self resultForNotRecognizedPatterns, text text).! !!PRMarkdownWriterTest methodsFor: 'tests'!testFigureWithoutLabelAndWithoutCaptionAreExportedWithoutEnvironment	self skip "Figures are no environnement in Markdown"! !!PRMarkdownWriterTest methodsFor: 'tests'!testNestingList	| item expected |	item := PRUnorderedList new		add:			(PRListItem new				add:					(PROrderedList new						add:							(PRListItem new								add: (PRText content: self listItemWith1);								yourself);						yourself);				yourself);		yourself.	expected := '' writeStream << '- ' << self configuration newLine << '  ' << self orderedListBegin		<< self listItemWith1.	self assert: (self write: item) includesSubstring: expected contents! !!PRMarkdownWriterTest methodsFor: 'tests'!testNestingListWith2Item	| item expected |	item := PRUnorderedList new		add:			(PRListItem new				add:					(PROrderedList new						add:							(PRListItem new								add: (PRText content: self listItemWith1);								yourself);						yourself);				yourself);		add:			(PRListItem new				add: (PRText content: self listItemWith1);				yourself);		yourself.	expected := '' writeStream << self unorderedListBegin << self configuration newLine << '  '		<< self orderedListBegin << self listItemWith1 << self configuration newLine		<< self unorderedListBegin << self listItemWith1.	self assert: (self write: item) includesSubstring: expected contents! !!PRMarkdownWriterTest methodsFor: 'tests'!testNestingListWith2ItemWith2SubItem	| item expected |	item := PRUnorderedList new		add:			(PRListItem new				add:					(PROrderedList new						add:							(PRListItem new								add: (PRText content: self listItemWith1);								add:									(PROrderedList new										add:											(PRListItem new												add: (PRText content: self listItemWith1);												yourself);										yourself);								yourself);						yourself);				yourself);		add:			(PRListItem new				add: (PRText content: self listItemWith1);				yourself);		yourself.	expected := '' writeStream << self unorderedListBegin << self configuration newLine << '  '		<< self orderedListBegin << self listItemWith1 << self configuration newLine << '    ' << self orderedListBegin		<< self listItemWith1 << self configuration newLine << self unorderedListBegin << self listItemWith1.	self assert: (self write: item) includesSubstring: expected contents! !!PRMarkdownWriterTest methodsFor: 'tests'!testScriptLabelGenerateAnchor	"Markdown does not support scripts with labels"	^ self skip! !!PRMarkdownWriterTest methodsFor: 'tests'!testScriptWithFormattedCaption	"Markdown does not support scripts with captions"	^ self skip! !!PRMarkdownWriterTest methodsFor: 'tests'!testScriptsHaveACaption	"Markdown does not support scripts with captions"	^ self skip! !!PRMarkdownWriterTest methodsFor: 'tests'!testSubscriptFormat	"Subscripts are not supported in markdown"	^ self skip! !!PRMarkdownWriterTest methodsFor: 'tests'!testSuperscriptFormat	"Superscripts are not supported in markdown"	^ self skip! !!PRMarkdownWriterTest methodsFor: 'requirements'!underlineFoo		"Markdown does not implement underlyning, so it ignores it"	^ 'foo'! !!PRMarkdownWriterTest methodsFor: 'requirements'!unorderedListBegin	^ '- '! !!PRMarkdownWriterTest methodsFor: 'requirements'!widthFor50percents	^ ''! !!PRInternalLinkTest methodsFor: '*Pillar-Tests-ExporterMarkdown'!testReferenceAsMarkdown	| link |	link := PRInternalLink reference: 'foo.pillar'.	self assert: link referenceAsMarkdown equals: 'foo.md'.	link := PRInternalLink reference: 'foo.pilla'.	self should: [ link referenceAsMarkdown ] raise: PRLinkWarning! !"Pillar-Tests-ExporterMarkdown"!!PRLaTeXWriterTest class methodsFor: 'testing'!isAbstract	^ false! !!PRLaTeXWriterTest methodsFor: 'private'!actualClass	^ PRLaTeXWriter! !!PRLaTeXWriterTest methodsFor: 'private'!annotationBegin: annotationString	^ '\begin{' , annotationString , '}'.	! !!PRLaTeXWriterTest methodsFor: 'requirements'!boldFoo	^ '\textbf{foo}'! !!PRLaTeXWriterTest methodsFor: 'requirements'!citationRepresentation	^'\cite{hello}'! !!PRLaTeXWriterTest methodsFor: 'requirements'!dataItemWithBar	^ ' bar'! !!PRLaTeXWriterTest methodsFor: 'requirements'!definitionListBegin	^ '\begin{description}'! !!PRLaTeXWriterTest methodsFor: 'requirements'!emailToFoo	^ '\href{mailto:foo@bar.com'! !!PRLaTeXWriterTest methodsFor: 'requirements'!figureAnchorForPierLogo	^ '\label{pierLogo}'! !!PRLaTeXWriterTest methodsFor: 'requirements'!figureBegin	^ '\begin{figure}'! !!PRLaTeXWriterTest methodsFor: 'requirements'!footnoteBar	^ '\footnote{Bar}'! !!PRLaTeXWriterTest methodsFor: 'requirements'!horizontalRule	^ '\rule{\textwidth}'! !!PRLaTeXWriterTest methodsFor: 'requirements'!italicFoo	^ '\textit{foo}'! !!PRLaTeXWriterTest methodsFor: 'requirements'!level1HeaderBegin	^ '\part{'! !!PRLaTeXWriterTest methodsFor: 'requirements'!level1HeaderWithFoo	^ '\part{foo}'! !!PRLaTeXWriterTest methodsFor: 'requirements'!level2HeaderBegin	^ '\chapter{'! !!PRLaTeXWriterTest methodsFor: 'requirements'!level3HeaderBegin	^ '\section{'! !!PRLaTeXWriterTest methodsFor: 'requirements'!listItemWith1	^ '\item 1'! !!PRLaTeXWriterTest methodsFor: 'requirements'!monospaceFoo	^ '\code{foo}'! !!PRLaTeXWriterTest methodsFor: 'requirements'!orderedListBegin	^ '\begin{enumerate}'! !!PRLaTeXWriterTest methodsFor: 'accessing'!packageNamesUnderTest	^ #('Pillar-ExporterLaTeX')! !!PRLaTeXWriterTest methodsFor: 'requirements'!paragraphFoo	| newLine |	newLine := self configuration newLine.	^ 'foo', newLine! !!PRLaTeXWriterTest methodsFor: 'requirements'!preformattedFooBegin	^ '\begin{verbatim}'! !!PRLaTeXWriterTest methodsFor: 'requirements'!preformattedTextFoo	^ 'foo'! !!PRLaTeXWriterTest methodsFor: 'requirements'!rawText	^ '\textbf{\textit{foo}'! !!PRLaTeXWriterTest methodsFor: 'requirements'!referenceToFigurePierLogo	^ '\ref{pierLogo}'! !!PRLaTeXWriterTest methodsFor: 'requirement-InternalLinks'!resultWithRefWithAnchorWithSeparateOutputFiles	^ ''! !!PRLaTeXWriterTest methodsFor: 'requirement-InternalLinks'!resultWithRefWithoutAnchorWithSeparateOutputFiles	^ ''! !!PRLaTeXWriterTest methodsFor: 'requirement-InternalLinks'!resultWithoutAliasWithoutRefWithAnchorWithSeparateOutputFiles	^ '\ref{foo}'! !!PRLaTeXWriterTest methodsFor: 'requirement-InternalLinks'!resultWithoutRefWithAnchorWithSeparateOutputFiles	^ '\hyperref[foo]'! !!PRLaTeXWriterTest methodsFor: 'requirements'!scriptAnchorForMyScript	^ 'label=myScript'! !!PRLaTeXWriterTest methodsFor: 'requirements'!scriptWithCaptionBegin	^ '\begin{listing}'! !!PRLaTeXWriterTest methodsFor: 'requirements'!scriptWithoutCaptionBegin	^ '\begin{listing}'! !!PRLaTeXWriterTest methodsFor: 'requirements'!strikethroughFoo	^ '\sout{foo}'! !!PRLaTeXWriterTest methodsFor: 'requirements'!subscriptFoo	^ '\textsubscript{foo}'! !!PRLaTeXWriterTest methodsFor: 'requirements'!superscriptFoo	^ '\textsuperscript{foo}'! !!PRLaTeXWriterTest methodsFor: 'requirements'!tableBegin	^ '\begin{tabular}'! !!PRLaTeXWriterTest methodsFor: 'requirements'!tableCellWithFoo	^ 'foo'! !!PRLaTeXWriterTest methodsFor: 'requirements'!tableCellWithHeadingFoo	^ '\textbf{foo}'! !!PRLaTeXWriterTest methodsFor: 'requirements'!tableRow	^ '\\'! !!PRLaTeXWriterTest methodsFor: 'requirements'!termItemWithFoo	^ '\item[foo]'! !!PRLaTeXWriterTest methodsFor: 'tests'!testAnchor	| item |	item := PRAnchor new name: 'foo'.	self assertWriting: item includesText: '\label{foo}'! !!PRLaTeXWriterTest methodsFor: 'requirements'!testExportCitation	| item |	item := PRDocument new		add: (PRCitation ref: 'hello');		yourself.	self		assertWriting: item		includesText: self citationRepresentation.! !!PRLaTeXWriterTest methodsFor: 'tests-internalLinks'!testExternalLinkWithCaptionShouldPrintUrlAsFootnote	| link |	link := self addText: 'Pharo' to: (PRExternalLink reference: 'http://www.pharo.org').	self assertWriting: link includesText: '\href{http://www.pharo.org}{Pharo}\footnote{\url{http://www.pharo.org}}'! !!PRLaTeXWriterTest methodsFor: 'tests-internalLinks'!testExternalLinkWithCaptionShouldProtectUrlInFootnotes	| link |	link := self addText: 'Launcher' to: (PRExternalLink reference: 'http://www.smalltalkhub.com/#!!/~Pharo/PharoLauncher').	self assertWriting: link includesText: '\footnote{\url{http://www.smalltalkhub.com/\#!!/~Pharo/PharoLauncher}}'! !!PRLaTeXWriterTest methodsFor: 'tests'!testFigureCaptionWithNonTextChildren	| item |	item := PRFigure new		reference: 'file://picture.png';		add: (self addText: 'foo' to: PRBoldFormat new);		yourself.	self assertWriting: item includesText: self boldFoo! !!PRLaTeXWriterTest methodsFor: 'tests'!testFigureLabelNotEscaped	| item |	item := PRFigure new		reference: 'file://picture.png';		label: 'a_b';		yourself.	self assertWriting: item includesText: 'a_b'! !!PRLaTeXWriterTest methodsFor: 'tests-internalLinks'!testInternalLinkWithoutAliasWithRefWithAncorWithSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add: (PRInternalLink reference: 'ref@foo');		yourself.	self should: [ resultString := self writeWithSeparateOutputFiles: item ] raise: PRLinkWarning.	[ resultString := self writeWithSeparateOutputFiles: item ]		on: PRLinkWarning		do: [ :w | w resume ].	self resultWithRefWithAnchorWithSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithRefWithAnchorWithSeparateOutputFiles) ]! !!PRLaTeXWriterTest methodsFor: 'tests-internalLinks'!testInternalLinkWithoutAliasWithReferenceWithoutAnchorWithSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add: (PRInternalLink reference: 'ref');		yourself.	self should: [ resultString := self writeWithSeparateOutputFiles: item ] raise: PRLinkWarning.	[ resultString := self writeWithSeparateOutputFiles: item ]		on: PRLinkWarning		do: [ :w | w resume ].	self resultWithRefWithoutAnchorWithSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithRefWithoutAnchorWithSeparateOutputFiles) ]! !!PRLaTeXWriterTest methodsFor: 'tests'!testLinksWithBadCharactersInCaption	| item url caption |	url := 'http://www.pharo.org'.	caption := 'bad chars #_'.	item := PRExternalLink new		reference: url;		add: (PRText content: caption);		yourself.	self assertWriting: item includesText: 'bad chars \#\_'! !!PRLaTeXWriterTest methodsFor: 'tests'!testLinksWithEitherHrefOrUrl	| item url caption |	url := 'http://www.pharo.org#foo'.	caption := 'some caption'.	item := PRExternalLink new reference: url.	self assertWriting: item includesText: '\url{' , url , '}'.	item := PRExternalLink new		reference: url;		add: (PRText content: caption);		yourself.	self assertWriting: item includesText: '\href{' , url , '}{' , caption , '}'! !!PRLaTeXWriterTest methodsFor: 'tests'!testPreformattedExportsToUnprotectedVerbatim	"Special characters in a Pillar preformattted group should not be protected by backslashes because they are exported in a verbatim LaTeX environment."	| item |	item := PRPreformatted with: (PRText content: '[[[').	self		assertWriting: item		includesText: self preformattedFooBegin , self configuration newLine , '[[[' , self configuration newLine! !!PRLaTeXWriterTest methodsFor: 'tests'!testReferencesToSectionsAreNotEscaped	|item|	item := PRInternalLink reference: '@a_section_somewhere'.	self assertWriting: item includesText: 'a_section_somewhere'! !!PRLaTeXWriterTest methodsFor: 'tests'!testScriptWithCorrectNewLines	| item |	item := (PRCodeblock content: 'foo')		label: 'myScript';		caption: 'a caption';		yourself.	self		assertWriting: item		includesText:			self configuration newLine , 'foo' , self configuration newLine , '\end{'! !!PRLaTeXWriterTest methodsFor: 'tests'!testStrictLineBreaksInAnnotatedParagraphs	| item lineBreak |	item := self		addText: 'Blah'		to:			(PRAnnotatedParagraph new				annotation: 'note';				yourself).	lineBreak := self configuration newLine.	self assertWriting: item includesText: '\begin{note}' , lineBreak , 'Blah' , lineBreak , '\end{note}' , lineBreak! !!PRLaTeXWriterTest methodsFor: 'tests'!testTableWith2CellsInARow	| item |	item := super testTableWith2CellsInARow.	self assertWriting: item includesText: 'foo & foo \\'	! !!PRLaTeXWriterTest methodsFor: 'tests'!testTablesHaveSeparatingLines	| text |	text := '|!!Syntax |!!What it represents|startPoint|a variable name'.	self assertWriting: (self parser parse: text) includesTexts: { 'toprule' . 'midrule' . 'bottomrule' }! !!PRLaTeXWriterTest methodsFor: 'tests'!testThereIsABlankLineBetweenTextAndTable	| text nLine |	nLine := Smalltalk os lineEnding.	text := 'This is a table:| foo| bar'.	self		assertWriting: (self parser parse: text)		includesText: 'This is a table:' , nLine , nLine , self tableBegin! !!PRLaTeXWriterTest methodsFor: 'tests-internalLinks'!testUrlsAreProtected	| writer |	writer := self createWriterOn: String new.	self assert: (writer protectUrl: '#') equals: '\#'.	self assert: (writer protectUrl: '~') equals: '~'.	self assert: (writer protectUrl: '&') equals: '&'.	self assert: (writer protectUrl: '%') equals: '\%'.	self assert: (writer protectUrl: '\') equals: '\\'.	self assert: (writer protectUrl: '\~#%') equals: '\\~\#\%'.! !!PRLaTeXWriterTest methodsFor: 'requirements'!underlineFoo	^ '\uline{foo}'! !!PRLaTeXWriterTest methodsFor: 'requirements'!unorderedListBegin	^ '\begin{itemize}'! !!PRLaTeXWriterTest methodsFor: 'requirements'!widthFor50percents	^ '0.5'! !!PRSBALaTeXWriterTest methodsFor: 'private'!actualClass	^ PRSBALaTeXWriter! !!PRSBALaTeXWriterTest methodsFor: 'requirements'!monospaceFoo	^ '\textcode{foo}'! !!PRSBALaTeXWriterTest methodsFor: 'requirements'!tableBegin	^ '\begin{fullwidthtabular}'! !!PRSBALaTeXWriterTest methodsFor: 'requirements'!tableEnd	^ '\end{fullwidthtabular}'! !!PRSBALaTeXWriterTest methodsFor: 'tests'!testFloatingScriptWithNoLanguageGeneratePlain	| script |	script := (PRCodeblock content: 'foo')		caption: 'a caption';		yourself.	self assertWriting: script includesText: '{plain}'! !!PRSBALaTeXWriterTest methodsFor: 'tests'!testInFlowScriptWithCorrectNewLines	| item |	item := PRCodeblock content: 'foo'.	self		assertWriting: item		includesText:			self configuration newLine , 'foo' , self configuration newLine , '\end{'! !!PRSBALaTeXWriterTest methodsFor: 'tests'!testInFlowScriptWithNoLanguageGeneratePlain	| script |	script := PRCodeblock content: 'foo'.	self assertWriting: script includesTexts: #('\begin{displaycode}{plain}' 'foo')! !!PRSBALaTeXWriterTest methodsFor: 'tests'!testScript	"ignore as we have much more explicit tests in this class"! !!PRSBALaTeXWriterTest methodsFor: 'tests'!testScriptWithBothLabelAndCaption	| script |	script := (PRCodeblock content: 'foo')					label: 'myScript';					caption: 'a caption';					language: PRHTMLScriptLanguage default;					yourself.	self assertWriting: script includesTexts: #('\begin{listing}[float, label=myScript]{html}{a caption}' 'foo')! !!PRSBALaTeXWriterTest methodsFor: 'tests'!testScriptWithCaptionAndNotLabel	| script |	script := (PRCodeblock content: 'foo')					caption: 'a caption';					language: PRHTMLScriptLanguage default;					yourself.	self assertWriting: script includesTexts: #('\begin{listing}[float]{html}{a caption}' 'foo')! !!PRSBALaTeXWriterTest methodsFor: 'tests'!testScriptWithCaptionAndNotLabelAndShortCaption	| script |	script := (PRCodeblock content: 'foo')					caption: 'a caption';					shortCaption: 'short';					language: PRHTMLScriptLanguage default;					yourself.	self assertWriting: script includesTexts: #('\begin{listing}[float, list text={short}]{html}{a caption}' 'foo')! !!PRSBALaTeXWriterTest methodsFor: 'tests'!testScriptWithLabelAndNotCaption	| script |	script := (PRCodeblock content: 'foo')					label: 'myScript';					language: PRHTMLScriptLanguage default;					yourself.	self assertWriting: script includesTexts: #('\begin{listing}[float, label=myScript]{html}{}' 'foo')! !!PRSBALaTeXWriterTest methodsFor: 'tests'!testScriptWithNeitherCaptionNorLabel	| script |	script := (PRCodeblock content: 'foo')					language: PRHTMLScriptLanguage default;					yourself.	self assertWriting: script includesTexts: #('\begin{displaycode}{html}' 'foo')! !"Pillar-Tests-ExporterLaTeX"!!PRBeamerWriterTest methodsFor: 'private' prior: 36229827!actualClass	^ PRBeamerWriter! !!PRBeamerWriterTest methodsFor: 'requirements' prior: 36229919!endSlideTag	^ '\end{frame}'! !!PRBeamerWriterTest methodsFor: 'requirements'!figureBegin	self skip: 'Beamer does not use figure environments because we typically don''t need a caption or label to reference'.	^ ''! !!PRBeamerWriterTest methodsFor: 'requirements' prior: 36230011!headerInSlide	"I return one string that define a header rendering in a slide."	^ '\huge{'! !!PRBeamerWriterTest methodsFor: 'requirements'!level1HeaderWithFoo	^ '\section{foo}'! !!PRBeamerWriterTest methodsFor: 'accessing'!packageNamesUnderTest	^ #('Pillar-ExporterBeamer')! !!PRBeamerWriterTest methodsFor: 'requirements' prior: 36230172!representationOfAnchor	"I return a string which reprensent an anchor in the slider format."	^ '\label{'! !!PRBeamerWriterTest methodsFor: 'requirement-InternalLinks'!resultWithoutRefWithAnchorWithSeparateOutputFiles	^ '\hyperlink{foo}'! !!PRBeamerWriterTest methodsFor: 'requirements' prior: 36230346!slideRepresentation	^ {'\begin{frame}'.	'\frametitle{Slide title}'.	'Presentation text'.	'\end{frame}'}! !!PRBeamerWriterTest methodsFor: 'requirements' prior: 36230446!slideTitle	"I return a collection with an explicite rendering of a slide title."	^ {'\frametitle{'.	'}'}! !!PRBeamerWriterTest methodsFor: 'tests'!testFigureCaptionWithNonTextChildren	"Ignore as we don't generate caption/label for figures"! !!PRBeamerWriterTest methodsFor: 'tests'!testFigureLabelGenerateAnchor	"Ignore as we don't generate caption/label for figures"! !!PRBeamerWriterTest methodsFor: 'tests'!testFigureLabelNotEscaped	"Ignore as we don't generate caption/label for figures"! !!PRBeamerWriterTest methodsFor: 'tests'!testFiguresHaveACaption	"Ignore as we don't generate caption/label for figures"! !!PRBeamerWriterTest methodsFor: 'tests'!testFrameWithInvalidOption	| wiki |	wiki := '${frame:title=Foo|option=bar}$'.	self should: [ self parser parse: wiki ] raise: PRError! !!PRBeamerWriterTest methodsFor: 'tests'!testFrameWithOption	"For now the option are not activated."	"	| item |	item := PRDocument new		add: (PRSlideTitleAnnotation parameters: (PRParameterParser parse: 'title=Slide title|option=plain') yourself);		add: (PRText content: 'Presentation text');		yourself.	self		assertWriting: item		includesTexts:			{'\begin{frame}[plain]'.			'\frametitle{Slide title}'.			'Presentation text'.			'\end{frame}'}"	! !!PRBeamerWriterTest methodsFor: 'tests'!testFrameWithoutOption	| item |	item := PRDocument new		add: (PRSlide titled: 'Slide title');		add: (PRText content: 'Presentation text');		yourself.	self		assertWriting: item		includesTexts:			{'\begin{frame}[fragile]'.			'\frametitle{Slide title}'.			'Presentation text'.			'\end{frame}'}! !!PRBeamerWriterTest methodsFor: 'tests'!testScriptDefaultLanguage	"Ignore as we don't generate a language attribute"! !!PRBeamerWriterTest methodsFor: 'tests'!testScriptLabelGenerateAnchor	"Ignore as we don't generate anchors"! !!PRBeamerWriterTest methodsFor: 'tests'!testScriptsHaveACaption	"Ignore as we don't generate captions"! !"Pillar-Tests-ExporterBeamer"!!PRPillarWriterTest methodsFor: 'private'!actualClass	^ PRPillarWriter! !!PRPillarWriterTest methodsFor: 'requirements'!annotationBegin: annotationString	^'@@' , annotationString.! !!PRPillarWriterTest methodsFor: 'requirements'!boldFoo	^ '""foo""'! !!PRPillarWriterTest methodsFor: 'requirements'!dataItemWithBar	^ ':bar'! !!PRPillarWriterTest methodsFor: 'requirements'!definitionListBegin	^ ';'! !!PRPillarWriterTest methodsFor: 'requirements'!emailToFoo	^ 'foo@bar.com*'! !!PRPillarWriterTest methodsFor: 'requirements'!figureAnchorForPierLogo	^ 'label=pierLogo'! !!PRPillarWriterTest methodsFor: 'requirements'!figureBegin	^ '+'! !!PRPillarWriterTest methodsFor: 'requirements'!horizontalRule	^ '_'! !!PRPillarWriterTest methodsFor: 'requirements'!italicFoo	^ '''foo'''! !!PRPillarWriterTest methodsFor: 'accessing'!level1HeaderBegin	^ self shouldBeImplemented! !!PRPillarWriterTest methodsFor: 'requirements'!level1HeaderWithFoo	^ '!!foo'! !!PRPillarWriterTest methodsFor: 'accessing'!level2HeaderBegin	^ self shouldBeImplemented! !!PRPillarWriterTest methodsFor: 'accessing'!level3HeaderBegin	^ self shouldBeImplemented! !!PRPillarWriterTest methodsFor: 'requirements'!listItemWith1	^ '1'! !!PRPillarWriterTest methodsFor: 'requirements'!monospaceFoo	^ '==foo=='! !!PRPillarWriterTest methodsFor: 'requirements'!orderedListBegin	^ '#'! !!PRPillarWriterTest methodsFor: 'requirements'!packageNamesUnderTest	^ #('Pillar-ExporterPillar')! !!PRPillarWriterTest methodsFor: 'requirements'!paragraphFoo	^ 'foo'! !!PRPillarWriterTest methodsFor: 'requirements'!preformattedFooBegin	^ '='! !!PRPillarWriterTest methodsFor: 'requirements'!preformattedTextFoo	^ 'foo'! !!PRPillarWriterTest methodsFor: 'requirements'!rawText	^ '*foo>http://bar.com* ''italic'''! !!PRPillarWriterTest methodsFor: 'requirements'!referenceToFigurePierLogo	^ '*@pierLogo*'! !!PRPillarWriterTest methodsFor: 'requirement-InternalLinks'!resultWithRefWithAnchorWithSeparateOutputFiles	^ 'ref.pillar@foo'! !!PRPillarWriterTest methodsFor: 'requirement-InternalLinks'!resultWithRefWithoutAnchorWithSeparateOutputFiles	^ 'ref.pillar'! !!PRPillarWriterTest methodsFor: 'requirement-InternalLinks'!resultWithoutAliasWithoutRefWithAnchorWithSeparateOutputFiles	^ '@foo'! !!PRPillarWriterTest methodsFor: 'requirement-InternalLinks'!resultWithoutRefWithAnchorWithSeparateOutputFiles	^ '@foo'! !!PRPillarWriterTest methodsFor: 'requirements'!scriptAnchorForMyScript	^ 'label=myScript'! !!PRPillarWriterTest methodsFor: 'requirements'!scriptWithCaptionBegin	^ '[[['! !!PRPillarWriterTest methodsFor: 'requirements'!scriptWithoutCaptionBegin	^ '[[['! !!PRPillarWriterTest methodsFor: 'requirements'!strikethroughFoo	^ '--foo--'! !!PRPillarWriterTest methodsFor: 'requirements'!subscriptFoo	^ '@@foo@@'! !!PRPillarWriterTest methodsFor: 'requirements'!superscriptFoo	^ '^^foo^^'! !!PRPillarWriterTest methodsFor: 'tests'!supportSyntaxHighlighting	^ false! !!PRPillarWriterTest methodsFor: 'requirements'!tableBegin	^ '|'! !!PRPillarWriterTest methodsFor: 'requirements'!tableCellWithFoo	^ '|foo'! !!PRPillarWriterTest methodsFor: 'requirements'!tableCellWithHeadingFoo	^ '|!!foo'! !!PRPillarWriterTest methodsFor: 'requirements'!tableRow	^ '|'! !!PRPillarWriterTest methodsFor: 'requirements'!termItemWithFoo	^ ';foo'! !!PRPillarWriterTest methodsFor: 'tests'!testAnnotation	| item |	item := PRMockAnnotation withParameters: (					PRParameters withAll: { 						PRParameter 							keyNode: (PRParameterKey named: 'value')							valueNode: (PRParameterValue value: 'Foo').						PRParameter 							keyNode: (PRParameterKey named: 'number')							valueNode: (PRParameterValue value: 5) }).	self assertWriting: item includesText: '${mock:value=Foo|number=5}$'! !!PRPillarWriterTest methodsFor: 'tests'!testCitationAnnotation	| input |	input := PRDocument new		add:			(PRCitationAnnotation new				parameterAt: 'ref' put: 'foo';				yourself).	self assertWriting: input includesText: '${cite:ref=foo}$'! !!PRPillarWriterTest methodsFor: 'tests'!testCommentedLineNotVisibleInOutput	"in Pillar output, we really want our comments back"! !!PRPillarWriterTest methodsFor: 'tests'!testFigureWithoutLabelAndWithoutCaptionAreExportedWithoutEnvironment	self skip: 'no figure environment in pillar'! !!PRPillarWriterTest methodsFor: 'requirements'!underlineFoo	^ '__foo__'! !!PRPillarWriterTest methodsFor: 'requirements'!unorderedListBegin	^ '-'! !!PRSectionTransformerTest methodsFor: '*Pillar-Tests-ExporterPillar'!testTransformationKeepSameContent	| input |	input := PRDocument new		add:			(PRHeader new				level: 1;				add: (PRText content: 'Bar') yourself);		add: (PRParagraph with: (PRText content: 'Foo') yourself);		add:			(PRHeader new				level: 2;				add: (PRText content: 'Bar2') yourself);		add: (PRParagraph with: (PRText content: 'Foo2') yourself);		yourself.	self		assert: (PRPillarWriter write: (self executePhase: input with: self configuration))		equals: (PRPillarWriter write: input)! !!PRPillarWriterAbstractAnnotationTest class methodsFor: 'testing'!isAbstract	^ self = PRPillarWriterAbstractAnnotationTest! !!PRPillarWriterAbstractAnnotationTest methodsFor: 'helpers'!annoteName	^ self actualClass tag! !!PRPillarWriterAbstractAnnotationTest methodsFor: 'tests'!referenceParameters	self subclassResponsibility! !!PRPillarWriterAbstractAnnotationTest methodsFor: 'helpers'!referenceString	"Pay attention to order the parameters according to sorted"		self subclassResponsibility! !!PRPillarWriterAbstractAnnotationTest methodsFor: 'tests'!testParagraphWithParameters	| wiki tree |	wiki := '${' , self referenceString , '}$'.	tree := PRDocument new		add:			(PRParagraph new				add: (self actualClass withParameters: self referenceParameters);				yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterAbstractAnnotationTest methodsFor: 'tests'!testParse	| wiki tree |	wiki := '${' , self referenceString , '}$'.	tree := PRDocument new		add:			(PRParagraph new				add: (self actualClass withParameters: self referenceParameters);				yourself);		yourself.		self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterBeginEnvironmentAnnotationTest methodsFor: 'private'!actualClass	^ PRBeginEnvironmentAnnotation! !!PRPillarWriterBeginEnvironmentAnnotationTest methodsFor: 'helpers'!referenceParameters	^ PRParameters withAll: { 		PRParameter 			keyNode: (PRParameterKey named: 'name')			valueNode: (PRParameterValue value: 'card').		PRParameter 			keyNode: (PRParameterKey named: 'number')			valueNode: (PRParameterValue value: 10).		PRParameter 			keyNode: (PRParameterKey named: 'string')			valueNode: (PRParameterValue value: 'a string').		PRParameter 			keyNode: (PRParameterKey named: 'boolean')			valueNode: (PRParameterValue value: true).		}! !!PRPillarWriterBeginEnvironmentAnnotationTest methodsFor: 'private'!referenceString	^ 'begin:name=card|number=10|string=a string|boolean=true'! !!PRPillarWriterEndEnvironmentAnnotationTest methodsFor: 'private'!actualClass	^ PREndEnvironmentAnnotation! !!PRPillarWriterEndEnvironmentAnnotationTest methodsFor: 'helpers'!referenceParameters	^ PRParameters withAll: { 		PRParameter 			keyNode: (PRParameterKey named: 'name')			valueNode: (PRParameterValue value: 'card').		PRParameter 			keyNode: (PRParameterKey named: 'number')			valueNode: (PRParameterValue value: 10).		PRParameter 			keyNode: (PRParameterKey named: 'string')			valueNode: (PRParameterValue value: 'a string').		PRParameter 			keyNode: (PRParameterKey named: 'boolean')			valueNode: (PRParameterValue value: true).		}! !!PRPillarWriterEndEnvironmentAnnotationTest methodsFor: 'private'!referenceString	^ 'end:name=card|number=10|string=a string|boolean=true'! !!PRPillarWriterAnchorTest class methodsFor: 'testing'!isAbstract	^ false! !!PRPillarWriterAnchorTest methodsFor: 'private'!actualClass	^ PRAnchor! !!PRPillarWriterAnchorTest methodsFor: 'tests-parsing'!testBasic	| wiki tree |	wiki := '@name'.	tree := PRDocument new		add: (PRAnchor named: 'name');		yourself.		self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterAnchorTest methodsFor: 'tests-parsing'!testMultiple	| wiki tree nLine |	nLine := self lineEnding.	wiki := '@one' , nLine , '@two' , nLine , nLine , '@tree'.	tree := PRDocument new		        add: (PRAnchor named: 'one');		        add: (PRAnchor named: 'two');		        add: PREmptyParagraph new;		        add: (PRAnchor named: 'tree');		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterAnchorTest methodsFor: 'tests-parsing'!testSpaces	| wiki tree |	wiki := '@one two'.	tree := PRDocument new		add: (PRAnchor named: 'one two');		yourself.		self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterAnnotatedParagraphTest class methodsFor: 'testing'!isAbstract	^ false! !!PRPillarWriterAnnotatedParagraphTest methodsFor: 'private'!actualClass	^ PRAnnotatedParagraph! !!PRPillarWriterAnnotatedParagraphTest methodsFor: 'tests-parsing'!testParseBasic	| wiki tree |	wiki := '@@foo bar zork'.	tree := PRDocument new		add: (PRAnnotatedParagraph new			annotation: 'foo';			add: (PRText content: 'bar zork');			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterAnnotatedParagraphTest methodsFor: 'tests-parsing'!testParseEmptyFollwedByPreformatted	| wiki tree nLine |	nLine := self lineEnding.	wiki := '@@foo' , nLine , '= bar'.	tree := PRDocument new		        add: (PRAnnotatedParagraph new				         annotation: 'foo';				         yourself);		        add: (PRPreformatted new				         add: (PRText content: 'bar');				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterAnnotatedParagraphTest methodsFor: 'tests-parsing'!testParseOnlyAnnotation	| wiki text tree |	wiki := '@@foo'.	tree := PRDocument new		add: (PRAnnotatedParagraph new			annotation: 'foo';			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.! !!PRPillarWriterAnnotatedParagraphTest methodsFor: 'tests-parsing'!testParseOnlyNothing	| wiki tree |	wiki := '@@'.	tree := PRDocument new		add: (PRAnnotatedParagraph new			annotation: '';			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterAnnotatedParagraphTest methodsFor: 'tests-parsing'!testParseOnlyText	| wiki  tree |	wiki := '@@ foo bar'.	tree := PRDocument new		add: (PRAnnotatedParagraph new			add: (PRText content: 'foo bar');			annotation: '';			yourself);		yourself.		self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterDocumentGroupTest methodsFor: 'private'!actualClass	^ PRDocumentGroup! !!PRPillarWriterDocumentTest class methodsFor: 'testing'!isAbstract	^ false! !!PRPillarWriterDocumentTest methodsFor: 'private'!actualClass	^ PRDocument! !!PRPillarWriterDocumentTest methodsFor: 'tests-parsing'!testParseEmpty	| wiki tree |	wiki := String new.	tree := PRDocument new.	self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterDocumentTest methodsFor: 'tests-parsing'!testParseMultipleProperties	| wiki tree |	wiki := '{''title'':''The title'',''authors'':''Someone else and me''}'.		tree := PRDocument new		propertyAt: 'title' put: 'The title';		propertyAt: 'authors' put: 'Someone else and me';		yourself.		self pillarWriterAssertTree: tree equalsWiki: wiki.! !!PRPillarWriterDocumentTest methodsFor: 'tests-parsing'!testParseProperties	| wiki  tree |	wiki := '{''title'':''The title''}'.	tree := PRDocument new		propertyAt: 'title' put: 'The title';		yourself.		self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterDocumentTest methodsFor: 'tests-parsing'!testParsePropertiesWithText	| wiki tree |	wiki := '{''title'':''The title''}' , self lineEnding , 'foobar'.	tree := PRDocument new		        propertyAt: 'title' put: 'The title';		        add: (PRParagraph new				         add: (PRText content: 'foobar');				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterFormatTest class methodsFor: 'testing'!isAbstract	^ false! !!PRPillarWriterFormatTest class methodsFor: 'testing'!testParameters	^ (ParametrizedTestMatrix new			forSelector: #actualClass addOptions: PRFormat subclasses )! !!PRPillarWriterFormatTest methodsFor: 'private'!actualClass	^ actualClass! !!PRPillarWriterFormatTest methodsFor: 'private'!actualClass: aClass	actualClass := aClass! !!PRPillarWriterFormatTest methodsFor: 'accessing'!otherClass	^ otherClass ifNil: [ otherClass := PRFormat allSubclasses detect: [ :each | self actualClass ~= each ] ]! !!PRPillarWriterFormatTest methodsFor: 'running'!setUp	super setUp.	markup := PRPillarGrammar markups at: self actualClass! !!PRPillarWriterFormatTest methodsFor: 'tests-parsing'!testParseBasic	| wiki tree |	wiki := '1' , markup , '2' , markup , '3'.		tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: '1');				add: (self actualClass with: (PRText content: '2'));				add: (PRText content: '3');				yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterFormatTest methodsFor: 'tests-parsing'!testParseEnd	| wiki tree |	wiki := '1' , markup , '2' , markup.		tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: '1');				add: (self actualClass with: (PRText content: '2'));				yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.! !!PRPillarWriterFormatTest methodsFor: 'tests-parsing'!testParseEscaped	| wiki  tree |	wiki := ' ' , (PRPillarWriter escapeMarkup: markup) , (PRPillarWriter escapeMarkup: markup).	tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: ' ' , markup , markup);				yourself);		yourself.		self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterFormatTest methodsFor: 'tests-parsing'!testParseIncomplete	| wiki1 wiki2  tree |	wiki1 := '1' , markup , '2'.	wiki2 := '1' , (PRPillarWriter escapeMarkup: markup) , '2'.		tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: '1' , markup , '2');				yourself);		yourself.			self pillarWriterAssertTree: tree equalsWiki: wiki2.! !!PRPillarWriterFormatTest methodsFor: 'tests-parsing'!testParseMany	| wiki tree |	wiki := '1' , markup , '2' , markup , '3' , markup , '4' , markup , '5'.	tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: '1');				add: (self actualClass with: (PRText content: '2'));				add: (PRText content: '3');				add: (self actualClass with: (PRText content: '4'));				add: (PRText content: '5');				yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterFormatTest methodsFor: 'tests-parsing'!testParseNested	| wiki tree |	wiki := '1' , markup , '2' , (PRPillarGrammar markups at: self otherClass) , '3'		, (PRPillarGrammar markups at: self otherClass) , '4' , markup , '5'.		tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: '1');				add:					(self actualClass new						add: (PRText content: '2');						add:							(self otherClass new								add: (PRText content: '3');								yourself);						add: (PRText content: '4');						yourself);				add: (PRText content: '5');				yourself);		yourself.		self pillarWriterAssertTree: tree equalsWiki: wiki.! !!PRPillarWriterFormatTest methodsFor: 'tests-parsing'!testParseNestedTight	| wiki  tree |	wiki := ' ' , markup , (PRPillarGrammar markups at: self otherClass)		, (PRPillarGrammar markups at: self otherClass) , markup.	tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: ' ');				add: (self actualClass new add: self otherClass new yourself);				yourself);		yourself.		self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterFormatTest methodsFor: 'tests-parsing'!testParseWithNewLine	| wiki tree |	wiki := '1' , markup , '2' , self lineEnding , '3' , markup , '4'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: '1');				         add:					         (self actualClass with:							          (PRText content: '2' , self lineEnding , '3'));				         add: (PRText content: '4');				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterFormatTest methodsFor: 'tests-parsing'!testParseWithSpace	| wiki tree |	wiki := '1' , markup , '2 3' , markup , '4'.	tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: '1');				add: (self actualClass with: (PRText content: '2 3'));				add: (PRText content: '4');				yourself);		yourself.		self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterListTest methodsFor: 'private'!actualClass	^ PRList! !!PRPillarWriterListTest methodsFor: 'private'!listItemClass	^ PRListItem! !!PRPillarWriterListTest methodsFor: 'private'!listItemWithText: aString	^ self listItemClass new		add: (PRText content: aString);		yourself! !!PRPillarWriterListTest methodsFor: 'tests-parsing'!testParseEmpty	| wiki tree |	wiki := self wikiString.	tree := PRDocument new		add: (self actualClass new			add: self listItemClass new;			yourself);		yourself.		self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterListTest methodsFor: 'tests-parsing'!testParseFlat	| wiki tree nLine |	nLine := self lineEnding.	wiki := self wikiString , '1st' , nLine , self wikiString , '2nd'	        , nLine , self wikiString , '3rd'.	tree := PRDocument new		        add: (self actualClass new				         add: (self listItemWithText: '1st');				         add: (self listItemWithText: '2nd');				         add: (self listItemWithText: '3rd');				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterListTest methodsFor: 'tests-parsing'!testParseMultiple	| wiki tree nLine |	nLine := self lineEnding.	wiki := self wikiString , '1st' , nLine , self wikiString , '2nd'	        , nLine , nLine , self wikiString , '3rd'.	tree := PRDocument new		        add: (self actualClass new				         add: (self listItemWithText: '1st');				         add: (self listItemWithText: '2nd');				         yourself);		        add: PREmptyParagraph new;		        add: (self actualClass new				         add: (self listItemWithText: '3rd');				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterListTest methodsFor: 'private'!textString: anObject level: anInteger	^ (2 to: anInteger) inject: '' into: [ :result :each | result , '	' ]! !!PRPillarWriterListTest methodsFor: 'private'!wikiString	self subclassResponsibility! !!PRPillarWriterOrderedListTest class methodsFor: 'testing'!isAbstract	^ false! !!PRPillarWriterOrderedListTest methodsFor: 'private'!actualClass	^ PROrderedList! !!PRPillarWriterOrderedListTest methodsFor: 'tests-parsing'!testParseMixed	| wiki tree nLine |	nLine := self lineEnding.	wiki := '#1' , nLine , '#2' , nLine , '-3'.	tree := PRDocument new		        add: (PROrderedList new				         add: (self listItemWithText: '1');				         add: (self listItemWithText: '2');				         yourself);		        add: (PRUnorderedList new				         add: (self listItemWithText: '3');				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterOrderedListTest methodsFor: 'tests-parsing'!testParseNested	| wiki tree nLine |	nLine := self lineEnding.	wiki := self wikiString , '1' , nLine , self wikiString	        , self wikiString , '1.1' , nLine , self wikiString	        , self wikiString , '1.2'.	tree := PRDocument new		        add: (self actualClass new				         add: (PRListItem new						          add: (PRText content: '1');						          add: (self actualClass new								           add: (self listItemWithText: '1.1');								           add: (self listItemWithText: '1.2');								           yourself);						          yourself);				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterOrderedListTest methodsFor: 'private'!textString: anObject level: anInteger 	^ (super 		textString: anObject		level: anInteger) , anObject asString , '. '! !!PRPillarWriterOrderedListTest methodsFor: 'private'!wikiString	^ '#'! !!PRPillarWriterUnorderedListTest class methodsFor: 'testing'!isAbstract	^ false! !!PRPillarWriterUnorderedListTest methodsFor: 'private'!actualClass	^ PRUnorderedList! !!PRPillarWriterUnorderedListTest methodsFor: 'tests-parsing'!testParseMixed	| wiki tree nLine |	nLine := self lineEnding.	wiki := '#1' , nLine , '##2' , nLine , '###3' , nLine , '#-4' , nLine	        , '#-5' , nLine , '##6' , nLine , '#7'.	tree := PRDocument new		        add: (PROrderedList new				         add: (PRListItem new						          add: (PRText content: '1');						          add: (PROrderedList new								           add: (PRListItem new										            add: (PRText content: '2');										            add: (PROrderedList new												             add: (self listItemWithText: '3');												             yourself);										            yourself);								           yourself);						          add: (PRUnorderedList new								           add: (self listItemWithText: '4');								           add: (self listItemWithText: '5');								           yourself);						          add: (PROrderedList new								           add: (self listItemWithText: '6');								           yourself);						          yourself);				         add: (self listItemWithText: '7');				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterUnorderedListTest methodsFor: 'tests-parsing'!testParseNested	| wiki tree nLine |	nLine := self lineEnding.	wiki := self wikiString , '1' , nLine , self wikiString	        , self wikiString , '1.1' , nLine , self wikiString	        , self wikiString , self wikiString , '1.1.1'.	tree := PRDocument new		        add: (self actualClass new				         add: (PRListItem new						          add: (PRText content: '1');						          add: (self actualClass new								           add: (PRListItem new										            add: (PRText content: '1.1');										            add: (self actualClass new												             add: (self listItemWithText: '1.1.1');												             yourself);										            yourself);								           yourself);						          yourself);				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterUnorderedListTest methodsFor: 'private'!textString: anObject level: anInteger	^ (super textString: anObject level: anInteger) , '* '! !!PRPillarWriterUnorderedListTest methodsFor: 'private'!wikiString	^ '-'! !!PRPillarWriterEmptyParagraphTest methodsFor: 'private'!actualClass	^ PREmptyParagraph! !!PRPillarWriterEmptyParagraphTest methodsFor: 'tests'!testParseEmptyParagraphAtBeginning	| wiki tree content |	content := 'Lorem ipsum dolor sit amet.'.	wiki := self lineEnding , content.	tree := PRDocument new		        add: PREmptyParagraph new;		        add: (PRParagraph new				         add: (PRText content: content);				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterEmptyParagraphTest methodsFor: 'tests'!testParseEmptyParagraphInTheMiddle	| wiki tree content nLine |	nLine := self lineEnding.	content := 'Lorem ipsum dolor sit amet.'.	wiki := content , nLine , nLine , content.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: content);				         yourself);		        add: PREmptyParagraph new;		        add: (PRParagraph new				         add: (PRText content: content);				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterParagraphTest class methodsFor: 'testing'!isAbstract	^ false! !!PRPillarWriterParagraphTest methodsFor: 'private'!actualClass	^ PRParagraph! !!PRPillarWriterParagraphTest methodsFor: 'tests-parsing'!testParseEmptyLineAtBeginning	| wiki tree |	wiki := '' , self lineEnding , 'Lorem ipsum dolor sit amet.'.	tree := PRDocument new		        add: PREmptyParagraph new;		        add: (PRParagraph new				         add: (PRText content: 'Lorem ipsum dolor sit amet.');				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterParagraphTest methodsFor: 'tests-parsing'!testParseOneLine	| wiki tree |	wiki := 'Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Nulla quis urna.'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText content: wiki);			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterParagraphTest methodsFor: 'tests-parsing'!testParseThreeEmptyLines	| wiki tree nLine |	nLine := self lineEnding.	wiki := 'Lorem ipsum dolor sit amet.' , nLine , nLine , nLine	        , 'Nulla mattis elementum nulla.'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: 'Lorem ipsum dolor sit amet.');				         yourself);		        add: PREmptyParagraph new;		        add: PREmptyParagraph new;		        add: (PRParagraph new				         add: (PRText content: 'Nulla mattis elementum nulla.');				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterParagraphTest methodsFor: 'tests-parsing'!testParseTwoConsecutiveNonTextLines	| wiki tree sentence title nLine |	nLine := self lineEnding.	sentence := 'sentence'.	title := 'title'.	wiki := sentence , nLine , '!!' , title.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: sentence);				         yourself);		        add: (PRHeader new				         level: 1;				         add: (PRText content: title);				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterParagraphTest methodsFor: 'tests-parsing'!testParseTwoEmptyLines	| wiki tree nLine |	nLine := self lineEnding.	wiki := 'Lorem ipsum dolor sit amet.' , nLine , nLine	        , 'Nulla mattis elementum nulla.'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: 'Lorem ipsum dolor sit amet.');				         yourself);		        add: PREmptyParagraph new;		        add: (PRParagraph new				         add: (PRText content: 'Nulla mattis elementum nulla.');				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterDocumentItemTest methodsFor: 'private'!actualClass	^ PRDocumentItem! !!PRPillarWriterDocumentItemTest methodsFor: 'utilities'!addText: aString to: aDocumentItem	^ aDocumentItem		add: (PRText content: aString);		yourself! !!PRPillarWriterDocumentItemTest methodsFor: 'private'!barInstance	^ PRText content: 'bar'! !!PRPillarWriterDocumentItemTest methodsFor: 'private'!fooInstance	^ PRText content: 'foo'! !!PRPillarWriterDocumentItemTest methodsFor: 'private'!foobarInstances	^ Array with: self fooInstance with: self barInstance! !!PRPillarWriterDocumentItemTest methodsFor: 'helper'!parser	^ PRDocument parser! !!PRPillarWriterDocumentItemTest methodsFor: 'utilities'!pillarWriterAssertTree: aDocument equalsWiki: aString	"Assert that traversing aDocument using the wiki writer results in aString."	self assert: (PRPillarWriter write: aDocument) = aString description: aString resumable: false! !"Pillar-Tests-ExporterPillar"!!PRPillarWriterDefinitionDataTest class methodsFor: 'testing'!isAbstract	^ false! !!PRPillarWriterDefinitionDataTest methodsFor: 'private'!actualClass	^ PRDefinitionList! !!PRPillarWriterDefinitionDataTest methodsFor: 'private'!listItemClass	^ PRDataItem! !!PRPillarWriterDefinitionDataTest methodsFor: 'tests'!testParseBug	| wiki2 tree nLine |	nLine := self lineEnding.	wiki2 := ':' , nLine , '::1' , nLine , '::-2'.	tree := PRDocument new		        add: (PRDefinitionList new				         add: (PRDataItem new						          add: (PRDefinitionList new								           add: (PRDataItem new										            add: (PRText content: '1');										            add: (PRUnorderedList new												             add: (PRListItem new														              add: (PRText content: '2');														              yourself);												             yourself);										            yourself);								           yourself);						          yourself);				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki2! !!PRPillarWriterDefinitionDataTest methodsFor: 'tests'!testParseMixed	| wiki tree |	wiki := ';1' , self lineEnding , ':2'.	tree := PRDocument new		        add: (PRDefinitionList new				         add: (PRTermItem new						          add: (PRText content: '1');						          yourself);				         add: (PRDataItem new						          add: (PRText content: '2');						          yourself);				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterDefinitionDataTest methodsFor: 'private'!textString: anObject level: anInteger	^ (super textString: anObject level: anInteger) , '  '! !!PRPillarWriterDefinitionDataTest methodsFor: 'private'!wikiString	^ ':'! !!PRPillarWriterDefinitionTermTest class methodsFor: 'testing'!isAbstract	^ false! !!PRPillarWriterDefinitionTermTest methodsFor: 'private'!actualClass	^ PRDefinitionList! !!PRPillarWriterDefinitionTermTest methodsFor: 'private'!listItemClass	^ PRTermItem! !!PRPillarWriterDefinitionTermTest methodsFor: 'tests'!testParseMixed	| wiki tree nLine |	nLine := self lineEnding.	wiki := ';1' , nLine , ';2' , nLine , ':3' , nLine , ':4'.	tree := PRDocument new		        add: (PRDefinitionList new				         add: (PRTermItem new						          add: (PRText content: '1');						          yourself);				         add: (PRTermItem new						          add: (PRText content: '2');						          yourself);				         add: (PRDataItem new						          add: (PRText content: '3');						          yourself);				         add: (PRDataItem new						          add: (PRText content: '4');						          yourself);				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterDefinitionTermTest methodsFor: 'private'!textString: anObject level: anInteger	^ (super textString: anObject level: anInteger) , '- '! !!PRPillarWriterDefinitionTermTest methodsFor: 'private'!wikiString	^ ';'! !!PRPillarWriterHeaderTest class methodsFor: 'testing'!isAbstract	^ false! !!PRPillarWriterHeaderTest methodsFor: 'private'!actualClass	^ PRHeader! !!PRPillarWriterHeaderTest methodsFor: 'tests-parsing'!testParseEmpty	| wiki tree |	wiki := '!!'.	tree := PRDocument new		add: (PRHeader new			level: 1;			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterHeaderTest methodsFor: 'tests-parsing'!testParseLevel1	| wiki tree |	wiki := '!!foo'.	tree := PRDocument new		add: ((PRHeader new)			level: 1;			add: (PRText content: 'foo');			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.! !!PRPillarWriterHeaderTest methodsFor: 'tests-parsing'!testParseLevel2	| wiki tree |	wiki := '!!!!foo'.	tree := PRDocument new		add: ((PRHeader new)			level: 2;			add: (PRText content: 'foo');			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.! !!PRPillarWriterHeaderTest methodsFor: 'tests-parsing'!testParseLevel3	| wiki tree |	wiki := '!!!!!!foo'.	tree := PRDocument new		add: ((PRHeader new)			level: 3;			add: (PRText content: 'foo');			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.! !!PRPillarWriterHeaderTest methodsFor: 'tests-parsing'!testParseLevel4	| wiki tree |	wiki := '!!!!!!!!foo'.	tree := PRDocument new		add: ((PRHeader new)			level: 4;			add: (PRText content: 'foo');			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.! !!PRPillarWriterHeaderTest methodsFor: 'tests-parsing'!testParseLevel5	| wiki tree |	wiki := '!!!!!!!!!!foo'.	tree := PRDocument new		add: ((PRHeader new)			level: 5;			add: (PRText content: 'foo');			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.! !!PRPillarWriterHeaderTest methodsFor: 'tests-parsing'!testParseLevel6	| wiki tree |	wiki := '!!!!!!!!!!!!foo'.	tree := PRDocument new		add: ((PRHeader new)			level: 6;			add: (PRText content: 'foo');			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.! !!PRPillarWriterHeaderTest methodsFor: 'tests-parsing'!testParseMultiline	| wiki tree nLine |	nLine := self lineEnding.	wiki := '!!!!Hello ""This is' , nLine , 'bold"" end' , nLine , 'new'.	tree := PRDocument new		        add: (PRHeader new				         level: 2;				         add: (PRText content: 'Hello ');				         add:					         (self						          addText: 'This is' , nLine , 'bold'						          to: PRBoldFormat new);				         add: (PRText content: ' end');				         yourself);		        add: (self addText: 'new' to: PRParagraph new);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterHeaderTest methodsFor: 'tests-parsing'!testParseNested	| wiki text tree |	wiki := '!!!!Hello *Link*'.	tree := PRDocument new		add: (PRHeader new			level: 2;			add: (PRText content: 'Hello ');			add: (PRInternalLink new				reference: 'Link';				yourself);			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.! !!PRPillarWriterHeaderTest methodsFor: 'tests-parsing'!testParseWithTrailingSpaces	| wiki tree |	wiki := '!!  foo'.	tree := PRDocument new		add: ((PRHeader new)			level: 1;			add: (PRText content: 'foo');			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: '!!foo'! !!PRPillarWriterPreformattedTest class methodsFor: 'testing'!isAbstract	^ false! !!PRPillarWriterPreformattedTest methodsFor: 'private'!actualClass	^ PRPreformatted! !!PRPillarWriterPreformattedTest methodsFor: 'tests-parsing'!testParseBasic	| wiki tree |	wiki := '= Line'.	tree := PRDocument new		add: (PRPreformatted new			add: (PRText content: 'Line');			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.! !!PRPillarWriterPreformattedTest methodsFor: 'tests-parsing'!testParseEmpty	| wiki text tree |	wiki := '= '.	tree := PRDocument new		add: (PRPreformatted new			add: (PRText content: '');			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.! !!PRPillarWriterPreformattedTest methodsFor: 'tests-parsing'!testParseMultiple	| wiki tree nLine |	nLine := self lineEnding.	wiki := '= line 1.1' , nLine , '= line 1.2' , nLine , nLine	        , '= line 2.1'.	tree := PRDocument new		        add: (PRPreformatted new				         add: (PRText content: 'line 1.1');				         add: (PRText content: 'line 1.2');				         yourself);		        add: PREmptyParagraph new;		        add: (PRPreformatted new				         add: (PRText content: 'line 2.1');				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterPreformattedTest methodsFor: 'tests-parsing'!testParseSpaces	| wiki tree nLine |	nLine := self lineEnding.	wiki := '=    A line with 3 spaces' , nLine , '= 	A line with a tab'.	tree := PRDocument new		        add: (PRPreformatted new				         add: (PRText content: '   A line with 3 spaces');				         add: (PRText content: '	A line with a tab');				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterPreformattedTest methodsFor: 'tests-parsing'!testParseSpecials	| wiki tree |	wiki := '= |, {, }, *, *, [, ||, |{, |}, +, +'.		tree := PRDocument new		add: (PRPreformatted new			add: (PRText content: '|, {, }, *, *, [, ||, |{, |}, +, +');			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.! !!PRPillarWriterExternalLinkTest class methodsFor: 'testing'!isAbstract	^ false! !!PRPillarWriterExternalLinkTest methodsFor: 'private'!actualClass	^ PRExternalLink! !!PRPillarWriterExternalLinkTest methodsFor: 'private'!referenceString	^ 'http://www.lukas-renggli.ch'! !!PRPillarWriterExternalLinkTest methodsFor: 'tests'!testLinkToAFigureIsExternalLink	| wiki tree |	wiki := '*file://foo.png*'.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				reference: 'file://foo.png';				yourself);			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterMailLinkTest methodsFor: 'private'!actualClass	^ PRMailLink! !!PRPillarWriterMailLinkTest methodsFor: 'private'!referenceString	^ 'renggli@gmail.com'! !!PRPillarWriterMailLinkTest methodsFor: 'as yet unclassified'!testLinkToAFigureIsExternalLink	"This test has no meaning in PRMailLinkTest."! !!PRPillarWriterMailLinkTest methodsFor: 'tests-parsing'!testParseBogus	| wiki tree |	wiki := '*ab12@x.com*'.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				reference: 'ab12@x.com';				yourself);			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterInternalLinkTest class methodsFor: 'testing'!isAbstract	^ false! !!PRPillarWriterInternalLinkTest methodsFor: 'private'!actualClass	^ PRInternalLink! !!PRPillarWriterInternalLinkTest methodsFor: 'private'!referenceString	^ 'Page'! !!PRPillarWriterInternalLinkTest methodsFor: 'tests-parsing'!testParseAnchored	| wiki tree |	wiki := '*' , self referenceString , '@Anchor*'.		tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				reference: self referenceString;				anchor: 'Anchor';				yourself);			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterInternalLinkTest methodsFor: 'tests-parsing'!testParseEverything	| wiki  tree |	wiki := '*Alias>' , self referenceString , '@Anchor*'.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				add: (PRText content: 'Alias');				reference: self referenceString;				anchor: 'Anchor';				yourself);			yourself);		yourself.		self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterLinkTest methodsFor: 'private'!actualClass	^ PRLink! !!PRPillarWriterLinkTest methodsFor: 'private'!markup	^ PRPillarParser markups at: PRLink! !!PRPillarWriterLinkTest methodsFor: 'tests-parsing'!testParseAliased	| wiki tree |	wiki := '*Alias>' , self referenceString , '*'.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				add: (PRText content: 'Alias');				reference: self referenceString;				yourself);			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterLinkTest methodsFor: 'tests-parsing'!testParseAliasedEmpty	| wiki tree |	wiki := '*>' , self referenceString , '*'.		tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				add: (PRText content: '');				reference: self referenceString;				yourself);			yourself);		yourself.		self pillarWriterAssertTree: tree equalsWiki: wiki.! !!PRPillarWriterLinkTest methodsFor: 'tests-parsing'!testParseBasic	| wiki tree |	wiki := '*' , self referenceString , '*'.		tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				reference: self referenceString;				yourself);			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterLinkTest methodsFor: 'tests-parsing'!testParseParameters	| wiki  tree |	wiki := '*Alias>' , self referenceString , '|a=1|b=2|c=true*'.	tree := PRDocument new		add:				(PRParagraph new						add:								(self actualClass new										add: (PRText content: 'Alias');										reference: self referenceString;										parameters:												(OrderedDictionary new														add: 'a' -> 1;														add: 'b' -> 2;														add: 'c' -> true;														yourself);										yourself);						yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterLinkTest methodsFor: 'tests-parsing'!testParseParametersEscaped	| wiki  tree |	wiki := '*Alias>' , self referenceString , '|2=\|\=|\|\==1*'.	tree := PRDocument new		add:				(PRParagraph new						add:								(self actualClass new										add: (PRText content: 'Alias');										reference: self referenceString;										parameters:												(OrderedDictionary new														add: '2' -> '|=';														add: '|=' -> 1;														yourself);										yourself);						yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterReferenceTest methodsFor: 'private'!actualClass	^ PRReference! !!PRPillarWriterReferenceTest methodsFor: 'private'!markup	^ self subclassResponsibility! !!PRPillarWriterReferenceTest methodsFor: 'private'!referenceString	self subclassResponsibility! !!PRPillarWriterReferenceTest methodsFor: 'tests'!testNonTextAlias	| wiki tree |	wiki := self markup , 'foo ""Alias"">' , self referenceString , self markup.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				add: (PRText content: 'foo ');				add: (self addText: 'Alias' to: PRBoldFormat new);				reference: self referenceString;				yourself);			yourself);		yourself.		self pillarWriterAssertTree: tree equalsWiki: wiki.! !!PRPillarWriterReferenceTest methodsFor: 'tests-parsing'!testParseAliased	| wiki tree |	wiki := self markup , 'Alias>' , self referenceString , self markup.		tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				add: (PRText content: 'Alias');				reference: self referenceString;				yourself);			yourself);		yourself.		self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterReferenceTest methodsFor: 'tests-parsing'!testParseAliasedEmpty	| wiki tree |	wiki := self markup , '>' , self referenceString , self markup.	tree := PRDocument new		add:			(PRParagraph new				add:					(self actualClass new						add: (PRText content: '');						reference: self referenceString;						yourself);				yourself);		yourself.		self pillarWriterAssertTree: tree equalsWiki: wiki.! !!PRPillarWriterReferenceTest methodsFor: 'tests-parsing'!testParseBasic	| wiki tree |	wiki := self markup  , self referenceString , self markup .	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				reference: self referenceString;				yourself);			yourself);		yourself.		self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterReferenceTest methodsFor: 'tests-parsing'!testParseEasyness	| wiki2 tree |	wiki2 := '\' , self markup , self lineEnding , '\' , self markup	         , self referenceString.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: self markup);				         add: PRLineBreak new;				         add: (PRText content: self markup , self referenceString);				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki2! !!PRPillarWriterReferenceTest methodsFor: 'tests-parsing'!testParseEmpty	| wiki2 text tree |		wiki2 := '\' , self markup , '\' , self markup.	tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: self markup , self markup);				yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki2.! !!PRPillarWriterReferenceTest methodsFor: 'tests-parsing'!testParseEscaped	| wiki tree |	wiki := 'Star \*' , self referenceString , '\*' , self lineEnding	        , 'Cross \+' , self referenceString , '\+'.	tree := PRDocument new		        add: (PRParagraph new				         add:					         (PRText content: 'Star *' , self referenceString , '*');				         add: PRLineBreak new;				         add:					         (PRText content: 'Cross +' , self referenceString , '+');				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterReferenceTest methodsFor: 'tests-parsing'!testParseParameters	| wiki tree |	wiki := self markup , 'Alias>' , self referenceString , '|a=1|b=2|c=true' , self markup .	tree := PRDocument new		add:				(PRParagraph new						add:								(self actualClass new										add: (PRText content: 'Alias');										reference: self referenceString;										parameters:												(OrderedDictionary new														add: 'a' -> 1;														add: 'b' -> 2;														add: 'c' -> true;														yourself);										yourself);						yourself);		yourself.		self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterReferenceTest methodsFor: 'tests-parsing'!testParseParametersEscaped	| wiki tree |	wiki := self markup , 'Alias>' , self referenceString , '|2=\|\=|\|\==1' , self markup .	tree := PRDocument new		add:				(PRParagraph new						add:								(self actualClass new										add: (PRText content: 'Alias');										reference: self referenceString;										parameters:												(OrderedDictionary new														add: '2' -> '|=';														add: '|=' -> 1;														yourself);										yourself);						yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.! !!PRPillarWriterTableCellTest class methodsFor: 'testing'!isAbstract	^ false! !!PRPillarWriterTableCellTest methodsFor: 'private'!actualClass	^ PRTableCell! !!PRPillarWriterTableCellTest methodsFor: 'tests-parsing'!testParseAlign1	| wiki tree |	wiki := '|{left||center|}right'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					beAlignedLeft;					add: (PRText content: 'left');					yourself);				add: (PRTableCell new					beAlignedCenter;					add: (PRText content: 'center');					yourself);				add: (PRTableCell new					beAlignedRight;					add: (PRText content: 'right');					yourself);				yourself);			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterTableCellTest methodsFor: 'tests-parsing'!testParseAlign2	| wiki tree |	wiki := '|}right|none|{left|none'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					beAlignedRight;					add: (PRText content: 'right');					yourself);				add: (PRTableCell new					add: (PRText content: 'none');					yourself);				add: (PRTableCell new					beAlignedLeft;					add: (PRText content: 'left');					yourself);				add: (PRTableCell new					add: (PRText content: 'none');					yourself);				yourself);			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.! !!PRPillarWriterTableCellTest methodsFor: 'tests-parsing'!testParseEncoding	| wiki tree |	wiki := '|*link*|+file://embedded.png+|foo{}'.		tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					add: (PRInternalLink new						reference: 'link';						yourself);					yourself);				add: (PRTableCell new					add: (PRFigure new						reference: 'file://embedded.png';						yourself);					yourself);				add: (PRTableCell new					add: (PRText content: 'foo{}');					yourself);				yourself);			yourself);		yourself.		self pillarWriterAssertTree: tree equalsWiki: wiki.! !!PRPillarWriterTableCellTest methodsFor: 'tests-parsing'!testParseHeading1	| wiki tree |	wiki := '|!!head|{!!left||!!center|}!!right'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					beHeading;					add: (PRText content: 'head');					yourself);				add: (PRTableCell new					beHeading;					beAlignedLeft;					add: (PRText content: 'left');					yourself);				add: (PRTableCell new					beHeading;					beAlignedCenter;					add: (PRText content: 'center');					yourself);				add: (PRTableCell new					beHeading;					beAlignedRight;					add: (PRText content: 'right');					yourself);				yourself);			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.! !!PRPillarWriterTableCellTest methodsFor: 'tests-parsing'!testParseHeading2	| wiki2 text tree |		wiki2 := '|!!head|{!!left||!!center|}!!right'.		tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					beHeading;					add: (PRText content: 'head');					yourself);				add: (PRTableCell new					beHeading;					beAlignedLeft;					add: (PRText content: 'left');					yourself);				add: (PRTableCell new					beHeading;					beAlignedCenter;					add: (PRText content: 'center');					yourself);				add: (PRTableCell new					beHeading;					beAlignedRight;					add: (PRText content: 'right');					yourself);				yourself);			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki2.	! !!PRPillarWriterTableTest class methodsFor: 'testing'!isAbstract	^ false! !!PRPillarWriterTableTest methodsFor: 'private'!actualClass	^ PRTable! !!PRPillarWriterTableTest methodsFor: 'tests-parsing'!testParseBasic	| wiki tree |	wiki := '|cell'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					add: (PRText content: 'cell');					yourself);				yourself);			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterTableTest methodsFor: 'tests-parsing'!testParseSquare	| wiki tree nLine |	nLine := self lineEnding.	wiki := '|a11|a12' , nLine , '|a21|a22'.	tree := PRDocument new		        add: (PRTable new				         add: (PRTableRow new						          add: (PRTableCell new								           add: (PRText content: 'a11');								           yourself);						          add: (PRTableCell new								           add: (PRText content: 'a12');								           yourself);						          yourself);				         add: (PRTableRow new						          add: (PRTableCell new								           add: (PRText content: 'a21');								           yourself);						          add: (PRTableCell new								           add: (PRText content: 'a22');								           yourself);						          yourself);				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterTableTest methodsFor: 'tests-parsing'!testParseTriangle	| wiki tree nLine |	nLine := self lineEnding.	wiki := '|a11' , nLine , '|a21|a22' , nLine , '|a31|a32|a33'.	tree := PRDocument new		        add: (PRTable new				         add: (PRTableRow new						          add: (PRTableCell new								           add: (PRText content: 'a11');								           yourself);						          yourself);				         add: (PRTableRow new						          add: (PRTableCell new								           add: (PRText content: 'a21');								           yourself);						          add: (PRTableCell new								           add: (PRText content: 'a22');								           yourself);						          yourself);				         add: (PRTableRow new						          add: (PRTableCell new								           add: (PRText content: 'a31');								           yourself);						          add: (PRTableCell new								           add: (PRText content: 'a32');								           yourself);						          add: (PRTableCell new								           add: (PRText content: 'a33');								           yourself);						          yourself);				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterTableTest methodsFor: 'tests-parsing'!testParseWithPreformattedAndLinkWithParameters	| wiki tree |	wiki := '|==\+link\|a\+==|'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					add: (PRMonospaceFormat new						add: (PRText content: '+link|a+');						yourself);					yourself);				add: (PRTableCell new					yourself);				yourself);			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.! !!PRPillarWriterTableTest methodsFor: 'tests-parsing'!testParseWithPreformattedAndProtectedPipe	| wiki tree |	wiki := '|==\|==|'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new				  					add: (PRMonospaceFormat new						add: (PRText content: '|');						yourself);								yourself);				add: (PRTableCell new					yourself);				yourself);			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.! !!PRPillarWriterHorizontalRuleTest class methodsFor: 'testing'!isAbstract	^ false! !!PRPillarWriterHorizontalRuleTest methodsFor: 'private'!actualClass	^ PRHorizontalRule! !!PRPillarWriterHorizontalRuleTest methodsFor: 'tests-parsing'!testParseBasic	| wiki tree |	wiki := '_'.	tree := PRDocument new		add: PRHorizontalRule new;		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterHorizontalRuleTest methodsFor: 'tests-parsing'!testParseLink	| wiki2 tree |	wiki2 := '\_ *link*'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText content: '_ ');			add: (PRInternalLink new				reference: 'link';				yourself);			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki2.! !!PRPillarWriterHorizontalRuleTest methodsFor: 'tests-parsing'!testParseMultiple	| wiki tree nLine |	nLine := self lineEnding.	wiki := '_' , nLine , '_' , nLine , nLine , '_'.	tree := PRDocument new		        add: PRHorizontalRule new;		        add: PRHorizontalRule new;		        add: PREmptyParagraph new;		        add: PRHorizontalRule new;		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterHorizontalRuleTest methodsFor: 'tests-parsing'!testParseParagraph	| wiki text tree |	wiki := '\_ is parsed as paragraph'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText content: '_ is parsed as paragraph');			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterHorizontalRuleTest methodsFor: 'tests-parsing'!testParseSpaces	| wiki tree |	wiki := '_       '.	tree := PRDocument new		add: PRHorizontalRule new;		yourself.	self pillarWriterAssertTree: tree equalsWiki: '_'.	! !!PRPillarWriterHorizontalRuleTest methodsFor: 'private'!textString	^ String new: 40 withAll: $-! !!PRPillarWriterLineBreakTest class methodsFor: 'testing'!isAbstract	^ false! !!PRPillarWriterLineBreakTest methodsFor: 'private'!actualClass	^ PRLineBreak! !!PRPillarWriterLineBreakTest methodsFor: 'tests-parsing'!testParseOneEmptyLine	| wiki tree nLine |	nLine := self lineEnding.	wiki := 'Lorem ipsum dolor sit amet.' , nLine , nLine	        , 'Nulla quis urna.'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: 'Lorem ipsum dolor sit amet.');				         yourself);		        add: PREmptyParagraph new;		        add:		        (PRParagraph new add:			         (PRText content: 'Nulla quis urna.') yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterLineBreakTest methodsFor: 'tests-parsing'!testParseTreeLines	| wiki tree nLine |	nLine := self lineEnding.	wiki := 'Lorem ipsum dolor sit amet.' , nLine , 'Nulla quis urna.'	        , nLine , 'Vestibulum turpis.'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: 'Lorem ipsum dolor sit amet.');				         add: PRLineBreak new;				         add: (PRText content: 'Nulla quis urna.');				         add: PRLineBreak new;				         add: (PRText content: 'Vestibulum turpis.');				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterLineBreakTest methodsFor: 'tests-parsing'!testParseTwoEmptyLines	| text tree nLine |	nLine := self lineEnding.	text := 'Lorem ipsum dolor sit amet.' , nLine , nLine , nLine	        , 'Nulla quis urna.'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: 'Lorem ipsum dolor sit amet.');				         yourself);		        add: PREmptyParagraph new;		        add: PREmptyParagraph new;		        add:		        (PRParagraph new add:			         (PRText content: 'Nulla quis urna.') yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: text! !!PRPillarWriterLineBreakTest methodsFor: 'tests-parsing'!testParseTwoLines	| wiki tree |	wiki := 'Lorem ipsum dolor sit amet.' , self lineEnding	        , 'Nulla quis urna.'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: 'Lorem ipsum dolor sit amet.');				         add: PRLineBreak new;				         add: (PRText content: 'Nulla quis urna.') yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterCommentedLineTest methodsFor: 'private'!actualClass	^ PRCommentedLine! !!PRPillarWriterCommentedLineTest methodsFor: 'tests-parsing'!testParseBasic	| wiki text tree |	wiki := '%some comment'.	tree := PRDocument new		add: (PRCommentedLine content: 'some comment');		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterCommentedLineTest methodsFor: 'tests-parsing'!testParseDontInterruptLists	| wiki tree nLine |	nLine := self lineEnding.	wiki := '#item one' , nLine , '##item one-point-one' , nLine	        , '%comment' , nLine , '##item one-point-two'.	tree := PRDocument new		        add: (PROrderedList new				         add: (PRListItem new						          add: (PRText content: 'item one');						          add: (PROrderedList new								           add: (PRListItem new										            add: (PRText content: 'item one-point-one');										            add: (PRCommentedLine content: 'comment');										            yourself);								           add: (PRListItem new										            add: (PRText content: 'item one-point-two');										            yourself);								           yourself);						          yourself);				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterCommentedLineTest methodsFor: 'tests-parsing'!testParseDontParseContent	| wiki tree |	wiki := '%some *comment*'.		tree := PRDocument new		add: (PRCommentedLine content: 'some *comment*');		yourself.		self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterRawTest methodsFor: 'private'!actualClass	^ PRRaw! !!PRPillarWriterRawTest methodsFor: 'tests-parsing'!testParseBasic	| wiki text tree |	wiki := '{{{abc}}}'.	tree := PRDocument new		add: (PRParagraph new			add: (PRRaw content: 'abc');			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterRawTest methodsFor: 'tests-parsing'!testParseEmpty	| wiki tree |	wiki := '{{{}}}'.	tree := PRDocument new		add: (PRParagraph new			add: (PRRaw content: '');			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterRawTest methodsFor: 'tests-parsing'!testParseMultiline	| wiki tree nLine |	nLine := self lineEnding.	wiki := '{{{a' , nLine , 'b}}}'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRRaw content: 'a' , nLine , 'b');				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterRawTest methodsFor: 'tests-parsing'!testParseMultiple	| wiki tree |	wiki := '{{{a}}}b{{{c}}}'.	tree := PRDocument new		add: (PRParagraph new			add: (PRRaw content: 'a');			add: (PRText content: 'b');			add: (PRRaw content: 'c');			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.! !!PRPillarWriterRawTest methodsFor: 'tests-parsing'!testParseMultipleMultiline	| wiki tree nLine |	nLine := self lineEnding.	wiki := '{{{a' , nLine , 'b}}}c{{{d' , nLine , 'e}}}'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRRaw content: 'a' , nLine , 'b');				         add: (PRText content: 'c');				         add: (PRRaw content: 'd' , nLine , 'e');				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterRawTest methodsFor: 'tests-parsing'!testParseStrange	| wiki tree |	wiki := '{{{a{{||}}b}}}'.	tree := PRDocument new		add: (PRParagraph new			add: (PRRaw content: 'a{{||}}b');			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.! !!PRPillarWriterRawTest methodsFor: 'tests-parsing'!testParseTypeHtml	| wiki tree |	wiki := '{{{html:abc}}}'.	tree := PRDocument new		add: (PRParagraph new			add: (PRRaw content: 'abc' type: 'html');			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterRawTest methodsFor: 'tests-parsing'!testParseTypeLatex	| wiki text tree |	wiki := '{{{latex:abc}}}'.	tree := PRDocument new		add: (PRParagraph new			add: (PRRaw content: 'abc' type: 'latex');			yourself);		yourself.		self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterRawTest methodsFor: 'tests-parsing'!testParseTypeText	| wiki tree |	wiki := '{{{text:abc}}}'.	tree := PRDocument new		add: (PRParagraph new			add: (PRRaw content: 'abc' type: 'text');			yourself);		yourself.		self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterScriptTest methodsFor: 'private'!actualClass	^ PRCodeblock! !!PRPillarWriterScriptTest methodsFor: 'tests-parsing'!testParseEscape	| wiki tree nLine |	nLine := self lineEnding.	wiki := '[[[language=foo\|' , nLine , 'foo' , nLine , ']]]'.	tree := PRDocument new		        add: ((PRCodeblock content: 'foo')				         language: 'foo|';				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterScriptTest methodsFor: 'tests-parsing'!testParseRealLanguage	| wiki text tree nLine |	nLine := self lineEnding.	wiki := '[[[language=smalltalk' , nLine , 'foo' , nLine , ']]]'.	tree := PRDocument new		        add: ((PRCodeblock content: 'foo')				         language: PRSmalltalkScriptLanguage default;				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterScriptTest methodsFor: 'tests-parsing'!testParseSimple	| wiki tree nLine |	nLine := self lineEnding.	wiki := '[[[' , nLine , 'foo' , nLine , ']]]'.	tree := PRDocument new		        add: (PRCodeblock content: 'foo');		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterScriptTest methodsFor: 'tests-parsing'!testParseWithSimpleCaption	| wiki tree nLine |	nLine := self lineEnding.	wiki := '[[[caption=foo' , nLine , 'foo' , nLine , ']]]'.	tree := PRDocument new		        add: ((PRCodeblock content: 'foo')				         caption: 'foo';				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterTextTest class methodsFor: 'testing'!isAbstract	^ false! !!PRPillarWriterTextTest methodsFor: 'private'!actualClass	^ PRText! !!PRPillarWriterTextTest methodsFor: 'tests-parsing'!testEscapeCpp	| wiki tree |	wiki := 'Text: \+\+'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText content: 'Text: ++');			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterTextTest methodsFor: 'tests-parsing'!testEscapeFirst	| wiki tree nLine |	nLine := self lineEnding.	wiki := '\* text' , nLine , '\+ text' , nLine , '\= text' , nLine	        , '\@ text' , nLine , '\!! text' , nLine , '\| text' , nLine	        , '\# text' , nLine , '\- text'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: '* text');				         add: PRLineBreak new;				         add: (PRText content: '+ text');				         add: PRLineBreak new;				         add: (PRText content: '= text');				         add: PRLineBreak new;				         add: (PRText content: '@ text');				         add: PRLineBreak new;				         add: (PRText content: '!! text');				         add: PRLineBreak new;				         add: (PRText content: '| text');				         add: PRLineBreak new;				         add: (PRText content: '# text');				         add: PRLineBreak new;				         add: (PRText content: '- text');				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterTextTest methodsFor: 'tests-parsing'!testEscapeStrange	| wiki tree |	wiki := '< text' , self lineEnding , '> text'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: '< text');				         add: PRLineBreak new;				         add: (PRText content: '> text');				         yourself);		        yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterTextTest methodsFor: 'tests-parsing'!testEscapeText	| wiki tree |	wiki := 'Text: \*\+'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText content: 'Text: *+');			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterTextTest methodsFor: 'tests-parsing'!testEscapeWiki	| wiki tree |	wiki := 'Wiki: =, |, !!, #, {, }, |{, ||, |}, [, ] and -'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText content: 'Wiki: =, |, !!, #, {, }, |{, ||, |}, [, ] and -');			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterTextTest methodsFor: 'tests-parsing'!testParseBasic	| wiki tree |	wiki := 'abcdefghijklmnopqrstuvwxyz... ABCDEFGHIJKLMNOPQRSTUVWXYZ... 0123456789...'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText content: 'abcdefghijklmnopqrstuvwxyz... ABCDEFGHIJKLMNOPQRSTUVWXYZ... 0123456789...');			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterTextTest methodsFor: 'tests-parsing'!testParseHtml	| wiki tree |	wiki := '<strong>strong <emph>strong, emph</emph></strong>'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText content: '<strong>strong <emph>strong, emph</emph></strong>');			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterTextTest methodsFor: 'tests-parsing'!testParseLatex	| wiki tree |	wiki := '\\begin{foo}[bar]$zork$\\end{foo}'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText content: '\begin{foo}[bar]$zork$\end{foo}');			yourself);		yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki.	! !!PRPillarWriterTextTest methodsFor: 'tests-parsing'!testParseSpecial	| wiki tree |	wiki := '????????????¬å???????????????¬ú??¬ü¬¬°¬¢¬£¬§¬·?¬ß?¬©¬¬´¬¨?¬Æ¬Ø¬¬±???¬µ¬¬??¬¬ª???¬ø¦Ä¦Å¦Ç¦É¦Ñ¦Ö¦Ü¦á¦à¦â¦ä¦ã¦å¦ç¦é¦è?¦ë¦í¦ì¦î¦ï¦ñ?¦ò¦ô¦ö¦õ¦ú??¦ü¦¦°¦¢¦£¦§¦·¦¶¦ß¦®¦©¦¦´¦¨¦¦Æ¦Ø?¦±¦¦¦¥¦µ¦¦¦¦¦¦ª¦º??'.	tree := (PRDocument new)				add: ((PRParagraph new)							add: (PRText										content: '????????????¬å???????????????¬ú??¬ü¬¬°¬¢¬£¬§¬·?¬ß?¬©¬¬´¬¨?¬Æ¬Ø¬¬±???¬µ¬¬??¬¬ª???¬ø¦Ä¦Å¦Ç¦É¦Ñ¦Ö¦Ü¦á¦à¦â¦ä¦ã¦å¦ç¦é¦è?¦ë¦í¦ì¦î¦ï¦ñ?¦ò¦ô¦ö¦õ¦ú??¦ü¦¦°¦¢¦£¦§¦·¦¶¦ß¦®¦©¦¦´¦¨¦¦Æ¦Ø?¦±¦¦¦¥¦µ¦¦¦¦¦¦ª¦º??');							yourself);				yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !!PRPillarWriterTextTest methodsFor: 'tests-parsing'!testParseWiki	| wiki tree |	wiki := ' !!_#-|=]@:<>\*'.	tree := (PRDocument new)				add: ((PRParagraph new)							add: (PRText content: ' !!_#-|=]@:<>*');							yourself);				yourself.	self pillarWriterAssertTree: tree equalsWiki: wiki! !"Pillar-Tests-Model-ExporterPillar"!!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!assertTemplate: template writesValue: value forNode: node	self assertTemplatePath: Path * template writesValue: value forNode: node ! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!assertTemplatePath: templatePath writesValue: contents forNode: node	self createTemplateFileAt: templatePath withContents: contents.	self assertWritingNode: node writes: contents.! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!assertWritingNode: node writes: contents	| document result |	document := PRDocument new		add: node;		yourself.	result := textDocument writer write: document.	self assert: result equals: contents! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!createTemplateFileAt: aPath withContents: contents	| templateFileReference |	templateFileReference := textDocument templateDirectory resolve: aPath.	templateFileReference parent ensureCreateDirectory.	templateFileReference writeStreamDo: [ :stream | stream nextPutAll: contents ].! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!setUp	super setUp.	textDocument := PRTextDocument new			project: (PRProject new				baseDirectory: FileSystem memory;				beTemplatable;				yourself);			yourself.! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!testWriteAnchorUsesAnchorTemplate	self		assertTemplate: 'todo.mustache'		writesValue: 'annotated paragraph'		forNode: (PRAnnotatedParagraph withAll: #() annotation: 'todo')! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!testWriteAnchorUsesDefaultIfNotSpecificIsDefinedTemplate	self		assertTemplate: PRTemplatedWriter defaultAnnotatedParagraphTemplateFileName		writesValue: 'annotated paragraph'		forNode: (PRAnnotatedParagraph withAll: #() annotation: 'todo')! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!testWriteBoldUsesBoldTemplate	self		assertTemplate: PRTemplatedWriter boldTemplateFileName		writesValue: 'boldTemplate'		forNode: (PRBoldFormat with: (PRText content: 'Bar'))! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!testWriteCodeBlockUsesCodeBlockTemplate	self		assertTemplate: PRTemplatedWriter codeBlockTemplateFileName		writesValue: 'codeBlockTemplate'		forNode: (PRCodeblock content: '^ self')! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!testWriteCommentedLineUsesCommentedLineTemplate	self		assertTemplate: PRTemplatedWriter commentedLineTemplateFileName		writesValue: 'commented line'		forNode: (PRCommentedLine content: 'some comment')! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!testWriteDataItemUsesDataItemTemplate	self		assertTemplate: PRTemplatedWriter dataItemTemplateFileName		writesValue: 'dataitem'		forNode: PRDataItem new! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!testWriteDefinitionListUsesDefinitionListTemplate	self		assertTemplate: PRTemplatedWriter definitionListTemplateFileName		writesValue: 'definitionList'		forNode: PRDefinitionList new! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!testWriteEmptyParagraphsUsesEmptyParagraphTemplate	self		assertTemplate: PRTemplatedWriter emptyParagraphTemplateFileName		writesValue: 'emptyParagraph'		forNode: PREmptyParagraph new! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!testWriteEnvironmentItselfUsesMainTemplate	self		assertTemplatePath: RelativePath * 'cards' / 'main.mustache'		writesValue: 'Template for cards itself'		forNode: ((PREnvironment named: 'cards')						add: (PRParagraph new							add: (PRText content: 'Foo');							yourself);			yourself)! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!testWriteEnvironmentUsesArguments	self		createTemplateFileAt: RelativePath * 'card' / 'main.mustache'		withContents: 'before {{{someArgument}}} after'.	self		assertWritingNode: ((PREnvironment named: 'card')			propertyAt: 'someArgument' put: 'test';			yourself)		writes: 'before test after'! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!testWriteExternalLinkUsesExternalLinkTemplate	self		assertTemplate: PRTemplatedWriter externalLinkTemplateFileName		writesValue: 'external link'		forNode: (PRExternalLink new reference: 'http://pharo.org')! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!testWriteFigureUsesFigureTemplate	self		assertTemplate: PRTemplatedWriter figureTemplateFileName		writesValue: 'figure'		forNode: (PRFigure reference: 'bla.png')! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!testWriteHeaderUsesHeaderTemplate	self		assertTemplate: PRTemplatedWriter headerTemplateFileName		writesValue: 'aHeader'		forNode: (PRHeader new			level: 2;			add: (PRText content: 'foo'))! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!testWriteHorizontalRuleUsesHorizontalRuleTemplate	self		assertTemplate: PRTemplatedWriter horizontalRuleTemplateFileName		writesValue: '-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-='		forNode: PRHorizontalRule new! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!testWriteInternalLinkUsesInternalLinkTemplate	self		assertTemplate: PRTemplatedWriter internalLinkTemplateFileName		writesValue: 'internal link'		forNode: (PRInternalLink new reference: 'bla.pillar')! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!testWriteItalicUsesItalicTemplate	self		assertTemplate: PRTemplatedWriter italicTemplateFileName		writesValue: 'italicTemplate'		forNode: (PRItalicFormat with: (PRText content: 'Bar'))! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!testWriteLineBreakUsesLineBreakTemplate	self		assertTemplate: PRTemplatedWriter lineBreakTemplateFileName		writesValue: 'line break'		forNode: PRLineBreak new! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!testWriteListItemUsesListItemTemplate	self		assertTemplate: PRTemplatedWriter listItemTemplateFileName		writesValue: 'list item'		forNode: PRListItem new! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!testWriteMailLinkUsesMailLinkTemplate	self		assertTemplate: PRTemplatedWriter mailLinkTemplateFileName		writesValue: 'a link'		forNode: (PRMailLink reference: 'foo@bar.com')! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!testWriteMonospaceUsesMonospaceTemplate	self		assertTemplate: PRTemplatedWriter monospaceTemplateFileName		writesValue: 'monospace'		forNode: (PRMonospaceFormat with: (PRText content: 'Bar'))! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!testWriteNestedEnvironmentItselfUsesMainTemplate	self		assertTemplatePath: RelativePath * 'cards' / 'card' / 'main.mustache'		writesValue: 'Template for the card itself'		forNode: ((PREnvironment named: 'cards')						add: ((PREnvironment named: 'card')									add: (PRParagraph new add: (PRText content: 'Foo');							yourself));					yourself)! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!testWriteNestedEnvironmentWithChilds	self		createTemplateFileAt: RelativePath * 'cards' / 'main.mustache'		withContents: '{{{contents}}}'.	self		createTemplateFileAt: RelativePath * 'cards' / 'card' / 'main.mustache'		withContents: '{{{contents}}}'.	self		assertTemplatePath: RelativePath * 'cards' / 'card' / 'paragraph.mustache'		writesValue: 'Paragraph definition in cards/card'		forNode: ((PREnvironment named: 'cards')						add: ((PREnvironment named: 'card')									add: (PRParagraph new add: (PRText content: 'Foo');							yourself));					yourself)! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!testWriteOrderedListUsesOrderedListTemplate	self		assertTemplate: PRTemplatedWriter orderedListTemplateFileName		writesValue: 'ordered list'		forNode: PROrderedList new! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!testWriteParagraphUsesParagraphTemplate	self		assertTemplate: PRTemplatedWriter paragraphTemplateFileName		writesValue: 'unorderedList'		forNode: PRParagraph new! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!testWritePreformattedUsesPreformattedTemplate	self		assertTemplate: PRTemplatedWriter preformattedTemplateFileName		writesValue: 'preformatted'		forNode: (PRPreformatted with: (PRText content: 'Bar'))! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!testWriteSectionUsesSectionTemplate	self		assertTemplate: PRTemplatedWriter sectionTemplateFileName		writesValue: 'section'		forNode: PRSection new! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!testWriteTextInsideEnvironmentLooksUpOutsideEnvironment	self		assertTemplate: 'paragraph.mustache'		writesValue: 'Paragraph outside card'		forNode: ((PREnvironment named: 'card')			add: (PRParagraph new				add: (PRText content: 'Foo');				yourself);			yourself)! !!PRTemplatedWriterTest methodsFor: 'tests-templatefiles'!testWriteTextInsideEnvironmentUsesTemplateInsideEnvironment	self		assertTemplatePath: (Path * 'card' / 'paragraph.mustache')		writesValue: 'Paragraph in card'		forNode: ((PREnvironment named: 'card')			add: (PRParagraph new				add: (PRText content: 'Foo');				yourself);			yourself)! !!PRTextWriterTest methodsFor: 'private'!actualClass	^ PRTextWriter! !!PRTextWriterTest methodsFor: 'requirements'!annotationBegin: annotationString	^''! !!PRTextWriterTest methodsFor: 'requirements'!boldFoo	^ 'foo'! !!PRTextWriterTest methodsFor: 'requirements'!dataItemWithBar	^ 'bar'! !!PRTextWriterTest methodsFor: 'requirements'!definitionListBegin	^ ''! !!PRTextWriterTest methodsFor: 'requirements'!emailToFoo	^ 'foo@bar.com'! !!PRTextWriterTest methodsFor: 'requirements'!figureAnchorForPierLogo	^ ''! !!PRTextWriterTest methodsFor: 'requirements'!figureBegin	^ ''! !!PRTextWriterTest methodsFor: 'requirements'!horizontalRule	^ ''! !!PRTextWriterTest methodsFor: 'requirements'!italicFoo	^ 'foo'! !!PRTextWriterTest methodsFor: 'requirements'!level1HeaderWithFoo	^ 'foo'! !!PRTextWriterTest methodsFor: 'requirements'!listItemWith1	^ '1'! !!PRTextWriterTest methodsFor: 'requirements'!monospaceFoo	^ 'foo'! !!PRTextWriterTest methodsFor: 'requirements'!orderedListBegin	^ ''! !!PRTextWriterTest methodsFor: 'requirements'!packageNamesUnderTest	^ #('Pillar-ExporterText')! !!PRTextWriterTest methodsFor: 'requirements'!paragraphFoo	^ 'foo'! !!PRTextWriterTest methodsFor: 'requirements'!preformattedFooBegin	^ 'foo'! !!PRTextWriterTest methodsFor: 'requirements'!preformattedTextFoo	^ 'foo'! !!PRTextWriterTest methodsFor: 'requirements'!rawText	^ 'nothing raw in plain text'! !!PRTextWriterTest methodsFor: 'requirements'!referenceToFigurePierLogo	^ ''! !!PRTextWriterTest methodsFor: 'requirement-InternalLinks'!resultWithRefWithAnchorWithSeparateOutputFiles	^ ''! !!PRTextWriterTest methodsFor: 'requirement-InternalLinks'!resultWithRefWithoutAnchorWithSeparateOutputFiles	^ ''! !!PRTextWriterTest methodsFor: 'requirement-InternalLinks'!resultWithoutAliasWithoutRefWithAnchorWithSeparateOutputFiles	^ ''! !!PRTextWriterTest methodsFor: 'requirement-InternalLinks'!resultWithoutRefWithAnchorWithSeparateOutputFiles	^ ''! !!PRTextWriterTest methodsFor: 'requirements'!scriptAnchorForMyScript	^ ''! !!PRTextWriterTest methodsFor: 'requirements'!scriptWithCaptionBegin	^ ''! !!PRTextWriterTest methodsFor: 'requirements'!scriptWithoutCaptionBegin	^ ''! !!PRTextWriterTest methodsFor: 'requirements'!strikethroughFoo	^ 'foo'! !!PRTextWriterTest methodsFor: 'requirements'!subscriptFoo	^ 'foo'! !!PRTextWriterTest methodsFor: 'requirements'!superscriptFoo	^ 'foo'! !!PRTextWriterTest methodsFor: 'tests'!supportSyntaxHighlighting	^ false! !!PRTextWriterTest methodsFor: 'requirements'!tableBegin	^ ''! !!PRTextWriterTest methodsFor: 'requirements'!tableCellWithFoo	^ 'foo'! !!PRTextWriterTest methodsFor: 'requirements'!tableCellWithHeadingFoo	^ 'foo'! !!PRTextWriterTest methodsFor: 'requirements'!tableRow	^ ''! !!PRTextWriterTest methodsFor: 'requirements'!termItemWithFoo	^ 'foo'! !!PRTextWriterTest methodsFor: 'tests'!testFigureLabelGenerateAnchor	"ignore as there is no anchor support in simple text"! !!PRTextWriterTest methodsFor: 'tests'!testFigureWithWidth	"ignore as there is no figure language support in simple text"! !!PRTextWriterTest methodsFor: 'tests'!testFiguresHaveACaption	"ignore as there is no caption support in simple text"! !!PRTextWriterTest methodsFor: 'tests'!testMailLink	"ignore as there is the email address is not written"! !!PRTextWriterTest methodsFor: 'tests'!testScriptLabelGenerateAnchor	"ignore as there is no anchor support in simple text"! !!PRTextWriterTest methodsFor: 'tests'!testScriptLanguage	"ignore as there is no script language support in simple text"! !!PRTextWriterTest methodsFor: 'tests'!testScriptWithFormattedCaption	"ignore as there is no caption support in simple text"! !!PRTextWriterTest methodsFor: 'tests'!testScriptsHaveACaption	"ignore as there is no caption support in simple text"! !!PRTextWriterTest methodsFor: 'requirements'!underlineFoo	^ 'foo'! !!PRTextWriterTest methodsFor: 'requirements'!unorderedListBegin	^ ''! !!PRTextWriterAnchorTest class methodsFor: 'testing'!isAbstract	^ false! !!PRTextWriterAnchorTest methodsFor: 'private'!actualClass	^ PRAnchor! !!PRTextWriterAnchorTest methodsFor: 'tests-parsing'!testBasic	| text tree |	text := ''.	tree := PRDocument new		add: (PRAnchor named: 'name');		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterAnchorTest methodsFor: 'tests-parsing'!testMultiple	| text tree nLine |	nLine := self lineEnding.	text := ''.	tree := PRDocument new		        add: (PRAnchor named: 'one');		        add: (PRAnchor named: 'two');		        add: PREmptyParagraph new;		        add: (PRAnchor named: 'tree');		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterAnchorTest methodsFor: 'tests-parsing'!testSpaces	| text tree |	text := ''.	tree := PRDocument new		add: (PRAnchor named: 'one two');		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterAnnotatedParagraphTest class methodsFor: 'testing'!isAbstract	^ false! !!PRTextWriterAnnotatedParagraphTest methodsFor: 'private'!actualClass	^ PRAnnotatedParagraph! !!PRTextWriterAnnotatedParagraphTest methodsFor: 'tests-parsing'!testParseBasic	| text tree |	text := 'bar zork'.	tree := PRDocument new		add: (PRAnnotatedParagraph new			annotation: 'foo';			add: (PRText content: 'bar zork');			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterAnnotatedParagraphTest methodsFor: 'tests-parsing'!testParseEmptyFollwedByPreformatted	| text tree nLine |	nLine := self lineEnding.	text := nLine , 'bar'.	tree := PRDocument new		        add: (PRAnnotatedParagraph new				         annotation: 'foo';				         yourself);		        add: (PRPreformatted new				         add: (PRText content: 'bar');				         yourself);		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterAnnotatedParagraphTest methodsFor: 'tests-parsing'!testParseOnlyAnnotation	| text tree |	text := ''.	tree := PRDocument new		add: (PRAnnotatedParagraph new			annotation: 'foo';			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterAnnotatedParagraphTest methodsFor: 'tests-parsing'!testParseOnlyNothing	| text tree |	text := ''.	tree := PRDocument new		add: (PRAnnotatedParagraph new			annotation: '';			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterAnnotatedParagraphTest methodsFor: 'tests-parsing'!testParseOnlyText	| text tree |	text := 'foo bar'.	tree := PRDocument new		add: (PRAnnotatedParagraph new			add: (PRText content: 'foo bar');			annotation: '';			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterDocumentGroupTest methodsFor: 'private'!actualClass	^ PRDocumentGroup! !!PRTextWriterDocumentTest class methodsFor: 'testing'!isAbstract	^ false! !!PRTextWriterDocumentTest methodsFor: 'private'!actualClass	^ PRDocument! !!PRTextWriterDocumentTest methodsFor: 'tests-parsing'!testParseEmpty	| text tree |	text := String new.	tree := PRDocument new.		self textWriterAssertTree: tree equalsText: text! !!PRTextWriterDocumentTest methodsFor: 'tests-parsing'!testParseMultipleProperties	| text tree|	text := String new.	tree := PRDocument new		propertyAt: 'title' put: 'The title';		propertyAt: 'authors' put: 'Someone else and me';		yourself.	self textWriterAssertTree: tree equalsText: text.! !!PRTextWriterDocumentTest methodsFor: 'tests-parsing'!testParseProperties	| text tree |	text := String new.	tree := PRDocument new		propertyAt: 'title' put: 'The title';		yourself.		self textWriterAssertTree: tree equalsText: text.	! !!PRTextWriterDocumentTest methodsFor: 'tests-parsing'!testParsePropertiesWithText	| text tree document |	text := 'foobar'.	tree := PRDocument new		propertyAt: 'title' put: 'The title';		add:				(PRParagraph new						add: (PRText content: 'foobar');						yourself);		yourself.		self textWriterAssertTree: tree equalsText: text.	! !!PRTextWriterFormatTest class methodsFor: 'building suites'!isAbstract	^ false! !!PRTextWriterFormatTest class methodsFor: 'building suites'!testParameters	^ (ParametrizedTestMatrix new			forSelector: #actualClass addOptions: PRFormat subclasses )! !!PRTextWriterFormatTest methodsFor: 'private'!actualClass	^ actualClass! !!PRTextWriterFormatTest methodsFor: 'private'!actualClass: aClass	actualClass := aClass! !!PRTextWriterFormatTest methodsFor: 'accessing'!otherClass	^ otherClass ifNil: [ otherClass := PRFormat allSubclasses detect: [ :each | self actualClass ~= each ] ]! !!PRTextWriterFormatTest methodsFor: 'running'!setUp	super setUp.	markup := PRPillarGrammar markups at: self actualClass! !!PRTextWriterFormatTest methodsFor: 'tests-parsing'!testParseBasic	| text tree |	text := '123'.	tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: '1');				add: (self actualClass with: (PRText content: '2'));				add: (PRText content: '3');				yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterFormatTest methodsFor: 'tests-parsing'!testParseEnd	| text tree |	text := '12'.	tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: '1');				add: (self actualClass with: (PRText content: '2'));				yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterFormatTest methodsFor: 'tests-parsing'!testParseEscaped	| text tree |	text := ' ' , markup , markup.	tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: ' ' , markup , markup);				yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterFormatTest methodsFor: 'tests-parsing'!testParseIncomplete	| text tree |	text := '1' , markup , '2'.	tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: '1' , markup , '2');				yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterFormatTest methodsFor: 'tests-parsing'!testParseMany	| text tree |	text := '12345'.	tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: '1');				add: (self actualClass with: (PRText content: '2'));				add: (PRText content: '3');				add: (self actualClass with: (PRText content: '4'));				add: (PRText content: '5');				yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterFormatTest methodsFor: 'tests-parsing'!testParseNested	| text tree |	text := '12345'.	tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: '1');				add:					(self actualClass new						add: (PRText content: '2');						add:							(self otherClass new								add: (PRText content: '3');								yourself);						add: (PRText content: '4');						yourself);				add: (PRText content: '5');				yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterFormatTest methodsFor: 'tests-parsing'!testParseNestedTight	| text tree |	text := ' '.	tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: ' ');				add: (self actualClass new add: self otherClass new yourself);				yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterFormatTest methodsFor: 'tests-parsing'!testParseWithNewLine	| text tree |	text := '12' , self lineEnding , '34'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: '1');				         add:					         (self actualClass with:							          (PRText content: '2' , self lineEnding , '3'));				         add: (PRText content: '4');				         yourself);		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterFormatTest methodsFor: 'tests-parsing'!testParseWithSpace	| text tree |	text := '12 34'.	tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: '1');				add: (self actualClass with: (PRText content: '2 3'));				add: (PRText content: '4');				yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterListTest methodsFor: 'private'!actualClass	^ PRList! !!PRTextWriterListTest methodsFor: 'private'!listItemClass	^ PRListItem! !!PRTextWriterListTest methodsFor: 'private'!listItemWithText: aString	^ self listItemClass new		add: (PRText content: aString);		yourself! !!PRTextWriterListTest methodsFor: 'tests-parsing'!testParseEmpty	| text tree |	text := self textString: 1 level: 1.	tree := PRDocument new		add: (self actualClass new			add: self listItemClass new;			yourself);		yourself.			self textWriterAssertTree: tree equalsText: text! !!PRTextWriterListTest methodsFor: 'tests-parsing'!testParseFlat	| text tree nLine |	nLine := self lineEnding.	text := (self textString: 1 level: 1) , '1st' , nLine	        , (self textString: 2 level: 1) , '2nd' , nLine	        , (self textString: 3 level: 1) , '3rd'.	tree := PRDocument new		        add: (self actualClass new				         add: (self listItemWithText: '1st');				         add: (self listItemWithText: '2nd');				         add: (self listItemWithText: '3rd');				         yourself);		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterListTest methodsFor: 'tests-parsing'!testParseMultiple	| text tree nLine |	nLine := self lineEnding.	text := (self textString: 1 level: 1) , '1st' , nLine	        , (self textString: 2 level: 1) , '2nd' , nLine , nLine	        , (self textString: 1 level: 1) , '3rd'.	tree := PRDocument new		        add: (self actualClass new				         add: (self listItemWithText: '1st');				         add: (self listItemWithText: '2nd');				         yourself);		        add: PREmptyParagraph new;		        add: (self actualClass new				         add: (self listItemWithText: '3rd');				         yourself);		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterListTest methodsFor: 'private'!textString: anObject level: anInteger	^ (2 to: anInteger) inject: '' into: [ :result :each | result , '	' ]! !!PRTextWriterListTest methodsFor: 'private'!wikiString	self subclassResponsibility! !!PRTextWriterOrderedListTest class methodsFor: 'testing'!isAbstract	^ false! !!PRTextWriterOrderedListTest methodsFor: 'private'!actualClass	^ PROrderedList! !!PRTextWriterOrderedListTest methodsFor: 'tests-parsing'!testParseNested	| text tree nLine |	nLine := self lineEnding.	text := (self textString: 1 level: 1) , '1' , nLine	        , (self textString: 1 level: 2) , '1.1' , nLine	        , (self textString: 2 level: 2) , '1.2'.	tree := PRDocument new		        add: (self actualClass new				         add: (PRListItem new						          add: (PRText content: '1');						          add: (self actualClass new								           add: (self listItemWithText: '1.1');								           add: (self listItemWithText: '1.2');								           yourself);						          yourself);				         yourself);		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterOrderedListTest methodsFor: 'private'!textString: anObject level: anInteger 	^ (super textString: anObject level: anInteger) , anObject asString , '. '! !!PRTextWriterUnorderedListTest class methodsFor: 'testing'!isAbstract	^ false! !!PRTextWriterUnorderedListTest methodsFor: 'private'!actualClass	^ PRUnorderedList! !!PRTextWriterUnorderedListTest methodsFor: 'tests-parsing'!testParseMixed	| tree text nLine |	nLine := self lineEnding.	text := '1. 1' , nLine , '	1. 2' , nLine , '		1. 3' , nLine , '	* 4'	        , nLine , '	* 5' , nLine , '	1. 6' , nLine , '2. 7'.	tree := PRDocument new		        add: (PROrderedList new				         add: (PRListItem new						          add: (PRText content: '1');						          add: (PROrderedList new								           add: (PRListItem new										            add: (PRText content: '2');										            add: (PROrderedList new												             add: (self listItemWithText: '3');												             yourself);										            yourself);								           yourself);						          add: (PRUnorderedList new								           add: (self listItemWithText: '4');								           add: (self listItemWithText: '5');								           yourself);						          add: (PROrderedList new								           add: (self listItemWithText: '6');								           yourself);						          yourself);				         add: (self listItemWithText: '7');				         yourself);		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterUnorderedListTest methodsFor: 'tests-parsing'!testParseNested	| text tree nLine |	nLine := self lineEnding.	text := (self textString: 1 level: 1) , '1' , nLine	        , (self textString: 1 level: 2) , '1.1' , nLine	        , (self textString: 1 level: 3) , '1.1.1'.	tree := PRDocument new		        add: (self actualClass new				         add: (PRListItem new						          add: (PRText content: '1');						          add: (self actualClass new								           add: (PRListItem new										            add: (PRText content: '1.1');										            add: (self actualClass new												             add: (self listItemWithText: '1.1.1');												             yourself);										            yourself);								           yourself);						          yourself);				         yourself);		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterUnorderedListTest methodsFor: 'private'!textString: anObject level: anInteger	^ (super textString: anObject level: anInteger) , '* '! !!PRTextWriterEmptyParagraphTest methodsFor: 'private'!actualClass	^ PREmptyParagraph! !!PRTextWriterEmptyParagraphTest methodsFor: 'tests'!testParseEmptyParagraphAtBeginning	| text tree content |	content := 'Lorem ipsum dolor sit amet.'.	text := self lineEnding , content.	tree := PRDocument new		        add: PREmptyParagraph new;		        add: (PRParagraph new				         add: (PRText content: content);				         yourself);		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterEmptyParagraphTest methodsFor: 'tests'!testParseEmptyParagraphInTheMiddle	| text tree content nLine |	nLine := self lineEnding.	content := 'Lorem ipsum dolor sit amet.'.	text := content , nLine , nLine , content.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: content);				         yourself);		        add: PREmptyParagraph new;		        add: (PRParagraph new				         add: (PRText content: content);				         yourself);		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterParagraphTest class methodsFor: 'testing'!isAbstract	^ false! !!PRTextWriterParagraphTest methodsFor: 'private'!actualClass	^ PRParagraph! !!PRTextWriterParagraphTest methodsFor: 'tests-parsing'!testParseEmptyLineAtBeginning	| text tree |	text := '' , self lineEnding , 'Lorem ipsum dolor sit amet.'.	tree := PRDocument new		        add: PREmptyParagraph new;		        add: (PRParagraph new				         add: (PRText content: 'Lorem ipsum dolor sit amet.');				         yourself);		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterParagraphTest methodsFor: 'tests-parsing'!testParseOneLine	| text tree |	text := 'Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Nulla quis urna.'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText content: text);			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterParagraphTest methodsFor: 'tests-parsing'!testParseThreeEmptyLines	| text tree nLine |	nLine := self lineEnding.	text := 'Lorem ipsum dolor sit amet.' , nLine , nLine , nLine	        , 'Nulla mattis elementum nulla.'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: 'Lorem ipsum dolor sit amet.');				         yourself);		        add: PREmptyParagraph new;		        add: PREmptyParagraph new;		        add: (PRParagraph new				         add: (PRText content: 'Nulla mattis elementum nulla.');				         yourself);		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterParagraphTest methodsFor: 'tests-parsing'!testParseTwoConsecutiveNonTextLines	| text tree sentence title nLine |	nLine := self lineEnding.	sentence := 'sentence'.	title := 'title'.	text := sentence , nLine , title.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: sentence);				         yourself);		        add: (PRHeader new				         level: 1;				         add: (PRText content: title);				         yourself);		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterParagraphTest methodsFor: 'tests-parsing'!testParseTwoEmptyLines	| text tree nLine |	nLine := self lineEnding.	text := 'Lorem ipsum dolor sit amet.' , nLine , nLine	        , 'Nulla mattis elementum nulla.'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: 'Lorem ipsum dolor sit amet.');				         yourself);		        add: PREmptyParagraph new;		        add: (PRParagraph new				         add: (PRText content: 'Nulla mattis elementum nulla.');				         yourself);		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterDocumentItemTest methodsFor: 'private'!actualClass	^ PRDocumentItem! !!PRTextWriterDocumentItemTest methodsFor: 'utilities'!addText: aString to: aDocumentItem	^ aDocumentItem		add: (PRText content: aString);		yourself! !!PRTextWriterDocumentItemTest methodsFor: 'private'!barInstance	^ PRText content: 'bar'! !!PRTextWriterDocumentItemTest methodsFor: 'private'!fooInstance	^ PRText content: 'foo'! !!PRTextWriterDocumentItemTest methodsFor: 'private'!foobarInstances	^ Array with: self fooInstance with: self barInstance! !!PRTextWriterDocumentItemTest methodsFor: 'helper'!parser	^ PRDocument parser! !!PRTextWriterDocumentItemTest methodsFor: 'utilities'!textWriterAssertTree: aDocument equalsText: aString	self assert: (PRTextWriter write: aDocument) = aString description: aString resumable: true! !"Pillar-Tests-ExporterText"!!PRTextWriterHeaderTest class methodsFor: 'testing'!isAbstract	^ false! !!PRTextWriterHeaderTest methodsFor: 'private'!actualClass	^ PRHeader! !!PRTextWriterHeaderTest methodsFor: 'tests-parsing'!testParseEmpty	| text tree |	text := ''.	tree := PRDocument new		add: (PRHeader new			level: 1;			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterHeaderTest methodsFor: 'tests-parsing'!testParseLevel1	| text tree |	text := 'foo'.	tree := PRDocument new		add: ((PRHeader new)			level: 1;			add: (PRText content: 'foo');			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterHeaderTest methodsFor: 'tests-parsing'!testParseLevel2	| text tree |	text := 'foo'.	tree := PRDocument new		add: ((PRHeader new)			level: 2;			add: (PRText content: 'foo');			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterHeaderTest methodsFor: 'tests-parsing'!testParseLevel3	| text tree |	text := 'foo'.	tree := PRDocument new		add: ((PRHeader new)			level: 3;			add: (PRText content: 'foo');			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterHeaderTest methodsFor: 'tests-parsing'!testParseLevel4	| text tree |	text := 'foo'.	tree := PRDocument new		add: ((PRHeader new)			level: 4;			add: (PRText content: 'foo');			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterHeaderTest methodsFor: 'tests-parsing'!testParseLevel5	| text tree |	text := 'foo'.	tree := PRDocument new		add: ((PRHeader new)			level: 5;			add: (PRText content: 'foo');			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterHeaderTest methodsFor: 'tests-parsing'!testParseLevel6	| text tree |	text := 'foo'.	tree := PRDocument new		add: ((PRHeader new)			level: 6;			add: (PRText content: 'foo');			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterHeaderTest methodsFor: 'tests-parsing'!testParseMultiline	| text tree nLine |	nLine := self lineEnding.	text := 'Hello This is' , nLine , 'bold end' , nLine , 'new'.	tree := PRDocument new		        add: (PRHeader new				         level: 2;				         add: (PRText content: 'Hello ');				         add:					         (self						          addText: 'This is' , nLine , 'bold'						          to: PRBoldFormat new);				         add: (PRText content: ' end');				         yourself);		        add: (self addText: 'new' to: PRParagraph new);		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterHeaderTest methodsFor: 'tests-parsing'!testParseNested	| text tree |	text := 'Hello Link'.	tree := PRDocument new		add: (PRHeader new			level: 2;			add: (PRText content: 'Hello ');			add: (PRInternalLink new				reference: 'Link';				yourself);			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterHeaderTest methodsFor: 'tests-parsing'!testParseWithTrailingSpaces	| text tree |	text := 'foo'.	tree := PRDocument new		add: ((PRHeader new)			level: 1;			add: (PRText content: 'foo');			yourself);		yourself.		self textWriterAssertTree: tree equalsText: text! !!PRTextWriterPreformattedTest class methodsFor: 'testing'!isAbstract	^ false! !!PRTextWriterPreformattedTest methodsFor: 'private'!actualClass	^ PRPreformatted! !!PRTextWriterPreformattedTest methodsFor: 'tests-parsing'!testParseBasic	| text tree |	text := 'Line'.	tree := PRDocument new		add: (PRPreformatted new			add: (PRText content: 'Line');			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterPreformattedTest methodsFor: 'tests-parsing'!testParseEmpty	| text tree |	text := ''.	tree := PRDocument new		add: (PRPreformatted new			add: (PRText content: '');			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterPreformattedTest methodsFor: 'tests-parsing'!testParseMultiple	| text tree nLine |	nLine := self lineEnding.	text := 'line 1.1' , nLine , 'line 1.2' , nLine , nLine , 'line 2.1'.	tree := PRDocument new		        add: (PRPreformatted new				         add: (PRText content: 'line 1.1');				         add: (PRText content: 'line 1.2');				         yourself);		        add: PREmptyParagraph new;		        add: (PRPreformatted new				         add: (PRText content: 'line 2.1');				         yourself);		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterPreformattedTest methodsFor: 'tests-parsing'!testParseSpaces	| text tree nLine |	nLine := self lineEnding.	text := '   A line with 3 spaces' , nLine , '	A line with a tab'.	tree := PRDocument new		        add: (PRPreformatted new				         add: (PRText content: '   A line with 3 spaces');				         add: (PRText content: '	A line with a tab');				         yourself);		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterPreformattedTest methodsFor: 'tests-parsing'!testParseSpecials	| text tree |	text := '|, {, }, *, *, [, ||, |{, |}, +, +'.	tree := PRDocument new		add: (PRPreformatted new			add: (PRText content: '|, {, }, *, *, [, ||, |{, |}, +, +');			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterExternalLinkTest class methodsFor: 'testing'!isAbstract	^ false! !!PRTextWriterExternalLinkTest methodsFor: 'private'!actualClass	^ PRExternalLink! !!PRTextWriterExternalLinkTest methodsFor: 'private'!referenceString	^ 'http://www.lukas-renggli.ch'! !!PRTextWriterExternalLinkTest methodsFor: 'tests'!testLinkToAFigureIsExternalLink	| text tree |	text := self actualClass new		reference: 'file://foo.png';		title.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				reference: 'file://foo.png';				yourself);			yourself);		yourself.		self textWriterAssertTree: tree equalsText: text! !!PRTextWriterMailLinkTest methodsFor: 'private'!actualClass	^ PRMailLink! !!PRTextWriterMailLinkTest methodsFor: 'private'!referenceString	^ 'renggli@gmail.com'! !!PRTextWriterMailLinkTest methodsFor: 'as yet unclassified'!testLinkToAFigureIsExternalLink	"This test has no meaning in PRMailLinkTest."! !!PRTextWriterMailLinkTest methodsFor: 'tests-parsing'!testParseBogus	| text tree |	text := 'ab12@x.com'.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				reference: 'ab12@x.com';				yourself);			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterInternalLinkTest class methodsFor: 'testing'!isAbstract	^ false! !!PRTextWriterInternalLinkTest methodsFor: 'private'!actualClass	^ PRInternalLink! !!PRTextWriterInternalLinkTest methodsFor: 'private'!referenceString	^ 'Page'! !!PRTextWriterInternalLinkTest methodsFor: 'tests-parsing'!testParseAnchored	| text tree |	text := self actualClass new		reference: self referenceString;		anchor: 'Anchor';		title.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				reference: self referenceString;				anchor: 'Anchor';				yourself);			yourself);		yourself.		self textWriterAssertTree: tree equalsText: text! !!PRTextWriterInternalLinkTest methodsFor: 'tests-parsing'!testParseEverything	| text tree |		text := 'Alias'.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				add: (PRText content: 'Alias');				reference: self referenceString;				anchor: 'Anchor';				yourself);			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterLinkTest methodsFor: 'private'!actualClass	^ PRLink! !!PRTextWriterLinkTest methodsFor: 'private'!markup	^ PRPillarParser markups at: PRLink! !!PRTextWriterLinkTest methodsFor: 'tests-parsing'!testParseAliased	| text tree |	text := 'Alias'.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				add: (PRText content: 'Alias');				reference: self referenceString;				yourself);			yourself);		yourself.		self textWriterAssertTree: tree equalsText: text! !!PRTextWriterLinkTest methodsFor: 'tests-parsing'!testParseAliasedEmpty	| text tree |	text := ''.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				add: (PRText content: '');				reference: self referenceString;				yourself);			yourself);		yourself.		self textWriterAssertTree: tree equalsText: text! !!PRTextWriterLinkTest methodsFor: 'tests-parsing'!testParseBasic	| text tree |	text := self actualClass new		reference: self referenceString;		title.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				reference: self referenceString;				yourself);			yourself);		yourself.		self textWriterAssertTree: tree equalsText: text! !!PRTextWriterLinkTest methodsFor: 'tests-parsing'!testParseParameters	| text tree |		text := 'Alias'.	tree := PRDocument new		add:				(PRParagraph new						add:								(self actualClass new										add: (PRText content: 'Alias');										reference: self referenceString;										parameters:												(OrderedDictionary new														add: 'a' -> 1;														add: 'b' -> 2;														add: 'c' -> true;														yourself);										yourself);						yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterLinkTest methodsFor: 'tests-parsing'!testParseParametersEmpty	| text tree |		text := 'Alias'.	tree := PRDocument new		add:				(PRParagraph new						add:								(self actualClass new										add: (PRText content: 'Alias');										reference: self referenceString;										parameters:												(OrderedDictionary new														add: 'a' -> true;														add: 'b' -> true;														yourself);										yourself);						yourself);		yourself.		self textWriterAssertTree: tree equalsText: text! !!PRTextWriterLinkTest methodsFor: 'tests-parsing'!testParseParametersEscaped	|  text tree |		text := 'Alias'.	tree := PRDocument new		add:				(PRParagraph new						add:								(self actualClass new										add: (PRText content: 'Alias');										reference: self referenceString;										parameters:												(OrderedDictionary new														add: '2' -> '|=';														add: '|=' -> 1;														yourself);										yourself);						yourself);		yourself.		self textWriterAssertTree: tree equalsText: text! !!PRTextWriterReferenceTest methodsFor: 'private'!actualClass	^ PRReference! !!PRTextWriterReferenceTest methodsFor: 'private'!markup	^ self subclassResponsibility! !!PRTextWriterReferenceTest methodsFor: 'private'!referenceString	self subclassResponsibility! !!PRTextWriterReferenceTest methodsFor: 'tests'!testNonTextAlias	| text tree |	text := 'foo Alias'.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				add: (PRText content: 'foo ');				add: (self addText: 'Alias' to: PRBoldFormat new);				reference: self referenceString;				yourself);			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterReferenceTest methodsFor: 'tests-parsing'!testParseAliased	| text tree |	text := 'Alias'.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				add: (PRText content: 'Alias');				reference: self referenceString;				yourself);			yourself);		yourself.		self textWriterAssertTree: tree equalsText: text! !!PRTextWriterReferenceTest methodsFor: 'tests-parsing'!testParseAliasedEmpty	| text tree |		text := ''.	tree := PRDocument new		add:			(PRParagraph new				add:					(self actualClass new						add: (PRText content: '');						reference: self referenceString;						yourself);				yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterReferenceTest methodsFor: 'tests-parsing'!testParseBasic	| text tree |		text := self actualClass new		reference: self referenceString;		title.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				reference: self referenceString;				yourself);			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterReferenceTest methodsFor: 'tests-parsing'!testParseEasyness	| text tree |	text := self markup , self lineEnding , self markup	        , self referenceString.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: self markup);				         add: PRLineBreak new;				         add: (PRText content: self markup , self referenceString);				         yourself);		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterReferenceTest methodsFor: 'tests-parsing'!testParseEmpty	| text tree |		text := self markup , self markup.	tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: self markup , self markup);				yourself);		yourself.		self textWriterAssertTree: tree equalsText: text! !!PRTextWriterReferenceTest methodsFor: 'tests-parsing'!testParseEscaped	| text tree |	text := 'Star *' , self referenceString , '*' , self lineEnding	        , 'Cross +' , self referenceString , '+'.	tree := PRDocument new		        add: (PRParagraph new				         add:					         (PRText content: 'Star *' , self referenceString , '*');				         add: PRLineBreak new;				         add:					         (PRText content: 'Cross +' , self referenceString , '+');				         yourself);		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterReferenceTest methodsFor: 'tests-parsing'!testParseParameters	| text tree |	text := 'Alias'.	tree := PRDocument new		add:				(PRParagraph new						add:								(self actualClass new										add: (PRText content: 'Alias');										reference: self referenceString;										parameters:												(OrderedDictionary new														add: 'a' -> 1;														add: 'b' -> 2;														add: 'c' -> true;														yourself);										yourself);						yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterReferenceTest methodsFor: 'tests-parsing'!testParseParametersEmpty	| text tree |	text := 'Alias'.	tree := PRDocument new		add:				(PRParagraph new						add:								(self actualClass new										add: (PRText content: 'Alias');										reference: self referenceString;										parameters:												(OrderedDictionary new														add: 'a' -> true;														add: 'b' -> true;														yourself);										yourself);						yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterReferenceTest methodsFor: 'tests-parsing'!testParseParametersEscaped	| text tree |	text := 'Alias'.	tree := PRDocument new		add:				(PRParagraph new						add:								(self actualClass new										add: (PRText content: 'Alias');										reference: self referenceString;										parameters:												(OrderedDictionary new														add: '2' -> '|=';														add: '|=' -> 1;														yourself);										yourself);						yourself);		yourself.		self textWriterAssertTree: tree equalsText: text! !!PRTextWriterTableCellTest class methodsFor: 'testing'!isAbstract	^ false! !!PRTextWriterTableCellTest methodsFor: 'private'!actualClass	^ PRTableCell! !!PRTextWriterTableCellTest methodsFor: 'tests-parsing'!testParseAlign1	| text tree |		text := 'left	center	right'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					beAlignedLeft;					add: (PRText content: 'left');					yourself);				add: (PRTableCell new					beAlignedCenter;					add: (PRText content: 'center');					yourself);				add: (PRTableCell new					beAlignedRight;					add: (PRText content: 'right');					yourself);				yourself);			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterTableCellTest methodsFor: 'tests-parsing'!testParseAlign2	|  text tree |	text := 'right	none	left	none'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					beAlignedRight;					add: (PRText content: 'right');					yourself);				add: (PRTableCell new					add: (PRText content: 'none');					yourself);				add: (PRTableCell new					beAlignedLeft;					add: (PRText content: 'left');					yourself);				add: (PRTableCell new					add: (PRText content: 'none');					yourself);				yourself);			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterTableCellTest methodsFor: 'tests-parsing'!testParseEncoding	| text tree |	text := 'link	file://embedded.png	foo{}'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					add: (PRInternalLink new						reference: 'link';						yourself);					yourself);				add: (PRTableCell new					add: (PRFigure new						reference: 'file://embedded.png';						yourself);					yourself);				add: (PRTableCell new					add: (PRText content: 'foo{}');					yourself);				yourself);			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterTableCellTest methodsFor: 'tests-parsing'!testParseHeading1	| text tree |		text := 'head	left	center	right'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					beHeading;					add: (PRText content: 'head');					yourself);				add: (PRTableCell new					beHeading;					beAlignedLeft;					add: (PRText content: 'left');					yourself);				add: (PRTableCell new					beHeading;					beAlignedCenter;					add: (PRText content: 'center');					yourself);				add: (PRTableCell new					beHeading;					beAlignedRight;					add: (PRText content: 'right');					yourself);				yourself);			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterTableCellTest methodsFor: 'tests-parsing'!testParseHeading2	| text tree |	text := 'head	left	center	right'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					beHeading;					add: (PRText content: 'head');					yourself);				add: (PRTableCell new					beHeading;					beAlignedLeft;					add: (PRText content: 'left');					yourself);				add: (PRTableCell new					beHeading;					beAlignedCenter;					add: (PRText content: 'center');					yourself);				add: (PRTableCell new					beHeading;					beAlignedRight;					add: (PRText content: 'right');					yourself);				yourself);			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterTableTest class methodsFor: 'testing'!isAbstract	^ false! !!PRTextWriterTableTest methodsFor: 'private'!actualClass	^ PRTable! !!PRTextWriterTableTest methodsFor: 'tests-parsing'!testParseBasic	| text tree |	text := 'cell'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					add: (PRText content: 'cell');					yourself);				yourself);			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterTableTest methodsFor: 'tests-parsing'!testParseSquare	| text tree nLine |	nLine := self lineEnding.	text := 'a11	a12' , nLine , 'a21	a22'.	tree := PRDocument new		        add: (PRTable new				         add: (PRTableRow new						          add: (PRTableCell new								           add: (PRText content: 'a11');								           yourself);						          add: (PRTableCell new								           add: (PRText content: 'a12');								           yourself);						          yourself);				         add: (PRTableRow new						          add: (PRTableCell new								           add: (PRText content: 'a21');								           yourself);						          add: (PRTableCell new								           add: (PRText content: 'a22');								           yourself);						          yourself);				         yourself);		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterTableTest methodsFor: 'tests-parsing'!testParseTriangle	| text tree nLine |	nLine := self lineEnding.	text := 'a11' , nLine , 'a21	a22' , nLine , 'a31	a32	a33'.	tree := PRDocument new		        add: (PRTable new				         add: (PRTableRow new						          add: (PRTableCell new								           add: (PRText content: 'a11');								           yourself);						          yourself);				         add: (PRTableRow new						          add: (PRTableCell new								           add: (PRText content: 'a21');								           yourself);						          add: (PRTableCell new								           add: (PRText content: 'a22');								           yourself);						          yourself);				         add: (PRTableRow new						          add: (PRTableCell new								           add: (PRText content: 'a31');								           yourself);						          add: (PRTableCell new								           add: (PRText content: 'a32');								           yourself);						          add: (PRTableCell new								           add: (PRText content: 'a33');								           yourself);						          yourself);				         yourself);		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterHorizontalRuleTest class methodsFor: 'testing'!isAbstract	^ false! !!PRTextWriterHorizontalRuleTest methodsFor: 'private'!actualClass	^ PRHorizontalRule! !!PRTextWriterHorizontalRuleTest methodsFor: 'tests-parsing'!testParseBasic	| text tree |	text := self textString.	tree := PRDocument new		add: PRHorizontalRule new;		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterHorizontalRuleTest methodsFor: 'tests-parsing'!testParseMultiple	| text tree nLine |	nLine := self lineEnding.	text := self textString , nLine , self textString , nLine , nLine	        , self textString.	tree := PRDocument new		        add: PRHorizontalRule new;		        add: PRHorizontalRule new;		        add: PREmptyParagraph new;		        add: PRHorizontalRule new;		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterHorizontalRuleTest methodsFor: 'tests-parsing'!testParseParagraph	| text tree |	text := '_ is parsed as paragraph'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText content: '_ is parsed as paragraph');			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterHorizontalRuleTest methodsFor: 'tests-parsing'!testParseSpaces	| text tree |	text := self textString.	tree := PRDocument new		add: PRHorizontalRule new;		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterHorizontalRuleTest methodsFor: 'private'!textString	^ String new: 40 withAll: $-! !!PRTextWriterLineBreakTest class methodsFor: 'testing'!isAbstract	^ false! !!PRTextWriterLineBreakTest methodsFor: 'private'!actualClass	^ PRLineBreak! !!PRTextWriterLineBreakTest methodsFor: 'tests-parsing'!testParseOneEmptyLine	| text tree nLine |	nLine := self lineEnding.	text := 'Lorem ipsum dolor sit amet.' , nLine , nLine	        , 'Nulla quis urna.'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: 'Lorem ipsum dolor sit amet.');				         yourself);		        add: PREmptyParagraph new;		        add:		        (PRParagraph new add:			         (PRText content: 'Nulla quis urna.') yourself);		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterLineBreakTest methodsFor: 'tests-parsing'!testParseTreeLines	| text tree nLine |	nLine := self lineEnding.	text := 'Lorem ipsum dolor sit amet.' , nLine , 'Nulla quis urna.'	        , nLine , 'Vestibulum turpis.'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: 'Lorem ipsum dolor sit amet.');				         add: PRLineBreak new;				         add: (PRText content: 'Nulla quis urna.');				         add: PRLineBreak new;				         add: (PRText content: 'Vestibulum turpis.');				         yourself);		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterLineBreakTest methodsFor: 'tests-parsing'!testParseTwoEmptyLines	| text tree nLine |	nLine := self lineEnding.	text := 'Lorem ipsum dolor sit amet.' , nLine , nLine , nLine	        , 'Nulla quis urna.'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: 'Lorem ipsum dolor sit amet.');				         yourself);		        add: PREmptyParagraph new;		        add: PREmptyParagraph new;		        add:		        (PRParagraph new add:			         (PRText content: 'Nulla quis urna.') yourself);		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterLineBreakTest methodsFor: 'tests-parsing'!testParseTwoLines	| text tree |	text := 'Lorem ipsum dolor sit amet.' , self lineEnding	        , 'Nulla quis urna.'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRText content: 'Lorem ipsum dolor sit amet.');				         add: PRLineBreak new;				         add: (PRText content: 'Nulla quis urna.') yourself);		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterCommentedLineTest methodsFor: 'private'!actualClass	^ PRCommentedLine! !!PRTextWriterCommentedLineTest methodsFor: 'tests-parsing'!testParseBasic	| text tree |	text := ''.	tree := PRDocument new		add: (PRCommentedLine content: 'some comment');		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterCommentedLineTest methodsFor: 'tests-parsing'!testParseDontInterruptLists	| text tree nLine |	nLine := self lineEnding.	text := '1. item one' , nLine , '	1. item one-point-one' , nLine	        , '	2. item one-point-two'.	tree := PRDocument new		        add: (PROrderedList new				         add: (PRListItem new						          add: (PRText content: 'item one');						          add: (PROrderedList new								           add: (PRListItem new										            add: (PRText content: 'item one-point-one');										            add: (PRCommentedLine content: 'comment');										            yourself);								           add: (PRListItem new										            add: (PRText content: 'item one-point-two');										            yourself);								           yourself);						          yourself);				         yourself);		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterCommentedLineTest methodsFor: 'tests-parsing'!testParseDontParseContent	| text tree |	text := ''.	tree := PRDocument new		add: (PRCommentedLine content: 'some *comment*');		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterRawTest methodsFor: 'private'!actualClass	^ PRRaw! !!PRTextWriterRawTest methodsFor: 'tests-parsing'!testParseBasic	| text tree |	text := 'abc'.	tree := PRDocument new		add: (PRParagraph new			add: (PRRaw content: 'abc');			yourself);		yourself.		self textWriterAssertTree: tree equalsText: text! !!PRTextWriterRawTest methodsFor: 'tests-parsing'!testParseEmpty	| text tree |	text := ''.	tree := PRDocument new		add: (PRParagraph new			add: (PRRaw content: '');			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterRawTest methodsFor: 'tests-parsing'!testParseMultiline	| text tree nLine |	nLine := self lineEnding.	text := 'a' , nLine , 'b'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRRaw content: 'a' , nLine , 'b');				         yourself);		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterRawTest methodsFor: 'tests-parsing'!testParseMultiple	| text tree |	text := 'abc'.	tree := PRDocument new		add: (PRParagraph new			add: (PRRaw content: 'a');			add: (PRText content: 'b');			add: (PRRaw content: 'c');			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterRawTest methodsFor: 'tests-parsing'!testParseMultipleMultiline	| text tree nLine |	nLine := self lineEnding.	text := 'a' , nLine , 'bcd' , nLine , 'e'.	tree := PRDocument new		        add: (PRParagraph new				         add: (PRRaw content: 'a' , nLine , 'b');				         add: (PRText content: 'c');				         add: (PRRaw content: 'd' , nLine , 'e');				         yourself);		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterRawTest methodsFor: 'tests-parsing'!testParseStrange	|  text tree |	text := 'a{{||}}b'.	tree := PRDocument new		add: (PRParagraph new			add: (PRRaw content: 'a{{||}}b');			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterRawTest methodsFor: 'tests-parsing'!testParseTypeHtml	| text tree |	text := ''.	tree := PRDocument new		add: (PRParagraph new			add: (PRRaw content: 'abc' type: 'html');			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterRawTest methodsFor: 'tests-parsing'!testParseTypeLatex	| text tree |	text := ''.	tree := PRDocument new		add: (PRParagraph new			add: (PRRaw content: 'abc' type: 'latex');			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterRawTest methodsFor: 'tests-parsing'!testParseTypeText	| text tree |	text := 'abc'.	tree := PRDocument new		add: (PRParagraph new			add: (PRRaw content: 'abc' type: 'text');			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterRawTest methodsFor: 'tests-accessing'!testType	self instance type: 'html'.	self assert: self instance type equals: 'html'! !!PRTextWriterScriptTest methodsFor: 'private'!actualClass	^ PRCodeblock! !!PRTextWriterScriptTest methodsFor: 'tests-parsing'!testParseEscape	| text tree nLine |	nLine := self lineEnding.	text := 'foo'.	tree := PRDocument new		        add: ((PRCodeblock content: 'foo')				         language: 'foo|';				         yourself);		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterScriptTest methodsFor: 'tests-parsing'!testParseRealLanguage	| text tree nLine |	nLine := self lineEnding.	text := 'foo'.	tree := PRDocument new		        add: ((PRCodeblock content: 'foo')				         language: PRSmalltalkScriptLanguage default;				         yourself);		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterScriptTest methodsFor: 'tests-parsing'!testParseSimple	| text tree nLine |	nLine := self lineEnding.	text := 'foo'.	tree := PRDocument new		        add: (PRCodeblock content: 'foo');		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterScriptTest methodsFor: 'tests-parsing'!testParseWithSimpleCaption	| text tree nLine |	nLine := self lineEnding.	text := 'foo'.	tree := PRDocument new		        add: ((PRCodeblock content: 'foo')				         caption: 'foo';				         yourself);		        yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterTextTest class methodsFor: 'testing'!isAbstract	^ false! !!PRTextWriterTextTest methodsFor: 'private'!actualClass	^ PRText! !!PRTextWriterTextTest methodsFor: 'tests-parsing'!testParseLatex	| text tree |	text := '\begin{foo}[bar]$zork$\end{foo}'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText content: '\begin{foo}[bar]$zork$\end{foo}');			yourself);		yourself.	self textWriterAssertTree: tree equalsText: text! !!PRTextWriterDefinitionDataTest class methodsFor: 'testing'!isAbstract	^ false! !!PRTextWriterDefinitionDataTest methodsFor: 'private'!actualClass	^ PRDefinitionList! !!PRTextWriterDefinitionDataTest methodsFor: 'private'!listItemClass	^ PRDataItem! !!PRTextWriterDefinitionDataTest methodsFor: 'private'!textString: anObject level: anInteger	^ (super textString: anObject level: anInteger) , '  '! !!PRTextWriterDefinitionDataTest methodsFor: 'private'!wikiString	^ ':'! !"Pillar-Tests-Model-ExporterText"!!ManifestDeprecatedFileStream commentStamp: '' prior: 0!Deprecated package including the old file stream implementations!!OldFileStream commentStamp: '' prior: 0!I'm a deprecated class. Since the version 5, Pharo provides a new file streams API that makes the old one based on classes like FileStream or MultiByteBinaryOrTextStream deprecated. Pharo 7 makes the next important steps and removes usages of the old API from the kernel.What you should remember:- use file references as entry points to file streams - DO NOT USE FileStream class- 'file.txt' asFileReference readStream and similar methods now return an instance of ZnCharacterReadStream instead of MultiByteFileStream- 'file.txt' asFileReference writeStream and similar methods now return an instance of ZnCharacterWriteStream instead of MultiByteFileStream- the new API has a clearer separation between binary and text files1. Basic FilesBy default files are binary. Not buffered.Read UTF-8 text from an existing fileObsolete code:FileStream readOnlyFileNamed: '1.txt' do: [ :stream |     stream upToEnd ].New code:(File named: 'name') readStream.(File named: 'name') readStreamDo: [ :stream | ‚Ä¶ ].'1.txt' asFileReference readStreamDo: [ :stream |     stream upToEnd ].2. EncodingTo add encoding, wrap a stream with a corresponding ZnCharacterRead/WriteStream.‚ÄúReading‚Äùutf8Encoded := ZnCharacterReadStream on: aBinaryStream encoding: ‚Äòutf8‚Äô.utf16Encoded := ZnCharacterReadStream on: aBinaryStream encoding: ‚Äòutf16‚Äô.‚ÄúWriting‚Äùutf8Encoded := ZnCharacterWriteStream on: aBinaryStream encoding: ‚Äòutf8‚Äô.utf16Encoded := ZnCharacterWriteStream on: aBinaryStream encoding: ‚Äòutf16‚Äô.Force creation of a new file and write a UTF-8 textObsolete code:FileStream forceNewFileNamed: '1.txt' do: [ :stream | stream nextPutAll: 'a ‚â† b' ].New code:(File named: ‚Äòname‚Äô) writeStream.(File named: ‚Äòname‚Äô) writeStreamDo: [ :stream | ‚Ä¶ ].'1.txt' asFileReference ensureDelete;     writeStreamDo: [ :stream | stream nextPutAll: 'a ‚â† b' ].Get all content of existing UTF-8 fileObsolete code:(FileStream readOnlyFileNamed: '1.txt') contentsOfEntireFile.New code:'1.txt' asFileReference readStream upToEnd.3. BufferingTo add buffering, wrap a stream with a corresponding ZnBufferedRead/WriteStream.bufferedReadStream := ZnBufferedReadStream on: aStream.bufferedWriteStream := ZnBufferedWriteStream on: aStream.It is in general better to buffer the reading on the binary file and apply the encoding on the buffer in memory than the other way around. See[file := Smalltalk sourcesFile fullName.(File named: file) readStreamDo: [ :binaryFile |(ZnCharacterReadStream on: (ZnBufferedReadStream on: binaryFile) encoding: ‚Äòutf8‚Äô) upToEnd]] timeToRun. ‚Äú0:00:00:09.288‚Äù[file := Smalltalk sourcesFile fullName.(File named: file) readStreamDo: [ :binaryFile |(ZnBufferedReadStream on: (ZnCharacterReadStream on: binaryFile encoding: ‚Äòutf8‚Äô)) upToEnd]] timeToRun. ‚Äú0:00:00:14.189‚ÄùThe MultiByteFileStream was buffered. If you create a stream using the expression'file.txt' asFileReference readStream.then the ZnCharacterReadStream is not created directly on top of the stream but on top of a buffered stream that uses the file stream internally.If you create a ZnCharacterReadStream directly on the file stream, then the characters from the file are read one by one which may be about ten times slower!!ZnCharacterReadStream on: (File openForReadFileNamed: 'file.txt').4. File SystemBy default, file system files are buffered and utf8 encoded to keep backwards compatibility.‚Äòname‚Äô asFileReference readStreamDo: [ :bufferedUtf8Stream | ‚Ä¶ ].‚Äòname‚Äô asFileReference writeStreamDo: [ :bufferedUtf8Stream | ‚Ä¶ ].FileStream also provides access to plain binary files using the #binaryRead/WriteStream messages. Binary streams are buffered by default too.‚Äòname‚Äô asFileReference binaryReadStreamDo: [ :bufferedBinaryStream | ‚Ä¶ ].‚Äòname‚Äô asFileReference binaryWriteStreamDo: [ :bufferedBinaryStream | ‚Ä¶ ].If you want a file with another encoding (to come in the PR https://github.com/pharo-project/pharo/pull/1134), you can specify it while obtaining the stream:‚Äòname‚Äô asFileReference    readStreamEncoded: ‚Äòutf16‚Äô    do: [ :bufferedUtf16Stream | ‚Ä¶ ].‚Äòname‚Äô asFileReference    writeStreamEncoded: ‚Äòutf8‚Äô    do: [ :bufferedUtf16Stream | ‚Ä¶ ].Force creation of a new file and write binary data into itObsolete code:(FileStream forceNewFileNamed: '1.bin')     binary;    nextPutAll: #[1 2 3].New code:'1.bin' asFileReference ensureDelete;     binaryWriteStreamDo: [ :stream | stream nextPutAll: #[1 2 3] ].Read binary data from an existing fileObsolete code:(FileStream readOnlyFileNamed: '1.bin') binary; contentsOfEntireFile.New code:'1.bin' asFileReference binaryReadStream upToEnd.Force creation of a new file with a different encodingObsolete code:FileStream forceNewFileNamed: '2.txt' do: [ :stream |     stream converter: (TextConverter newForEncoding: 'cp-1250').    stream nextPutAll: 'P≈ô√≠li≈° ≈ælu≈•ouƒçk√Ω k≈Ø≈à √∫pƒõl ƒè√°belsk√© √≥dy.' ].New code:('2.txt' asFileReference) ensureDelete;    writeStreamEncoded: 'cp-1250' do: [ :stream |        stream nextPutAll: 'P≈ô√≠li≈° ≈ælu≈•ouƒçk√Ω k≈Ø≈à √∫pƒõl ƒè√°belsk√© √≥dy.' ].Read encoded text from an existing fileObsolete code:FileStream readOnlyFileNamed: '2.txt' do: [ :stream |     stream converter: (TextConverter newForEncoding: 'cp-1250').    stream upToEnd ].New code:('2.txt' asFileReference)    readStreamEncoded: 'cp-1250' do: [ :stream |        stream upToEnd ].Write a UTF-8 text to STDOUTObsolete code:FileStream stdout nextPutAll: 'a ‚â† b'; lf.New code:(ZnCharacterWriteStream on: Stdio stdout)    nextPutAll: 'a ‚â† b'; lf;    flush.Write CP-1250 encoded text to STDOUTObsolete code:FileStream stdout     converter: (TextConverter newForEncoding: 'cp-1250');    nextPutAll: 'P≈ô√≠li≈° ≈ælu≈•ouƒçk√Ω k≈Ø≈à √∫pƒõl ƒè√°belsk√© √≥dy.'; lf.New code:(ZnCharacterWriteStream on: Stdio stdout encoding: 'cp1250')    nextPutAll: 'P≈ô√≠li≈° ≈ælu≈•ouƒçk√Ω k≈Ø≈à √∫pƒõl ƒè√°belsk√© √≥dy.'; lf;    flush.Read a UTF-8 text from STDINCAUTION: Following code will stop your VM until an input on STDIN will be provided!!Obsolete code:FileStream stdin upTo: Character lf.New code:(ZnCharacterReadStream on: Stdio stdin) upTo: Character lf.Write binary data to STDOUTobsolete codeFileStream stdout     binary    nextPutAll: #[80 104 97 114 111 10 ].New code:Stdio stdout     nextPutAll: #[80 104 97 114 111 10 ].Read binary data from STDINCAUTION: Following code will stop your VM until an input on STDIN will be provided!!Obsolete code:FileStream stdin binary upTo: 10.New code:Stdio stdin upTo: 10.Positionable streamsThe message #position: always works on the binary level, not on the character level.'1.txt' asFileReference readStreamDo: [ :stream |     stream position: 4.    stream upToEnd ].This will lead to an error (ZnInvalidUTF8: Illegal leading byte for UTF-8 encoding) in case of the file created above because we set the position into the middle of a UTF-8 encoded character. To be safe, you need to read the file from the beginning.'1.txt' asFileReference readStreamDo: [ :stream |    3 timesRepeat: [ stream next ].    stream upToEnd.].5. Line Ending ConventionsIf you want to write files following a specific line ending convention, use the ZnNewLineWriterStream.This stream decorator will transform any line ending (cr, lf, crlf) into a defined line ending.By default, it chooses the platform line ending convention.lineWriter := ZnNewLineWriterStream on: aStream.If you want to choose another line ending convention you can do:lineWriter forCr.lineWriter forLf.lineWriter forCrLf.lineWriter forPlatformLineEnding.-------------------------------------------Old comment: I represent a Stream that accesses a FilePage from a File. One use for my instance is to access larger "virtual Strings" than can be stored contiguously in main memory. I restrict the objects stored and retrieved to be Integers or Characters. An end of file pointer terminates reading; it can be extended by writing past it, or the file can be explicitly truncated.	To use the file system for most applications, you typically create a FileStream. This is done by sending a message to a FileDirectory (file:, oldFile:, newFile:, rename:newName:) which creates an instance of me. Accesses to the file are then done via my instance.*** On DOS, files cannot be shortened!!  ***  To overwrite a file with a shorter one, first delete the old file (FileDirectory deleteFilePath: 'Hard Disk:aFolder:dataFolder:foo') or (aFileDirectory deleteFileNamed: 'foo').  Then write your new shorter version.!!OldStandardFileStream commentStamp: '' prior: 0!Provides a simple, platform-independent, interface to a file system. The instance variable rwmode, inherited from class PositionableStream, here is used to hold a Boolean -- true means opened for read-write, false means opened for read-only.  2/12/96 swI implement a simple read buffering scheme with the variables defined in PositionableStream (which are unused in me otherwise) in the following way:	collection	<ByteString> or <ByteArray>	This is the buffer.	position	<Integer>	The relative position in the buffer. Greater or equal to zero.	readLimit	<Integer>	The number of bytes buffered. Greater or equal to zero.Read buffering is enabled with #enableReadBuffering, disabled with #disableReadBuffering and it is enabled by default. The buffer is filled when a read attempt of an unbuffered absolute position is requested, or when a negative repositioning is made (with #position: with an argument < than the current absolute position) to an absolute position which is not buffered. In the first case, the buffer is positioned to the given absolute position. In the latter case the repositioning is made to the requested absolute position minus fourth of the buffer size. This means that further small negative repositionings won't result in buffer flushing. This is really useful when filing in code.The read buffer is flushed (#flushReadBuffer) whenever a write attempt is made.The buffer state is valid if and only if collection is not nil and position < readLimit.!!OldMultiByteFileStream commentStamp: '' prior: 0!The central class to access the external file.  The interface of this object is similar to good old StandardFileStream, but internally it asks the converter, which is a sub-instance of TextConverter, and do the text conversion.  It also combined the good old CrLfFileStream.  CrLfFileStream class>>new now returns an instance of MultiByteFileStream.  There are several pitfalls:  * You always have to be careful about the binary/text distinction.  In #text mode, it usually interpret the bytes.  * A few file pointer operations treat the file as uninterpreted byte no matter what.  This means that if you use 'fileStream skip: -1', 'fileStream position: x', etc. in #text mode, the file position can be in the middle of multi byte character.  If you want to implement some function similar to #peek for example, call the saveStateOf: and restoreStateOf: methods to be able to get back to the original state.  * #lineEndConvention: and #wantsLineEndConversion: (and #binary) can cause some puzzling situation because the inst var lineEndConvention and wantsLineEndConversion are mutated.  If you have any suggestions to clean up the protocol, please let me know.!!OldMultiByteBinaryOrTextStream commentStamp: '' prior: 0!It is similar to MultiByteFileStream, but works on in memory stream.!!OldRWBinaryOrTextStream commentStamp: '' prior: 0!This package is to support the migration of OSSubProcess to Pharo 9.0 where FileStream has been removed after been deprecated in Pharo 8.0.A simulation of a FileStream, but living totally in memory.  Hold the contents of a file or web page from the network.  Can then fileIn like a normal FileStream.Need to be able to switch between binary and text, as a FileStream does, without recopying the whole collection.  Convert to binary upon input and output.  Always keep as text internally.!!OldFileExistsException commentStamp: '' prior: 0!Notify when file exists!!OldLimitingLineStreamWrapper commentStamp: '' prior: 0!I'm a wrapper for a stream optimized for line-by-line access using #nextLine. My instances can be nested.I read one line ahead. Reading terminates when the stream ends, or if the limitingBlock evaluated with the line answers true. To skip the delimiting line for further reading use #skipThisLine.Character-based reading (#next) is permitted, too. Send #updatePosition when switching from line-based reading.See examples at the class side.--bf 2/19/1999 12:52!!PositionableStream methodsFor: '*OldFileStream'!asBinaryOrTextStream	"Convert to a stream that can switch between bytes and characters"	^ (OldRWBinaryOrTextStream with: self contentsOfEntireFile) reset! !!ManifestDeprecatedFileStream class methodsFor: 'deprecation'!isDeprecated	^true! !!OldFileStream class methodsFor: 'file reader services'!changesFileSuffixes	^#('changes')! !!OldFileStream class methodsFor: 'concrete classes'!concreteStream	"Who should we really direct class queries to?  "	^ OldMultiByteFileStream.! !!OldFileStream class methodsFor: 'utilities'!convertCRtoLF: fileName	"Convert the given file to LF line endings. Put the result in a file with the extention '.lf'"	| in out c justPutCR |	in := (self readOnlyFileNamed: fileName) binary.	out :=  (self newFileNamed: fileName, '.lf') binary.	justPutCR := false.	[in atEnd] whileFalse: [		c := in next.		c = 10			ifTrue: [				out nextPut: 13.				justPutCR := true]			ifFalse: [				(justPutCR and: [c = 10]) ifFalse: [out nextPut: c].				justPutCR := false]].	in close.	out close.! !!OldFileStream class methodsFor: 'instance creation'!detectFile: aBlock do: anotherBlock	^aBlock value		ifNil: [nil]      	ifNotNil: [:file| [anotherBlock value: file] ensure: [file close]]! !!OldFileStream class methodsFor: 'file reader services'!fileIn: fullName	"File in the entire contents of the file specified by the name provided"	| ff fn |	fullName ifNil: [^ self inform: 'Filename is nil.'].	fn := fullName asFileReference.	fn := (Smalltalk hasClassNamed: #GZipReadStream) 		ifTrue: [(Smalltalk classNamed:  #GZipReadStream) uncompressedFileName: fn fullName]		ifFalse: [fn fullName].	ff := self readOnlyFileNamed: fn.	ff fileIn.! !!OldFileStream class methodsFor: 'instance creation'!fileNamed: fileName 	^ self concreteStream fileNamed: (self fullName: fileName)! !!OldFileStream class methodsFor: 'instance creation'!fileNamed: fileName do: aBlock	"Returns the result of aBlock."		^ self detectFile: [ self fileNamed: fileName ] do: aBlock! !!OldFileStream class methodsFor: 'stdio'!flushAndVoidStdioFiles	StdioFiles ifNotNil: [		StdioFiles do: [ :file |			file ifNotNil: [ 				file isReadOnly ifFalse: [					[ file flush ]						on: Error						do: [ :ex | "care less" ] ] ] ].	].	self voidStdioFiles! !!OldFileStream class methodsFor: 'instance creation'!forceNewFileNamed: fileName 	"Create a new file with the given name, and answer a stream opened for writing on that file. If the file already exists, delete it without asking before creating the new file."	SessionManager default currentSession isReadOnlyAccessMode ifTrue: [ ((CannotDeleteFileException fileName: fileName)		messageText: 'Could not delete the old version of file ' , fileName) signal.		^ NullStream new ].	^self concreteStream forceNewFileNamed: fileName! !!OldFileStream class methodsFor: 'instance creation'!forceNewFileNamed: fileName do: aBlock	"Returns the result of aBlock."		^ self detectFile: [ self forceNewFileNamed: fileName ] do: aBlock! !!OldFileStream class methodsFor: 'instance creation'!fullName: fileName	^ fileName asFileReference fullName ! !!OldFileStream class methodsFor: 'initialize-release'!initialize	TheStdioHandles := Array new: 3.	SessionManager default registerSystemClassNamed: self name! !!OldFileStream class methodsFor: 'instance creation'!isAFileNamed: fName	"return whether a file exists with the given name"	^self concreteStream isAFileNamed: (self fullName: fName)! !!OldFileStream class methodsFor: 'file reader services'!isChangesFileSuffix: suffix	^ self changesFileSuffixes includes: suffix! !!OldFileStream class methodsFor: 'deprecation'!isDeprecated	^true! !!OldFileStream class methodsFor: 'file reader services'!isSourceFileSuffix: suffix	^ self sourceFileSuffixes includes: suffix! !!OldFileStream class methodsFor: 'instance creation'!new	^ self basicNew! !!OldFileStream class methodsFor: 'instance creation'!newFileNamed: fileName 	^ self concreteStream newFileNamed: (self fullName: fileName)! !!OldFileStream class methodsFor: 'instance creation'!newFileNamed: fileName do: aBlock	"Returns the result of aBlock."		^ self detectFile: [ self newFileNamed: fileName ] do: aBlock! !!OldFileStream class methodsFor: 'stdio'!newForStdio	"This is a hook for subclasses to initialize themselves properly."	^self new! !!OldFileStream class methodsFor: 'instance creation'!oldFileNamed: fileName 	^ self concreteStream oldFileNamed: (self fullName: fileName)! !!OldFileStream class methodsFor: 'instance creation'!oldFileNamed: fileName do: aBlock	"Returns the result of aBlock."		^ self detectFile: [ self oldFileNamed: fileName ] do: aBlock! !!OldFileStream class methodsFor: 'instance creation'!oldFileOrNoneNamed: fileName	"If the file exists, answer a read-only FileStream on it. If it doesn't, answer nil."	| fullName |	fullName := self fullName: fileName.	^ (self concreteStream isAFileNamed: fullName)		ifTrue: [ self concreteStream readOnlyFileNamed: fullName]		ifFalse: [ nil].! !!OldFileStream class methodsFor: 'instance creation'!onHandle: aFileSystemHandle	^ self concreteStream new		open: aFileSystemHandle fullName		forWrite: aFileSystemHandle isWritable! !!OldFileStream class methodsFor: 'instance creation'!readOnlyFileNamed: fileName 	^ self concreteStream readOnlyFileNamed: (self fullName: fileName)! !!OldFileStream class methodsFor: 'instance creation'!readOnlyFileNamed: fileName do: aBlock	"Open the existing file with the given name for read-only access and pass it as argument to aBlock.	Returns the result of aBlock."		^ self detectFile: [ self readOnlyFileNamed: fileName ] do: aBlock! !!OldFileStream class methodsFor: 'file reader services'!removeLineFeeds: fullName	| fileContents |	fileContents := ((OldFileStream readOnlyFileNamed: fullName) wantsLineEndConversion: true) contentsOfEntireFile.	(OldFileStream newFileNamed: fullName) 		nextPutAll: fileContents;		close.! !!OldFileStream class methodsFor: 'dnd requests'!requestDropStream: dropIndex	"Request a read-only stream for some file that was dropped onto the application"	^self concreteStream new requestDropStream: dropIndex.! !!OldFileStream class methodsFor: 'system startup'!shutDown: isImageQuitting	isImageQuitting ifTrue: [ self flushAndVoidStdioFiles ]! !!OldFileStream class methodsFor: 'file reader services'!sourceFileSuffixes	^#('st' 'cs')! !!OldFileStream class methodsFor: 'stdio'!standardIOStreamNamed: moniker forWrite: forWrite	"Create if necessary and store default stdin, stdout and other files based on the their names"		| index |		"This is an ugly hack, while waiting for a real fix for windows. There  several problems with this approach, but it allow us to run tests, etc."	Smalltalk os isWin32 		ifTrue: [ 			[ ^ OldMultiByteFileStream forceNewFileNamed: moniker asString ]			on: CannotDeleteFileException do: [				"HACK: if the image is opened a second time windows barks about the already opened locked file"				^ OldMultiByteFileStream forceNewFileNamed: moniker asString, '_', (Random new nextInt: SmallInteger maxVal) asString   ]]. 			index := #(stdin stdout stderr) identityIndexOf: moniker.	^((StdioFiles ifNil: [ StdioFiles := Array new: 3 ]) at: index)		ifNil: [			StdioFiles				at: index 				put: (					(TheStdioHandles at: index)						ifNil: [ ^self error: moniker, ' is unavailable' ]						ifNotNil: [ :handle |							OldMultiByteFileStream newForStdio								openOnHandle: handle								name: moniker								forWrite: forWrite ]) ]! !!OldFileStream class methodsFor: 'system startup'!startUp: isImageStarting	isImageStarting		ifFalse: [ ^ self ].	self voidStdioFiles.	[ TheStdioHandles := self stdioHandles ]		on: Error		do: [ :ex | 			TheStdioHandles isArray				ifFalse: [ TheStdioHandles := Array new: 3 ] ]! !!OldFileStream class methodsFor: 'stdio'!stderr	^Stderr ifNil: [ Stderr := self standardIOStreamNamed: #stderr forWrite: true ]! !!OldFileStream class methodsFor: 'stdio'!stdin	^Stdin ifNil: [		Stdin := self standardIOStreamNamed: #stdin forWrite: false.		Stdin			disableReadBuffering;			yourself ].! !!OldFileStream class methodsFor: 'stdio'!stdioHandles	<primitive: 'primitiveFileStdioHandles' module: 'FilePlugin' error: ec>	self primitiveFailed! !!OldFileStream class methodsFor: 'stdio'!stdout	^Stdout ifNil: [ Stdout := self standardIOStreamNamed: #stdout forWrite: true ]! !!OldFileStream class methodsFor: 'stdio'!voidStdioFiles			Smalltalk os isWin32 ifTrue: [ 		{Stdout . Stderr } do: [ :each | 			[ 	each ifNotNil: [ 					each size isZero ifTrue: [ 						each close.						each name asFileReference delete	 					] 				]			] ifError: [ ].		]	].		Stdin := Stdout := Stderr := StdioFiles := nil! !!OldFileStream class methodsFor: 'utilities'!writeSourceCodeFrom: aStream baseName: baseName isSt: stOrCsFlag	| extension converter fileName  |	[ 	extension :=  stOrCsFlag ifTrue: ['.st']  ifFalse: ['.cs'].		converter := aStream contents isAsciiString 			ifTrue: [MacRomanTextConverter new] 			ifFalse: [UTF8TextConverter new].		fileName := baseName, extension.		fileName := FileSystem disk checkName: fileName fixErrors: true.		[OldFileStream newFileNamed: fileName do: [:fileStream |			fileName := fileStream name. "in case it is changed when handling FileExistsException"			(converter isMemberOf: UTF8TextConverter)				ifTrue: [fileStream binary.						UTF8TextConverter writeBOMOn: fileStream].			fileStream				text;				converter: converter;				nextPutAll: aStream contents;				close]] on: Abort do: [:e | ^self ]	] on: Error do: 	[ 	:error | 		error isResumable 			ifTrue: [ error resumeUnchecked: error defaultAction]			ifFalse: [ error pass ]	].	self inform: 'Filed out to: ', String cr, fileName.! !!OldFileStream methodsFor: 'converting'!asBinaryOrTextStream	"I can switch between binary and text data"	^ self! !!OldFileStream methodsFor: 'modes'!ascii	"Set this file to ascii (text) mode."	self subclassResponsibility! !!OldFileStream methodsFor: 'testing'!atEnd	"Answer true if the current position is >= the end of file position."	self subclassResponsibility! !!OldFileStream methodsFor: 'modes'!binary	"Set this file to binary mode."	self subclassResponsibility! !!OldFileStream methodsFor: 'open/close'!close	"Close this file."	self subclassResponsibility! !!OldFileStream methodsFor: 'testing'!closed	"Answer true if this file is closed."	self subclassResponsibility! !!OldFileStream methodsFor: 'accessing'!contents	"Return the contents of the receiver. Do not close or otherwise touch the receiver. Return data in whatever mode the receiver is in (e.g., binary or text)."	| s savePos |	savePos := self position.	self position: 0.	s := self next: self size.	self position: savePos.	^s! !!OldFileStream methodsFor: 'accessing'!contentsOfEntireFile	"Read all of the contents of the receiver."	| s binary |	self readOnly.	binary := self isBinary.	self reset.	"erases knowledge of whether it is binary"	binary ifTrue: [self binary].	s := self next: self size.	self close.	^s! !!OldFileStream methodsFor: 'actions'!delete		(File named: self name) delete! !!OldFileStream methodsFor: 'actions'!exists		^ (File named: self name) exists! !!OldFileStream methodsFor: 'accessing'!file	"Answer the file for the page the receiver is streaming over."	self subclassResponsibility! !!OldFileStream methodsFor: 'ToDeprecate'!fileIn	"Guarantee that the receiver is readOnly before fileIn for efficiency and	to eliminate remote sharing conflicts."	self readOnly.	CodeImporter evaluateFileStream: self.! !!OldFileStream methodsFor: 'flushing'!flush	"When writing, this flushes the write buffer the stream uses to reduce	the number of write() system calls it makes. This should generally be	used before #sync, but on Windows they do the same thing."	self subclassResponsibility! !!OldFileStream methodsFor: 'accessing'!localName	^ self name asFileReference basename! !!OldFileStream methodsFor: 'printing'!longPrintOn: aStream	"Do nothing, so it will print short.  Called to print the error file.  If the error was in a file operation, we can't read the contents of that file.  Just print its name instead."! !!OldFileStream methodsFor: 'printing'!longPrintOn: aStream limitedTo: sizeLimit indent: indent	"Do nothing, so it will print short.  Called to print the error file.  If the error was in a file operation, we can't read the contents of that file.  Just print its name instead."	aStream cr! !!OldFileStream methodsFor: 'accessing'!mimeTypes	^ self name asFileReference mimeTypes.! !!OldFileStream methodsFor: 'accessing'!name	"Answer the name of the file for the page the receiver is streaming over."	self subclassResponsibility! !!OldFileStream methodsFor: 'accessing'!next	(position >= readLimit and: [self atEnd])		ifTrue: [^nil]		ifFalse: [^collection at: (position := position + 1)]! !!OldFileStream methodsFor: 'accessing'!next: anInteger	| newCollection howManyRead increment |	newCollection := self collectionSpecies new: anInteger.	howManyRead := 0.	[howManyRead < anInteger] whileTrue:		[self atEnd ifTrue:			[(howManyRead + 1) to: anInteger do: [:i | newCollection at: i put: (self next)].			^newCollection].		increment := (readLimit - position) min: (anInteger - howManyRead).		newCollection replaceFrom: (howManyRead + 1)			to: (howManyRead := howManyRead + increment)			with: collection			startingAt: (position + 1).		position := position + increment].	^newCollection! !!OldFileStream methodsFor: 'accessing'!nextPut: aByte	"1/31/96 sw: subclassResponsibility"	self subclassResponsibility! !!OldFileStream methodsFor: 'accessing'!nextPutAll: aCollection	"1/31/96 sw: made subclass responsibility"	self subclassResponsibility! !!OldFileStream methodsFor: 'positioning'!position	"Answer the current character position in the file."	self subclassResponsibility! !!OldFileStream methodsFor: 'positioning'!position: pos	"Set the current character position in the file to pos."	self subclassResponsibility! !!OldFileStream methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' on '.	self file printOn: aStream! !!OldFileStream methodsFor: 'modes'!readOnly	"Set this file's mode to read-only."	self subclassResponsibility! !!OldFileStream methodsFor: 'modes'!readOnlyStream	^self readOnly! !!OldFileStream methodsFor: 'modes'!readWrite	"Set this file's mode to read-write."	self subclassResponsibility! !!OldFileStream methodsFor: 'open/close'!reopen	"Ensure that the receiver is open, re-open it if necessary."	"Details: Files that were open when a snapshot occurs are no longer valid when the snapshot is resumed. This operation re-opens the file if that has happened."	self subclassResponsibility! !!OldFileStream methodsFor: 'initialization'!reset	"Set the current character position to the beginning of the file."	self subclassResponsibility! !!OldFileStream methodsFor: 'positioning'!setToEnd	"Set the current character position to the end of the File. The same as	self position: self size."	self subclassResponsibility! !!OldFileStream methodsFor: 'accessing'!size	"Answer the size of the file in characters."	self subclassResponsibility! !!OldFileStream methodsFor: 'positioning'!skip: n	"Set the character position to n characters from the current position.	Error if not enough characters left in the file." 	self subclassResponsibility! !!OldFileStream methodsFor: 'flushing'!sync	"When writing, this syncs any written/flushed data still in the kernel	file system buffers to disk. This should generally be used after #flush,	but on Windows they do the same thing."	self subclassResponsibility! !!OldFileStream methodsFor: 'modes'!text	"Set this file to text (ascii) mode."	self ascii.! !!OldFileStream methodsFor: 'positioning'!truncate: pos	"Truncate file to pos"	self subclassResponsibility! !!OldMultiByteFileStream class methodsFor: 'defaults'!defaultToCR	"MultiByteFileStream defaultToCR"	LineEndDefault := #cr.! !!OldMultiByteFileStream class methodsFor: 'defaults'!defaultToCRLF	"MultiByteFileStream defaultToCRLF"	LineEndDefault := #crlf.! !!OldMultiByteFileStream class methodsFor: 'defaults'!defaultToLF	"MultiByteFileStream defaultToLF"	LineEndDefault := #lf.! !!OldMultiByteFileStream class methodsFor: 'defaults'!guessDefaultLineEndConvention	"Lets try to guess the line end convention from what we know about the	path name delimiter from FileDirectory."		FileSystem disk delimiter = $:		ifTrue: [^ self defaultToCR].			FileSystem disk delimiter = $/		ifTrue: [^ (Smalltalk os isMacOSX or: [Smalltalk os isUnix])				ifTrue: [ self defaultToLF]				ifFalse: [ self defaultToCR]].				FileSystem disk delimiter = $\		ifTrue: [^ self defaultToCRLF].			"in case we don't know"	^ self defaultToCR! !!OldMultiByteFileStream class methodsFor: 'class initialization'!initialize	Cr := Character cr.	Lf := Character lf.	CrLf := String with: Cr with: Lf.	LineEndStrings := Dictionary new.	LineEndStrings at: #cr put: (String with: Character cr).	LineEndStrings at: #lf put: (String with: Character lf).	LineEndStrings at: #crlf put: (String with: Character cr with: Character lf).	LookAheadCount := 2048.		SessionManager default registerSystemClassNamed: self name.	self startUp.! !!OldMultiByteFileStream class methodsFor: 'accessing'!lineEndDefault	"Answer the default line-ending convention that will be used by default, which was determined at start-up by looking at platform attributes."	^ LineEndDefault! !!OldMultiByteFileStream class methodsFor: 'instance creation'!newFrom: aFileStream	| rw n |	n := aFileStream name.	rw := aFileStream isReadOnly not.	aFileStream close.	^self new open: n forWrite: rw.! !!OldMultiByteFileStream class methodsFor: 'system startup'!startUp	self guessDefaultLineEndConvention.! !!OldMultiByteFileStream class methodsFor: 'system startup'!startUp: resuming	self guessDefaultLineEndConvention.! !!OldMultiByteFileStream methodsFor: 'remnant'!accepts: aSymbol 	^ converter accepts: aSymbol.! !!OldMultiByteFileStream methodsFor: 'modes'!ascii	super ascii.	self detectLineEndConvention.! !!OldMultiByteFileStream methodsFor: 'private - crlf'!bareNext	 ^ self converter nextFromStream: self.! !!OldMultiByteFileStream methodsFor: 'file in/out'!basicChunk	"If our buffer in collection contains an chunk with no embedded !!'s, nor	any non-ascii characters, return that.	This presumes the source code encoding is unambiguously ascii-compatible"	| bufferIX goodString |	"Not possible if read buffering disabled"	collection ifNil: [^nil].	^ ((bufferIX := (collection indexOf: $!! startingAt: position + 1) min: readLimit +1) > 0			and: [bufferIX < collection size					and: [(collection at: bufferIX + 1)								~= $!!							and: [goodString := collection copyFrom: position + 1 to: bufferIX - 1.								goodString isAsciiString]]])		ifTrue: [ position := bufferIX.				goodString]! !!OldMultiByteFileStream methodsFor: 'private'!basicNext: anInteger	^ super next: anInteger.! !!OldMultiByteFileStream methodsFor: 'private'!basicNext: n into: aString	^ super next: n into: aString.! !!OldMultiByteFileStream methodsFor: 'private'!basicNext: anInteger putAll: aCollection startingAt: startIndex        ^super next: anInteger putAll: aCollection startingAt: startIndex! !!OldMultiByteFileStream methodsFor: 'private'!basicNextInto: aString	^ super nextInto: aString.! !!OldMultiByteFileStream methodsFor: 'private'!basicNextPut: char	^ super nextPut: char.! !!OldMultiByteFileStream methodsFor: 'private'!basicNextPutAll: aString	^ super nextPutAll: aString.! !!OldMultiByteFileStream methodsFor: 'private'!basicPeek	^ super peek! !!OldMultiByteFileStream methodsFor: 'private'!basicPosition	^ super position.! !!OldMultiByteFileStream methodsFor: 'private'!basicPosition: pos	^ super position: pos.! !!OldMultiByteFileStream methodsFor: 'private'!basicReadInto: byteArray startingAt: startIndex count: count	^ super readInto: byteArray startingAt: startIndex count: count.! !!OldMultiByteFileStream methodsFor: 'private'!basicSetToEnd	^ super setToEnd.! !!OldMultiByteFileStream methodsFor: 'private'!basicSkip: n	^ super skip: n.! !!OldMultiByteFileStream methodsFor: 'private'!basicUpTo: delim	^ super upTo: delim.! !!OldMultiByteFileStream methodsFor: 'private'!basicVerbatim: aString	^ super verbatim: aString.! !!OldMultiByteFileStream methodsFor: 'modes'!binary	super binary.	self lineEndConvention: nil! !!OldMultiByteFileStream methodsFor: 'private - crlf'!convertStringFromCr: aString 	| inStream outStream |	lineEndConvention ifNil: [^ aString].	lineEndConvention == #cr ifTrue: [^ aString].	lineEndConvention == #lf ifTrue: [^ aString copy replaceAll: Cr with: Lf].	"lineEndConvention == #crlf"	inStream := aString readStream.	outStream :=  (String new: aString size) writeStream.	[inStream atEnd]		whileFalse: 			[outStream nextPutAll: (inStream upTo: Cr).			(inStream atEnd not or: [aString last = Cr])				ifTrue: [outStream nextPutAll: CrLf]].	^ outStream contents! !!OldMultiByteFileStream methodsFor: 'private - crlf'!convertStringToCr: aString 	| inStream outStream |	lineEndConvention ifNil: [^ aString].	lineEndConvention == #cr ifTrue: [^ aString].	lineEndConvention == #lf ifTrue: [^ aString copy replaceAll: Lf with: Cr].	"lineEndConvention == #crlf"	inStream := aString readStream.	outStream := (String new: aString size) writeStream.	[inStream atEnd]		whileFalse: 			[outStream nextPutAll: (inStream upTo: Cr).			(inStream atEnd not or: [aString last = Cr])				ifTrue: 					[outStream nextPut: Cr.					inStream peek = Lf ifTrue: [inStream next]]].	^ outStream contents! !!OldMultiByteFileStream methodsFor: 'accessing'!converter	converter ifNil: [self converter: TextConverter defaultSystemConverter].	^ converter! !!OldMultiByteFileStream methodsFor: 'accessing'!converter: aConverter	converter := aConverter.	self installLineEndConventionInConverter! !!OldMultiByteFileStream methodsFor: 'private - crlf'!detectLineEndConvention	"Detect the line end convention used in this stream. The result may be either #cr, #lf or #crlf."	| char numRead state |	self isBinary ifTrue: [^ self error: 'Line end conventions are not used on binary streams'].	wantsLineEndConversion == true ifFalse: [self lineEndConvention: nil.					^lineEndConvention].	self closed ifTrue: [self lineEndConvention: LineEndDefault.					^lineEndConvention].	"Default if nothing else found"	numRead := 0.	state := self converter saveStateOf: self.	lineEndConvention := nil.	[super atEnd not and: [numRead < LookAheadCount]]		whileTrue: 			[char := self next.			char = Lf				ifTrue: 					[converter restoreStateOf: self with: state.					self lineEndConvention: #lf.					^lineEndConvention].			char = Cr				ifTrue: 					[self peek = Lf						ifTrue: [self lineEndConvention: #crlf]						ifFalse: [self lineEndConvention: #cr].					converter restoreStateOf: self with: state.					^ lineEndConvention].			numRead := numRead + 1].	converter restoreStateOf: self with: state.	self lineEndConvention: LineEndDefault.	^ lineEndConvention! !!OldMultiByteFileStream methodsFor: 'private - crlf'!doConversion	^wantsLineEndConversion == true and: [ lineEndConvention notNil ]! !!OldMultiByteFileStream methodsFor: 'accessing'!fileInEncodingName: aString	self converter: (TextConverter newForEncoding: aString).	super fileIn.! !!OldMultiByteFileStream methodsFor: 'private'!installLineEndConventionInConverter	converter ifNotNil: [		converter installLineEndConvention: (			(wantsLineEndConversion == true and: [ lineEndConvention notNil ]) "#doConversion is inlined here"				ifTrue: [ LineEndStrings at: lineEndConvention ]				ifFalse: [ nil ]) ]! !!OldMultiByteFileStream methodsFor: 'accessing'!lineEndConvention	^lineEndConvention! !!OldMultiByteFileStream methodsFor: 'accessing'!lineEndConvention: aSymbol	(lineEndConvention := aSymbol) ifNotNil: [wantsLineEndConversion := true].	self installLineEndConventionInConverter! !!OldMultiByteFileStream methodsFor: 'accessing'!next	| char secondChar state |	char := (converter ifNil: [ self converter ]) nextFromStream: self.	(wantsLineEndConversion == true and: [ lineEndConvention notNil ]) "#doConversion is inlined here"		 ifTrue: [			char == Cr ifTrue: [				state := converter saveStateOf: self.				secondChar := self bareNext.				secondChar ifNotNil: [					secondChar == Lf ifFalse: [ converter restoreStateOf: self with: state ] ].				^Cr ].			char == Lf ifTrue: [				^Cr ] ].	^char.! !!OldMultiByteFileStream methodsFor: 'accessing'!next: anInteger 	| multiString |	self isBinary ifTrue: [^ super next: anInteger].	multiString := String new: anInteger.	1 to: anInteger do: [:index |		| character |		(character := self next)			ifNotNil: [ multiString at: index put: character ]			ifNil: [				multiString := multiString copyFrom: 1 to: index - 1.				(wantsLineEndConversion == true and: [ lineEndConvention notNil ]) "#doConversion is inlined here"					ifFalse: [ ^multiString ].				^self next: anInteger innerFor: multiString ] ].	(wantsLineEndConversion == true and: [ lineEndConvention notNil ]) "#doConversion is inlined here"		 ifFalse: [ ^multiString ].	multiString := self next: anInteger innerFor: multiString.	(multiString size = anInteger or: [self atEnd]) ifTrue: [ ^ multiString].	^ multiString, (self next: anInteger - multiString size).! !!OldMultiByteFileStream methodsFor: 'private - crlf'!next: n innerFor: aString	| peekChar state |	"if we just read a CR, and the next character is an LF, then skip the LF"	aString size = 0 ifTrue: [^ aString].	(aString last = Character cr) ifTrue: [		state := converter saveStateOf: self.		peekChar := self bareNext.		"super peek doesn't work because it relies on #next"		(peekChar notNil and: [peekChar ~= Character lf]) ifTrue: [			converter restoreStateOf: self with: state.		].	]. 	^ aString withInternalLineEndings.! !!OldMultiByteFileStream methodsFor: 'accessing'!next: anInteger putAll: aCollection startingAt: startIndex        (self isBinary or: [ aCollection class == ByteArray ]) ifTrue: [                ^super next: anInteger putAll: aCollection startingAt: startIndex ].        ^self converter next: anInteger putAll: aCollection startingAt: startIndex toStream: self! !!OldMultiByteFileStream methodsFor: 'file in/out'!nextChunk	"Answer the contents of the receiver, up to the next terminator	character. Doubled terminators indicate an embedded terminator	character."	self skipSeparators.	^ self		parseLangTagFor: (self basicChunk				ifNil: [String						new: 1000						streamContents: [:stream | 							| character state |							[(character := self next) == nil								or: [character == $!!										and: [state := converter saveStateOf: self.											self next ~~ $!!]]]								whileFalse: [stream nextPut: character].							character								ifNotNil: [converter restoreStateOf: self with: state.]]])! !!OldMultiByteFileStream methodsFor: 'accessing'!nextDelimited: terminator	| out ch save |	out := (String new: 1000) writeStream.	self atEnd ifTrue: [^ ''].	save := converter saveStateOf: self.	self next = terminator ifFalse: [		"absorb initial terminator"		converter restoreStateOf: self with: save.	].	[(ch := self next) == nil] whileFalse: [		(ch = terminator) ifTrue: [			self peek = terminator ifTrue: [				self next.  "skip doubled terminator"			] ifFalse: [				^ out contents  "terminator is not doubled; we're done!!"			].		].		out nextPut: ch.	].	^ out contents.! !!OldMultiByteFileStream methodsFor: 'accessing'!nextMatchAll: aColl    | save |    save := converter saveStateOf: self.    aColl do: [:each |       (self next) = each ifFalse: [            converter restoreStateOf: self with: save.            ^ false.		].	].    ^ true.! !!OldMultiByteFileStream methodsFor: 'file in/out'!nextPreamble	"Assuming that preamble part does not contain ]lang[ tag"	self skipSeparators.	^ self basicChunk				ifNil: [String						new: 1000						streamContents: [:stream | 							| character state |							[(character := self next) == nil								or: [character == $!!										and: [state := converter saveStateOf: self.											self next ~~ $!!]]]								whileFalse: [stream nextPut: character].							character								ifNotNil: [converter restoreStateOf: self with: state.]]]! !!OldMultiByteFileStream methodsFor: 'accessing'!nextPut: aCharacter	aCharacter isInteger 		ifTrue: [ ^ super nextPut: aCharacter ].	(wantsLineEndConversion == true and: [ lineEndConvention notNil ]) "#doConversion is inlined here"		 ifTrue: [			aCharacter = Cr				ifTrue: [ converter nextPutAll: (LineEndStrings at: lineEndConvention) toStream: self ]				ifFalse: [ converter nextPut: aCharacter toStream: self ].			^aCharacter ].	^ self converter nextPut: aCharacter toStream: self! !!OldMultiByteFileStream methodsFor: 'accessing'!nextPutAll: aCollection	^ (self isBinary or: [ aCollection class == ByteArray ])		ifTrue: [ super nextPutAll: aCollection ]		ifFalse: [ self converter nextPutAll: aCollection toStream: self ]! !!OldMultiByteFileStream methodsFor: 'open/close'!open: fileName forWrite: writeMode 	| result |	(writeMode and: [SessionManager default currentSession isReadOnlyAccessMode]) 		ifTrue: [ ((CannotDeleteFileException fileName: fileName)			messageText: 'Attempt to open file ' , fileName, ' as writable on read-only filesystem') signal. ].	result := super open: fileName forWrite: writeMode.	result ifNotNil: [			converter ifNil: [self converter: UTF8TextConverter new].			lineEndConvention ifNil: [ self detectLineEndConvention ]	].	^result! !!OldMultiByteFileStream methodsFor: 'accessing'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	| next save |	self atEnd ifTrue: [^ nil].	save := converter saveStateOf: self.	next := self next.	converter restoreStateOf: self with: save.	^ next.! !!OldMultiByteFileStream methodsFor: 'accessing'!peekFor: item 	| next state |	state := converter saveStateOf: self.	(next := self next) == nil ifTrue: [^ false].	item = next ifTrue: [^ true].	converter restoreStateOf: self with: state.	^ false.! !!OldMultiByteFileStream methodsFor: 'accessing'!readInto: buffer startingAt: offset count: requestedCount	"Read up to requestedCount elements into the given buffer starting at offset.	Return the number of elements actually read.	If I am binary or if buffer is a ByteArray, I skip decoding. Yes this is weird.	This is a necessarily inefficient implementation, reading and decoding characters one by one."	(self isBinary or: [ buffer class == ByteArray ])		ifTrue: [ ^ super readInto: buffer startingAt: offset count: requestedCount ].	0 to: requestedCount - 1 do: [ :count | 		| element |		(element := self next) ifNil: [ ^ count ].		buffer at: offset + count put: element ].	^ requestedCount! !!OldMultiByteFileStream methodsFor: 'private'!requestDropStream: dropIndex	"Needs to install proper converter"		| result |	result := super requestDropStream: dropIndex.	result ifNotNil: [		converter ifNil: [self converter: UTF8TextConverter new].		lineEndConvention ifNil: [ self detectLineEndConvention] ].	^result! !!OldMultiByteFileStream methodsFor: 'initialization'!reset	super reset.	converter ifNil: [		self converter: UTF8TextConverter new.	].! !!OldMultiByteFileStream methodsFor: 'private'!setConverterForCode	| current |	SourceFiles changesFileStream ifNotNil: [ :aStream |		self fullName = aStream fullName ifTrue: [ ^ self ] ].	current := self converter saveStateOf: self.	self position: 0.	self binary.	((self next: 3) = #[ 16rEF 16rBB 16rBF ]) ifTrue: [		self converter: UTF8TextConverter new	] ifFalse: [		self converter: MacRomanTextConverter new.	].	converter restoreStateOf: self with: current.	self text.! !!OldMultiByteFileStream methodsFor: 'positioning'!skipSeparators	| state character |	[ 		state := converter saveStateOf: self.		(character := self next) 			ifNil: [ false ]			ifNotNil: [ character isSeparator ] ] whileTrue.	character ifNotNil: [ 		converter restoreStateOf: self with: state ]! !!OldMultiByteFileStream methodsFor: 'accessing'!skipSeparatorsAndPeekNext	"Same as #skipSeparators, but returns the next character after the separators if such exists."	| state character |	[ 		state := converter saveStateOf: self.		(character := self next) 			ifNil: [ false ]			ifNotNil: [ character isSeparator ] ] whileTrue.	character ifNotNil: [ 		converter restoreStateOf: self with: state.		^character ].	! !!OldMultiByteFileStream methodsFor: 'accessing'!upTo: delimiter	^self collectionSpecies new: 1000 streamContents: [ :stream |		| ch |		[ (ch := self next) == nil or: [ ch = delimiter ] ] 			whileFalse: [ stream nextPut: ch ] ]! !!OldMultiByteFileStream methodsFor: 'accessing'!upToAnyOf: delimiters do: aBlock	^self collectionSpecies new: 1000 streamContents: [ :stream |		| ch |		[ (ch := self next) == nil or: [ (delimiters includes: ch) and: [aBlock value: ch. true] ] ] 			whileFalse: [ stream nextPut: ch ] ]! !!OldMultiByteFileStream methodsFor: 'accessing'!upToEnd	^self collectionSpecies		new: self size - self position		streamContents: [ :stream |			| element |			[ (element := self next) == nil ] whileFalse: [				stream nextPut: element ] ]! !!OldMultiByteFileStream methodsFor: 'accessing'!upToPosition: anInteger	"Answer a subcollection containing items starting from the current position and ending including the given position. Usefully different to #next: in that positions measure *bytes* from the file, where #next: wants to measure *characters*."	^self collectionSpecies new: 1000 streamContents: [ :stream |		| ch |		[ (ch := self next) == nil or: [ position > anInteger ] ] 			whileFalse: [ stream nextPut: ch ] ]! !!OldMultiByteFileStream methodsFor: 'private - crlf'!wantsLineEndConversion	^wantsLineEndConversion == true! !!OldMultiByteFileStream methodsFor: 'remnant'!wantsLineEndConversion: aBoolean		wantsLineEndConversion :=  aBoolean.	lineEndConvention ifNil: [ self detectLineEndConvention ]. ! !!OldStandardFileStream class methodsFor: 'error handling'!fileDoesNotExistUserHandling: fullFileName	| selection newName |	selection := UIManager default		chooseFrom:			{('create a new file' translated).			('choose another name' translated).			('cancel' translated)}		title: fullFileName asFileReference basename , ' does not exist.'.	selection = 1		ifTrue: [ ^ self new open: fullFileName forWrite: true ].	selection = 2		ifFalse: [ ^ self ].	newName := UIManager default request: 'Enter a new file name' initialAnswer: fullFileName.	^ self oldFileNamed: (self fullName: newName)! !!OldStandardFileStream class methodsFor: 'error handling'!fileExistsUserHandling: fullFileName	| file localName choice newName newFullFileName |		file := fullFileName asFileReference.	localName := file basename.	choice := UIManager default chooseFrom:{		'overwrite that file'.		'choose another name'.		'cancel'	} title: localName, ' already exists.'. 	choice = 1 ifTrue: [		file delete.		file exists ifTrue:  [self error: 'Could not delete the old version of that file'].		^ self new open: fullFileName forWrite: true].	choice = 2 ifTrue: [		newName := UIManager default request: 'Enter a new file name' initialAnswer: fullFileName.		newName ifNil: [Abort signal].		newFullFileName := self fullName: newName.		^ self newFileNamed: newFullFileName].	Abort signal: 'Please close this to abort file opening'! !!OldStandardFileStream class methodsFor: 'file creation'!fileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new open: (self fullName: fileName) forWrite: true! !!OldStandardFileStream class methodsFor: 'file creation'!forceNewFileNamed: fileName 	"Create a new file with the given name, and answer a stream opened 	for writing on that file. If the file already exists, delete it without 	asking before creating the new file."	| dir  fullName f |		SessionManager default currentSession isReadOnlyAccessMode ifTrue: [ ((CannotDeleteFileException fileName: fileName)		messageText: 'Could not delete the old version of file ' , fileName) signal.		^ NullStream new ].		fullName := self fullName: fileName.	(self isAFileNamed: fullName)		ifFalse: [f := self new open: fullName forWrite: true.			^ f ifNil: ["Failed to open the file"					(FileDoesNotExistException fileName: fullName) signal]].				dir := fullName asFileReference.	dir delete.	dir exists ifTrue: [(CannotDeleteFileException new			messageText: 'Could not delete the old version of file ' , fullName) signal].			f := self new open: fullName forWrite: true.	^ f ifNil: ["Failed to open the file"			(FileDoesNotExistException fileName: fullName) signal].! !!OldStandardFileStream class methodsFor: 'file creation'!isAFileNamed: fileName	"Answer true if a file of the given name exists."	| f |	f := self new open: fileName forWrite: false.	f ifNil: [^ false].	f close.	^ true! !!OldStandardFileStream class methodsFor: 'file creation'!newFileNamed: fileName 	"Create a new file with the given name, and answer a stream opened for writing on that file. If the file already exists, ask the user what to do."	| fullName |	fullName := self fullName: fileName.	^(self isAFileNamed: fullName)		ifTrue: ["file already exists:"			(OldFileExistsException fileName: fullName fileClass: self) signal]		ifFalse: [self new open: fullName forWrite: true]! !!OldStandardFileStream class methodsFor: 'file creation'!oldFileNamed: fileName	"Open an existing file with the given name for reading and writing. If the name has no directory part, then the  default directory will be assumed. If the file does not exist, an exception is signaled. If the file exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	| fullName |	fullName := self fullName: fileName.	^(self isAFileNamed: fullName)		ifTrue: [self new open: fullName forWrite: true]		ifFalse: ["File does not exist..."			(FileDoesNotExistException fileName: fullName) signal]! !!OldStandardFileStream class methodsFor: 'error handling'!readOnlyFileDoesNotExistUserHandling: fullFileName	| dir files choices selection newName fileName |		dir := fullFileName asFileReference.	files := dir parent fileNames.	fileName := dir basename.		choices := fileName correctAgainst: files.	choices add: 'Choose another name'.	choices add: 'Cancel'.		selection := UIManager default chooseFrom: choices lines: (Array with: 5)		title: (fullFileName asFileReference basename), ' does not exist.'.			selection = choices size ifTrue:["cancel" ^ nil "should we raise another exception here?"].	selection < (choices size - 1) ifTrue: [		newName := dir parent / (choices at: selection)].	selection = (choices size - 1) ifTrue: [		newName := UIManager default 							request: 'Enter a new file name' 							initialAnswer: fileName].	newName = '' ifFalse: [^ self readOnlyFileNamed: (self fullName: newName)].	^ self error: 'Could not open a file'! !!OldStandardFileStream class methodsFor: 'file creation'!readOnlyFileNamed: fileName 	"Open an existing file with the given name for reading."	| fullName f |	fullName := self fullName: fileName.	f := self new open: fullName forWrite: false.	^ f ifNil: ["File does not exist..."			((FileDoesNotExistException fileName: fullName) readOnly: true) signal].	"StandardFileStream readOnlyFileNamed: 'kjsd.txt' "! !!OldStandardFileStream class methodsFor: 'registry'!register: anObject	^self registry add: anObject! !!OldStandardFileStream class methodsFor: 'registry'!registry	^Registry ifNil: [Registry := WeakRegistry new]! !!OldStandardFileStream class methodsFor: 'registry'!retryWithGC: execBlock until: testBlock forFileNamed: fullName	"Re-implemented to only force GC if a file with the given name exists"	| blockValue foundIt |	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	"See if we have a file with the given name"	foundIt := self registry keys "hold on strongly for now" 		anySatisfy:[:file| file name sameAs: fullName].	foundIt ifFalse:[^blockValue].	Smalltalk garbageCollectMost.	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollect.	^execBlock value.! !!OldStandardFileStream class methodsFor: 'registry'!unregister: anObject	^self registry remove: anObject ifAbsent:[]! !!OldStandardFileStream methodsFor: 'finalization'!actAsExecutor	super actAsExecutor.	name := nil.! !!OldStandardFileStream methodsFor: 'modes'!ascii	"opposite of binary"	buffer1 := String new: 1.	collection ifNotNil: [ collection := collection asString ]! !!OldStandardFileStream methodsFor: 'testing'!atEnd	"Answer whether the receiver is at its end.  "		collection ifNotNil: [		position < readLimit ifTrue: [ ^false ] ].	^self primAtEnd: fileID! !!OldStandardFileStream methodsFor: 'private'!basicNext	"Answer the next byte from this file, or nil if at the end of the file."		| count |	collection ifNotNil: [		position < readLimit 			ifFalse: [ 				readLimit := self primRead: fileID into: collection startingAt: 1 count: collection size.				position := 0.				readLimit = 0 ifTrue: [ ^nil ] ].		^collection at: (position := position + 1) ].		count := self primRead: fileID into: buffer1 startingAt: 1 count: 1.	count = 1		ifTrue: [ ^buffer1 at: 1 ]		ifFalse: [ ^nil ]! !!OldStandardFileStream methodsFor: 'modes'!binary	buffer1 := ByteArray new: 1.	collection ifNotNil: [ collection := collection asByteArray ]! !!OldStandardFileStream methodsFor: 'open/close'!close	"Close this file."	fileID ifNotNil: [		collection ifNotNil: [			readLimit := position := 0 ].		self primClose: fileID.		self unregister.		fileID := nil].! !!OldStandardFileStream methodsFor: 'testing'!closed	"Answer true if this file is closed."	^ fileID == nil or: [ (self primSizeNoError: fileID) == nil ]! !!OldStandardFileStream methodsFor: 'private'!collectionSpecies	"Answer the species of collection into which the receiver can stream"		^buffer1 species! !!OldStandardFileStream methodsFor: 'accessing'!directory	"Return the directory containing this file."	^ self fullName asFileReference parent! !!OldStandardFileStream methodsFor: 'private'!disableReadBuffering	collection ifNotNil: [		position < readLimit			ifTrue: [				| currentPosition |				currentPosition := self position.				collection := readLimit := position := nil.				self position: currentPosition ]			ifFalse: [				collection := readLimit := position := nil ] ]		! !!OldStandardFileStream methodsFor: 'private'!enableReadBuffering	collection ifNil: [		buffer1 ifNotNil: [			collection := self collectionSpecies new: 2048 ] ].	readLimit := position := 0! !!OldStandardFileStream methodsFor: 'open/close'!ensureOpen	"Make sure that this file really is open."	self closed ifTrue: [^ self reopen].	(self primSizeNoError: fileID) ifNotNil: [^ self].	self reopen.! !!OldStandardFileStream methodsFor: 'accessing'!file	"Answer the object representing the receiver's file.  Need for compatibility with some calls -- check senders. "	^ self! !!OldStandardFileStream methodsFor: 'finalization'!finalize	self primCloseNoError: fileID.! !!OldStandardFileStream methodsFor: 'accessing'!findString: string	"Fast version of #upToAll: to find a String in a file starting from the beginning.	Returns the position and also sets the position there.	If string is not found 0 is returned and position is unchanged."	| pos buffer count oldPos sz |	oldPos := self position.	self reset.	sz := self size.	pos := 0.	buffer := String new: 2000.	[ buffer := self nextInto: buffer.	(count := buffer findString: string) > 0		ifTrue: ["Found the string part way into buffer"			self position: pos.			self next: count - 1.			^self position ].	pos := ((pos + 2000 - string size) min: sz).	self position: pos.	pos = sz] whileFalse.	"Never found it, and hit end of file"	self position: oldPos.	^0! !!OldStandardFileStream methodsFor: 'accessing'!findStringFromEnd: string	"Fast version to find a String in a file starting from the end.	Returns the position and also sets the position there.	If string is not found 0 is returned and position is unchanged."	| pos buffer count oldPos |	oldPos := self position.	self setToEnd.	pos := self position.	[ pos := ((pos - 2000 + string size) max: 0).  "the [+ string size] allows for the case where the end of the search string is at the beginning of the current buffer"	self position: pos.	buffer := self next: 2000.	(count := buffer findString: string) > 0		ifTrue: ["Found the string part way into buffer"			self position: pos.			self next: count-1.  "use next instead of position:, so that CrLfFileStream can do its magic if it is being used"			^self position].	pos = 0] whileFalse.	"Never found it, and hit beginning of file"	self position: oldPos.	^0! !!OldStandardFileStream methodsFor: 'flushing'!flush	"When writing, this flushes the write buffer the stream uses to reduce	the number of write() system calls it makes. This should generally be	used before #sync, but on Windows they do the same thing."	^ self primFlush: fileID! !!OldStandardFileStream methodsFor: 'private'!flushReadBuffer	collection ifNotNil: [		position < readLimit ifTrue: [			| currentPosition |			currentPosition := self position.			position := readLimit := 0.			self primSetPosition: fileID to: currentPosition ] ]! !!OldStandardFileStream methodsFor: 'accessing'!fullName	"Answer this file's full path name."	^ name! !!OldStandardFileStream methodsFor: 'utilities'!insertLineFeeds	"(FileStream oldFileNamed: 'BBfix2.st') insertLineFeeds"	| s crLf f |	crLf := String crlf.	s := self next: self size.	self close.	f := OldFileStream newFileNamed: self name.	s linesDo: [:line | f nextPutAll: line; nextPutAll: crLf].	f close! !!OldStandardFileStream methodsFor: 'testing'!isBinary	^ buffer1 class == ByteArray! !!OldStandardFileStream methodsFor: 'testing'!isDirectory	"Answer whether the receiver represents a directory.  For the post-transition case, uncertain what to do."	^ false! !!OldStandardFileStream methodsFor: 'testing'!isReadOnly	^ rwmode not! !!OldStandardFileStream methodsFor: 'accessing'!localName	^ name ifNotNil: [		(name findTokens: FileSystem disk delimiter asString) last]! !!OldStandardFileStream methodsFor: 'accessing'!name	"Answer this file's full path name."	^ name! !!OldStandardFileStream methodsFor: 'accessing'!next	"Answer the next byte from this file, or nil if at the end of the file."	^ self basicNext! !!OldStandardFileStream methodsFor: 'accessing'!next: n	"Return a string with the next n characters of the filestream in it."	^ self nextInto: (self collectionSpecies new: n)! !!OldStandardFileStream methodsFor: 'accessing'!next: n into: aString startingAt: startIndex	"Read n bytes into the given string.	Return aString or a partial copy if less than	n elements have been read."	|read|	read := (self readInto: aString startingAt: startIndex count: n).	^read = n 		ifTrue: [ aString ]		ifFalse: [ aString copyFrom: 1 to: startIndex + read - 1 ]		! !!OldStandardFileStream methodsFor: 'accessing'!next: anInteger putAll: aString startingAt: startIndex	"Store the next anInteger elements from the given collection."	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	collection ifNotNil: [		position < readLimit ifTrue: [ self flushReadBuffer ] ].		self primWrite: fileID from: aString startingAt: startIndex count: anInteger.	^aString! !!OldStandardFileStream methodsFor: 'accessing'!nextPut: char	"Write the given character to this file."	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	collection ifNotNil: [ 		position < readLimit ifTrue: [ self flushReadBuffer ] ].	buffer1 at: 1 put: char.	self primWrite: fileID from: buffer1 startingAt: 1 count: 1.	^ char! !!OldStandardFileStream methodsFor: 'accessing'!nextPutAll: stringOrByteArray	"Write all the characters of the given string to this file."	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	collection ifNotNil: [ 		position < readLimit ifTrue: [ self flushReadBuffer ] ].	self primWrite: fileID from: stringOrByteArray startingAt: 1 count: stringOrByteArray basicSize.	^ stringOrByteArray! !!OldStandardFileStream methodsFor: 'open/close'!open	"For compatibility with a few existing things."	^ self reopen! !!OldStandardFileStream methodsFor: 'open/close'!open: fileName forWrite: writeMode 	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	| f |	f := fileName asVmPathName.		(writeMode and: [ FileSystem disk isWritable not ]) ifTrue: [ ^ nil ].	fileID := OldStandardFileStream retryWithGC:[self primOpen: f writable: writeMode] 					until:[:id| id notNil] 					forFileNamed: fileName.	fileID ifNil: [^ nil].  "allows sender to detect failure"	name := fileName.	self register.	rwmode := writeMode.	buffer1 := String new: 1.	self enableReadBuffering	! !!OldStandardFileStream methodsFor: 'open/close'!openOnHandle: aFileID name: streamName forWrite: writeMode	"Initialize the file with the given handle. If writeMode is true then	 allow writing, otherwise put the file in read-only mode.	 N.B. Do _not_ register the stream.  We do not want it to be	 closed implicitly (e.g. on GC).  There may be multiple instances	 accessing the same stream.  The stream is not a file."	fileID := aFileID.	name := streamName.	rwmode := writeMode.	buffer1 := String new: 1.	self enableReadBuffering! !!OldStandardFileStream methodsFor: 'open/close'!openReadOnly	"Open the receiver as a read-only file."	^ self open: name forWrite: false! !!OldStandardFileStream methodsFor: 'accessing'!padToEndWith: aChar	"On the Mac, files do not truncate.  One can delete the old file and write a new one, but sometime deletion fails (file still open? file stale?).  This is a sad compromise.  Just let the file be the same length but pad it with a harmless character."	| pad |	self atEnd ifTrue: [^ self].	pad := self isBinary 		ifTrue: [aChar asCharacter asciiValue]	"ok for char or number"		ifFalse: [aChar asCharacter].	self nextPutAll: (self collectionSpecies new: ((self size - self position) min: 20000) 							withAll: pad).! !!OldStandardFileStream methodsFor: 'accessing'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	| next |	self atEnd ifTrue: [^ nil].	next := self basicNext.	self position: self position - 1.	^ next! !!OldStandardFileStream methodsFor: 'accessing'!peekFor: item 	"Answer false and do not advance if the next element is not equal to item, or if this stream is at the end.  If the next element is equal to item, then advance over it and return true"	| next |	(next := self next) == nil ifTrue: [^ false].	item = next ifTrue: [^ true].	self skip: -1.	^ false! !!OldStandardFileStream methodsFor: 'accessing'!peekLast	"Return that item just put at the end of the stream"	^ buffer1 size > 0 		ifTrue: [buffer1 last]		ifFalse: [nil]! !!OldStandardFileStream methodsFor: 'positioning'!position	"Return the receiver's current file position."	collection ifNotNil: [		position < readLimit ifTrue: [			^(self primGetPosition: fileID) - readLimit + position ] ].	^self primGetPosition: fileID! !!OldStandardFileStream methodsFor: 'positioning'!position: pos	"Set the receiver's position as indicated."	collection ifNotNil: [		position < readLimit ifTrue: [			| newPosition |			newPosition := pos - (self primGetPosition: fileID) + readLimit.			newPosition < 0 ifTrue: [					| offsetPos |					self primSetPosition: fileID to: (offsetPos := pos - (collection size // 4) max: 0).					readLimit := self primRead: fileID into: collection startingAt: 1 count: collection size.					position := pos - offsetPos.					^self ].			newPosition < readLimit 				ifTrue: [					position := newPosition.					^self ]				ifFalse: [					readLimit := position := 0 ] ] ].	^self primSetPosition: fileID to: pos! !!OldStandardFileStream methodsFor: 'private - primitives'!primAtEnd: id	"Answer true if the file position is at the end of the file."	<primitive: 'primitiveFileAtEnd' module: 'FilePlugin'>	self primitiveFailed! !!OldStandardFileStream methodsFor: 'private - primitives'!primClose: id	"Close this file."	<primitive: 'primitiveFileClose' module: 'FilePlugin'>	self primitiveFailed! !!OldStandardFileStream methodsFor: 'private - primitives'!primCloseNoError: id	"Close this file. Don't raise an error if the primitive fails."	<primitive: 'primitiveFileClose' module: 'FilePlugin'>! !!OldStandardFileStream methodsFor: 'private'!primDropRequestFileHandle: dropIndex	"Primitive. Return the (read-only) file handle for some file that was just dropped onto the application.	Fail if dropIndex is out of range or the primitive is not supported."	<primitive: 'primitiveDropRequestFileHandle' module:'DropPlugin'>	^nil! !!OldStandardFileStream methodsFor: 'private'!primDropRequestFileName: dropIndex	"Primitive. Return the file name for some file that was just dropped onto the application.	Fail if dropIndex is out of range or the primitive is not supported."	<primitive: 'primitiveDropRequestFileName' module:'DropPlugin'>	^nil! !!OldStandardFileStream methodsFor: 'private - primitives'!primFlush: id	"On Unix, the FilePlugin uses stdio FILE* structs which maintain their	own internal buffer to minimize write() syscalls. This flushes that buffer.	On Windows this and primSync: do the same thing."	<primitive: 'primitiveFileFlush' module: 'FilePlugin'>		"We can't ignore fflush() failing, because it can fail for any of the	reasons write() can."	self primitiveFailed! !!OldStandardFileStream methodsFor: 'private - primitives'!primGetPosition: id	"Get this files current position."	<primitive: 'primitiveFileGetPosition' module: 'FilePlugin'>	self primitiveFailed! !!OldStandardFileStream methodsFor: 'private - primitives'!primOpen: fileName writable: writableFlag	"Open a file of the given name, and return the file ID obtained.	If writableFlag is true, then		if there is none with this name, then create one		else prepare to overwrite the existing from the beginning	otherwise		if the file exists, open it read-only		else return nil"	<primitive: 'primitiveFileOpen' module: 'FilePlugin'>	^ nil! !!OldStandardFileStream methodsFor: 'private - primitives'!primRead: id into: byteArray startingAt: startIndex count: count	"Read up to count bytes of data from this file into the given string or byte array starting at the given index. Answer the number of bytes actually read."	<primitive: 'primitiveFileRead' module: 'FilePlugin'>	self closed ifTrue: [^ self error: 'File is closed'].	self error: 'File read failed'.! !!OldStandardFileStream methodsFor: 'private - primitives'!primSetPosition: id to: anInteger	"Set this file to the given position."	<primitive: 'primitiveFileSetPosition' module: 'FilePlugin'>	self primitiveFailed! !!OldStandardFileStream methodsFor: 'private - primitives'!primSize: id	"Answer the size of this file."	<primitive: 'primitiveFileSize' module: 'FilePlugin'>	self primitiveFailed! !!OldStandardFileStream methodsFor: 'private - primitives'!primSizeNoError: id	"Answer the size of this file. Answer nil if the primitive fails; this indicates that the file handle has become stale."	<primitive: 'primitiveFileSize' module: 'FilePlugin'>	^ nil! !!OldStandardFileStream methodsFor: 'private - primitives'!primSync: id	"On Unix, this syncs any written or flushed data still in the kernel file	system buffers to disk. On Windows this and primFlush: do the same thing"	<primitive: 'primitiveFileSync' module: 'FilePlugin'>	"fsync() failing cannot be ignored"	self primitiveFailed! !!OldStandardFileStream methodsFor: 'private - primitives'!primTruncate: id to: anInteger	"Truncate this file to the given position."	<primitive: 'primitiveFileTruncate' module: 'FilePlugin'>	self primitiveFailed! !!OldStandardFileStream methodsFor: 'private - primitives'!primWrite: id from: stringOrByteArray startingAt: startIndex count: count	"Write count bytes onto this file from the given string or byte array starting at the given index. Answer the number of bytes written."	<primitive: 'primitiveFileWrite' module: 'FilePlugin'>	(FileWriteError fileName: name)		signal: (self closed			ifTrue: [ 'File ', name, ' is closed' ]			ifFalse: [ 'File ', name, ' write failed' ])! !!OldStandardFileStream methodsFor: 'printing'!printOn: aStream	"Put a printed version of the receiver onto aStream."	aStream nextPutAll: self class name; nextPutAll: ': '; print: name! !!OldStandardFileStream methodsFor: 'accessing'!readInto: byteArray startingAt: startIndex count: count	"Read up to n bytes into the given byteArray.	Return the number of bytes actually read."		| newN newStartIndex available|	available := 0.	collection 		ifNil: [ 			newN := count.			newStartIndex := startIndex ]		ifNotNil: [			byteArray class isBytes 				ifFalse: [ 					position < readLimit ifTrue: [ self flushReadBuffer ].					newN := count.					newStartIndex := startIndex ]				ifTrue: [					(available := readLimit - position) > 0 						ifTrue: [							| bufferedCount |							bufferedCount := count min: available.							byteArray								replaceFrom: startIndex								to: startIndex + bufferedCount - 1								with: collection								startingAt: position + 1.							position := position + bufferedCount.							bufferedCount = count ifTrue: [ ^count ] ].					newN := count - available.					newStartIndex := startIndex + available ] ].	^available + (self primRead: fileID into: byteArray				startingAt: newStartIndex count: newN).! !!OldStandardFileStream methodsFor: 'modes'!readOnly	"Make this file read-only."	rwmode := false.! !!OldStandardFileStream methodsFor: 'copying'!readOnlyCopy	^ self class readOnlyFileNamed: self name.! !!OldStandardFileStream methodsFor: 'modes'!readWrite	"Make this file writable."	rwmode := true.! !!OldStandardFileStream methodsFor: 'registry'!register	^self class register: self! !!OldStandardFileStream methodsFor: 'open/close'!reopen	"Close and reopen this file. The file position is reset to zero."	"Details: Files that were open when a snapshot occurs are no longer valid when the snapshot is resumed. This operation re-opens the file if that has happened."	fileID ifNotNil: [		collection ifNotNil: [			position < readLimit ifTrue: [				self flushReadBuffer ] ].		self primCloseNoError: fileID ].	self open: name forWrite: rwmode.! !!OldStandardFileStream methodsFor: 'dnd requests'!requestDropStream: dropIndex	"Return a read-only stream for some file the user has just dropped onto the application."	| rawName |	rawName := self primDropRequestFileName: dropIndex.	name := FilePathEncoder decode: rawName.	fileID := self primDropRequestFileHandle: dropIndex.	fileID == nil		ifTrue: [ ^ nil ].	self register.	rwmode := false.	buffer1 := String new: 1.	self enableReadBuffering! !!OldStandardFileStream methodsFor: 'initialization'!reset	self ensureOpen.	self position: 0.! !!OldStandardFileStream methodsFor: 'positioning'!setToEnd	"Set the position of the receiver to the end of file."	self position: self size! !!OldStandardFileStream methodsFor: 'accessing'!size	"Answer the size of the file in characters."	^ self primSize: fileID! !!OldStandardFileStream methodsFor: 'positioning'!skip: n	"Set the character position to n characters from the current position.	Error if not enough characters left in the file."	collection ifNotNil: [		position < readLimit ifTrue: [			| newPosition |			((newPosition := position + n) >= 0 and: [ newPosition < readLimit ])				ifTrue: [ 					position := newPosition.					^self ] ] ].	self position: self position + n! !!OldStandardFileStream methodsFor: 'flushing'!sync	"When writing, this syncs any written/flushed data still in the kernel	file system buffers to disk. This should generally be used after #flush,	but on Windows they do the same thing."	^ self primSync: fileID! !!OldStandardFileStream methodsFor: 'positioning'!truncate	"Truncate to zero"	^ self truncate: 0! !!OldStandardFileStream methodsFor: 'positioning'!truncate: pos	"Truncate to this position"	self position: pos.	^self primTruncate: fileID to: pos! !!OldStandardFileStream methodsFor: 'registry'!unregister	^self class unregister: self! !!OldStandardFileStream methodsFor: 'accessing'!upTo: delim 	"Fast version to speed up nextChunk"	| pos buffer count |	collection ifNotNil: [		(position < readLimit and: [			(pos := collection indexOf: delim startingAt: position + 1) <= readLimit and: [				pos > 0 ] ]) ifTrue: [					^collection copyFrom: position + 1 to: (position := pos) - 1 ] ].	pos := self position.	buffer := self next: 2000.	(count := buffer indexOf: delim) > 0 ifTrue: 		["Found the delimiter part way into buffer"		self position: pos + count.		^ buffer copyFrom: 1 to: count - 1].	self atEnd ifTrue:		["Never found it, and hit end of file"		^ buffer].	"Never found it, but there's more..."	^ buffer , (self upTo: delim)! !!OldStandardFileStream methodsFor: 'accessing'!upToAnyOf: delimiters do: aBlock	"Fast version to speed up nextChunk"	| pos buffer count result |	collection ifNotNil: [		(position < readLimit and: [			(count := collection indexOfAnyOf: delimiters startingAt: position + 1) <= readLimit and: [				count > 0 ] ]) ifTrue: [					result := collection copyFrom: position + 1 to: (position := count) - 1.					aBlock value: (collection at: count).					^result ] ].	pos := self position.	buffer := self next: 2000.	(count := buffer indexOfAnyOf: delimiters) > 0 ifTrue: 		["Found one of the delimiters part way into buffer"		self position: pos + count.		aBlock value: (buffer at: count).		^ buffer copyFrom: 1 to: count - 1].	self atEnd ifTrue:		["Never found it, and hit end of file"		^ buffer].	"Never found it, but there's more..."	^ buffer , (self upToAnyOf: delimiters do: aBlock)! !!OldStandardFileStream methodsFor: 'accessing'!upToEnd	"Answer a subcollection from the current access position through the last element of the receiver."	^self collectionSpecies streamContents: [ :newStream |		| next |		[ (next := self next) == nil ] whileFalse: [			newStream nextPut: next ] ]! !!OldMultiByteBinaryOrTextStream class methodsFor: 'defaults'!defaultConverter	^ Latin1TextConverter new.! !!OldMultiByteBinaryOrTextStream class methodsFor: 'deprecation'!isDeprecated	^true! !!OldMultiByteBinaryOrTextStream class methodsFor: 'instance creation'!on: aCollection encoding: encodingName 	| aTextConverter |	encodingName 		ifNil: [aTextConverter := TextConverter default]		ifNotNil: [aTextConverter := TextConverter newForEncoding: encodingName].	^ (self on: aCollection)		converter: aTextConverter! !!OldMultiByteBinaryOrTextStream class methodsFor: 'instance creation'!with: aCollection encoding: encodingName 	| aTextConverter |	encodingName 		ifNil: [aTextConverter := TextConverter default]		ifNotNil: [aTextConverter := TextConverter newForEncoding: encodingName].	^ (self with: aCollection)		converter: aTextConverter! !!OldMultiByteBinaryOrTextStream methodsFor: 'converting'!asBinaryOrTextStream	^ self! !!OldMultiByteBinaryOrTextStream methodsFor: 'modes'!ascii	isBinary := false! !!OldMultiByteBinaryOrTextStream methodsFor: 'private'!basicNext	| nextChar |	^ isBinary		ifTrue: [super next]		ifFalse: [			(nextChar := super next)				ifNotNil: [nextChar asCharacter]].! !!OldMultiByteBinaryOrTextStream methodsFor: 'private'!basicNext: anInteger	^ super next: anInteger.! !!OldMultiByteBinaryOrTextStream methodsFor: 'private'!basicNext: n into: aString	^ self next: n into: aString.! !!OldMultiByteBinaryOrTextStream methodsFor: 'private'!basicNext: anInteger putAll: aCollection startingAt: startIndex		^super next: anInteger putAll: aCollection startingAt: startIndex! !!OldMultiByteBinaryOrTextStream methodsFor: 'private'!basicNextInto: aString	^ self nextInto: aString.! !!OldMultiByteBinaryOrTextStream methodsFor: 'private'!basicNextPut: char	^ super nextPut: char.! !!OldMultiByteBinaryOrTextStream methodsFor: 'private'!basicNextPutAll: aString	^ super nextPutAll: aString.! !!OldMultiByteBinaryOrTextStream methodsFor: 'private'!basicPeek	^ super peek! !!OldMultiByteBinaryOrTextStream methodsFor: 'private'!basicPosition	^ self position.! !!OldMultiByteBinaryOrTextStream methodsFor: 'private'!basicPosition: pos	^ self position: pos.! !!OldMultiByteBinaryOrTextStream methodsFor: 'modes'!binary	isBinary := true! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!contents	| ret state |	state := converter saveStateOf: self.	ret := self upToEnd.	converter restoreStateOf: self with: state.	^ ret.! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!converter	converter ifNil: [converter := self class defaultConverter].	^ converter! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!converter: aConverter	converter := aConverter.! !!OldMultiByteBinaryOrTextStream methodsFor: 'testing'!isBinary	^ isBinary! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!next	| n |	n := self converter nextFromStream: self.	n ifNil: [^ nil].	isBinary and: [n isCharacter ifTrue: [^ n asciiValue]].	^ n.! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!next: anInteger 	| multiString |	self isBinary ifTrue: [^ (super next: anInteger) asByteArray].	multiString := WideString new: anInteger.	1 to: anInteger do: [:index |		| character |		(character := self next) ifNotNil: [			multiString at: index put: character		] ifNil: [			multiString := multiString copyFrom: 1 to: index - 1.			^ multiString		]	].	^ multiString.! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!next: anInteger putAll: aCollection startingAt: startIndex        (self isBinary or: [ aCollection class == ByteArray ]) ifTrue: [                ^super next: anInteger putAll: aCollection startingAt: startIndex ].        ^self converter next: anInteger putAll: aCollection startingAt: startIndex toStream: self! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!nextDelimited: terminator	| out ch pos |	out := (String new: 1000) writeStream.	self atEnd ifTrue: [^ ''].	pos := self position.	self next = terminator ifFalse: [		"absorb initial terminator"		self position: pos.	].	[(ch := self next) == nil] whileFalse: [		(ch = terminator) ifTrue: [			self peek = terminator ifTrue: [				self next.  "skip doubled terminator"			] ifFalse: [				^ out contents  "terminator is not doubled; we're done!!"			].		].		out nextPut: ch.	].	^ out contents.! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!nextMatchAll: aColl    | save |    save := converter saveStateOf: self.    aColl do: [:each |       (self next) = each ifFalse: [            converter restoreStateOf: self with: save.            ^ false.		].	].    ^ true.! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!nextPut: aCharacter	^ aCharacter isInteger 		ifTrue: [ super nextPut: aCharacter asCharacter ]		ifFalse: [ self converter nextPut: aCharacter toStream: self ]! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!nextPutAll: aCollection	^ self isBinary		ifTrue: [ super nextPutAll: aCollection ]		ifFalse: [ aCollection do: [ :each | self nextPut: each ] ]! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!padToEndWith: aChar	"We don't have pages, so we are at the end, and don't need to pad."! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	| next pos |	self atEnd ifTrue: [^ nil].	pos := self position.	next := self next.	self position: pos.	^ next.! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!peekFor: item 	| next state |	"self atEnd ifTrue: [^ false]. -- SFStream will give nil"	state := converter saveStateOf: self.	(next := self next) == nil ifTrue: [^ false].	item = next ifTrue: [^ true].	converter restoreStateOf: self with: state.	^ false.! !!OldMultiByteBinaryOrTextStream methodsFor: 'initialization'!reset	super reset.	isBinary ifNil: [isBinary := false].	collection class == ByteArray ifTrue: ["Store as String and convert as needed."		collection := collection asString.		isBinary := true].	self converter. "ensure that we have a converter."! !!OldMultiByteBinaryOrTextStream methodsFor: 'file in/out'!setConverterForCode	| current |	current := converter saveStateOf: self.	self position: 0.	self binary.	((self next: 3) =  #[239 187 191]) ifTrue: [		self converter: UTF8TextConverter new	] ifFalse: [		self converter: MacRomanTextConverter new.	].	converter restoreStateOf: self with: current.	self text.! !!OldMultiByteBinaryOrTextStream methodsFor: 'file in/out'!setEncoderForSourceCodeNamed: streamName	| l |	l := streamName asLowercase.	((l endsWith: 'cs') or: [		(l endsWith: 'st') or: [			(l endsWith: ('st.gz')) or: [				(l endsWith: ('st.gz'))]]]) ifTrue: [					self converter: MacRomanTextConverter new.					^ self.	].	self converter: UTF8TextConverter new.! !!OldMultiByteBinaryOrTextStream methodsFor: 'positioning'!skipSeparators	[self atEnd] whileFalse: [		self basicNext isSeparator ifFalse: [			^ self position: self position - 1]]! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!skipSeparatorsAndPeekNext	"A special function to make nextChunk fast"	| peek pos |	[self atEnd] whileFalse: [		pos := self position.		(peek := self next) isSeparator ifFalse: [			self position: pos.			^ peek.		].	].! !!OldMultiByteBinaryOrTextStream methodsFor: 'modes'!text	isBinary := false! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!upTo: delim 	| out ch |	out := (String new: 1000) writeStream.	self atEnd ifTrue: [^ ''].	[(ch := self next) isNil] whileFalse: [		(ch = delim) ifTrue: [			^ out contents  "terminator is not doubled; we're done!!"		].		out nextPut: ch.	].	^ out contents.! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!upToEnd	| newStream element newCollection |	newCollection := self isBinary				ifTrue: [ByteArray new: 100]				ifFalse: [String new: 100].	newStream := newCollection writeStream.	[(element := self next) notNil]		whileTrue: [newStream nextPut: element].	^ newStream contents! !!OldRWBinaryOrTextStream class methodsFor: 'deprecation'!isDeprecated	^true! !!OldRWBinaryOrTextStream methodsFor: 'converting'!asBinaryOrTextStream	^ self! !!OldRWBinaryOrTextStream methodsFor: 'modes'!ascii	isBinary := false! !!OldRWBinaryOrTextStream methodsFor: 'modes'!binary	isBinary := true! !!OldRWBinaryOrTextStream methodsFor: 'accessing'!contents	"Answer with a copy of my collection from 1 to readLimit."	| newArray |	readLimit := readLimit max: position.	isBinary ifFalse: [ "String"		^ collection copyFrom: 1 to: readLimit].	newArray := ByteArray new: readLimit.	^ newArray replaceFrom: 1		to: readLimit		with: collection		startingAt: 1.! !!OldRWBinaryOrTextStream methodsFor: 'testing'!isBinary	^ isBinary! !!OldRWBinaryOrTextStream methodsFor: 'accessing'!next	| byte |	^ isBinary 			ifTrue: [byte := super next.				 byte ifNil: [nil] ifNotNil: [byte asciiValue]]			ifFalse: [super next].! !!OldRWBinaryOrTextStream methodsFor: 'accessing'!next: anInteger 	"Answer the next anInteger elements of my collection. Must override to get class right."	| newArray |	newArray := (isBinary ifTrue: [ByteArray] ifFalse: [ByteString]) new: anInteger.	^ self nextInto: newArray! !!OldRWBinaryOrTextStream methodsFor: 'accessing'!next: n into: aCollection startingAt: startIndex	"Read n objects into the given collection. 	Return aCollection or a partial copy if less than n elements have been read."	"Overriden for efficiency"	| max |	max := (readLimit - position) min: n.	aCollection 		replaceFrom: startIndex 		to: startIndex+max-1		with: collection		startingAt: position+1.	position := position + max.	max = n		ifTrue:[^aCollection]		ifFalse:[^aCollection copyFrom: 1 to: startIndex+max-1]! !!OldRWBinaryOrTextStream methodsFor: 'accessing'!next: anInteger putAll: aCollection startingAt: startIndex	"Optimized for ByteArrays"	aCollection class == ByteArray 		ifTrue:[^super next: anInteger putAll: aCollection asString startingAt: startIndex].	^super next: anInteger putAll: aCollection startingAt: startIndex! !!OldRWBinaryOrTextStream methodsFor: 'accessing'!nextPut: charOrByte	^ super nextPut: charOrByte asCharacter! !!OldRWBinaryOrTextStream methodsFor: 'accessing'!nextPutAll: aCollection	"Optimized for ByteArrays"	^ aCollection class == ByteArray 		ifTrue: [ super nextPutAll: aCollection asString ]		ifFalse: [ super nextPutAll: aCollection ]! !!OldRWBinaryOrTextStream methodsFor: 'converting'!on: aCollection	super on: aCollection.	readLimit := 0! !!OldRWBinaryOrTextStream methodsFor: 'accessing'!padToEndWith: aChar	"We don't have pages, so we are at the end, and don't need to pad."! !!OldRWBinaryOrTextStream methodsFor: 'accessing'!readInto: aCollection startingAt: startIndex count: n	"Read n objects into the given collection. 	Return number of elements that have been read."	"Overriden for efficiency"	| max |	max := (readLimit - position) min: n.	aCollection 		replaceFrom: startIndex 		to: startIndex + max - 1		with: collection		startingAt: position + 1.	position := position + max.	^ max! !!OldRWBinaryOrTextStream methodsFor: 'initialization'!reset	"Set the receiver's position to the beginning of the sequence of objects."	super reset.	isBinary ifNil: [isBinary := false].	collection class == ByteArray ifTrue: ["Store as String and convert as needed."		collection := collection asString.		isBinary := true].! !!OldRWBinaryOrTextStream methodsFor: 'modes'!text	isBinary := false! !!OldRWBinaryOrTextStream methodsFor: 'accessing'!upTo: anObject 	"Answer a subcollection from the current access position to the 	occurrence (if any, but not inclusive) of anObject in the receiver. If 	anObject is not in the collection, answer the entire rest of the receiver."	| newStream element species |	species := isBinary ifTrue:[ByteArray] ifFalse:[String].	newStream := WriteStream on: (species new: 100).	[self atEnd or: [(element := self next) = anObject]]		whileFalse: [newStream nextPut: element].	^newStream contents! !!OldRWBinaryOrTextStream methodsFor: 'accessing'!upToEnd	"Must override to get class right."	| newArray |	newArray := (isBinary ifTrue: [ByteArray] ifFalse: [ByteString]) new: self size - self position.	^ self nextInto: newArray! !!OldFileExistsException class methodsFor: 'exceptioninstantiator'!fileName: aFileName fileClass: aClass 	^ self new		fileName: aFileName;		fileClass: aClass! !!OldFileExistsException class methodsFor: 'deprecation'!isDeprecated	^true! !!OldFileExistsException methodsFor: 'exceptiondescription'!defaultAction	"The default action taken if the exception is signaled."	^ UIManager default fileExistsDefaultAction: self! !!OldFileExistsException methodsFor: 'accessing'!file		^ self fileClass fileNamed: fileName! !!OldFileExistsException methodsFor: 'accessing'!fileClass	^ fileClass ifNil: [OldStandardFileStream]! !!OldFileExistsException methodsFor: 'accessing'!fileClass: aClass	fileClass := aClass! !!OldLimitingLineStreamWrapper class methodsFor: 'examples'!example1	<sampleInstance>	"LimitingLineStreamWrapper example1"	"Separate chunks of text delimited by a special string"	| inStream msgStream messages |	inStream := self exampleStream.	msgStream := self on: inStream delimiter: 'From '.	messages := OrderedCollection new.	[inStream atEnd] whileFalse: [		msgStream skipThisLine.		messages add: msgStream upToEnd].	^messages			! !!OldLimitingLineStreamWrapper class methodsFor: 'examples'!example2	<sampleInstance>	"LimitingLineStreamWrapper example2"	"Demo nesting wrappers - get header lines from some messages"	| inStream msgStream headers headerStream |	inStream := self exampleStream.	msgStream := self on: inStream delimiter: 'From '.	headers := OrderedCollection new.	[inStream atEnd] whileFalse: [		msgStream skipThisLine. "Skip From"		headerStream := self on: msgStream delimiter: ''.		headers add: headerStream linesUpToEnd.		[msgStream nextLine isNil] whileFalse. "Skip Body"	].	^headers			! !!OldLimitingLineStreamWrapper class methodsFor: 'examples'!exampleStream	<sampleInstance>	^ 'From me@somewhereFrom: meTo: youSubject: TestTestFrom you@elsewhereFrom: youTo: meSubject: Re: testokay' readStream! !!OldLimitingLineStreamWrapper class methodsFor: 'deprecation'!isDeprecated	^true! !!OldLimitingLineStreamWrapper class methodsFor: 'instance creation'!on: aStream delimiter: aString	^self new setStream: aStream delimiter: aString! !!OldLimitingLineStreamWrapper methodsFor: 'testing'!atEnd	^line isNil or: [limitingBlock value: line]! !!OldLimitingLineStreamWrapper methodsFor: 'stream protocol'!close	^stream close! !!OldLimitingLineStreamWrapper methodsFor: 'accessing'!delimiter: aString	"Set limitBlock to check for a delimiting string. Be unlimiting if nil"	self limitingBlock: (aString caseOf: {		[nil] -> [[:aLine | false]].		[''] -> [[:aLine | aLine size = 0]]	} otherwise: [[:aLine | aLine beginsWith: aString]])! !!OldLimitingLineStreamWrapper methodsFor: 'accessing'!lastLineRead	"Return line last read. At stream end, this is the boundary line or nil"	^ line! !!OldLimitingLineStreamWrapper methodsFor: 'accessing'!limitingBlock: aBlock	"The limitingBlock is evaluated with a line to check if this line terminates the stream"	limitingBlock := aBlock.	self updatePosition! !!OldLimitingLineStreamWrapper methodsFor: 'accessing'!linesUpToEnd	| elements ln |	elements := OrderedCollection new.	[(ln := self nextLine) isNil] whileFalse: [ 		elements add: ln].	^elements! !!OldLimitingLineStreamWrapper methodsFor: 'accessing'!next	"Provide character-based access"	position ifNil: [^nil].	position < line size ifTrue: [^line at: (position := position + 1)].	line := stream nextLine.	self updatePosition.	^ Character cr! !!OldLimitingLineStreamWrapper methodsFor: 'accessing'!nextLine	| thisLine |	self atEnd ifTrue: [^nil].	thisLine := line.	line := stream nextLine.	^thisLine! !!OldLimitingLineStreamWrapper methodsFor: 'accessing'!peekLine	self atEnd ifTrue: [^nil].	^ line! !!OldLimitingLineStreamWrapper methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' on '.	stream printOn: aStream! !!OldLimitingLineStreamWrapper methodsFor: 'private'!setStream: aStream delimiter: aString	stream := aStream.	line := stream nextLine.	self delimiter: aString.	"sets position"! !!OldLimitingLineStreamWrapper methodsFor: 'accessing'!skipThisLine	line := stream nextLine.	self updatePosition.! !!OldLimitingLineStreamWrapper methodsFor: 'accessing'!upToEnd		^String streamContents: [:strm | | ln |		[(ln := self nextLine) isNil] whileFalse: [ 			strm nextPutAll: ln; cr]]! !!OldLimitingLineStreamWrapper methodsFor: 'accessing'!updatePosition	"Call this before doing character-based access"	position := self atEnd ifFalse: [0]! !"OldFileStream"!!OSPlatform methodsFor: '*FFICHeaderExtractor'!cHeaderExtractorFor: aSharedPool	"IMPORATNT: first read comment of FFISharedPool #cHeaderExtractorFor:	Subclass should likely check if platform is 32 or 64 bits and depending on that	send the correct method (from 'platform' protocol) to FFISharedPool.		Answers an instance of a FFICHeaderExtractor specially created for this platform.	"	^ self subclassResponsibility ! !!MacOSXPlatform methodsFor: '*FFICHeaderExtractor'!cHeaderExtractorFor: aSharedPool	"Read comment of superclass first.	So far there is none 64 bits VMs"	^ aSharedPool macOSX32Extractor! !!UnixPlatform methodsFor: '*FFICHeaderExtractor'!cHeaderExtractorFor: aSharedPool	"Read comment of superclass first.	So far there is none 64 bits VMs"	^ aSharedPool unix32Extractor! !!FFICHeaderExtractor class methodsFor: 'accessing'!autogeneratedMethodProtocol	^ 'autogenerated by FFICHeaderExtractor'! !!FFICHeaderExtractor methodsFor: 'filenames'!autogeneratedMethodName	"Answers the name/selector of the autogenerated init method. Examples of names are 'initVariablesMacOS32', 'initVariablesunix32', etc "	^ ('initVariables', (self platformName copyWithout: Character space) , (self wordSize * 8) asString)		! !!FFICHeaderExtractor methodsFor: 'filenames'!basicGeneralFilename	"For internal usage only. It answers the base filname from which we then base the C program filename, the binary, the log,  the output, etc"	^ self sharedPool name , '.', self platformName ! !!FFICHeaderExtractor methodsFor: 'filenames'!binaryFilename	"Answers the filename for the compiled C program, that is, the binary file. This is typically the argument to the '-o' in gcc and cc."	^ self basicGeneralFilename , '.o'! !!FFICHeaderExtractor methodsFor: 'method generation'!buildMethodSource	"This method creates the source of a Smalltalk method that would initialize the class vars of the shared pool with the values obtained from the output file of the C program"	| sourceStream ouput | 	sourceStream := String new writeStream.	ouput := self outputFilename asFileReference readStream contents.	"The output file of the C program is a literal array that looks like this:	#(SIGKILL 9 4)	#(UNDEFINED-SIGLOST 0 0)	#(SIGPIPE 13 4)	"	sourceStream nextPutAll: self autogeneratedMethodName; cr.	sourceStream nextPutAll: '"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"'; cr.	sourceStream tab; nextPutAll: '<platformName: '''; nextPutAll: FFISharedPool currentPlatformName; nextPutAll: ''' wordSize: '; nextPutAll: FFISharedPool currentWordSize asString; nextPutAll:'>'; cr.	ouput linesDo: [ :aLine | 		| array |		array := self class compilerClass new evaluate: aLine. 		((array first beginsWith: 'UNDEFINED') and: [ array third = 0 ])			ifTrue: [ 				"Undefined constants will be written in the method like this: 				WHATEVER := nil.""WHATEVER is UNDEFINED for this platform""				"				sourceStream tab.				sourceStream nextPutAll: (array first allButFirst: 'UNDEFINED' size); nextPutAll: ' := nil.'.				sourceStream nextPutAll: '"'.				sourceStream nextPutAll: (array first allButFirst: 'UNDEFINED' size).				sourceStream nextPutAll: ' is UNDEFINED for this platform'.				sourceStream nextPutAll: '"'.			]			ifFalse: [  				"Defined constants will be written like:				SIGKILL := 9.				"				sourceStream tab; nextPutAll: array first; nextPutAll: ' := '; nextPutAll: array second asString; nextPutAll: '.' ].		sourceStream cr.	].	^ sourceStream contents! !!FFICHeaderExtractor methodsFor: 'accessing'!cFlags	^ cFlags! !!FFICHeaderExtractor methodsFor: 'accessing'!cFlags: anObject	cFlags := anObject! !!FFICHeaderExtractor methodsFor: 'filenames'!cProgramFilename	"Answers the filename for the autogenerated C program."	^ self basicGeneralFilename , '.c'! !!FFICHeaderExtractor methodsFor: 'running C program'!compileCProgram	"This method takes care of compiling the autogenerated C program. The following is an example of a compilation command for the shared pool FFITestingSharedPool for MacOSX 32 bits:		cd /Users/mariano/pharo/imagenes; cc -m32 -o 'FFITestingSharedPool.Mac OS.o' 'FFITestingSharedPool.Mac OS.c' > 'FFITestingSharedPool.Mac OS.log' 2>&1 		As you can see, STDOUT and STDERR are redirected to #logFilename for analysis in case of errors.	"	| compileScriptStream | 	compileScriptStream := String new writeStream.	compileScriptStream nextPutAll: 'cd ', FileSystem workingDirectory fullName, '; '.	compileScriptStream nextPutAll: self compiler.	compileScriptStream nextPutAll: ' '.	compileScriptStream nextPutAll: self cFlags.	compileScriptStream nextPutAll: ' -o '.	compileScriptStream nextPutAll: '"', self binaryFilename, '"'.	compileScriptStream nextPutAll: ' '.	compileScriptStream nextPutAll: '"', self cProgramFilename, '"'.	compileScriptStream nextPutAll: ' > '.	compileScriptStream nextPutAll: '"', self logFilename, '"'.	compileScriptStream nextPutAll: ' 2>&1 '.	"Transcript show: 'Compile string: ', compileScriptStream contents; cr."	self executeOSShellCommand: compileScriptStream contents.	! !!FFICHeaderExtractor methodsFor: 'accessing'!compiler	^ compiler! !!FFICHeaderExtractor methodsFor: 'accessing'!compiler: anObject	compiler := anObject! !!FFICHeaderExtractor methodsFor: 'running C program'!executeOSShellCommand: aCommandString	"To perform the OS command, this method simply does a system() call via FFI. "	self flag: #fixIt.	"This won't work for Windows as it doesn't have system() function."	self system: aCommandString! !!FFICHeaderExtractor methodsFor: 'extracting'!extractAndStoreHeadersInformation	"Main API method used by FFISharedPool. It first extracts all the constants values (defined in C header files) and then creates a smalltalk init method which is then compiled/installed in the shared pool"	self extractHeadersInformation.		self storeFromExtracted.! !!FFICHeaderExtractor methodsFor: 'extracting'!extractHeadersInformation	"This method takes care of extracting all the constants values of a FFISharedPool from C header files. The way it does this is by first autogenerating a C program that will write down into an output text file, each constant and its value. Then such C program is compiled and run."	| log |	[	self 		generateCProgram;		compileCProgram;		runCProgram.	] on: Error do: [ :ex | 		self error: 'Error: ', ex printString. '. You may want to check ', self logFilename	].	log := self logFilename asFileReference readStream contents.	log ifNotEmpty: [ 		log inspect.		self inform: 'There was a problem in the autogeneration. You may want to check ', self logFilename		 ].		! !!FFICHeaderExtractor methodsFor: 'primitives'!ffiLibraryName 	^ LibC ! !!FFICHeaderExtractor methodsFor: 'generating C program'!generateCProgram	"This method is the one that finally autogenereates the C program"		self cProgramFilename asFileReference 		ensureDelete;		writeStreamDo: [ :stream |			self writeCMainCommentOn: stream.			self writeCIncludesOn: stream.			self writeRestOfCFileOn: stream.	]! !!FFICHeaderExtractor methodsFor: 'accessing'!headersToInclude	^ headersToInclude! !!FFICHeaderExtractor methodsFor: 'accessing'!headersToInclude: anObject	headersToInclude := anObject! !!FFICHeaderExtractor methodsFor: 'accessing'!includeFiles	^ includeFiles! !!FFICHeaderExtractor methodsFor: 'accessing'!includeFiles: anObject	includeFiles := anObject! !!FFICHeaderExtractor methodsFor: 'filenames'!logFilename	"Answers the log filename in which we redirect stdout and stderr in both, the compilation and execution of the C program"	^  self basicGeneralFilename, '.log'! !!FFICHeaderExtractor methodsFor: 'filenames'!outputFilename	"Answers the filename for the output file (that contains all the names and values of the constants) that the C program will write when executed"	^  self basicGeneralFilename, '.output'! !!FFICHeaderExtractor methodsFor: 'primitives'!perror: aMessage	"Prints the errno gloabl variable into the stderr together with aMessage string	and then signal an error"	self primitivePerror: aMessage.	self error: 'Error: ', aMessage,' You may want to check errors in stderr'! !!FFICHeaderExtractor methodsFor: 'accessing'!platformName	^ platformName! !!FFICHeaderExtractor methodsFor: 'accessing'!platformName: anObject	platformName := anObject! !!FFICHeaderExtractor methodsFor: 'primitives'!primitivePerror: anErrorString	^ self ffiCall: #( void perror(String anErrorString) )! !!FFICHeaderExtractor methodsFor: 'primitives'!primitiveSystem: commandString	 ^ self ffiCall: #(int system(char* commandString) ) 		! !!FFICHeaderExtractor methodsFor: 'running C program'!runCProgram	"This method takes care of executing the autogenerated and compiled C program. The following is an example of a execution command for the shared pool FFITestingSharedPool for MacOSX 32 bits:		cd /Users/mariano/pharo/imagenes; ./'FFITestingSharedPool.Mac OS.o' >> 'FFITestingSharedPool.Mac OS.log' 2>&1 		As you can see, STDOUT and STDERR are redirected to #logFilename for analysis in case of errors.	"		| runCStream | 	runCStream := String new writeStream.	runCStream nextPutAll: 'cd ', FileSystem workingDirectory fullName, '; '.	runCStream nextPutAll: './', '"', self binaryFilename, '"'.	runCStream nextPutAll: ' >> '.	runCStream nextPutAll: '"', self logFilename, '"'.	runCStream nextPutAll: ' 2>&1 '.	"Transcript show: 'Execute C program string: ', runCStream contents; cr."	self executeOSShellCommand: runCStream contents.	! !!FFICHeaderExtractor methodsFor: 'accessing'!sharedPool	^ sharedPool! !!FFICHeaderExtractor methodsFor: 'accessing'!sharedPool: anObject	sharedPool := anObject! !!FFICHeaderExtractor methodsFor: 'method generation'!storeFromExtracted	"This method first takes the output file generated by the C program and creates a Smalltalk init method that would set the constants values extracted into the shared pool class variables. Then, the created method is stored in the shared pool class."	| methodSource |	methodSource := self buildMethodSource.	self sharedPool class compile: methodSource classified: self class autogeneratedMethodProtocol! !!FFICHeaderExtractor methodsFor: 'primitives'!system: aCommandString	"Executes aCommandString in the OS via the system() call."	| returnValue |	returnValue := self primitiveSystem: aCommandString.	(returnValue = -1) ifTrue: [ 		self perror: 'system()'		].	^ returnValue ! !!FFICHeaderExtractor methodsFor: 'accessing'!wordSize	^ wordSize! !!FFICHeaderExtractor methodsFor: 'accessing'!wordSize: anObject	wordSize := anObject! !!FFICHeaderExtractor methodsFor: 'generating C program'!writeCInclude: aHeaderName on: aStream	"Internal method for the C program creation. Giving aHeaderName like 'signal.h' this method writes the C #include definition."	aStream 		nextPutAll: '#include <';		nextPutAll: aHeaderName;		nextPutAll: '>';		cr.	! !!FFICHeaderExtractor methodsFor: 'generating C program'!writeCIncludes: aListOfHeaderNames on: stream	"Internal method for the C program creation. It writes each of the user-defined header names (aListOfHeaderNames) as a C #include definition."	aListOfHeaderNames do: [ :each | self writeCInclude: each on: stream ]! !!FFICHeaderExtractor methodsFor: 'generating C program'!writeCIncludesOn: stream	"Internal method for the C program creation. It writes C #include definitions for all the header names. It includes the mandatry ones for our C program (such as stdio.h and stdlib.h) and then all the user-defined ones which should define the constants defined as class variables in the shared pool."	self writeCIncludes: #('stdio.h' 'stdlib.h') on: stream.	self writeCIncludes: self headersToInclude on: stream.	stream cr.		! !!FFICHeaderExtractor methodsFor: 'generating C program'!writeCMainCommentOn: stream	"Internal method for the C program creation. This one just writes a general comment at the beginning."	stream nextPutAll: ('//////  Program automatically generated on <1s> by FFICHeaderExtractor.// For more details, see https://github.com/marianopeck/FFICHeaderExtractor////'	expandMacrosWith: Date today yyyymmdd ).	stream cr.! !!FFICHeaderExtractor methodsFor: 'generating C program'!writeListOfConstantsOn: aStream	"Internal method for the C program creation. This one iterates each class variable of the shared pool and calls the correct function to write the values into the output file."	self sharedPool classVarNames withIndexDo: [ :each :index |		aStream nextPutAll: (('	#ifdef <1s>		printDefinedConstant(file, <1s>);	#else		printUndefinedConstant(file, <1s>);	#endif') expandMacrosWith: each); cr	].	! !!FFICHeaderExtractor methodsFor: 'generating C program'!writeRestOfCFileOn: stream	"Internal method for the C program creation. This one writes the end of the file, including the main(), the definition of our functions, and the opening of the FILE stream for the output. printDefinedConstant() and printUndefinedConstant() are called for each constant."	stream cr.	stream nextPutAll: '#define printDefinedConstant(file, const) fprintf(file, "#(%s %d %ld)\n", #const, const, sizeof(const))	#define printUndefinedConstant(file, const) fprintf(file, "#(UNDEFINED%s %d %d)\n", #const, 0, 0)	int main(int argc, const char * argv[]) {	    FILE *file = fopen("', self outputFilename, '", "w");	    if (file == NULL)	    {	        printf("Error opening file!!\n");	        exit(1);	    }	'.	self writeListOfConstantsOn: stream. 	stream nextPutAll: '	    fclose(file);    	    return 0;	}	'! !!FFISharedPool class methodsFor: 'methods generation'!allAutogeneratedMethodSelectors	"Answers the list of all the selectors of this class that are init methods autogenerated by FFICHeaderExtractor"	^ self class allSelectorsInProtocol: FFICHeaderExtractor autogeneratedMethodProtocol.! !!FFISharedPool class methodsFor: 'accessing'!cHeaderExtractor	"This is a double dispatch with the OSPlatform class. Each platform should be respoonsible of sending the correct message to the shared pool (methods under protocol 'platforms') based on the current platform information (like wether it is 32 or 64 bits), such as unix32Extractor, macOSX32Extractor, etc.	Answers an instance of a FFICHeaderExtractor specially created for current platform."	^ Smalltalk os cHeaderExtractorFor: self! !!FFISharedPool class methodsFor: 'accessing'!currentPlatformName	"Answers the platform name of the current platform"	^ Smalltalk os platformName! !!FFISharedPool class methodsFor: 'accessing'!currentWordSize	"Answers the word size of the current platform. This could be either 32 or 64. Right now the way we obtain this is via FFIExternalType"	^ FFIExternalType sizeOf: #int! !!FFISharedPool class methodsFor: 'testing'!didPlatformChange	"Answers whether this shared pool was initialized for the same platform as the current one. In other words, it answers whether the platform has changed."	^ ((self platformName = self currentPlatformName) and: [ self wordSize = self currentWordSize ]) not ! !!FFISharedPool class methodsFor: 'extracting'!extractAndStoreHeadersInformation	"Read the comment of FFICHeaderExtractor >> extractAndStoreHeadersInformation"	self cHeaderExtractor extractAndStoreHeadersInformation.! !!FFISharedPool class methodsFor: 'testing'!hasAlreadyBeenInitializedBefore	"Answers whether this shared pool was already initialized before or not"	^ self platformName notNil and: [ self wordSize notNil ] ! !!FFISharedPool class methodsFor: 'accessing'!headersContainingVariables	"Answers an array with the `C` header names that define all the defined constants of this SharedPool. Subclasses can override and define their own C headers."	^ self subclassResponsibility ! !!FFISharedPool class methodsFor: 'initialize - release'!initialize	self flag: #removeIt.	"This IF will be eliminated soon...only here temporary"	(SystemVersion current highestUpdate >= 50558)		ifTrue: [ 			SessionManager default registerToolClassNamed: self name			 ]		ifFalse: [ 			Smalltalk addToStartUpList: self. 		]	! !!FFISharedPool class methodsFor: 'variables initialization'!initializeVariables	"This method does the lookup for an autogenerated init method for this platform. If found, then initialize from it. If not found, then do nothing."	| selector |	selector := self lookupInitMethodForCurrentPlatform.	selector ifNotNil: [ 		self initializeVariablesFrom: selector.		self updatePlatformInfo.	] ! !!FFISharedPool class methodsFor: 'variables initialization'!initializeVariablesFrom: aSelector	"Initializes the class variables of this shared pool with the autogenerated init method aSelector"	aSelector ifNotNil: [ self perform: aSelector. ]	! !!FFISharedPool class methodsFor: 'DEPRECATED'!initializeVariablesFromStonExtracted	| stonStream parsedDict |	stonStream := (Smalltalk os cHeaderExtractorFor: self) outputFilename asFileReference readStream. 	parsedDict := STON fromStream: stonStream.	"The STON file looks like this:	{        'SIGHUP' : [                1,                4        ],        'SIGKILL' : [                9,                4        ],        'SIGTERM' : [                15,                4        ]}	"	parsedDict keysAndValuesDo: [ :key :value |		self classVarNamed: key put: value first.	 	]! !!FFISharedPool class methodsFor: 'variables initialization'!initializeVariablesIfNeeded	"If this shared pool shared pool should be initialized, then let's do it!!"	self shouldInitializeVariables ifTrue: [ 		self initializeVariables.	]	! !!FFISharedPool class methodsFor: 'methods generation'!lookupInitMethodForCurrentPlatform	"This method searches an autogenerated init method for the current platform. The lookup basically means checking the selectors in a specific protocol and search for the one (if exists) with the pragma matching the #platformName and #wordSize of the current platform. If found, it answers the selector. If not found, it answers nil. "	| selectors |	selectors := self allAutogeneratedMethodSelectors. 	^ selectors detect: [ :each | 		| method arguments |		method := self class compiledMethodAt: each. 		arguments := (method pragmaAt: #platformName:wordSize:) arguments.		(arguments first = self currentPlatformName) 			and: [ (arguments second = self currentWordSize) ]	] ifNone: [ 		"IMPORTANT: Here we cannot throw an error becasue this method is called from the startup code (from startUp: -> initializeVariablesIfNeeded) and if we throw an error during statup, the image shutsdown and doesn't start anymore."		Transcript show: 'There is no autogenerated init method for platform name ', self currentPlatformName, ' and word size ', self currentWordSize asString; cr.		nil ]! !!FFISharedPool class methodsFor: 'platforms'!macOSX32Extractor	"This is the default setup of a FFICHeaderExtractor for OSX 32 bits. Shared pool subclasses may need to override this if they want to add or change the default settings. For example, setting #includeFiles: to custom directories."	^ FFICHeaderExtractor new		sharedPool: self;		platformName: 'Mac OS'; "IMPORTANT: Should match with 'Smalltalk os platformName ' "		wordSize: 4;		cFlags: '-m32';		headersToInclude: self headersContainingVariables;		compiler: 'cc';		yourself! !!FFISharedPool class methodsFor: 'accessing'!platformName	^ platformName! !!FFISharedPool class methodsFor: 'accessing'!platformName: aString	platformName := aString! !!FFISharedPool class methodsFor: 'methods generation'!removeAllGeneratedMethods	"This is a facility method, likely only used for tests. It simply removes all the autogenerated init methods from this shared pool"	self allAutogeneratedMethodSelectors do: [ :each |		self class removeSelector: each.		]! !!FFISharedPool class methodsFor: 'resetting'!reset	"Simply resets the none-constants class vars of this shared pool. Only used for testing right now."	platformName := nil.	wordSize := nil.! !!FFISharedPool class methodsFor: 'testing'!shouldInitializeVariables	"We should initialize variables if: 1) the platform has changed (for example, if this image was now started in a different OS) or if 2) the class variables where never initialized before."	^ self hasAlreadyBeenInitializedBefore not or: [ self didPlatformChange ]! !!FFISharedPool class methodsFor: 'system startup'!startUp: resuming	"If 'resuming' is true, it means the image is being started. It's time then to iterate every subclass and initialize the class variables from the autogenerated init methods, for those subclasses that need such an initialization."	resuming ifTrue: [ 		self allSubclassesDo: [ :each | each initializeVariablesIfNeeded ]		]! !!FFISharedPool class methodsFor: 'platforms'!unix32Extractor	"This is the default setup of a FFICHeaderExtractor for Unix 32 bits. Shared pool subclasses may need to override this if they want to add or change the default settings. For example, setting #includeFiles: to custom directories."	^ FFICHeaderExtractor new		sharedPool: self;		platformName: 'unix'; "Should match with 'Smalltalk os platformName ' "		wordSize: 4;		cFlags: '-m32';		headersToInclude: self headersContainingVariables;		compiler: 'gcc';		yourself! !!FFISharedPool class methodsFor: 'variables initialization'!updatePlatformInfo	"Updates this shared pool with the info of the current platform."	platformName := self currentPlatformName.	wordSize := self currentWordSize.! !!FFISharedPool class methodsFor: 'accessing'!wordSize	^ wordSize! !!FFISharedPool class methodsFor: 'accessing'!wordSize: aNumber	wordSize := aNumber! !"FFICHeaderExtractor"!!FFICHeaderExtractorTest methodsFor: 'tests'!testBuildMethodSource	| extractor methodSource | 	extractor := self testingSharedPool cHeaderExtractor.	extractor 		generateCProgram;		compileCProgram;		runCProgram.	methodSource := extractor buildMethodSource.	self assert: (methodSource beginsWith: 'initVariables').	self assert: (methodSource includesSubstring: '<platformName:').	self assert: (methodSource includesSubstring: 'wordSize:').	self assert: (methodSource includesSubstring: '"WHATEVER is UNDEFINED for this platform"').	self assert: (methodSource includesSubstring: 'SIGKILL := 9.').	self assert: (methodSource includesSubstring: 'EINVAL := 22.').	self assert: methodSource lines size equals: 8. ! !!FFICHeaderExtractorTest methodsFor: 'tests'!testCProgramOutput	| extractor output | 	extractor := self testingSharedPool cHeaderExtractor.	extractor outputFilename asFileReference ensureDelete.	extractor 		generateCProgram;		compileCProgram;		runCProgram.	output := extractor outputFilename asFileReference readStream contents.	self assert: (output includesSubstring: '#(UNDEFINEDWHATEVER 0 0)').	self assert: (output includesSubstring: '#(SIGKILL 9').	self assert: (output includesSubstring: '#(EINVAL 22').	self assert: output lines size equals: 5. ! !!FFICHeaderExtractorTest methodsFor: 'tests'!testCompileCProgram	| extractor | 	extractor := self testingSharedPool cHeaderExtractor.	extractor binaryFilename asFileReference ensureDelete.	extractor 		generateCProgram;		compileCProgram.	self assert: extractor binaryFilename asFileReference exists.	self assert: extractor binaryFilename asFileReference size > 100.! !!FFICHeaderExtractorTest methodsFor: 'tests'!testGenerateCProgram	| extractor cProgram | 	extractor := self testingSharedPool cHeaderExtractor.	extractor generateCProgram.	cProgram := extractor cProgramFilename asFileReference readStream contents.	self assert: (cProgram includesSubstring: '#include <signal.h>').	self assert: (cProgram includesSubstring: '#include <errno.h>').	self assert: (cProgram includesSubstring: '#ifdef SIGKILL		printDefinedConstant(file, SIGKILL);	#else		printUndefinedConstant(file, SIGKILL);	#endif	#ifdef SIGTERM		printDefinedConstant(file, SIGTERM);	#else		printUndefinedConstant(file, SIGTERM);	#endif	#ifdef WHATEVER		printDefinedConstant(file, WHATEVER);	#else		printUndefinedConstant(file, WHATEVER);	#endif')	! !!FFICHeaderExtractorTest methodsFor: 'tests'!testRunCProgram	| extractor | 	extractor := self testingSharedPool cHeaderExtractor.	extractor outputFilename asFileReference ensureDelete.	extractor 		generateCProgram;		compileCProgram;		runCProgram.	self assert: extractor outputFilename asFileReference exists.	self assert: extractor outputFilename asFileReference size > 10.! !!FFICHeaderExtractorTest methodsFor: 'tests'!testStoreMethod	| extractor | 	extractor := self testingSharedPool cHeaderExtractor.	extractor 		generateCProgram;		compileCProgram;		runCProgram;		extractAndStoreHeadersInformation.		self assert: (self testingSharedPool class includesSelector: extractor autogeneratedMethodName asSymbol).! !!FFICHeaderExtractorTest methodsFor: 'accessing'!testingSharedPool	^ FFITestingSharedPool! !!FFISharedPoolTest methodsFor: 'tests'!testChangePlatformAndTestingMethods	self testingSharedPool reset; updatePlatformInfo.	self deny: self testingSharedPool platformName isNil.	self deny: self testingSharedPool wordSize isNil.	self assert: self testingSharedPool hasAlreadyBeenInitializedBefore.	self testingSharedPool platformName: 'whatever'. 	self assert: self testingSharedPool shouldInitializeVariables.	self assert: self testingSharedPool didPlatformChange.	! !!FFISharedPoolTest methodsFor: 'tests'!testInitializeVariables	self testingSharedPool 		reset;		extractAndStoreHeadersInformation.	self assert: self testingSharedPool shouldInitializeVariables.	self testingSharedPool initializeVariablesIfNeeded. 	self assert: self testingSharedPool platformName equals: FFISharedPool currentPlatformName.	self assert: self testingSharedPool wordSize equals: FFISharedPool currentWordSize.	self assert: (self testingSharedPool classVarNamed: 'SIGKILL') equals: 9.	self assert: (self testingSharedPool classVarNamed: 'EINVAL') equals: 22.	self assert: (self testingSharedPool classVarNamed: 'WHATEVER') isNil.		! !!FFISharedPoolTest methodsFor: 'tests'!testInitializeVariablesWithNoMethodFound	self testingSharedPool reset.	self testingSharedPool removeAllGeneratedMethods.	self testingSharedPool classVarNamed: 'SIGKILL' put: 42.	self assert: self testingSharedPool shouldInitializeVariables.	self testingSharedPool initializeVariablesIfNeeded.	self assert: self testingSharedPool platformName isNil.	self assert: self testingSharedPool wordSize isNil.	"Class variables are untouched if the initialize does not run"	self assert: (self testingSharedPool classVarNamed: 'SIGKILL') equals: 42.		! !!FFISharedPoolTest methodsFor: 'tests'!testLookupInitMethodForCurrentPlatform	self testingSharedPool 		reset;		extractAndStoreHeadersInformation.	self testingSharedPool class compile: 'initVariablesWhatever32		<platformName: ''Whatever'' wordSize: 4>	EACCES := 13.	EINVAL := 22.	SIGKILL := 9.	SIGTERM := 15.	"WHATEVER is UNDEFINED for this platform"	' classified: 'autogenerated by FFICHeaderExtractor'.	self assert: self testingSharedPool cHeaderExtractor autogeneratedMethodName asString equals: self testingSharedPool lookupInitMethodForCurrentPlatform asString. 	! !!FFISharedPoolTest methodsFor: 'tests'!testRemoveAllGeneratedMethods	self testingSharedPool 		reset; 		extractAndStoreHeadersInformation.	self assert: self testingSharedPool  allAutogeneratedMethodSelectors size >= 1.		self testingSharedPool removeAllGeneratedMethods.	self assert: self testingSharedPool  allAutogeneratedMethodSelectors isEmpty.		! !!FFISharedPoolTest methodsFor: 'tests'!testResetAndTestingMethods	self testingSharedPool classVarNamed: 'SIGKILL' put: 9.	self testingSharedPool reset. 	"Class variables values are not reset"	self assert: (self testingSharedPool classVarNamed: 'SIGKILL') isNil not.	self assert: self testingSharedPool platformName isNil.	self assert: self testingSharedPool wordSize isNil.	self deny: self testingSharedPool hasAlreadyBeenInitializedBefore.	self assert: self testingSharedPool shouldInitializeVariables.! !!FFISharedPoolTest methodsFor: 'accessing'!testingSharedPool	^ FFITestingSharedPool ! !!FFITestingSharedPool class methodsFor: 'accessing'!headersContainingVariables	^ #( 'signal.h' 'errno.h' )! !!FFITestingSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor'!initVariablesMacOS32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'Mac OS' wordSize: 4>	EACCES := 13.	EINVAL := 22.	SIGKILL := 9.	SIGTERM := 15.	WHATEVER := nil."WHATEVER is UNDEFINED for this platform"! !!FFITestingSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor'!initVariablesunix32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'unix' wordSize: 4>	EACCES := 13.	EINVAL := 22.	SIGKILL := 9.	SIGTERM := 15.	WHATEVER := nil."WHATEVER is UNDEFINED for this platform"! !"FFICHeaderExtractor-Tests"!!LibCErrnoSharedPool commentStamp: '' prior: 0!The class variables of this class was manually extracted from: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/errno.h.html!!LibCFcntlSharedPool commentStamp: '' prior: 0!The class variables of this class was manually extracted from: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/fcntl.h.html!!LibCWaitSharedPool commentStamp: '' prior: 0!The class variables of this class was manually extracted from: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_wait.h.html!!LibCErrnoSharedPool class methodsFor: 'accessing'!headersContainingVariables	^ #( 'errno.h' )! !!LibCErrnoSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor'!initVariablesMacOS32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'Mac OS' wordSize: 4>	E2BIG := 7.	EACCES := 13.	EADDRINUSE := 48.	EADDRNOTAVAIL := 49.	EAFNOSUPPORT := 47.	EAGAIN := 35.	EALREADY := 37.	EBADF := 9.	EBADMSG := 94.	EBUSY := 16.	ECANCELED := 89.	ECHILD := 10.	ECONNABORTED := 53.	ECONNREFUSED := 61.	ECONNRESET := 54.	EDEADLK := 11.	EDESTADDRREQ := 39.	EDOM := 33.	EDQUOT := 69.	EEXIST := 17.	EFAULT := 14.	EFBIG := 27.	EHOSTUNREACH := 65.	EIDRM := 90.	EILSEQ := 92.	EINPROGRESS := 36.	EINTR := 4.	EINVAL := 22.	EIO := 5.	EISCONN := 56.	EISDIR := 21.	ELOOP := 62.	EMFILE := 24.	EMLINK := 31.	EMSGSIZE := 40.	EMULTIHOP := 95.	ENAMETOOLONG := 63.	ENETDOWN := 50.	ENETRESET := 52.	ENETUNREACH := 51.	ENFILE := 23.	ENOBUFS := 55.	ENODATA := 96.	ENODEV := 19.	ENOENT := 2.	ENOEXEC := 8.	ENOLCK := 77.	ENOLINK := 97.	ENOMEM := 12.	ENOMSG := 91.	ENOPROTOOPT := 42.	ENOSPC := 28.	ENOSR := 98.	ENOSTR := 99.	ENOSYS := 78.	ENOTCONN := 57.	ENOTDIR := 20.	ENOTEMPTY := 66.	ENOTRECOVERABLE := 104.	ENOTSOCK := 38.	ENOTSUP := 45.	ENOTTY := 25.	ENXIO := 6.	EOPNOTSUPP := 102.	EOVERFLOW := 84.	EOWNERDEAD := 105.	EPERM := 1.	EPIPE := 32.	EPROTO := 100.	EPROTONOSUPPORT := 43.	EPROTOTYPE := 41.	ERANGE := 34.	EROFS := 30.	ESPIPE := 29.	ESRCH := 3.	ESTALE := 70.	ETIME := 101.	ETIMEDOUT := 60.	ETXTBSY := 26.	EWOULDBLOCK := 35.	EXDEV := 18.! !!LibCErrnoSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor'!initVariablesunix32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'unix' wordSize: 4>	E2BIG := 7.	EACCES := 13.	EADDRINUSE := 98.	EADDRNOTAVAIL := 99.	EAFNOSUPPORT := 97.	EAGAIN := 11.	EALREADY := 114.	EBADF := 9.	EBADMSG := 74.	EBUSY := 16.	ECANCELED := 125.	ECHILD := 10.	ECONNABORTED := 103.	ECONNREFUSED := 111.	ECONNRESET := 104.	EDEADLK := 35.	EDESTADDRREQ := 89.	EDOM := 33.	EDQUOT := 122.	EEXIST := 17.	EFAULT := 14.	EFBIG := 27.	EHOSTUNREACH := 113.	EIDRM := 43.	EILSEQ := 84.	EINPROGRESS := 115.	EINTR := 4.	EINVAL := 22.	EIO := 5.	EISCONN := 106.	EISDIR := 21.	ELOOP := 40.	EMFILE := 24.	EMLINK := 31.	EMSGSIZE := 90.	EMULTIHOP := 72.	ENAMETOOLONG := 36.	ENETDOWN := 100.	ENETRESET := 102.	ENETUNREACH := 101.	ENFILE := 23.	ENOBUFS := 105.	ENODATA := 61.	ENODEV := 19.	ENOENT := 2.	ENOEXEC := 8.	ENOLCK := 37.	ENOLINK := 67.	ENOMEM := 12.	ENOMSG := 42.	ENOPROTOOPT := 92.	ENOSPC := 28.	ENOSR := 63.	ENOSTR := 60.	ENOSYS := 38.	ENOTCONN := 107.	ENOTDIR := 20.	ENOTEMPTY := 39.	ENOTRECOVERABLE := 131.	ENOTSOCK := 88.	ENOTSUP := 95.	ENOTTY := 25.	ENXIO := 6.	EOPNOTSUPP := 95.	EOVERFLOW := 75.	EOWNERDEAD := 130.	EPERM := 1.	EPIPE := 32.	EPROTO := 71.	EPROTONOSUPPORT := 93.	EPROTOTYPE := 91.	ERANGE := 34.	EROFS := 30.	ESPIPE := 29.	ESRCH := 3.	ESTALE := 116.	ETIME := 62.	ETIMEDOUT := 110.	ETXTBSY := 26.	EWOULDBLOCK := 11.	EXDEV := 18.! !!LibCErrnoSharedPool class methodsFor: 'initialize - release'!initialize	self initializeVariables	! !!LibCFcntlSharedPool class methodsFor: 'accessing'!headersContainingVariables	^ #( 'fcntl.h' )! !!LibCFcntlSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor'!initVariablesMacOS32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'Mac OS' wordSize: 4>	AT_EACCESS := 16.	AT_FDCWD := -2.	AT_SYMLINK_FOLLOW := 64.	AT_SYMLINK_NOFOLLOW := 32.	FD_CLOEXEC := 1.	F_DUPFD := 0.	F_DUPFD_CLOEXEC := 67.	F_GETFD := 1.	F_GETFL := 3.	F_GETLK := 7.	F_GETOWN := 5.	F_RDLCK := 1.	F_SETFD := 2.	F_SETFL := 4.	F_SETLK := 8.	F_SETLKW := 9.	F_SETOWN := 6.	F_UNLCK := 2.	F_WRLCK := 3.	O_ACCMODE := 3.	O_APPEND := 8.	O_CLOEXEC := 16777216.	O_CREAT := 512.	O_DIRECTORY := 1048576.	O_DSYNC := 4194304.	O_EXCL := 2048.	O_EXEC := nil."O_EXEC is UNDEFINED for this platform"	O_NOCTTY := 131072.	O_NOFOLLOW := 256.	O_NONBLOCK := 4.	O_RDONLY := 0.	O_RDWR := 2.	O_RSYNC := nil."O_RSYNC is UNDEFINED for this platform"	O_SEARCH := nil."O_SEARCH is UNDEFINED for this platform"	O_SYNC := 128.	O_TRUNC := 1024.	O_TTY_INIT := nil."O_TTY_INIT is UNDEFINED for this platform"	O_WRONLY := 1.	POSIX_FADV_DONTNEED := nil."POSIX_FADV_DONTNEED is UNDEFINED for this platform"	POSIX_FADV_NOREUSE := nil."POSIX_FADV_NOREUSE is UNDEFINED for this platform"	POSIX_FADV_NORMAL := nil."POSIX_FADV_NORMAL is UNDEFINED for this platform"	POSIX_FADV_RANDOM := nil."POSIX_FADV_RANDOM is UNDEFINED for this platform"	POSIX_FADV_SEQUENTIAL := nil."POSIX_FADV_SEQUENTIAL is UNDEFINED for this platform"	POSIX_FADV_WILLNEED := nil."POSIX_FADV_WILLNEED is UNDEFINED for this platform"! !!LibCFcntlSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor'!initVariablesunix32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'unix' wordSize: 4>	AT_EACCESS := 512.	AT_FDCWD := -100.	AT_SYMLINK_FOLLOW := 1024.	AT_SYMLINK_NOFOLLOW := 256.	FD_CLOEXEC := 1.	F_DUPFD := 0.	F_DUPFD_CLOEXEC := 1030.	F_GETFD := 1.	F_GETFL := 3.	F_GETLK := 5.	F_GETOWN := 9.	F_RDLCK := 0.	F_SETFD := 2.	F_SETFL := 4.	F_SETLK := 6.	F_SETLKW := 7.	F_SETOWN := 8.	F_UNLCK := 2.	F_WRLCK := 1.	O_ACCMODE := 3.	O_APPEND := 1024.	O_CLOEXEC := 524288.	O_CREAT := 64.	O_DIRECTORY := 65536.	O_DSYNC := 4096.	O_EXCL := 128.	O_EXEC := nil."O_EXEC is UNDEFINED for this platform"	O_NOCTTY := 256.	O_NOFOLLOW := 131072.	O_NONBLOCK := 2048.	O_RDONLY := 0.	O_RDWR := 2.	O_RSYNC := 1052672.	O_SEARCH := nil."O_SEARCH is UNDEFINED for this platform"	O_SYNC := 1052672.	O_TRUNC := 512.	O_TTY_INIT := nil."O_TTY_INIT is UNDEFINED for this platform"	O_WRONLY := 1.	POSIX_FADV_DONTNEED := 4.	POSIX_FADV_NOREUSE := 5.	POSIX_FADV_NORMAL := 0.	POSIX_FADV_RANDOM := 1.	POSIX_FADV_SEQUENTIAL := 2.	POSIX_FADV_WILLNEED := 3.! !!LibCFcntlSharedPool class methodsFor: 'initialize - release'!initialize	self initializeVariables	! !!LibCSignalSharedPool class methodsFor: 'accessing'!headersContainingVariables	^ #( 'signal.h' )! !!LibCSignalSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor'!initVariablesMacOS32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'Mac OS' wordSize: 4>	SIGABRT := 6.	SIGALRM := 14.	SIGBUS := 10.	SIGCHLD := 20.	SIGCLD := nil."SIGCLD is UNDEFINED for this platform"	SIGCONT := 19.	SIGEMT := 7.	SIGFPE := 8.	SIGHUP := 1.	SIGINFO := 29.	SIGINT := 2.	SIGIO := 23.	SIGIOT := 6.	SIGKILL := 9.	SIGLOST := nil."SIGLOST is UNDEFINED for this platform"	SIGPIPE := 13.	SIGPOLL := nil."SIGPOLL is UNDEFINED for this platform"	SIGPROF := 27.	SIGQUIT := 3.	SIGSEGV := 11.	SIGSTOP := 17.	SIGSYS := 12.	SIGTERM := 15.	SIGTRAP := 5.	SIGTSTP := 18.	SIGTTIN := 21.	SIGTTOU := 22.	SIGURG := 16.	SIGUSR1 := 30.	SIGUSR2 := 31.	SIGVTALRM := 26.	SIGWINCH := 28.	SIGXCPU := 24.	SIGXFSZ := 25.! !!LibCSignalSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor'!initVariablesunix32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'unix' wordSize: 4>	SIGABRT := 6.	SIGALRM := 14.	SIGBUS := 7.	SIGCHLD := 17.	SIGCLD := 17.	SIGCONT := 18.	SIGEMT := nil."SIGEMT is UNDEFINED for this platform"	SIGFPE := 8.	SIGHUP := 1.	SIGINFO := nil."SIGINFO is UNDEFINED for this platform"	SIGINT := 2.	SIGIO := 29.	SIGIOT := 6.	SIGKILL := 9.	SIGLOST := nil."SIGLOST is UNDEFINED for this platform"	SIGPIPE := 13.	SIGPOLL := 29.	SIGPROF := 27.	SIGQUIT := 3.	SIGSEGV := 11.	SIGSTOP := 19.	SIGSYS := 31.	SIGTERM := 15.	SIGTRAP := 5.	SIGTSTP := 20.	SIGTTIN := 21.	SIGTTOU := 22.	SIGURG := 23.	SIGUSR1 := 10.	SIGUSR2 := 12.	SIGVTALRM := 26.	SIGWINCH := 28.	SIGXCPU := 24.	SIGXFSZ := 25.! !!LibCSignalSharedPool class methodsFor: 'initialization-release'!initialize	self initializeVariables	! !!LibCWaitSharedPool class methodsFor: 'accessing'!headersContainingVariables	^ #( 'sys/wait.h' )! !!LibCWaitSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor'!initVariablesMacOS32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'Mac OS' wordSize: 4>	WCONTINUED := 16.	WEXITED := 4.	WNOHANG := 1.	WNOWAIT := 32.	WSTOPPED := 8.	WUNTRACED := 2.! !!LibCWaitSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor'!initVariablesunix32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'unix' wordSize: 4>	WCONTINUED := 8.	WEXITED := 4.	WNOHANG := 1.	WNOWAIT := 16777216.	WSTOPPED := 2.	WUNTRACED := 2.! !!LibCWaitSharedPool class methodsFor: 'initialize - release'!initialize	self initializeVariables	! !"FFICHeaderExtractor-LibC"!!OSSAttachableFileStream commentStamp: '' prior: 0!OSSAttachableFileStream represents a  stream on an input or output channel provided by the underlying operating system. It behaves like an ordinary file stream, except that it can be attached myself to an input or output stream which has already been opened by the underlying operating system.The most common use is to represent either the read or write end of a Pipe from the  Operatying System . This way, it provides a Stream API for both, reading and writing. An OSSPipe  contains a 'reader' and a 'writer' which will be two different instances of this class.!!OSSPipe commentStamp: '' prior: 0!OSSPipe represents a pipe provided by the underlying operating system, such as a Unix pipe. I have a reader stream and a writer stream which behave similarly to a read-only FileStream and a writeable FileStream. These streams are instances of OSSAttachableFileStream which are attached  to the underlying created  pipe (to either read and write end). The idea of OSSPipe is to provide an Stream-like API for pipes. The write-related methods will be delagated to the 'writer' (for example, #nextPutAll:) and the read-related methods (like #upToEnd) will be forwarded to the reader.Thanks to the Stream-API, it almos allows a code user, to either use Pipes or regular files polymorphically.  In fact, OSSUnixSubprocess can either work with regular files or with OSSPipe for dealing with stdin, stdout and stderr. OSSPipe uses a single-character buffer to implement #peek without losing data from the external OS pipe.!!OSSCFile commentStamp: '' prior: 0!OSSCFile is a external object which provides  a way for mapping C-level  FILE*  in our FFI calls. We have FFI calls that either answer or receive FILE*  and in these cases we use OSSCFile for the FFI signature. !!OSSUnixProcessExitStatus commentStamp: '' prior: 0!A OSSUnixProcessExitStatus represents the exit status of a unix process. This is an integer bit field answered by the wait() system call that contains information about exit status of the process. The meaning of the bit field varies according to the cause of process exit. When the OS process of a OSSUnixSubprocess exits and we collect the exit status via (#queryExitStatus which ends up doing the waitpid()), we get this bit integer bit fields. OSSUnixSubprocess #exitStatus answers this integer. To interpret it's result better, then we use this class OSSUnixProcessExitStatus (via #exitStatusInterpreter). Ideally, we should take the resulting integer and call the macros WIFSIGNALED, WIFEXITED etc.. but since they are macros, they are not accessible via FFI. Therefore, we do the internal bit shits ourselves.However, OSSUnixProcessExitStatus decodes the process exit status in a manner compatible with a typical GNU unix implementation. It is not guaranteed to be portable and may produce misleading results on other unix systems.Following a normal process exit, the status may be decoded to provide a small positive integer value in the range 0 - 255, which is the value that is presented by a unix shell as the exit status of a program. If terminated by a signal, the corresponding value is the signal number of the signal that caused process exit.!!OSSUnixSystemAccessor commentStamp: '' prior: 0!OSSUnixSystemAccessor provides access to the operating system in which the Pharo VM is currently running.  There is only one instance of this class, holded by 'OSSVMProcess vmProcess'  which depends on it  to provide access to the operating system process which they represent.This class provides GENERAL funcionallity for managing files, errors, environments variables, waiting calls, etc etc. Ideally, 100% of its functionallity should be implemented via FFI calls. However, we still use some OSProcess primitives which would be a bit complicaated to implement via FFI (mostly because they access macros, or constants, or things related to a the C pre-processor that we do not have at FFI level). The functionallity that is NOT GENERAL (like the call to posix_spawn() family of functions), should not be here but in the concrete place such as OSSUnixSubprocess. For the parts that are based on FFI calls, we split each call in two sides. The first side is the method that does the FFI call (under a 'XXX - primitives' protocol, for example, #primitiveFileno:). The other side, is wrapper method that calls the primitive internally but also takes care about managing possible errors of it, informing those, etc (for example, #fileno:). Therefore, is very much likely that the "code users" of this class, will be using the latter side (wrappers) of the methods and not the primitive ones.!!!! Management of dead processesNew processes are created as childs of the current process. The method #waitpidNoHang: is used to query the exit status of processes.However, since we use the waitpid() function using WNOHANG, it returns a finished process id that is not necessarily the one that is asked for.Becayse of this, the Accessor contains a map of process exit statuses.If the asked process is the one returned by waitpid, we return the corresponding exit status, otherwise we store that value in the map for later accesses.!!OSSVMProcess commentStamp: '' prior: 0!OSSVMProcess represents the operating system process in which this Pharo VM is currently running. OSSVMProcess has a unique instance accessed via #vmProcess and it also uses a unique instance of  OSSUnixSystemAccessor  which provides access to the external operating system.OSSVMProcess can answer some information about the OS process running the VM, such as running PID, children, etc etc. More can be added later. Another important task of this class is to keep track of all the launched children processes (instances of OSSUnixSubprocess). Whenever a process is started it's registered in OSSVMProcess and unregister in certain scenarios (see senders of #unregisterChildProcess:). We keep a  list of all our children, and ocasionally prune all those that have already been exited. This class takes care of running what we call the "child watcher" which is basically a way to monitor children status and collect exit code when they finish. This also  guarantees not to let zombies process (a child whose parent did not collected child exit status). Basically, we use a SIGCHLD handler to capture  a child death. For more details, see method #initializeChildWatcher. !!OSSUnixSubprocess commentStamp: '' prior: 0!OSSUnixSubprocess is the main interface for spwaning subprocesses in a Unix OS. A process consist at minimun of a program/command to be executed (a Unix binary..could be cat , ls, cp,  custom shell scripts, etc etc.  ) and an optional list of arguments that will be passed to that program.This class also allows you to define streams  (either StandardFileStream or OSSPipe) that will be mapped to the underlying standard streams stdout/stderr/stdin. This way it provides an API for reading and writing from those. In addition, it takes care of opening, closing, cleaning and all the rest of streams operations. It also provides code for checking the status or waiting the exit of the OS process. Different strategies are supported (SIGCHLD based or delay polling). See the different methods in the protocol 'running'.' In addition, once the subprocess was started, the subprocess instance is registered in OSSVMProcess which takes care of handling the child death via the childWatcher. Some additional features involved env variable settings (environmentAt:put:) for the child, defining a working directory (#workingDirectory: ), facilities for shell commands, etc.To achieve it's goals, this class relies on OSSUnixSystemAccessor for accessing Unix system calls. As for  implementation details to spwan processes this class relies on the posix_spwan() family of functions which we call via FFI. The following is ONE example of ONE possible usage. We define and set settings which are actually the default, so they wouldn't make sense..but just for showing the most of the API:OSSUnixSubprocess new		command: 'ls';	arguments: (Array with: Smalltalk image imagePath);	defaultWriteStreamCreationBlock: [ OSSVMProcess vmProcess systemAccessor makeNonBlockingPipe ];	redirectStdout; "automatic default stream creation...above closure."	redirectStderrTo: '/tmp/stderrFile.txt' asFileReference writeStream; "custom stream creation"	createMissingStandardStreams: false; "therefore won't create stdin stream"	workingDirectory: '/home'; "set working directory for child"	environmentAt: 'HOME' put: '/tmp/home';	addAllEnvVariablesFromParentWithoutOverride; "we will inherit then all but $HOME"	runAndWaitOnExitDo: [ :command :outString :errString |		self assert: (outString includesSubstring: Smalltalk image imagePath).			self assert: command isSuccess.		self assert: errString isEmpty. 	]	 !!OSSAttachableFileStream class methodsFor: 'file creation'!fileNamed: fileName	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"	self shouldNotImplement! !!OSSAttachableFileStream class methodsFor: 'file creation'!isAFileNamed: fileName	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"	self shouldNotImplement! !!OSSAttachableFileStream class methodsFor: 'instance creation'!name: aSymbolOrString attachTo: aFileID writable: readWriteFlag 	"Create a new instance attached to aFileID. For write streams, this represents two	Smalltalk streams which write to the same OS file or output stream,	presumably with interleaved output. The purpose of this method is to	permit a FileStream to be attached to an existing aFileID, such as	the handle for standard input, standard output, and standard error."	^ (super basicNew		name: aSymbolOrString		attachTo: aFileID		writable: readWriteFlag) initialize! !!OSSAttachableFileStream class methodsFor: 'TO USE LATER WITHOUT OSPROCESS'!name: aSymbolOrString attachToCFile: aCFile writable: readWriteFlag 	"Create a new instance attached to aCFile. For write streams, this represents two	Smalltalk streams which write to the same OS file or output stream,	presumably with interleaved output. The purpose of this method is to	permit a FileStream to be attached to an existing aCFile, such as	the handle for standard input, standard output, and standard error."	^ (super basicNew		name: aSymbolOrString		attachToCFile: aCFile		writable: readWriteFlag) initialize! !!OSSAttachableFileStream class methodsFor: 'file creation'!newFileNamed: fileName	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"		self shouldNotImplement! !!OSSAttachableFileStream class methodsFor: 'file creation'!oldFileNamed: fileName	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"		self shouldNotImplement! !!OSSAttachableFileStream class methodsFor: 'file creation'!readOnlyFileNamed: fileName	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"		self shouldNotImplement! !!OSSAttachableFileStream class methodsFor: 'registry'!register: anObject	"An attachable file stream is generally either a second reference to an	existing file stream, or a reference to a transient object such as a pipe	endpoint. There is no need to register it for finalization."	^ anObject! !!OSSAttachableFileStream class methodsFor: 'registry'!unregister: anObject	"An attachable file stream is generally either a second reference to an	existing file stream, or a reference to a transient object such as a pipe	endpoint. There is no need to register it for finalization."	^ anObject! !!OSSAttachableFileStream methodsFor: 'converting'!asAttachableFileStream	^ self! !!OSSAttachableFileStream methodsFor: 'finalization'!autoClose	"Private. Answer true if the file should be automatically closed when 	this object is finalized."	^ autoClose		ifNil: [autoClose := true]! !!OSSAttachableFileStream methodsFor: 'open/close'!close	"Close this file."	| handle |	(handle := self basicFileID) ifNotNil: [		self primCloseNoError: handle.		self unregister.		fileID := nil	]! !!OSSAttachableFileStream methodsFor: 'open/close'!ensureOpen	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"	self shouldNotImplement! !!OSSAttachableFileStream methodsFor: 'finalization'!finalize	"If #autoClose is true, then we try to close the stream upon finalization - GC "		self autoClose		ifTrue: [[self primCloseNoError: fileID] on: Error do: []]! !!OSSAttachableFileStream methodsFor: 'read, write, position'!flush	"Flush the external OS stream (the one in the C library)."		self systemAccessor fflush: self getFilePointerAsCFile! !!OSSAttachableFileStream methodsFor: 'finalization'!keepOpen	"Do not allow the file to be closed when this object is finalized."	autoClose := false! !!OSSAttachableFileStream methodsFor: 'attaching'!name: aSymbolOrString attachTo: aFileID writable: readWriteFlag	"Attach to an existing file handle, assumed to have been previously	 opened by the underlying operating system.	"		name := aSymbolOrString.	fileID := aFileID.	readWriteFlag ifTrue: [self readWrite] ifFalse: [self readOnly].	self ascii.	self register! !!OSSAttachableFileStream methodsFor: 'TO USE LATER WITHOUT OSPROCESS'!name: aSymbolOrString attachToCFile: externalFilePointer writable: readWriteFlag	"Attach to an existing file handle, assumed to have been previously opened by the underlying operating system.	We assume a 32 bits machine and here we document the SQFile used by the VM:	/* squeak file record; see sqFilePrims.c for details */typedef struct {  int			 sessionID;	/* ikp: must be first */  void			*file;  squeakFileOffsetType	 fileSize;	/* 64-bits we hope. */  char			 writable;  char			 lastOp; /* 0 = uncommitted, 1 = read, 2 = write */  char			 lastChar;  char			 isStdioStream;} SQFile;	"	| fileIDByteArray |	self flag: #fixIt.	"Hack...I calculated that the size of the SQFile struct in a 32 bits machine is 20 bytes only	if the fileSize was 64 bits. This is the case of Pharo OSX VM. However, Linux VM has not yet been build	with 64 buts but 32 bits for fileSize and so, instead of 20 it is 16.	For more details read thread with subject 'Why StandardFileStream fileID is 16 bytes in Linux while 20 bytes in OSX?'	"	fileIDByteArray := ByteArray new: 20. 	name := aSymbolOrString.	self setSessionIDTo: fileIDByteArray.	"Hack. I calculated that the File* of the SQFile is the second element of the struct and starts at the byte 5.	The first 4 byets is the session ID. "	self setOSFilePointerFromByteArray: externalFilePointer getHandle getHandle asByteArrayPointer to: fileIDByteArray offset: 4.	readWriteFlag 		ifTrue: [			self flag: #fixIt.			"Again, in 32 bytes machines, the byte17 is the variable 'writable' from the SQFile. 			In Linux, instead if 17 it should be 13.			 "			fileIDByteArray at: 17 put: 1.			self readWrite] 		ifFalse: [			self readOnly].	fileID := fileIDByteArray.	self ascii.	self register! !!OSSAttachableFileStream methodsFor: 'TO USE LATER WITHOUT OSPROCESS'!oldname: aSymbolOrString attachTo: externalFilePointer writable: readWriteFlag	"Attach to an existing file handle, assumed to have been previously opened by the underlying operating system.	We assume a 32 bits machine and here we document the SQFile used by the VM:	/* squeak file record; see sqFilePrims.c for details */typedef struct {  int			 sessionID;	/* ikp: must be first */  void			*file;  squeakFileOffsetType	 fileSize;	/* 64-bits we hope. */  char			 writable;  char			 lastOp; /* 0 = uncommitted, 1 = read, 2 = write */  char			 lastChar;  char			 isStdioStream;} SQFile;	"	| fileIDByteArray |	"Hack...I calculated that the size of the SQFile struct in a 32 bits machine is 20 bytes. "	fileIDByteArray := ByteArray new: 20. 	name := aSymbolOrString.	self setSessionIDTo: fileIDByteArray.	"Hack. I calculated that the File* of the SQFile is the second element of the struct and starts at the byte 5.	The first 4 byets is the session ID. "	self setOSFilePointerFromByteArray: externalFilePointer getHandle getHandle asByteArrayPointer to: fileIDByteArray offset: 4.	readWriteFlag 		ifTrue: [			"Again, in 32 bytes machines, the byte17 is the variable 'writable' from the SQFile.  "			fileIDByteArray at: 17 put: 1.			self readWrite] 		ifFalse: [			self readOnly].	fileID := fileIDByteArray.	self ascii.	self register! !!OSSAttachableFileStream methodsFor: 'open/close'!open	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"		self shouldNotImplement! !!OSSAttachableFileStream methodsFor: 'open/close'!open: fileName forWrite: writeMode	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"		self shouldNotImplement! !!OSSAttachableFileStream methodsFor: 'open/close'!openReadOnly	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"		self shouldNotImplement! !!OSSAttachableFileStream methodsFor: 'read, write, position'!position	"Return the receiver's current file position. If the stream is not positionable,	as in the case of a Unix pipe stream, answer 0."	^ [super position]		on: Error		do: [0]! !!OSSAttachableFileStream methodsFor: 'open/close'!reopen	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"		self shouldNotImplement! !!OSSAttachableFileStream methodsFor: 'non blocking'!setNonBlocking	"Make this stream to be none blocking. In Linux it means 	calling fcntl() to set the file non-blocking (O_NONBLOCK)." 	self systemAccessor makeFileNoneBocking: fileID! !!OSSAttachableFileStream methodsFor: 'TO USE LATER WITHOUT OSPROCESS'!setOSFilePointerFromByteArray: externalFilePointer to: aDestByteArray offset: anOffsetNumber	1 to: 4 do: [ :index | aDestByteArray at: (index + anOffsetNumber) put: (externalFilePointer at: index) ]	! !!OSSAttachableFileStream methodsFor: 'TO USE LATER WITHOUT OSPROCESS'!setSessionIDTo: fileIDByteArray	| currentSession |	currentSession := OSSVMProcess vmProcess sessionID.	1 to: currentSession size do: [ :index | fileIDByteArray at: index put: (currentSession at: index) ]! !!OSSAttachableFileStream methodsFor: 'read, write, position'!upToEnd	"Answer a subcollection from the current access position through the last element	of the receiver. This is slower than the method in StandardFileStream, but it	works with pipes which answer false to #atEnd when no further input is	currently available, but the pipe is not yet closed."	| newStream buffer nextBytes |	buffer := buffer1 species new: 1000.	newStream := WriteStream on: (buffer1 species new: 100).	[self atEnd or: [(nextBytes := self nextInto: buffer) isEmpty]]		whileFalse: [newStream nextPutAll: nextBytes].	^ newStream contents! !!OldStandardFileStream methodsFor: '*OSSubprocess'!atEndOfFile	"Answer whether the receiver is at its end based on the result of the last read operation. This uses feof() to test the underlying file stream status, and can be used as an alternative to #atEnd, which does not properly report end of file status for an OSPipe.		Answer whether the file represented by #getFilePointerAsCFile is at end of file, as determined by a call to feof(). This is different from StandardFileStream>>primAtEnd: which answers true if the file pointer is at the end of the file, but which does not call feof() to determine that an end of file condition has occurred. The difference is significant	if aSqFileStruct represents a pipe. Another case where the difference is significant is when using StandardFileStream to communicate with a child process since  the SQFile will not automatically be updated if some other process has changed the actual size of the file.	"	^ fileID isNil or: [ self systemAccessor feof: self getFilePointerAsCFile ]! !!OldStandardFileStream methodsFor: '*OSSubprocess'!basicFileID	^ fileID! !!OldStandardFileStream methodsFor: '*OSSubprocess'!getFilePointerAsCFile	| pointerSize secondFieldStart secondFieldEnd |	pointerSize := FFIExternalType pointerSize.	secondFieldStart := pointerSize + 1.	secondFieldEnd := secondFieldStart + pointerSize - 1.	^ OSSCFile new 		setHandle: (ExternalData 							fromHandle: ((fileID copyFrom: secondFieldStart to: secondFieldEnd) asExternalPointer  ) 							type: ExternalType void asPointerType);		yourself	! !!OldStandardFileStream methodsFor: '*OSSubprocess'!ossIsPipe	^ false! !!OldStandardFileStream methodsFor: '*OSSubprocess'!systemAccessor	^ OSSVMProcess vmProcess systemAccessor! !!OldStandardFileStream methodsFor: '*OSSubprocess'!upToEndOfFile	"Answer a subcollection from the current access position through the last element of the receiver.  Use #atEndOfFile to determine end of file status with feof(), required for reliable end of file test on OS pipes or in files that could have been written by another (child) process different than the VM process."		| newStream buffer |	self closed 		ifTrue: [ self error: 'File already closed' ]		ifFalse: [  			buffer := buffer1 species new: 1000.			newStream := WriteStream on: (buffer1 species new: 100).			[self atEndOfFile] whileFalse: [newStream nextPutAll: (self nextInto: buffer)].			^ newStream contents		]! !!OSSPipe class methodsFor: 'instance creation'!newWith: fileIDsArray readBlocking: readBlocking	"fileIDsArray is an array of two elements where the first represents a sqFile struct of the reader of the pipe and the second represents the sqFile of the writer of the pipe. 	If readBlocking is true, then the pipe will lock the reading waiting until there is data. If false, then the streams will not lock and answer immediatly instead.  	 "	^ self basicNew 			initializeWith: fileIDsArray readBlocking: readBlocking			yourself! !!OSSPipe methodsFor: 'testing'!atEnd	"Answer whether the receiver can access any more objects."	^ writer closed and: [self peek == nil]! !!OSSPipe methodsFor: 'testing'!atEndOfFile	"Answer whether the receiver is at its end based on the result of	the last read operation. This uses feof() to test the underlying file	stream status, and can be used as an alternative to #atEnd, which	does not properly report end of file status for an OSSPipe."	^ reader atEndOfFile! !!OSSPipe methodsFor: 'closing'!close	"Closes both streams"		self closeWriter.	self closeReader.! !!OSSPipe methodsFor: 'closing'!closeReader	reader ifNotNil: [reader close]! !!OSSPipe methodsFor: 'closing'!closeWriter	writer ifNotNil: [writer close]! !!OSSPipe methodsFor: 'testing'!closed	^ reader closed! !!OSSPipe methodsFor: 'accessing'!contents	"Answer contents of the pipe, and return the contents to the pipe so it can still be read."	| string |	self closed ifTrue:		[self notify: self printString, ' ', self reader printString, ' closed'.		^ nil].	string := self reader upToEnd.	string isEmpty ifFalse:		[self writer closed			ifTrue: [self notify: self printString, ' ', self writer printString,								' closed, cannot replace contents']			ifFalse: [self nextPutAll: string]].	^ string! !!OSSPipe methodsFor: 'character writing'!cr	"Append a return character to the receiver."	self writer cr! !!OSSPipe methodsFor: 'read, write, position'!flush	^writer flush! !!OSSPipe methodsFor: 'initialize - release'!initializeWith: fileIDsArray readBlocking: aBoolean	super initialize.	readBlocking := aBoolean.	self openReadStreamFor: fileIDsArray first withName: 'pipeReader'.	self openWriteStreamFor: fileIDsArray second withName: 'pipeWriter'.! !!OSSPipe methodsFor: 'read, write, position'!next	"Answer the next object accessible by the receiver."	| character |	nextChar isNil		ifTrue:			[^ [reader next]				on: Error				do: [nil]]		ifFalse:			[character := nextChar.			nextChar := nil.			^ character]! !!OSSPipe methodsFor: 'read, write, position'!next: anInteger 	"Answer the next anInteger elements of my collection."	| character stream |	stream := WriteStream on: String new.	(1 to: anInteger) do:		[:index |		character := self next.		character isNil			ifTrue: [^ stream contents]				ifFalse: [stream nextPut: character. false]].	^ stream contents! !!OSSPipe methodsFor: 'read, write, position'!nextPut: anObject 	"Insert the argument, anObject, as the next object accessible by the 	receiver. Answer anObject."	^ writer nextPut: anObject! !!OSSPipe methodsFor: 'read, write, position'!nextPutAll: aCollection 	"Append the elements of aCollection to the sequence of objects accessible 	by the receiver. Answer aCollection."	^ writer nextPutAll: aCollection! !!OSSPipe methodsFor: 'initialize - release'!openReadStreamFor: aFileID withName: aReadStreamName	"Creates a read OSSAttachableFileStream for the read end of the pipe. 	If the readBlock is false, then make the stream to be non blocking. "	reader := OSSAttachableFileStream name: aReadStreamName attachTo: aFileID writable: false.	readBlocking ifFalse: [ reader setNonBlocking ].	^ reader! !!OSSPipe methodsFor: 'initialize - release'!openWriteStreamFor: aFileID withName: aWriteStreamName	"Creates a write OSSAttachableFileStream for the write end of the pipe.  "	writer := OSSAttachableFileStream name: aWriteStreamName attachTo: aFileID writable: true.	^ writer! !!OSSPipe methodsFor: 'testing'!ossIsPipe	^ true! !!OSSPipe methodsFor: 'read, write, position'!peek	^ nextChar isNil		ifTrue: [reader closed				ifFalse: [nextChar := reader next]]		ifFalse: [nextChar]! !!OSSPipe methodsFor: 'printing'!printOn: aStream	"The implementation of Stream>>printOn: has bad side effects when used	for OSPipe. This implementation is copied from Object."	| title |	title := self class name.	aStream		nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);		nextPutAll: title! !!OSSPipe methodsFor: 'accessing'!reader	"Answer a stream on the read end of the pipe."	^ reader! !!OSSPipe methodsFor: 'accessing'!reader: aReadStream	reader := aReadStream! !!OSSPipe methodsFor: 'accessing'!systemAccessor	^ OSSVMProcess vmProcess systemAccessor! !!OSSPipe methodsFor: 'read, write, position'!upToEnd	"Answer the remaining elements in the string."	| strm s |	strm := WriteStream on: String new.	[(s := self next: 2000) isEmpty		ifTrue: [^ strm contents]		ifFalse: [strm nextPutAll: s]] repeat! !!OSSPipe methodsFor: 'read, write, position'!upToEndOfFile	"Answer the remaining elements in the pipe. Use #atEndOfFile to	determine end of file status with feof(), required for reliable end of	file test on OS pipes. Compare #upToEnd, which uses the generic end	of file test in FilePlugin."	| stream delay string |	stream := WriteStream on: String new.	delay := Delay forMilliseconds: 200.	[(string := self next: 2000) isEmpty		ifTrue: [self atEndOfFile						ifTrue: [^ stream contents]						ifFalse: [delay wait]]		ifFalse: [stream nextPutAll: string]] repeat! !!OSSPipe methodsFor: 'accessing'!writer	"Answer a stream on the write end of the pipe."	^ writer! !!OSSPipe methodsFor: 'accessing'!writer: aWriteStream	writer := aWriteStream! !!OSSUnixProcessExitStatus class methodsFor: 'instance creation'!for: integerValue	^self new for: integerValue! !!OSSUnixProcessExitStatus methodsFor: 'accessing'!exitStatus		self isExited ifTrue: [^self statusIfExited].	self isSignaled ifTrue: [^self statusIfSignaled].	self isStopped ifTrue: [^self statusIfStopped].	self notify: 'cannot decode exit status ', intValue asString.	^intValue! !!OSSUnixProcessExitStatus methodsFor: 'initialize-release'!for: anInteger	intValue := anInteger! !!OSSUnixProcessExitStatus methodsFor: 'testing'!isExited	"	/* Nonzero if STATUS indicates normal termination.  */	#define __WIFEXITED(status)     (__WTERMSIG(status) == 0)	"	^ self statusIfSignaled = 0! !!OSSUnixProcessExitStatus methodsFor: 'testing'!isSignaled	"	/* Nonzero if STATUS indicates termination by a signal.  */	#define __WIFSIGNALED(status) \	  (((signed char) (((status) & 0x7f) + 1) >> 1) > 0)	"	^(((intValue bitAnd: 16r7F) + 1) >> 1) > 0! !!OSSUnixProcessExitStatus methodsFor: 'testing'!isStopped	"	/* Nonzero if STATUS indicates the child is stopped.  */	#define __WIFSTOPPED(status)    (((status) & 0xff) == 0x7f)	"	^(intValue bitAnd: 16rFF) = 16r7F! !!OSSUnixProcessExitStatus methodsFor: 'testing'!isSuccess	^ self exitStatus = 0! !!OSSUnixProcessExitStatus methodsFor: 'testing'!notFinished		^ intValue isNil! !!OSSUnixProcessExitStatus methodsFor: 'printing'!printOn: aStream	self notFinished		ifTrue: [^ aStream nextPutAll: 'Not finished'].	self isExited		ifTrue: [aStream nextPutAll: 'normal termination with status ';				 nextPutAll: self statusIfExited asString].	self isSignaled		ifTrue: [aStream nextPutAll: 'exit due to signal ';				nextPutAll: self statusIfSignaled asString].	self isStopped		ifTrue: [aStream nextPutAll: 'stopped due to signal ';				nextPutAll: self statusIfStopped].! !!OSSUnixProcessExitStatus methodsFor: 'accessing'!statusIfExited	"	/* If WIFEXITED(STATUS), the low-order 8 bits of the status.  */	#define __WEXITSTATUS(status)   (((status) & 0xff00) >> 8)	"	^(intValue bitAnd: 16rFF00) >> 8! !!OSSUnixProcessExitStatus methodsFor: 'accessing'!statusIfSignaled	"	/* If WIFSIGNALED(STATUS), the terminating signal.  */	#define __WTERMSIG(status)      ((status) & 0x7f)	"	^intValue bitAnd: 16r7F! !!OSSUnixProcessExitStatus methodsFor: 'accessing'!statusIfStopped	"	/* If WIFSTOPPED(STATUS), the signal that stopped the child.  */	#define __WSTOPSIG(status)      __WEXITSTATUS(status)	"	^self statusIfExited! !!OSSUnixProcessExitStatus methodsFor: 'accessing'!statusNotFinished	^ 'Not finished'! !!OSSUnixProcessExitStatus methodsFor: 'accessing'!value	^intValue! !!OSSUnixSystemAccessor class methodsFor: 'instance creation'!forVMProcess	^ VMProcessSystemAcessor ifNil: [ VMProcessSystemAcessor := self basicNew initialize ]! !!OSSUnixSystemAccessor class methodsFor: 'instance creation'!new	self error: 'You cannot create instances of OSSUnixSystemAccessor. You can only access the correct instance via OSSVMProcess >> systemAccessor '.! !!OSSUnixSystemAccessor methodsFor: 'cwd'!chdir: aDirString encoding: encoding	"Changes the current working directory of the vmProcess to aDirString"	| returnValue | 	returnValue := self primitiveChdir: aDirString encoding: encoding.	(returnValue = -1) ifTrue: [ self perror: 'chdir()' ].	(returnValue = 0) ifFalse: [ self error: 'Unexpected return value from chdir() ', returnValue printString ].	! !!OSSUnixSystemAccessor methodsFor: 'files'!closeFileDescriptor: aFileDescription	"It closes the stream associated to aFileDescriptor"	| returnValue |	returnValue := self primitiveClose: aFileDescription.	(returnValue = -1) ifTrue:  [ self perror: 'close()' ].	^ returnValue! !!OSSUnixSystemAccessor methodsFor: 'files'!feof: aCFile	"Answers whether a FILE* is at the end of the file or not. This is trustful for pipes too"	| result |	result := self primitiveFeof: aCFile.	^ result ~= 0	! !!OSSUnixSystemAccessor methodsFor: 'private - support primitives'!ffiLibraryName 	^ LibC ! !!OSSUnixSystemAccessor methodsFor: 'files'!fflush: aCFile	"Flushes the file associated to the FILE* represented by aCFile"	| returnValue |	aCFile ifNil: [ self error: 'We disallow the fflush() of nil files since it will flush all open output streams' ].	returnValue := self primitiveFflush: aCFile.	(returnValue = 0) ifFalse: [ self perror: 'fflush()' ].	! !!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED'!fileDescriptorOpen: aFileDescription mode: aMode	| cFile |	cFile := self primitiveFdopen: aFileDescription mode: aMode.	cFile isNull ifTrue: [ self perror: 'fdopen()' ].	^ cFile! !!OSSUnixSystemAccessor methodsFor: 'files'!fileno: aCFile	"Answers the file descriptor associated to the FILE* represented by aCFile"	| returnValue |	returnValue := self primitiveFileno: aCFile.	(returnValue = -1) ifTrue: [ self perror: 'fileno()' ].	^ returnValue "file descriptor"! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS'!forwardSigChld	"Set a signal handler for SIGCHLD. Answer a new Semaphore, or nil if unable	to set the handler (possibly because it has already been set)."	^ self forwardSignal: self primSigChldNumber! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS'!forwardSignal: signalNumber 	"Set a signal handler in the VM which will signal a Smalltalk semaphore 	at semaphoreIndex whenever an external signal signalNumber is received.	Answer a new Semaphore, or nil if unable to set the handler (possibly	because it has already been set). A Smalltalk process can wait on the	Semaphore, and take action when a signal is detected. See man(7) signal	for signal number definitions on your unix system."		| sema index |	sema := Semaphore new.	index := Smalltalk registerExternalObject: sema.	(self primForwardSignal: signalNumber toSemaphore: index)		ifNil:			[Smalltalk unregisterExternalObject: sema.			^ nil].	^ sema! !!OSSUnixSystemAccessor methodsFor: 'general'!getPid	"Answers the PID of the vmProcess"	^ self primitiveGetpid! !!OSSUnixSystemAccessor methodsFor: 'cwd'!getcwd 	"Returns the current working directory of the vmProcess"	| buffer bytesRead |	"Ideally, we should use a smaller buffer and then if the answer is NULL 	and errno is ERANGE then try again with a larget buffer. But...since we cannot	have access to errno.... we simply create a very large buffer that we trust that	any path fill fit in it..."	buffer := ExternalAddress allocate: 4096 + 1.	[	bytesRead := self primitiveGetcwd: buffer size: 4096 + 1.	bytesRead ifNil: [ self perror: 'getcwd()'].	] ensure: [ buffer free ].	^ bytesRead		! !!OSSUnixSystemAccessor methodsFor: 'initialization'!initialize	super initialize.	finishedChildProcesses := Dictionary new! !!OSSUnixSystemAccessor methodsFor: 'signals'!kill: aPid signal: aSignal	"Sends aSignal to aPid"	| answer | 	answer := self primitiveKill: aPid signal: aSignal.	(answer = -1) ifTrue: [ 		self perror: 'kill()'.	].	(answer = 0) 		ifTrue: [ ^ answer ]		ifFalse: [ self error: 'Unkown answer for kill()' ]! !!OSSUnixSystemAccessor methodsFor: 'pipes'!makeBlockingPipe	" Create a pipes with blocking reads"	^ self makePipeWithReadBlocking: true! !!OSSUnixSystemAccessor methodsFor: 'files'!makeFileNoneBocking: aFileId	"Make this stream to be none blocking. In Linux it means 	calling fcntl() to set the file non-blocking (O_NONBLOCK)."	self primSQFileSetNonBlocking: aFileId! !!OSSUnixSystemAccessor methodsFor: 'pipes'!makeNonBlockingPipe	"Creates a pipe with non blocking read"	^ self makePipeWithReadBlocking: false! !!OSSUnixSystemAccessor methodsFor: 'pipes'!makePipeWithReadBlocking: aBoolean	"Originally, we created the pipes ourselves and the answer was an array of file descriptors.	This was complicated because we have to then create our own sqFile structure and deal	with with offsets and their sizeof(). 		So now we use OSProcess primitive primCreatePipe which directly answers an array of sqFile structs	specifially created for them. This way we avoid all the sqFile creation and management at image side. 		"" ==================== OLD CODe =======================	| pipePointer returnValue fileDescriptors |	pipePointer := ExternalAddress allocate: 8.	[		returnValue := self primitivePipe: pipePointer.			(returnValue = -1) ifTrue: [ self perror: 'pipe()' ]. 		fileDescriptors := Array new: 2.		fileDescriptors at: 1 put: (pipePointer nbUInt32AtOffset: 0).		fileDescriptors at: 2 put: (pipePointer nbUInt32AtOffset: 4).		^ OSSPipe newWith: fileDescriptors readBlocking: aBoolean. 	] ensure:[		pipePointer free.	] ==================== OLD CODe ======================="	| fileIDsArray |	fileIDsArray := self primCreatePipe.	^ OSSPipe newWith: fileIDsArray readBlocking: aBoolean. ! !!OSSUnixSystemAccessor methodsFor: 'errors'!perror: aMessage	"Prints the errno gloabl variable into the stderr together with aMessage string	and then signal an error"	self primitivePerror: aMessage.	self error: 'Error: ', aMessage,' You may want to check errors in stderr'! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS'!primCreatePipe	"Create a pipe, and answer an array of two file handles (SQFile data structures in interp.c)	for the pipe reader and writer."	<primitive: 'primitiveCreatePipe' module: 'UnixOSProcessPlugin'>	^ nil! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS'!primForwardSignal: signalNumber toSemaphore: semaphoreIndex	"Set a signal handler in the VM which will signal a Smalltalk semaphore at	semaphoreIndex whenever an external signal sigNum is received. Answer the	prior value of the signal handler. If semaphoreIndex is zero, the handler is	unregistered, and the VM returns to its default behavior for handling that	signal.	The Smalltalk semaphore is expected to be kept at the same index location	indefinitely during the lifetime of a Squeak session. If that is not the case, the	handler must be unregistered prior to unregistering the Smalltalk semaphore."	<primitive: 'primitiveForwardSignalToSemaphore' module: 'UnixOSProcessPlugin'>	^ nil! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS'!primSQFileSetNonBlocking: aSQFileStruct	"Pass a struct SQFile on the stack, and call fcntl() to set the file non-blocking."	<primitive: 'primitiveSQFileSetNonBlocking' module: 'UnixOSProcessPlugin'>	^ nil! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS'!primSemaIndexFor: sigNum	"Answer the registration index of the semaphore currently associated with the	signal handler for sigNum."	<primitive: 'primitiveSemaIndexFor' module: 'UnixOSProcessPlugin'>	^ nil! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS'!primSigChldNumber	"Integer value corresponding to SIGCHLD"	<primitive: 'primitiveSigChldNumber' module: 'UnixOSProcessPlugin'>	^ nil! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS'!primUnixFileNumber: aFileID	"Pass a struct SQFile on the stack, and answer the corresponding Unix file number."	<primitive: 'primitiveUnixFileNumber' module: 'UnixOSProcessPlugin'>	^ nil! !!OSSUnixSystemAccessor methodsFor: 'cwd - primitives'!primitiveChdir: aDirString encoding: encoding	| encodingOption |	encodingOption := #optStringEncoding , encoding.	^ self 		ffiCall: #( int chdir(String aDirString) )		options: { #optStringEncodingMandatory . encodingOption }.! !!OSSUnixSystemAccessor methodsFor: 'files - primitives'!primitiveClose: aFileDescription 		^ self ffiCall: #( int close(int aFileDescription) )	! !!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED'!primitiveFdopen: aFileDescription mode: aMode		^ self ffiCall: #( OSSCFile fdopen(int aFileDescription, String aMode) )	! !!OSSUnixSystemAccessor methodsFor: 'files - primitives'!primitiveFeof: filePointer	^ self ffiCall: #( int feof( OSSCFile filePointer) )! !!OSSUnixSystemAccessor methodsFor: 'files - primitives'!primitiveFflush: file	^ self ffiCall: #( int fflush( OSSCFile file) )! !!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED'!primitiveFgetsInto: bufferPointer size: size file: file 	"Not directly used for the moment but could be useful to test the reading without the	SCAttachableFileStream using a code like this:		buffer := NativeBoost allocate: 1001.	(self primitiveFgetsInto: buffer  size: 1001 file: popenFile).	self primitivePerror: 'fgets()'.	buffer byteAt: 1001 put: 0.	string := buffer readString.	buffer free.	string inspect. 		"	^ self ffiCall: #( String fgets(void* bufferPointer, int size, OSSCFile file) )! !!OSSUnixSystemAccessor methodsFor: 'files - primitives'!primitiveFileno: file	^ self ffiCall: #( int fileno( OSSCFile file) )! !!OSSUnixSystemAccessor methodsFor: 'cwd - primitives'!primitiveGetcwd: buffer size: size		^ self ffiCall: #( String getcwd(char *buffer, int size) )	! !!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED'!primitiveGetdtablesize		^ self ffiCall: #( int getdtablesize(void) )! !!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED'!primitiveGetenv: variableName		^ self ffiCall: #( char * getenv(char* variableName) )! !!OSSUnixSystemAccessor methodsFor: 'general'!primitiveGetpid	^ self ffiCall: #( int getpid(void) )	! !!OSSUnixSystemAccessor methodsFor: 'signals - primitives'!primitiveKill: aPid signal: aSignal	^ self ffiCall: #( int kill(int aPid, int aSignal) )	! !!OSSUnixSystemAccessor methodsFor: 'errors - primitives'!primitivePerror: anErrorString	^ self ffiCall: #( void perror(String anErrorString) )! !!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED'!primitivePipe: pipePointer		^ self ffiCall: #( int pipe(void* pipePointer) )! !!OSSUnixSystemAccessor methodsFor: 'errors - primitives'!primitiveStrerror: errorNumber		^ self ffiCall: #( String strerror( int errorNumber) )! !!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED'!primitiveSysconf: aNumber		^ self ffiCall: #( long sysconf(int aNumber) )! !!OSSUnixSystemAccessor methodsFor: 'system - primitives'!primitiveSystem: commandString	 ^ self ffiCall: #(int system(char* commandString) ) 		! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS'!restoreSigChld	"Unset a SIGCHLD signal handler and unregister the Smalltalk semaphore.	Answer the unregistered Semaphore, or nil if unable to restore the signal	(possibly because no handler had been set)."	^ self restoreSignal: self primSigChldNumber! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS'!restoreSignal: signalNumber 	"Unset a signal handler and unregister the Smalltalk semaphore. Answer	the unregistered Semaphore, or nil if unable to restore the signal (possibly	because no handler had been set)."	| semaphoreIndex sema |	semaphoreIndex := self primSemaIndexFor: signalNumber.	semaphoreIndex ifNotNil:		[sema := Smalltalk externalObjects at: semaphoreIndex ifAbsent: [].		sema ifNotNil:			[self primForwardSignal: signalNumber toSemaphore: nil.			Smalltalk unregisterExternalObject: sema]].	^ sema! !!OSSUnixSystemAccessor methodsFor: 'sizeof'!sizeOfInt		^ FFIExternalType sizeOf: #long! !!OSSUnixSystemAccessor methodsFor: 'sizeof'!sizeOfPointer		^ FFIExternalType pointerSize	! !!OSSUnixSystemAccessor methodsFor: 'errors'!strerror: aReturnValue message: aMessage	"Get the string description of the error numnber aReturnValue and signal 	and error with such a description together with aMessage string"	| internalError | 	internalError := self primitiveStrerror: aReturnValue.	self error: 'Error: ', aMessage, ', code: ', aReturnValue asString, ', description: ', internalError! !!OSSUnixSystemAccessor methodsFor: 'system'!system: aCommandString	"Executes aCommandString in the OS via the system() call. Only used for testing."	| returnValue |	returnValue := self primitiveSystem: aCommandString.	(returnValue = -1) ifTrue: [ 		self perror: 'system()'		].	^ returnValue ! !!OSSVMProcess class methodsFor: 'initialize - release'!initialize	Smalltalk os isWindows ifTrue: [ ^ self ]. "Cannot be initialized nor used on Windows."		self initializeVMProcessInstance. 	self flag: #removeIt.	"This IF will be eliminated soon...only here temporary"	(SystemVersion current highestUpdate >= 50558)		ifTrue: [ 			SessionManager default registerToolClassNamed: self name			 ]		ifFalse: [ 			Smalltalk addToStartUpList: OSSVMProcess.			Smalltalk addToShutDownList: OSSVMProcess. 		]	! !!OSSVMProcess class methodsFor: 'initialize - release'!initializeVMProcessInstance	VMProcess isNil 		ifTrue: [ VMProcess := self basicNew. ]		ifFalse: [ VMProcess finalizePreviousSession ].	VMProcess initialize.! !!OSSVMProcess class methodsFor: 'instance creation'!new	self error: 'Only one instance of OSSVMProcess or any of its subclasses should exist in the image. Use #vmProcess to obtain the singleton instance.'.! !!OSSVMProcess class methodsFor: 'system startup'!shutDown: quitting	self vmProcess shutDown: quitting! !!OSSVMProcess class methodsFor: 'system startup'!startUp: resuming		resuming ifTrue: [ 		"To understand why the #stopWaiting, first read the comment of 		OSSVMProcess shutDown:		It could happen that when the shutDown happened, the child process		was in the wait of #waitForExitPollingEvery:doing:. Therefore, until the		next cycle of the loop it won't do the queryExitStatus. So we may still 		have this problem in image startup. So just in case we run it too in the startup code.		 "		self vmProcess activeChildren do: [ :each | each stopWaiting ].		self initializeVMProcessInstance.		]! !!OSSVMProcess class methodsFor: 'OS Process'!tryToDisableOSProcessSigchldHandler		self flag: #fixIt. "hack!!!!!!!!"	Smalltalk at: #OSProcess ifPresent: [ 		(Smalltalk at: #OSProcess) thisOSProcess processAccessor restoreSigChld. 		(Smalltalk at: #OSProcess) thisOSProcess processAccessor grimReaperProcess terminate.		(Smalltalk at: #ThisOSProcess) shutDown: true.		Smalltalk removeFromShutDownList: (Smalltalk at: #ThisOSProcess).		Smalltalk removeFromStartUpList: (Smalltalk at: #ThisOSProcess).	].! !!OSSVMProcess class methodsFor: 'accessing'!vmProcess	"Answer a single instance representing the OS process in 	which this Smalltalk VM and image is executing."	^ VMProcess! !!OSSVMProcess methodsFor: 'childs management'!activeChildren	"Answer child processes which are currently believed to be running."	^ accessProtect critical: [ childProcessList select: [ :process | process isRunning ] ].! !!OSSVMProcess methodsFor: 'childs management'!allMyChildren	^ childProcessList! !!OSSVMProcess methodsFor: 'child watching'!checkFinishedChildren	"Does a waitpid() with the flag WNOHANG which makes the system call to answer immediatly rather than waiting until child has exited. 	Answers nil if child has not yet exited or the exit status if it has.		http://man7.org/linux/man-pages/man2/waitpid.2.html	waitpid man's page is ambiguous with respect of the usage of the WNOHANG option.	It looks like waitpid ignores the first argument if WNOHANG is specified, and returns with ANY child process id.	This means that, in combination with the previous issue, it may happen that calling waitpid for process X will unregister process Y, what will make fail a subsequent call to waitpid from Y.	"	| waitedChildren childrenSize |	"Skip checking if we have no children"	waitedChildren := 0.	childrenSize := self activeChildren size.	[ waitedChildren < childrenSize ]		whileTrue: [ | statusPointer |			[ | status returnValue |			statusPointer := ExternalAddress allocate: systemAccessor sizeOfInt.			returnValue := self primitiveWaitpid: -1 statusPointer: statusPointer options: WNOHANG.			"If return value is 0 then there are no more changes, we can exit"			returnValue = 0				ifTrue: [ ^ self ].			"Only throw error in case it is an error other than no childs (represented as return -1 and errno=ECHILD)"			returnValue = -1				ifTrue: [ systemAccessor perror: 'waitpid()' ].			waitedChildren := waitedChildren + 1.			status := statusPointer platformLongAt: 1.			self updateChildProcessWithId: returnValue withStatus: status ]				ensure: [ statusPointer free ] ]! !!OSSVMProcess methodsFor: 'childs management'!childPids	^ childProcessList collect: [ :process | process pid ]! !!OSSVMProcess methodsFor: 'accessing'!earlyFinishedProcesses		^ earlyFinishedProcesses ifNil: [ earlyFinishedProcesses := Dictionary new ]! !!OSSVMProcess methodsFor: 'childs management'!exitedChildren	"Answer child processes which have exited and are no longer running."	^ accessProtect critical: [ childProcessList select: [ :process | process isComplete ]].! !!OSSVMProcess methodsFor: 'library path'!ffiLibraryName 	^ LibC! !!OSSVMProcess methodsFor: 'updating'!finalizePreviousSession	"This method is likely called at image startup and it's job is to finalize	stuff related to the previous run and let everything clean so that 	the unique instance vmProcess of OSSVMProcess can be initialized correctly at startup. "	childWatcher ifNotNil: [ 		childWatcher isTerminated ifFalse: [ childWatcher terminate ].		childWatcher := nil.	].	sigChldSemaphore ifNotNil: [		self systemAccessor restoreSigChld.		sigChldSemaphore := nil	]! !!OSSVMProcess methodsFor: 'initialize - release'!initialize	"Set my instance variables to reflect the state of the OS process in which 	this Smalltalk virtual machine is. executing."	Smalltalk os isWindows ifTrue: [ ^ self ]. "Cannot be initialized nor used on Windows."	accessProtect := Semaphore forMutualExclusion.	mutexForCwd := Semaphore forMutualExclusion.	self initializeAllMyChildren.	systemAccessor := OSSUnixSystemAccessor forVMProcess. 	pid := systemAccessor getPid.	childListTreshold := 20. "Once child list gets bigger than this number, we delete all exited processes"	self initializeSessionID.	self initializeSignalHandlers.	self initializeChildWatcher.! !!OSSVMProcess methodsFor: 'initialize - release'!initializeAllMyChildren	"Use a Dictionary if process identifiers are unique. On Windows, the	process ID is not unique, so use an OrderedCollection instead."	^ childProcessList := OrderedCollection new! !!OSSVMProcess methodsFor: 'child watching'!initializeChildWatcher	"This is a process which waits for the death of a child processes. Use SIGCHLD events rather than a Delay to poll."	| processSynchronizationDelay |	processSynchronizationDelay := Delay forMilliseconds: 30.	childWatcher	 ifNil: [		childWatcher := [[				"OSProcess authors suspected that there were various ways in which OS signals				could be missed under conditions of heavy load. For that reason, we use				#waitTimeoutMSecs: with the semaphore, so that if a signal is missed,				we time out and rescan occasionally anyway (#updateActiveChildrenAndNotifyDead				sends queryExitStatus which sends waitpid() )				"				self sigChldSemaphore waitTimeoutMSecs: 1000.				processSynchronizationDelay wait. "Avoids lost signals in heavy process switching"				self checkFinishedChildren.				] repeat] newProcess priority: Processor highIOPriority.		childWatcher resume.		"name selected to look reasonable in the process browser"		childWatcher name: ((ReadStream on: childWatcher hash asString) next: 5)				, ': the OSSubprocess child watcher'	]! !!OSSVMProcess methodsFor: 'initialize - release'!initializeSessionID	| oldFile | 	self flag: #fixMe. 	"grrr I need the sessionID (first int of the SQFile). .. there is no primitive to get it. Since it is the same for all files	lets try to grab it from a file we know there will be always there: the image file."	oldFile := OldStandardFileStream oldFileNamed: Smalltalk image imagePath.	sessionID := oldFile basicFileID copy first: (self systemAccessor sizeOfInt).	oldFile close.! !!OSSVMProcess methodsFor: 'initialize - release'!initializeSignalHandlers	"#sigChldSemaphore will lazily create and register the semaphore if needed"	self sigChldSemaphore.	! !!OSSVMProcess methodsFor: 'cwd'!lockCwdWithValue: cwdNewValue encoding: encoding during: aBlock	"This method is a complete hack in order to support a #cmd: option in OSSUnixSubprocess. 	OSSUnixSubprocess relies in posix_spawn() family of functions to spwan processes in the OS,	and these functions do not allow specifying a starting working directory for the child process. 	However, this is sometimes needed by subprocess.	Therefore, we propose this hack. Basically, we change the current directory of the parent process (vmProcess) 	BEFORE launching the subprocess. When the child is launched, it inherits the working directory of the parent.	As soon as the child was launched, we rollback and put back the original working directory in the parent. 	Because if this, it's very much likely that aBlock represents the launching of a child process.	mutexForCwd is needed because we may have multiple children at the same time trying to change working	directory (not thread safe..). So with mutexForCwd we sincronize this. 		Forking with userInterruptPriority is useful just in case there could be other Smalltalk process 	using another code, trying to ALSO change the working directory (very very unlikely). So at least with 	userInterruptPriority we make sure that we a higher priority than the rest of the normal user code	and so we minimize that problem.		"	| completed |	cwdNewValue asFileReference exists ifFalse: [ ^ self error: 'The directory: ', cwdNewValue, ' does not exist' ]. 	completed :=  Semaphore new. 	[ 		| oldCwd |		oldCwd := self systemAccessor getcwd.		[			self systemAccessor chdir: cwdNewValue encoding: encoding.			mutexForCwd critical: aBlock.		]		ensure: [ 			self systemAccessor chdir: oldCwd encoding: encoding.			completed signal.			]	] forkAt: Processor userInterruptPriority.	completed wait.	! !!OSSVMProcess methodsFor: 'accessing'!pid	^ pid! !!OSSVMProcess methodsFor: 'child watching'!primitiveWaitpid: aProcessId statusPointer: statusPointer options: optionBits		^ self ffiCall: #( int waitpid(int aProcessId, void* statusPointer, int optionBits) )! !!OSSVMProcess methodsFor: 'childs management'!pruneExitedChildrenAfter: size	"Limit the size of the child process registry. Select the last entries, and unregister	them if they are no longer active."	(accessProtect critical: [childProcessList allButFirst: size])		do: [ :aProcess |			aProcess isComplete ifTrue: [ self unregisterChildProcess: aProcess ]]! !!OSSVMProcess methodsFor: 'childs management'!registerChildProcess: anOSProcess	"Unregister anOSProcess, and trim the child process registry to prevent excessive	accumulation of exited children.		If the process finished before this registration, set it the exit status.	Otherwise, register it"	accessProtect critical: [ 		self earlyFinishedProcesses			at: anOSProcess pid			ifPresent: [ :exitStatus |				anOSProcess setExitStatus: exitStatus.				self earlyFinishedProcesses removeKey: anOSProcess pid ]			ifAbsent: [ childProcessList addFirst: anOSProcess ] ].	self pruneExitedChildrenAfter: childListTreshold.	^ anOSProcess	! !!OSSVMProcess methodsFor: 'accessing'!sessionID	"The sessionID is something internal to the VM and it's used	as part of the fileID structure (sqFile) of StandardFileStream. 	We use it for some file operations"	^ sessionID! !!OSSVMProcess methodsFor: 'system startup & shutdown'!shutDown: quitting	"If we have a process that do not stop automatically (like a tail -f) and it runs	with #fork  (at Smalltalk level)	then that process will be continue running 	after the image has stopped and started again. 	If this process continues running, it may be waiting via a delay polling	and that will throw an error since waitpid() will fail since the parent process 	(the VM process) is NOT the parent anymore of the child process.	And so.if the process fails, it makes the system startup to fail and we cannot	open the image anymore. See https://github.com/marianopeck/OSSubprocess/issues/12	So... to solve this we simply make all active childs to stop waiting so that the 	next startup of the image has no problem. 		"	quitting ifTrue: [ self activeChildren do: [ :each | each shutDown: quitting ] ].! !!OSSVMProcess methodsFor: 'child watching'!sigChldSemaphore	"Answer the value of sigChldSemaphore.	If nil, then register and create a semaphore to be signaled upon SIGCHLD.	See #forwardSigChld for more details. "	^ sigChldSemaphore ifNil: [sigChldSemaphore := self systemAccessor forwardSigChld].! !!OSSVMProcess methodsFor: 'accessing'!systemAccessor	^ systemAccessor ! !!OSSVMProcess methodsFor: 'childs management'!unregisterChildProcess: anOSProcess	"Unregister anOSProcess from the list of children"	accessProtect critical: [childProcessList remove: anOSProcess ifAbsent: [] ].	^ anOSProcess! !!OSSVMProcess methodsFor: 'child watching'!updateChildProcessWithId: aChildPid withStatus: status		| childProcess |	childProcess := self activeChildren		detect: [ :child | child pid = aChildPid ]		ifNone: [ ^ self earlyFinishedProcesses at: aChildPid put: status ].	childProcess setExitStatus: status.	childProcess processHasExitNotification.! !!OSSUnixSubprocess class methodsFor: 'temp files'!createTempFileToBeUsedAsReadStreamOn: aDirectoryPath	"Important: for some reason, if we use MultiByteFileStream instances, we have some test failures.	So for the moment, until we fix or understand this, always use StandardFileStream instances.		This is a simple facility method if the user wants to use regular files rather than pipes.	In the customization of defaultReadStreamCreationBlock: or defaultWriteStreamCreationBlock: 	the user may want to use this method to automatically create a temp file on a aDirectoryPath.	If you want another way of building temp files, then simply do not use this method and	set the closure you want in defaultReadStreamCreationBlock: or defaultWriteStreamCreationBlock: 		"		^ OldStandardFileStream forceNewFileNamed: (aDirectoryPath asFileReference / self createTempFilename) fullName! !!OSSUnixSubprocess class methodsFor: 'temp files'!createTempFileToBeUsedAsWriteStreamOn: aDirectoryPath	"See comment of #createTempFileToBeUsedAsReadStreamOn:."	^  OldStandardFileStream forceNewFileNamed: (aDirectoryPath asFileReference / self createTempFilename) fullName! !!OSSUnixSubprocess class methodsFor: 'temp files'!createTempFilename	"Read comment of createTempFileToBeUsedAsReadStreamOn:.		This answers just ONE WAY of defining a temp filename"		^ self name , '-p', OSSVMProcess vmProcess pid asString, '-', UUID new printString, '.deleteme'	! !!OSSUnixSubprocess methodsFor: 'env building'!addAllEnvVariablesFromParentWithoutOverride	"The user may have done an explicit set of a variable via #environmentAt:put: in which case	we do not want to override it with the inherit one.	This method allows to set all but overriden variables inherit from parent. "	self defaultEnvVariablesDictionary keysAndValuesDo: [ :key :value |		envVariables at: key ifAbsentPut: value.	]	! !!OSSUnixSubprocess methodsFor: 'close and dup2'!allocatePosixSpawnFilesActionStructure	"IMPORTANT:  It seems posix_spawn_file_actions_init() sometimes allocates AND initializes, and sometimes only initializes.	For OSX I found it it also allocates memory, so only allocating for the pointer is enough.	For Linux it seems we need to allocate the full structure of posix_spawn_file_actions_t.	Wathing at the implementation of GNU libc (glibc) here: http://osxr.org:8080/glibc/source/posix/spawn.h?v=glibc-2.17 	I found this struct definition:		typedef struct	 {	   int __allocated;	   int __used;	   struct __spawn_action *__actions;	   int __pad[16];	 } posix_spawn_file_actions_t;		We need a better solution to solve this kind of sizeof(). For the moment, see below how I estimate the size of this struct.  	For more details see thread 'Help with FFI crash in latest Spur (only in Linux)'	"	OSPlatform current isMacOSX ifTrue: [ posixSpawnFileActionsT := ExternalAddress allocate: self systemAccessor sizeOfPointer. ].	OSPlatform current isUnix ifTrue: [ posixSpawnFileActionsT := ExternalAddress allocate: (self systemAccessor sizeOfPointer + (self systemAccessor sizeOfInt * 2) + (16 * self systemAccessor sizeOfInt)). ].! !!OSSUnixSubprocess methodsFor: 'argv building'!argVArguments	"Answers the whole list of argV including the command as the first argument and a	null terminated."	^ OrderedCollection new		add: command;		addAll: (arguments ifNil: [#()]);		add: 0; "shell arguments are '\0' terminated"		yourself! !!OSSUnixSubprocess methodsFor: 'settings'!arguments: anObject	arguments := anObject collect: [ :each | (each encodeWith: encoding) asString ]! !!OSSUnixSubprocess methodsFor: 'argv building'!buildPrimitiveArgVArgument	"Takes care of allocating and building the array of arguments as expected	by the posix_spawn() function. 	Answers the array ready to be used."	| bufferPointer |	bufferPointer := ExternalAddress allocate: self argVArguments size * self systemAccessor sizeOfPointer.	self registerPointer: bufferPointer.	self collectArgumentPointersInto: bufferPointer.	 ^ bufferPointer! !!OSSUnixSubprocess methodsFor: 'env building'!buildPrimitiveEnvArgument	"Builds the whole env argument as expected by posix_spawn(), taking into account the variables	defined by the API #environmentAt:put:"	| envPointer |	"By default, if none variable was set, we add all the ones existing in parent"	envVariables isEmpty ifTrue: [ self addAllEnvVariablesFromParentWithoutOverride ].	"The +1 is because we will have a NULL at the end"	envPointer := ExternalAddress allocate: (envVariables keys size + 1) * self systemAccessor sizeOfPointer.	self registerPointer: envPointer.	self collectEnvVariablesPointersInto: envPointer.	^ envPointer! !!OSSUnixSubprocess methodsFor: 'cleaning'!cleanAndFixCopiedStreams	"If the stream is a pipe, we must close the end that we do not use at VM level (parent).	If we are using regular files, we must reopen them otherwise we won't be able to read what the	child has written "	stdinStream ifNotNil: [ stdinStream ossIsPipe ifTrue: [ stdinStream closeReader ] ifFalse: [ stdinStream reopen. ] ].	stdoutStream ifNotNil: [ stdoutStream ossIsPipe ifTrue: [ stdoutStream closeWriter ] ifFalse: [ stdoutStream reopen. ] ].	stderrStream ifNotNil: [ stderrStream ossIsPipe ifTrue: [ stderrStream closeWriter ] ifFalse: [ stderrStream reopen. ] ].	 ! !!OSSUnixSubprocess methodsFor: 'cleaning'!cleanResources	"Clear all resources. This step is mandatory and happens immeditaly after the process has 	started. And this must be called even if there is an error, since we must free pointers,	close streams, etc etc. "	self destroyPosixSpawnFileActionsT.	self cleanAndFixCopiedStreams.	self freePointers.! !!OSSUnixSubprocess methodsFor: 'close and dup2'!closeAllButStandardFileStreams	"Here I should loop and close all but fd 0 1 2"	"do a loop with #posixSpawnFileActionsAddClose:"		self flag: #toDo! !!OSSUnixSubprocess methodsFor: 'cleaning'!closeAndCleanStreams	"This method closes all the streams that have been opened and mapped to standard steams.	They could be either pipes or regular temp files. In the case of files, we also remove those temp files"	self closeStreams.	self deleteTempFilesFromStandardStreams.! !!OSSUnixSubprocess methodsFor: 'close and dup2'!closeAndDup2FilesActions	"First, it initializes the structure for managing the file actions allowed by posix_spwan(). 	Then defines and sets all actions we want. That is, closing or opening file descriptors,	or doing a dup2() "	self initPosixSpawnFileActionsT.	self closeAllButStandardFileStreams.	self defineActionsForStandardFileStreams.	! !!OSSUnixSubprocess methodsFor: 'streams'!closeStderrStream	" Close stderrStream if needed"	stderrStream ifNotNil: [ stderrStream close ]! !!OSSUnixSubprocess methodsFor: 'streams'!closeStdinStream	" Close stdinStream if needed"	stdinStream ifNotNil: [ stdinStream close ]! !!OSSUnixSubprocess methodsFor: 'streams'!closeStdoutStream	" Close stdoutStream if needed"	stdoutStream ifNotNil: [ stdoutStream close ]! !!OSSUnixSubprocess methodsFor: 'cleaning'!closeStreams	"Closes all the streams that have been opened and mapped to standard steams."	self closeStdinStream.	self closeStdoutStream.	self closeStderrStream.	! !!OSSUnixSubprocess methodsFor: 'argv building'!collectArgumentPointersInto: aPointer	"Allocates each string argument with a null terminated char and add them into aPointer"		"#allButLast is because the last is 0."	self argVArguments allButLast withIndexDo: [ :string :index |		| pointer | "0 terminated"		pointer := ExternalAddress allocate: string size + 1.		self registerPointer: pointer.		LibC memCopy: string to: pointer size: string size.		pointer nbUInt8AtOffset: string size put: 0. "string terminating null char"		aPointer platformUnsignedLongAt: ((index - 1) * self systemAccessor sizeOfPointer) + 1 put: pointer value ].	aPointer platformUnsignedLongAt: ((self argVArguments size - 1) * self systemAccessor sizeOfPointer) + 1 put: 0.! !!OSSUnixSubprocess methodsFor: 'env building'!collectEnvVariablesPointersInto: aPointer	"Creates the pair of KEY=VALUE string, allocating the memory and adding a null terminated char to each of the env.	Each processed pair of KEY=VALUE is added to aPointer. "	envVariables keys withIndexDo: [ :aKey :index |		| string pointer | 		string := aKey trimmed , '=', (envVariables at: aKey) trimmed. 		"The +1 is because string must be NULL terminated"		pointer := ExternalAddress allocate: string size + 1.		self registerPointer: pointer.		LibC memCopy: string to: pointer size: string size.		pointer nbUInt8AtOffset: string size put: 0. "string terminating null char"		aPointer platformUnsignedLongAt: ((index - 1) * self systemAccessor sizeOfPointer) + 1 put: pointer value	].	"The array of pointers also needs to finish with a NULL"	aPointer platformUnsignedLongAt: (envVariables keys size * self systemAccessor sizeOfPointer) + 1 put: 0! !!OSSUnixSubprocess methodsFor: 'settings'!command: aString	command := (aString encodeWith: encoding) asString! !!OSSUnixSubprocess methodsFor: 'streams'!createADefaultReadStream	"Creates a default read stream, most likely for stdin"	^ defaultReadStreamCreationBlock value! !!OSSUnixSubprocess methodsFor: 'streams'!createADefaultWriteStream	"Creates a default write stream, most likely for stdout or stderr"	^ defaultWriteStreamCreationBlock value! !!OSSUnixSubprocess methodsFor: 'settings'!createMissingStandardStreams: aBoolean	"If we don't create streams for the standard streams of the child process,	then the child will be used the inherit standard files from the parent. 		If aBoolean is true, then we will automatically create streams for mapping stdout/stderr/stdin.	Note that we will create streams ONLY for those standard streams that had not already been set by	another parts of the API (like #redirectStdoutTo:, or #createAndSetStdeoutStream, etc.).	In addition, the type of streams that we will automatically create is defined by defaultReadStreamCreationBlock	and defaultWriteStreamCreationBlock. So you can customize that to define the type of stream automatically created. 		"	createMissingStandardStreams := aBoolean	! !!OSSUnixSubprocess methodsFor: 'accessing'!defaultEncoding 	^ OSEnvironment current defaultEncoding ! !!OSSUnixSubprocess methodsFor: 'env building'!defaultEnvVariablesDictionary	"Get all the env vars inherit from the vmProcess as a dictionary"	^ Smalltalk os environment asDictionary! !!OSSUnixSubprocess methodsFor: 'settings'!defaultReadStreamCreationBlock: aClosure	"Read the comment of #createMissingStandardStreams:"	defaultReadStreamCreationBlock := aClosure! !!OSSUnixSubprocess methodsFor: 'settings'!defaultWriteStreamCreationBlock: aClosure	"Read the comment of createMissingStandardStreams:"	defaultWriteStreamCreationBlock := aClosure! !!OSSUnixSubprocess methodsFor: 'close and dup2'!defineActionsForReadStream: aReadStream dupTo: aFileDescriptor	"Sets all needed actions (close() and dup2()) for a aReadStream (stdin) FOR THE CHILD.	"	aReadStream ifNotNil: [ 		aReadStream ossIsPipe 			ifTrue: [  				"For pipes, in the child, we close write end (the child will read), 				then dup2 the reader to stdin, and then close the reader too. "				self posixSpawnFileActionsAddClose: (self systemAccessor primUnixFileNumber: aReadStream writer basicFileID).				self posixSpawnFileActionsAddDup2: (self systemAccessor primUnixFileNumber: aReadStream reader basicFileID) newFileDescritpion: aFileDescriptor.				self posixSpawnFileActionsAddClose: (self systemAccessor primUnixFileNumber: aReadStream reader basicFileID).				] 			ifFalse: [ 				| fileDesc |				fileDesc := self getFdFromStream: aReadStream. 				"For regular files, in the child, we dup2 the reader to stdin, and then close the reader too. "				self posixSpawnFileActionsAddDup2: fileDesc newFileDescritpion: aFileDescriptor.				self posixSpawnFileActionsAddClose: fileDesc.						]	]! !!OSSUnixSubprocess methodsFor: 'close and dup2'!defineActionsForStandardFileStreams	"Define close() and dup2() actions for standard file streams for the child process"	self defineActionsForStdin.	self defineActionsForStdout.	self defineActionsForStderr.		! !!OSSUnixSubprocess methodsFor: 'close and dup2'!defineActionsForStderr	"If needed, automatically create a stream (regular files or pipes) to be used for stderr, and then perform the needed close() and dup2()	for the mapping in the child"	self shouldCreateStreamFor: stderrStream ifTrue: [ self redirectStderr ].	self defineActionsForWriteStream: stderrStream dupTo: 2! !!OSSUnixSubprocess methodsFor: 'close and dup2'!defineActionsForStdin	"If needed, automatically create a stream (regular files or pipes) to be used for stdin, and then perform the needed close() and dup2()	for the mapping in the child"	self shouldCreateStreamFor: stdinStream ifTrue: [ self redirectStdin ].	self defineActionsForReadStream: stdinStream dupTo: 0! !!OSSUnixSubprocess methodsFor: 'close and dup2'!defineActionsForStdout	"If needed, automatically create a stream (regular files or pipes) to be used for stdout, and then perform the needed close() and dup2()	for the mapping in the child"	self shouldCreateStreamFor: stdoutStream ifTrue: [ self redirectStdout ].	self defineActionsForWriteStream: stdoutStream dupTo: 1! !!OSSUnixSubprocess methodsFor: 'close and dup2'!defineActionsForWriteStream: aWriteStream dupTo: aFileDescriptor	"Sets all needed actions (close() and dup2()) for a aWriteStream (stdout or stderr) FOR THE CHILD	"	aWriteStream ifNotNil: [ 		aWriteStream ossIsPipe 			ifTrue: [  				"For pipes, in the child, we close read end (the child will write), 				then dup2 the writer to stderr or stdout, and then close the writer too. "				self posixSpawnFileActionsAddClose: (self systemAccessor primUnixFileNumber: aWriteStream reader basicFileID).				self posixSpawnFileActionsAddDup2: (self systemAccessor primUnixFileNumber: aWriteStream writer basicFileID) newFileDescritpion: aFileDescriptor.				self posixSpawnFileActionsAddClose: (self systemAccessor primUnixFileNumber: aWriteStream writer basicFileID).				] 			ifFalse: [ 				| fileDesc |				fileDesc := self getFdFromStream: aWriteStream. 				"For regular files, in the child, we dup2 the writer to stdout or stderr, and then close the writer too. "				self posixSpawnFileActionsAddDup2: fileDesc newFileDescritpion: aFileDescriptor.				self posixSpawnFileActionsAddClose: fileDesc.						]	]! !!OSSUnixSubprocess methodsFor: 'cleaning'!deleteTempFileOf: aStream	"Deletes the temp file associated to aStream"	aStream ifNotNil: [ 		aStream ossIsPipe ifFalse: [ aStream fullName asFileReference ensureDelete ] 	]	! !!OSSUnixSubprocess methodsFor: 'cleaning'!deleteTempFilesFromStandardStreams	"Delete all temp files that were associated to standard streams."	self deleteTempFileOf: stdinStream.	self deleteTempFileOf: stdoutStream.	self deleteTempFileOf: stderrStream.		! !!OSSUnixSubprocess methodsFor: 'close and dup2'!destroyPosixSpawnFileActionsT	"This is part of the needed API of posix_spawn() family of functions and dismply destroys	the struct initialized by #initPosixSpawnFileActionsT"	posixSpawnFileActionsT ifNotNil: [ 		| returnValue |		returnValue := self primitivePosixSpawnFileActionsDestroy: posixSpawnFileActionsT. 		returnValue = 0 ifFalse: [ self systemAccessor strerror: returnValue message: 'posix_spawn_file_actions_distroy()'. ].		].! !!OSSUnixSubprocess methodsFor: 'settings'!encoding: anEncoder	"Specify the encoder to use to encode/decode Strings given to/retrieved from the process.	Default encoding for Unix-like systems is UTF-8".	" self encoding: #utf8 "	encoding := anEncoder! !!OSSUnixSubprocess methodsFor: 'env building'!envVariables	^ envVariables! !!OSSUnixSubprocess methodsFor: 'env building'!environmentAt: aVariableName put: aValue	"This is the expected API to allow users to define custom variables and values."	(aVariableName isString and: [ aValue isString ])		ifFalse: [ self error: 'Variable names and values must be strings' ].	envVariables at: aVariableName put: aValue! !!OSSUnixSubprocess methodsFor: 'status'!exitStatus	"Answers the bit field integer representing the exit status exactly as returned from #queryExitStatus (waitpid()). "	^ exitStatus! !!OSSUnixSubprocess methodsFor: 'status'!exitStatusInterpreter	"#exitStatus answers the bit field integer representing the exit status exactly as returned from #queryExitStatus (waitpid()).	However, sometimes you want to decode the internal meaning of the integer to get more information about the status. 	For those purposes, you can use this method and then query the result. 	For more details, read class comment of OSSUnixProcessExitStatus "	^ OSSUnixProcessExitStatus for: exitStatus! !!OSSUnixSubprocess methodsFor: 'private - support primitives'!ffiLibraryName 	^ LibC! !!OSSUnixSubprocess methodsFor: 'pointers management'!freePointers	"Frees all registered pointers. This must be called just after process is launched whether it	was successful or not to avoid memory leaks... Also, all users of FFI #allocate: kind of method	should either explicitly send #free (inside a ensure:) or register the allocated pointer so that 	it can be free here."	self pointers do: [ :pointer | pointer free ].	pointers := nil! !!OSSUnixSubprocess methodsFor: 'close and dup2'!getFdFromStream: aStream	^ self systemAccessor fileno: aStream getFilePointerAsCFile! !!OSSUnixSubprocess methodsFor: 'close and dup2'!initPosixSpawnFileActionsT	"This is part of the needed API of posix_spawn() family of functions and initializes	the struct posix_spawn_file_actions_t"	| returnValue |	self allocatePosixSpawnFilesActionStructure.	self registerPointer: posixSpawnFileActionsT.	returnValue := self primitivePosixSpawnFileActionsInit: posixSpawnFileActionsT. 	returnValue = 0 ifFalse: [ self systemAccessor strerror: returnValue message: 'posix_spawn_file_actions_init()' ].! !!OSSUnixSubprocess methodsFor: 'initialize - release'!initialize	super initialize.	envVariables := Dictionary new. 	createMissingStandardStreams := false.	"By default, we create a none blocking pipe for writers (stdout and stderr). For reader, we prefer blocking pipes (stdin), otherwise the child will exit quickly. We also allow regular StandardFileStreams instances."	defaultReadStreamCreationBlock := [self systemAccessor makeBlockingPipe].	defaultWriteStreamCreationBlock := [self systemAccessor makeNonBlockingPipe].	retrievedStdout := String new writeStream. 	retrievedStderr := String new writeStream. 	terminateOnShutdown := false.	waitPidCriticalSemaphore := Semaphore forMutualExclusion.	encoding := self defaultEncoding.! !!OSSUnixSubprocess methodsFor: 'running'!internalRun	"This is the real method that spwans the subprocess in the OS via the posix_spawn() function. 	It first must deal with all the file acctions for close() and dup() in the child.	Then spawns the process and sets the pid. 	Finally, it registers the process in the OSSVMProcess vmProcess (so that the childWatcher considers this child).	After this method is sent, we have to be sure to free resources (via #cleanResources)	"		| pidtPointer returnValue   |	pidtPointer := ExternalAddress allocate: self systemAccessor sizeOfPointer.	self registerPointer: pidtPointer.	self closeAndDup2FilesActions.	workingDirectory 		ifNil: [ returnValue := self primitivePosixSpawn: pidtPointer command: command fileActions: posixSpawnFileActionsT attributes: nil argPointer: self buildPrimitiveArgVArgument envPointer: self buildPrimitiveEnvArgument. ] 		ifNotNil: [ 			"This is a hack in order to support a #workingDirectory: kind of feature. 			Please read the comment of lockCwdWithValue:during: "			OSSVMProcess vmProcess				lockCwdWithValue: workingDirectory				encoding: encoding identifier				during: [ returnValue := self primitivePosixSpawn: pidtPointer command: command fileActions: posixSpawnFileActionsT attributes: nil argPointer: self buildPrimitiveArgVArgument envPointer: self buildPrimitiveEnvArgument. ]		].	(returnValue > 0) 		ifTrue: [ self systemAccessor strerror: returnValue message: 'posix_spawn()'. ].			"Pid is of type pid_t, which is mostly 32bits even in 64bit platforms"	pid := pidtPointer unsignedLongAt: 1.	OSSVMProcess vmProcess registerChildProcess: self.	! !!OSSUnixSubprocess methodsFor: 'status'!isComplete	"Answers whether the process has been completed or not (to our best knowledge)"	^ exitStatus notNil! !!OSSUnixSubprocess methodsFor: 'status'!isRunning	"Answers whether the process is still running or not (to our best knowledge)"	^ pid notNil and: [ self isComplete not ]! !!OSSUnixSubprocess methodsFor: 'status'!isSuccess	"Answers whether the process has been completed successfuly (to our best knowledge)"	^ self isComplete and: [ self exitStatusInterpreter exitStatus = 0 ]! !!OSSUnixSubprocess methodsFor: 'terminating'!kill	^ self sigkill! !!OSSUnixSubprocess methodsFor: 'shell'!loginShellCommand: aShellCommandString	"This is a simple facility method for the cases when the user wants to use a login shell as the program.	See comments of shellCommand: for more information."	self shellCommand: aShellCommandString.	arguments := Array with: '-l' withAll: arguments.! !!OSSUnixSubprocess methodsFor: 'accessing'!pid	^ pid! !!OSSUnixSubprocess methodsFor: 'pointers management'!pointers	^ pointers ifNil: [ pointers := Set new ]! !!OSSUnixSubprocess methodsFor: 'close and dup2'!posixSpawnFileActionsAddClose: aFileDescriptor	"Add a close() action for aFileDescriptor for the child process"	| returnValue |	returnValue := self primitivePosixSpawnFileActionsAddClose: posixSpawnFileActionsT fileDescription: aFileDescriptor.	returnValue = 0 ifFalse: [ self systemAccessor strerror: returnValue message: 'posix_spawn_file_actions_adddclose()' ].	^ returnValue! !!OSSUnixSubprocess methodsFor: 'close and dup2'!posixSpawnFileActionsAddDup2: oldFileDescription newFileDescritpion: newFileDescription	"Add a dup2() action for from oldFileDescription to newFileDescription, for the child process"	| returnValue |	returnValue := self primitivePosixSpawnFileActionsAddDup2: posixSpawnFileActionsT oldFileDescription: oldFileDescription newFileDescritpion: newFileDescription.	returnValue = 0 ifFalse: [ self systemAccessor strerror: returnValue message: 'posix_spawn_file_actions_adddup2()' ].	^ returnValue! !!OSSUnixSubprocess methodsFor: 'private - primitives'!primitivePosixSpawn: pidPointer command: commandString fileActions: fileActions attributes: attributes argPointer: argPointer envPointer: envPointer	 ^ self ffiCall: #( int posix_spawnp (void* pidPointer, String commandString, void* fileActions, void * attributes, void* argPointer, void* envPointer) ) 				! !!OSSUnixSubprocess methodsFor: 'private - primitives'!primitivePosixSpawnFileActionsAddClose: fileActions fileDescription: fileDescriptionNumber		^ self ffiCall: #( int posix_spawn_file_actions_addclose ( void* fileActions, int fileDescriptionNumber) )! !!OSSUnixSubprocess methodsFor: 'private - primitives'!primitivePosixSpawnFileActionsAddDup2: fileActions oldFileDescription: oldFileDescription newFileDescritpion: newFileDescription 	 ^ self ffiCall: #( int posix_spawn_file_actions_adddup2 ( void* fileActions, int oldFileDescription, int newFileDescription ) )! !!OSSUnixSubprocess methodsFor: 'private - primitives'!primitivePosixSpawnFileActionsDestroy: aPosixSpawnFileActionsT 		^ self ffiCall: #( int posix_spawn_file_actions_destroy(void*  aPosixSpawnFileActionsT) )	! !!OSSUnixSubprocess methodsFor: 'private - primitives'!primitivePosixSpawnFileActionsInit: aPosixSpawnFileActionsT 		^ self ffiCall: #( int posix_spawn_file_actions_init(void* aPosixSpawnFileActionsT) )	! !!OSSUnixSubprocess methodsFor: 'printing'!printOn: aStream	aStream		nextPutAll: self class name asString;		nextPut: $(;		nextPutAll: 'Command: ';		nextPutAll: command asString;		nextPutAll: '; Pid: ';		nextPutAll: pid asString;		nextPutAll: '; Status: ';		nextPutAll: self exitStatusInterpreter asString;		nextPut: $)! !!OSSUnixSubprocess methodsFor: 'status'!processHasExitNotification	"This method is called from the OSSVMProcess when its child watcher detects that this process has	exited (via the receive of SIGCHLD) and so it notifies to it (via #updateActiveChildrenAndNotifyDead).	We signal mutexForSigchld so that the #runAndWait can now finish.	Note that the mutexForSigchld could be nil if the waitForExit API was not used"	mutexForSigchld ifNotNil: [ mutexForSigchld signal ]! !!OSSUnixSubprocess methodsFor: 'status'!queryExitStatus	^ exitStatus! !!OSSUnixSubprocess methodsFor: 'streams'!redirectStderr	"Creates a default stream and set it as stderr. 	This method can be called directly by the user to note that he wants to map that standard stream,	or by our own if createMissingStandardStreams is true."	stderrStream := self createADefaultWriteStream ! !!OSSUnixSubprocess methodsFor: 'streams'!redirectStderrTo: aStream	stderrStream := aStream! !!OSSUnixSubprocess methodsFor: 'streams'!redirectStdin	"Creates a default stream and set it as stdin. 	This method can be called directly by the user to note that he wants to map that standard stream,	or by our own if createMissingStandardStreams is true."		stdinStream := self createADefaultReadStream ! !!OSSUnixSubprocess methodsFor: 'streams'!redirectStdinTo: aStream	stdinStream := aStream! !!OSSUnixSubprocess methodsFor: 'streams'!redirectStdout	"Creates a default stream and set it as stdout. 	This method can be called directly by the user to note that he wants to map that standard stream,	or by our own if createMissingStandardStreams is true."		stdoutStream := self createADefaultWriteStream ! !!OSSUnixSubprocess methodsFor: 'streams'!redirectStdoutTo: aStream	stdoutStream := aStream! !!OSSUnixSubprocess methodsFor: 'pointers management'!registerPointer: aPointer	"Register a pointer so that it is free automatically in #freePointers"	self pointers add: aPointer! !!OSSUnixSubprocess methodsFor: 'streams'!retrieveWhatIsAvailableOn: aStream andAddItTo: accumulatingStream	"This is an internal method which should only be used IF the user will NOT	retrieve contents himself from streams while the process is still running.	The usecase of this method is #runAndWaitOnExitDo: and #waitForExitPollingEvery:retrievingStreams:	in which we are sure the user will not be reading from the streams. 	What this method does is to simply get what is available in aStream and write it in  accumulatingStream, which is 	the one we are using for appending contents (so that it is available all togther when the process has exited)	This is important because for example, for pipes, you cannot read something twice as you consume what you read. 		 "	aStream 		ifNotNil: [ :str | 			accumulatingStream nextPutAll: str upToEnd 		].! !!OSSUnixSubprocess methodsFor: 'running'!run	"Main method for spwaning the process. It starts the subprocess, it cleans the needed resources for that, and answers,	it does not wait for child. There are others high end API for running the process,	but they will all end up sending this message for starting the subprocess."	[ self internalRun ] ensure: [ 		self cleanResources.	]! !!OSSUnixSubprocess methodsFor: 'running'!runAndWait	"IMPORTANT: read first the comment of #waitForExit.		This methods runs the subprocess AND waits until the child has exited. 	"	self run.	self waitForExit.	! !!OSSUnixSubprocess methodsFor: 'running'!runAndWaitOnExitDo: anExitClosure	"This is a high end API for #runAndWait. IMPORTANT: read the comment in #runAndWait to know when to use this API.	The facility this method adds over #runAndWait is that when the process has finished it:	1) Retrieves all contents from stdout and stderr (if they were defined)	2) It automatically closes the streams mapped to stdout/stderr (if defined)	3) It allows you to plug anExitClosure which will be evaluated with this subprocess and the contents of stdout and stderr. 		With this method, the user does not need to do anything else. 	"	self run.	self waitForExit.	self retrieveWhatIsAvailableOn: stdoutStream andAddItTo: retrievedStdout.	self retrieveWhatIsAvailableOn: stderrStream andAddItTo: retrievedStderr.	self closeAndCleanStreams.	anExitClosure cull: self cull: retrievedStdout contents cull: retrievedStderr contents.	! !!OSSUnixSubprocess methodsFor: 'running'!runAndWaitPollingEvery: aDelay doing: aClosure onExitDo: onExitClosure	"IMPORTANT: first read the comment of #waitForExitPollingEvery:doing:		This method runs the subprocess, then waits for it doing an image-based delay polling. 	It does not automatically retrieve from streams nor closes them on exit. 	The user must explicitly read from streams in aClosure otherwise it might 	have the problem mentioned in the comment of #waitForExit.	The user must also close streams at some point. Either inside the #onExitClosure	or later, but should be done. 		 	"	self run.	self waitForExitPollingEvery: aDelay doing: aClosure.	onExitClosure cull: self cull: stdoutStream cull: stderrStream.	! !!OSSUnixSubprocess methodsFor: 'running'!runAndWaitPollingEvery: aDelay retrievingStreams: retrieveStreams onExitDo: onExitClosure	"IMPORTANT: first read the comment of #waitForExitPollingEvery:retrievingStreams:		This method runs the subprocess, then waits for it doing an image-based delay polling. 	If retrieveStreams is true, then as part of the polling loop, it also reads from the streams and	appends the intemediate results in retrievedStdout / retrievedStderr. 	Once the process has finished we evaluate onExitClosure.	If retrieveStreams was true, before evaluating onExitClosure, we automatically close streams	so that there is nothing else to be done for the user, and we also pass as arguments the	retrievedStdout / retrievedStderr  to the closure.		With this method, the user does not need to do anything else. 	 	"	self run.	self waitForExitPollingEvery: aDelay retrievingStreams: retrieveStreams.	retrieveStreams 		ifTrue: [ 			self closeAndCleanStreams.			onExitClosure cull: self cull: retrievedStdout contents cull: retrievedStderr contents.		]		ifFalse: [ 			onExitClosure cull: self.		]		! !!OSSUnixSubprocess methodsFor: 'status'!setExitStatus: aStatus	"This method set's the current process exit status.	If exitStatus was already set it will fail.		This method is synchronized to avoid race conditions on the access to the exit status"	waitPidCriticalSemaphore critical: [		exitStatus ifNotNil: [ self error: 'Modification not allowed' ].		exitStatus := aStatus	]		! !!OSSUnixSubprocess methodsFor: 'shell'!shell: aShellPath command: aShellCommandString	"Please read comment of #shellCommand:.	This is the same as shellCommand: but with the addition that the use can define which shell to be used via 'aBasePath' "	command := aShellPath.	arguments := Array with: '-c' with: (aShellCommandString encodeWith: encoding) asString. ! !!OSSUnixSubprocess methodsFor: 'shell'!shellCommand	"We first try to use the SHELL defined in the OS by getting the env variable $SHELL. 	If not found, then we fallback to /bin/sh"	^ Smalltalk platform environment at: 'SHELL' ifAbsent: ['/bin/sh']! !!OSSUnixSubprocess methodsFor: 'shell'!shellCommand: aShellCommandString	"This is a simple facility method for the cases when the user wants to use shell as the program.	This way, the user can directly send shellCommand: 'ls -la | grep Pharo > /tmp/test.txt ' with the whole string 	rather than having to do set the command sh, send the '-c' argument, etc etc etc.	We first try to use the SHELL defined in the OS by getting the env variable $SHELL. 	If not found, then we fallback to /bin/sh"		self shell: self shellCommand command: aShellCommandString. ! !!OSSUnixSubprocess methodsFor: 'streams'!shouldCreateStreamFor: aStream ifTrue: aBlock	"Internal method. 	If aStream was not specified explicitly by the user, but createMissingStandardStreams is true,	then it evaluates aBlock"	(aStream isNil and: [ createMissingStandardStreams ]) 		ifTrue: [ aBlock value ]! !!OSSUnixSubprocess methodsFor: 'system startup & shutdown'!shutDown: quitting	" IMPORTANT: read first the comment of OSSVMProcess >> shutDown:	This method is called if this process is still running at the time a 'Quit image' is happening 	in Pharo. If terminateOnShutdown is true, then we simply terminate the process via sigterm	and collect it exit status.	If it false, then we simply stop waiting for it, and allow to finish at OS level	(althought it may become orphan process as the parent will be die).	"	quitting ifTrue: [ 		terminateOnShutdown 			ifTrue: [ 				self terminate.				"To avoid problems..let's wait until we have the	exit status"				self waitForExitPolling.			]			ifFalse: [ self stopWaiting ]	] ! !!OSSUnixSubprocess methodsFor: 'OS signal sending'!sigabrt	"Send a SIGABRT signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGABRT! !!OSSUnixSubprocess methodsFor: 'OS signal sending'!sigalrm	"Send a SIGALRM signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGALRM! !!OSSUnixSubprocess methodsFor: 'OS signal sending'!sigchld	"Send a SIGCHLD signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGCHLD! !!OSSUnixSubprocess methodsFor: 'OS signal sending'!sigcont	"Send a SIGCONT signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGCONT! !!OSSUnixSubprocess methodsFor: 'OS signal sending'!sighup	"Send a SIGHUP signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGHUP! !!OSSUnixSubprocess methodsFor: 'OS signal sending'!sigint	"Send a SIGINT signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGINT! !!OSSUnixSubprocess methodsFor: 'OS signal sending'!sigkill	"Send a SIGKILL signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGKILL! !!OSSUnixSubprocess methodsFor: 'OS signal sending'!sigpipe	"Send a SIGPIPE signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGPIPE! !!OSSUnixSubprocess methodsFor: 'OS signal sending'!sigquit	"Send a SIGQUIT signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGQUIT! !!OSSUnixSubprocess methodsFor: 'OS signal sending'!sigstop	"Send a SIGSTOP signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGSTOP! !!OSSUnixSubprocess methodsFor: 'OS signal sending'!sigterm	"Send a SIGTERM signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGTERM! !!OSSUnixSubprocess methodsFor: 'OS signal sending'!sigusr1	"Send a SIGUSR1 signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGUSR1! !!OSSUnixSubprocess methodsFor: 'OS signal sending'!sigusr2	"Send a SIGUSR2 signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGUSR2! !!OSSUnixSubprocess methodsFor: 'streams'!stderrStream	^ stderrStream! !!OSSUnixSubprocess methodsFor: 'streams'!stdinStream	^ stdinStream! !!OSSUnixSubprocess methodsFor: 'streams'!stdoutStream	^ stdoutStream! !!OSSUnixSubprocess methodsFor: 'waiting'!stopWaiting	"This will work only for the High Methods API that rely in the waiting provided by the framework. If the user	user custom waiting, this won't work.	The wait inside this framework could be done either from #waitForExit with mutexForSigchld or via  #waitForExitPollingEvery:doing:	with the delay polling"	mutexForSigchld ifNotNil: [ mutexForSigchld signal ].	(shouldContinueWaiting = true) ifTrue: [ shouldContinueWaiting := false. ] 	! !!OSSUnixSubprocess methodsFor: 'accessing'!systemAccessor 	^ OSSVMProcess vmProcess systemAccessor! !!OSSUnixSubprocess methodsFor: 'terminating'!terminate	^ self sigterm! !!OSSUnixSubprocess methodsFor: 'system startup & shutdown'!terminateOnShutdown	" IMPORTANT: read first the comment of OSSVMProcess >> shutDown:	If terminateOnShutdown is true, then the external process will be terminated if it was still	running at the time a system quit image is happening.	If false, then we will simply stop waiting for it and allow it to finish (thought it will likely become a orphan).	"	terminateOnShutdown := true! !!OSSUnixSubprocess methodsFor: 'waiting'!waitForExit	"The waiting in this case is efficient since it is NOT done with a delay polling but using the SIGCHLD handler of OSSVMProcess childWatcher. The childWatcher when received a SIGCHLD will detect the child 	that died and will send #processHasExitNotification to such a child. 	In #processHasExitNotification the child will signal this 'mutexForSigchld' and hence	make the #waitForExit to proceed.  		IMPORTANT: This kind of waiting could generate a deadlock when the user uses pipes 	for mapping standard streams and the child writes a lot of stuff into it. Basically, there is a problem in	general with waiting for an external process to exit before reading its output. If the external process 	creates a large amount of output, and if the output is a pipe, it will block on writing to the pipe until	 someone (our VM process) reads some data from the pipe to make room for the writing. That leads to cases where 	we never read the output (because the external process did not exit) and the external process never exits 	(because we have not read the data from the pipe).			Therefore, use this method (and all its senders) only when using FileStreams for the standard streams, 	when not defining standard streams at all, or when you know the command to be executed does not write much in stdout/stderr."	exitStatus ifNotNil: [ ^ exitStatus ].	mutexForSigchld := Semaphore new.	mutexForSigchld wait. 	^ exitStatus  ! !!OSSUnixSubprocess methodsFor: 'waiting'!waitForExitPolling	"Read the comment of waitForExitPollingEvery:retrievingStreams:"	^ self waitForExitPollingEvery: (Delay forMilliseconds: 50)! !!OSSUnixSubprocess methodsFor: 'waiting'!waitForExitPollingEvery: aDelay 	"Read the comment of waitForExitPollingEvery:retrievingStreams:"	^ self waitForExitPollingEvery: aDelay retrievingStreams: true! !!OSSUnixSubprocess methodsFor: 'waiting'!waitForExitPollingEvery: aDelay doing: aClosure	" IMPORTANT: read first the comment of #waitForExit. 		This method does NOT use #runAndWait nor #waitForExit. Instead, it does an image-based polling to check status of child process. 	Note that the loop does send #queryExitStatus which is the method that indeeds does the waitpid() to check it.	This is not strictly necessary because the childWatcher of the OSSVMProcess	takes care of capturing SIGCHDL and update exitStatus. 	However, as a more reliable solution, we can also check exit status here in case there are missed SIGCHLD or whatever.		As part of the loop, besides checking the exit status (#queryExitStatus) it also evaluates aClosure		"	shouldContinueWaiting := true.	[		"If the #shutDown: (shouldContinueWaiting was set to false) happened while this process was in the #wait 		 then we simply check 'shouldContinueWaiting' here before doing the #queryExitStatus"		shouldContinueWaiting 			ifTrue: [ self queryExitStatus ]			ifFalse: [ ^ nil ].		"nil answer means the child has not yet finished" 		(exitStatus isNil and: [ shouldContinueWaiting ])	]	whileTrue: [ 		aDelay wait.		aClosure cull: self cull: stdoutStream cull: stderrStream.	].	"We might have more contents in the streams that could have been written since the last 'aClosure value' and the moment #queryExitStatus answers non nil.	So just in case we execute aClosure one more time"	shouldContinueWaiting 		ifTrue: [ aClosure cull: self cull: stdoutStream cull: stderrStream. ].	^ exitStatus  ! !!OSSUnixSubprocess methodsFor: 'waiting'!waitForExitPollingEvery: aDelay retrievingStreams: retrieveStreams	" IMPORTANT: read first the comment of #waitForExit. 	Second, read the comment of #waitForExitPollingEvery:doing:		If retrieveStreams is true, we read from stdout/stderr as part of the loop and	append the answers in retrievedStdout / retrievedStderr.	And this solves the deadlock mentioned in #waitForExit.		This method (with retrieveStreams in true) should be used when mapping stdout / stderr with pipes	and the command to be executed may write a lot to it. Does not make much sense to be used with regular files. 		Answers the exit status of the child."	^ self 		waitForExitPollingEvery: aDelay		doing: [ 			retrieveStreams ifTrue: [ 				self retrieveWhatIsAvailableOn: stdoutStream andAddItTo: retrievedStdout.				self retrieveWhatIsAvailableOn: stderrStream andAddItTo: retrievedStderr.			]		] 	! !!OSSUnixSubprocess methodsFor: 'waiting'!waitForExitWithTimeout: aDuration	"The waiting in this case is efficient since it is NOT done with a delay polling but using the SIGCHLD handler of OSSVMProcess childWatcher. The childWatcher when received a SIGCHLD will detect the child 	that died and will send #processHasExitNotification to such a child. 	In #processHasExitNotification the child will signal this 'mutexForSigchld' and hence	make the #waitForExit to proceed.  		IMPORTANT: This kind of waiting could generate a deadlock when the user uses pipes 	for mapping standard streams and the child writes a lot of stuff into it. Basically, there is a problem in	general with waiting for an external process to exit before reading its output. If the external process 	creates a large amount of output, and if the output is a pipe, it will block on writing to the pipe until	 someone (our VM process) reads some data from the pipe to make room for the writing. That leads to cases where 	we never read the output (because the external process did not exit) and the external process never exits 	(because we have not read the data from the pipe).			Therefore, use this method (and all its senders) only when using FileStreams for the standard streams, 	when not defining standard streams at all, or when you know the command to be executed does not write much in stdout/stderr."	| expired |	exitStatus ifNotNil: [ ^ exitStatus ].	mutexForSigchld := Semaphore new.	expired := mutexForSigchld waitTimeoutMSecs: aDuration asMilliSeconds.	expired ifTrue: [ OSSTimeout signal: 'Process not finished after ', aDuration asString ].	^ exitStatus  ! !!OSSUnixSubprocess methodsFor: 'settings'!workingDirectory: aString	"This is a setting that allows defining a working directory for the OS process once started."	"Working directory is not encoded when set because it is used as FileReference at some places.	Instead, we encode it in #lockCwdWithValue:encoding:during:"	workingDirectory := aString! !"OSSubprocess"!!UnicodeCharacterData commentStamp: '' prior: 0!I am UnicodeCharacterData, I represent one record in the Unicode Character Database and describe properties of one character.I am uniquely identified by my code point (#codePoint), my Unicode scalar value.I have an official name (#name). Sometimes I also know my older name (#oldName).I have a general and a bidirectional category (#generalCategory  #bidirectionalCategory) and I know my canonicalCombiningClasses (#canonicalCombiningClasses).If applicable, I know my case mapping, what code point is like me, but upper, lower or title cased (#uppercase  #lowercase #titelcase)If applicable, I know my numerical mapping, the mathematical number that I represent (#decimalDigitValue #digitValue #numericValue).If I am a precomposed character, I know my decomposition (#decompositionMapping). This information is needed for normalization.I also known whether I am mirrored (#mirrored).My class side holds the full database of all official Unicode characters, indexed by codePoint (#database), which is loaded lazily from the official URL or from a local file system cache.Given a Unicode code point, my class method #forCodePoint: will answer an instance of me. A NotFound exception is raised if the code point is outside the allowed range.Given an integer, #unicodeCharacterData will answer an instance of me.	16r00C5 unicodeCharacterData.The character that I represent is available with #character.  Given a character instance, #unicodeCharacterData will answer an instance of me.	$a unicodeCharacterData.	$é unicodeCharacterData.	$7 unicodeCharacterData.More:For the interpretation of these concepts, please consult the Unicode documentation at http://unicode.orgIn particular, the UCD dataset is described in detail in http://www.unicode.org/reports/tr44/ and available directly at http://www.unicode.org/Public/UNIDATA/ and can be downloaded as http://www.unicode.org/Public/UNIDATA/UCD.zip.Implementation notesTo conserve space (the full database has about 30K entries), some of my fields (canonicalCombiningClass, generalCategory, bidirectionalCategory and mirrored) are combined in bitEncodedFields.Furthermore, since many entries (about 20K) have neither decomposition, case or numeric mappings, I have no instance variables for these properties, but my extended subclass does.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeCharacterDataExtended commentStamp: '' prior: 0!I am UnicodeCharacterDataExtended, a subclass of UnicodeCharacterData.I am an implementation detail, from an external viewpoint I am identical to my superclass.Since many UCD entries (about 20K) have neither decomposition, case or numeric mappings, my superclass has no instance variables for these properties, but I do.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!Character methodsFor: '*unicode-character-data'!gtInspectorGlyphIn: composite	<gtInspectorPresentationOrder: 60>	^ composite morph		title: 'Glyph';		display: [ 			| morph largeFont |			"Add an extra space in front to prevent rendering glitches on combining marks"			morph := (String space , self asString) asMorph.			(largeFont := morph font copy)				clearRealFont;				pointSize: 256.			morph font: largeFont.			morph fitContents.			morph ]! !!Character methodsFor: '*unicode-character-data'!gtInspectorUnicodeCharacterDataIn: composite	<gtInspectorPresentationOrder: 40>	| unicodeCharacterData |	unicodeCharacterData := [ self unicodeCharacterData ] on: NotFound do: [ ^ self ].	^ (unicodeCharacterData gtInspectorCharacterIn: composite)			title: 'Unicode';			yourself ! !!Character methodsFor: '*unicode-character-data'!unicodeCharacterData	"Answer the official record from the Unicode Character Database for me"		^ UnicodeCharacterData forCodePoint: self codePoint ! !!SmallInteger methodsFor: '*unicode-character-data'!unicodeCharacterData	"Answer the official record from the Unicode Character Database for me"		^ UnicodeCharacterData forCodePoint: self ! !!UnicodeCharacterData class methodsFor: 'constants'!bidirectionalCategories	"Return the possible values for bidirectional category"		"Table 13. Bidi_Class Values in http://www.unicode.org/reports/tr44/#Bidi_Class_Values"		^ #(L R AL EN ES ET AN CS NSM BN B S WS ON LRE LRO RLE RLO PDF LRI RLI FSI PDI)! !!UnicodeCharacterData class methodsFor: 'initialization'!cleanUp: aggressive	"self cleanUp"	"self cleanUp: true"	self resetHangulDatabase.	"Not 100% sure this is a good idea"	aggressive		ifTrue: [ self resetDataSets ]! !!UnicodeCharacterData class methodsFor: 'accessing - datasets'!compositionExclusions	"D112"		^ CompositionExclusions ifNil: [ CompositionExclusions := self loadCompositionExclusions ]! !!UnicodeCharacterData class methodsFor: 'private - composition exclusion'!compositionExclusionsFile	^ 'CompositionExclusions.txt'! !!UnicodeCharacterData class methodsFor: 'accessing - datasets'!database	"Return the Unicode Character Database an a dictionary mapping each codepoint to an instance of me. 	Load the database if needed from the official URL over the internet or from a local filesystem cache."		UnicodeCharacterDatabase ifNil: [ self initializeDatabase ].	^ UnicodeCharacterDatabase! !!UnicodeCharacterData class methodsFor: 'constants'!decompositionCompatibilityTypes	"Return the possible values for type of compatibility decomposition"		"Table 14. Compatibility Formatting Tags in http://www.unicode.org/reports/tr44/#Character_Decomposition_Mappings"		^ #(font noBreak initial medial final isolated circle super sub vertical wide narrow small square fraction compat)! !!UnicodeCharacterData class methodsFor: 'private - derived normalization properties'!derivedNormalizationPropertiesFile	^ 'DerivedNormalizationProps.txt'! !!UnicodeCharacterData class methodsFor: 'private - database'!extractSpecialRanges: collectionOfCharacterData	|ranges|	ranges := (collectionOfCharacterData 			select: [ :each | (each name endsWith: 'First>') or: [ each name endsWith: 'Last>' ] ])				pairsCollect: [ :first :last | Array with: first with: last ].	"Happily, in Pharo, removeAllSuchThat does *not* return the collection of removed elements..."	collectionOfCharacterData 			removeAllSuchThat: [ :each | (each name endsWith: 'First>') or: [ each name endsWith: 'Last>' ] ].	^ranges! !!UnicodeCharacterData class methodsFor: 'accessing'!forCodePoint: integer	"Return an instance of me for codepoint integer. Fail if there is no such codepoint."	^ self		forCodePoint: integer		ifAbsent: [ KeyNotFound signalFor: integer in: self database ]! !!UnicodeCharacterData class methodsFor: 'accessing'!forCodePoint: integer ifAbsent: block	"Return an instance of me for codepoint integer. Execute block if there is no such codepoint."		^ self database 		at: integer 		ifAbsent: [ self hangulDataForCodePoint: integer ifAbsent: block ]! !!UnicodeCharacterData class methodsFor: 'constants'!generalCategories	"Return the possible values for general category"		"See Table 12. General_Category Values in http://www.unicode.org/reports/tr44/#General_Category_Values"		^ #(Lu Ll Lt Lm Lo Mn Mc Me Nd Nl No Pc Pd Ps Pe Pi Pf Po Sm Sc Sk So Zs Zl Zp Cc Cf Cs Co Sn)! !!UnicodeCharacterData class methodsFor: 'private - database common'!getUnicodeCharacterDatabaseRaw: file	"Return the contents of file from the Unicode Character Database specification as a String.	Optionally use a locally downloaded cache, to enable this,	decompress http://www.unicode.org/Public/UNIDATA/UCD.zip next to your image."		| fileReference url |	fileReference := self unicodeCharacterDatabaseCacheDirectory / file.	url := self unicodeCharacterDatabaseBaseUrl / file.	^ fileReference exists		ifTrue: [ 			fileReference binaryReadStreamDo: [ :bin |				(ZnCharacterReadStream on: bin) upToEnd ] ]		ifFalse: [ 			url retrieveContents ]! !!UnicodeCharacterData class methodsFor: 'private - hangul'!hangulDataForCodePoint: integer	^ self 		hangulDataForCodePoint: integer 		ifAbsent: [ KeyNotFound signalFor: integer in: self database ]! !!UnicodeCharacterData class methodsFor: 'private - hangul'!hangulDataForCodePoint: integer ifAbsent: aBlock	"Could use on: DomainError do: aBlock rather than check range here explicitly, not sure of the perf overhead though"	(integer notNil and: [ self isHangulSyllableCodePoint: integer ])		ifFalse: [ ^ aBlock value ].	^ self hangulDatabase 		at: integer 		ifAbsentPut: [ 			UnicodeCharacterDataExtended new 				initializeFromHangulSyllable: integer;				yourself ]! !!UnicodeCharacterData class methodsFor: 'private - hangul'!hangulDatabase	"Thumb-in-air figure; assume 1000 hangul characters will be a good working set."	^ HangulCache		ifNil: [ 			HangulCache := LRUCache new				maximumWeight: 1000;				yourself ]! !!UnicodeCharacterData class methodsFor: 'initialization'!initializeDatabase	| entries |	entries := self loadUnicodeCharacterDatabase.	SpecialRanges := self extractSpecialRanges: entries.	UnicodeCharacterDatabase := IdentityDictionary new: entries size.	entries do: [ :each | 		UnicodeCharacterDatabase at: each codePoint put: each ].	self sanityCheck: entries! !!UnicodeCharacterData class methodsFor: 'initialization'!initializeJamoShortNames	JamoShortNames := self loadJamoShortNames ! !!UnicodeCharacterData class methodsFor: 'private - hangul'!isHangulSyllableCodePoint: codePoint	^ codePoint between: 16rAC00 and: 16rD7A3! !!UnicodeCharacterData class methodsFor: 'accessing - normalization quick check'!isSupplementaryCodePoint: codePoint	^ codePoint between: 16r10000 and: 16r10FFFF! !!UnicodeCharacterData class methodsFor: 'accessing - datasets'!jamoShortNames	JamoShortNames ifNil: [ self initializeJamoShortNames  ].	^JamoShortNames! !!UnicodeCharacterData class methodsFor: 'private - jamo short names'!jamoShortNamesFile	^ 'Jamo.txt'! !!UnicodeCharacterData class methodsFor: 'private - composition exclusion'!loadCompositionExclusions	| compositionExclusions |	compositionExclusions := IdentitySet new.	(self getUnicodeCharacterDatabaseRaw: self compositionExclusionsFile) linesDo: [ :each | 		(each notEmpty and: [ each first ~= $# ])			ifTrue: [ compositionExclusions add: (Integer readFrom: each base: 16) ] ].	^ compositionExclusions! !!UnicodeCharacterData class methodsFor: 'private - derived normalization properties'!loadDerivedNormalizationProperties	^ OrderedCollection streamContents: [ :out |		(self getUnicodeCharacterDatabaseRaw: self derivedNormalizationPropertiesFile) linesDo: [ :line |			(line isEmpty or: [ line first = $# ])				ifFalse: [ 					out nextPut: (self parseDerivedNormalizationProperty: line) ] ] ]! !!UnicodeCharacterData class methodsFor: 'private - jamo short names'!loadJamoShortNames	| shortNames |	shortNames := IdentityDictionary new.	(self getUnicodeCharacterDatabaseRaw: self jamoShortNamesFile)		linesDo: [ :each | 			(self parseUnicodeJamoShortNames: each) 				ifNotNil: [ :shortName | shortNames add: shortName ] ].	^ shortNames! !!UnicodeCharacterData class methodsFor: 'private - derived normalization properties'!loadNormalizationQuickCheck	| normalizationQuickCheck derivedNormalizationProperties values |	normalizationQuickCheck := IdentityDictionary new.	derivedNormalizationProperties := self loadDerivedNormalizationProperties.	#(NFC_QC NFD_QC NFKC_QC NFKD_QC) do: [ :property |		values := IdentityDictionary new.		derivedNormalizationProperties 			select: [ :each | (each at: #property) = property ] 			thenDo: [ :each | 				(each at: #range) isInteger					ifTrue: [ 						values at: (each at: #range) put: (each at: #value) asSymbol ] 					ifFalse: [ 						(each at: #range) do: [ :codePoint | 							values at: codePoint put: (each at: #value) asSymbol ] ] ].		normalizationQuickCheck at: property put: values ].	^ normalizationQuickCheck! !!UnicodeCharacterData class methodsFor: 'private - database'!loadUnicodeCharacterDatabase	^ OrderedCollection streamContents: [ :out |		(self getUnicodeCharacterDatabaseRaw: self unicodeCharacterDatabaseFile) linesDo: [ :each |			out nextPut: (self parseUnicodeCharacterData: each) ] ]! !!UnicodeCharacterData class methodsFor: 'queries'!minimalCCC		| ccc |	ccc := IdentityDictionary new.	(self database values reject: #isStarter)		do: [ :each | ccc at: each codePoint put: each ccc ].	^ ccc! !!UnicodeCharacterData class methodsFor: 'queries'!minimalDecomposition	| decomposition |	decomposition := IdentityDictionary new.	(self database values select: #hasDecomposition)		do: [ :each | decomposition at: each codePoint put: each decompositionMapping ].	^ decomposition! !!UnicodeCharacterData class methodsFor: 'queries'!nameMatching: fragment	"Find and return the Unicode Character Data objects whose official name matches fragment."		"self nameMatching: 'CAPITAL LETTER A'"		| matches |	matches := Array streamContents: [ :out |		self database valuesDo: [ :each |			"Note that by using #names both #name and #oldName if any will be used"			(each names findString: fragment startingAt: 1 caseSensitive: false) ~= 0				ifTrue: [ out nextPut: each ] ] ].	^ matches! !!UnicodeCharacterData class methodsFor: 'queries'!named: fullName	"Find and return the Unicode Character Data object whose official name is fullName."		"self named: 'LATIN CAPITAL LETTER A'"		self database valuesDo: [ :each |		each name = fullName ifTrue: [ ^ each ] ].	NotFound signalFor: fullName in: self ! !!UnicodeCharacterData class methodsFor: 'queries'!nonStarterDecompositions	"D111"		^ self database values select: #isNonStarterDecomposition! !!UnicodeCharacterData class methodsFor: 'accessing - datasets'!normalizationQuickCheck	^ NormalizationQuickCheck ifNil: [ NormalizationQuickCheck := self loadNormalizationQuickCheck ]! !!UnicodeCharacterData class methodsFor: 'accessing - normalization quick check'!normalizationQuickCheck: property forCodePoint: codePoint	"Return #Y (yes), #N (no) or #M (maybe) for property, #NFC_QC, #NFD_QC, #NFKC_QC or #NFKD_QC"		^ (self normalizationQuickCheck at: property) at: codePoint ifAbsent: [ #Y ] ! !!UnicodeCharacterData class methodsFor: 'accessing - normalization quick check'!normalizationQuickCheck: property forCodePointStream: codePointStream	| result lastCCC codePoint ccc check |	result := #Y.	lastCCC := 0.	[ codePointStream atEnd ] whileFalse: [		codePoint := codePointStream next.		"(self isSupplementaryCodePoint: codePoint) ifTrue: [ codePointStream next ]."		ccc := [ codePoint unicodeCharacterData ccc ] on: NotFound do: [ 0 ].		(lastCCC > ccc and: [ ccc ~= 0 ]) ifTrue: [ ^ #N ].		check := self normalizationQuickCheck: property forCodePoint: codePoint.		check = #N ifTrue: [ ^ #N ].		check = #M ifTrue: [ result := #M ]. 		lastCCC := ccc ].	^ result! !!UnicodeCharacterData class methodsFor: 'accessing - normalization quick check'!normalizationQuickCheck: property forString: string	^ self 		normalizationQuickCheck: property 		forCodePointStream: string readStream unicodeCodePoints! !!UnicodeCharacterData class methodsFor: 'private - derived normalization properties'!parseDerivedNormalizationProperty: line	| fields range value comment |	fields := $; split: (line copyFrom: 1 to: (line indexOf: $#) - 1).	comment := line copyFrom: (line indexOf: $#) + 2 to: line size.	range := fields first trimBoth.	range := (range indexOfSubCollection: '..' startingAt: 1 ifAbsent: [ ])		ifNil: [ Integer readFrom: range base: 16 ]		ifNotNil: [ :ellipsis | 				(Integer readFrom: (range copyFrom: 1 to: ellipsis - 1) base: 16) 					to: (Integer readFrom: (range copyFrom: ellipsis + 2 to: range size) base: 16) ].	value := fields size = 2					ifTrue: [ true ]					ifFalse: [ fields third trimBoth asSymbol ].	^ { 		#range -> range.		#property -> fields second trimBoth asSymbol.		#value -> value.		#comment -> comment trimBoth } asDictionary! !!UnicodeCharacterData class methodsFor: 'private - database'!parseUnicodeCharacterData: line	| fields isCompact concreteClass |	fields := $; split: line.	"Test if the fields for decomposition, numerical and case mapping are all empty"	isCompact := #(6 7 8 9 13 14 15) allSatisfy: [ :each | (fields at: each) isEmpty ].	concreteClass := isCompact 		ifTrue: [ UnicodeCharacterData ] 		ifFalse: [ UnicodeCharacterDataExtended ].	^ concreteClass new		initializeFrom: fields;		yourself! !!UnicodeCharacterData class methodsFor: 'private - jamo short names'!parseUnicodeJamoShortNames: aLine	| codePoint start end shortName |	"Don't parse comments and empty lines"	(aLine isEmpty or: [aLine first = $#]) ifTrue: [ ^nil ].	"All lines are in format CODEPOINT; SHORTNAME #LONGNAME "	codePoint := Number readFrom: aLine base: 16.	start := (aLine indexOf: $;) + 2.	end := (aLine indexOf: Character space startingAt: start) -1.	shortName := aLine copyFrom: start to: end.	^codePoint -> shortName	 ! !!UnicodeCharacterData class methodsFor: 'initialization'!resetDataSets	"self resetDataSets"	UnicodeCharacterDatabase := nil.	SpecialRanges := nil.	JamoShortNames := nil.	NormalizationQuickCheck := nil.	CompositionExclusions := nil! !!UnicodeCharacterData class methodsFor: 'private - hangul'!resetHangulDatabase	^ HangulCache ifNotNil: [ HangulCache removeAll ]! !!UnicodeCharacterData class methodsFor: 'initialization'!sanityCheck: newlyImportedCharacterData	"Check that assumptions made of the structure in algoritmic implementations still hold."	 newlyImportedCharacterData do: [ :one | one decompositionWarning ifNotNil: [ :warning | warning logCr ] ].! !!UnicodeCharacterData class methodsFor: 'queries'!singletons	"D110"		^ self database values select: #isSingleton! !!UnicodeCharacterData class methodsFor: 'accessing - datasets'!specialRanges	SpecialRanges ifNil: [ self initializeDatabase ].	^ SpecialRanges! !!UnicodeCharacterData class methodsFor: 'private - database common'!unicodeCharacterDatabaseBaseUrl	"Return the base of URL where all files of the UCD dataset can be found"		^ 'http://www.unicode.org/Public/UNIDATA' asZnUrl! !!UnicodeCharacterData class methodsFor: 'private - database common'!unicodeCharacterDatabaseCacheDirectory	"Return the directory where a local filesystem copy of the UCD data is stored.	Decompress http://www.unicode.org/Public/UNIDATA/UCD.zip next to your image"		^ FileLocator imageDirectory / #UCD! !!UnicodeCharacterData class methodsFor: 'private - database'!unicodeCharacterDatabaseFile	"Return the name of the main Unicode Character Database specification file"		^ 'UnicodeData.txt'! !!UnicodeCharacterData class methodsFor: 'queries'!unmappedDecompositionCodePoints	^ (Array streamContents: [ :out | 			self database valuesDo: [ :ucd | 				ucd decompositionMappingDo: [ :each | 					self forCodePoint: each ifAbsent: [ out nextPut: each ] ] ] ]) asSet sorted! !!UnicodeCharacterData class methodsFor: 'queries'!unmappedDecompositions	^ (self database values select: [ :ucd | 			| missing |			missing := false.			ucd decompositionMappingDo: [ :each |				self forCodePoint: each ifAbsent: [ missing := true ] ]. 			missing ]) sorted! !!UnicodeCharacterData methodsFor: 'comparing'!<= otherUnicodeCharacterData	^ self codePoint <= otherUnicodeCharacterData codePoint! !!UnicodeCharacterData methodsFor: 'comparing'!= anObject	self == anObject ifTrue: [ ^ true ].	self class = anObject class ifFalse: [ ^ false ].	^ codePoint = anObject codePoint! !!UnicodeCharacterData methodsFor: 'accessing'!bidirectionalCategory	"Return the symbol indicating the Bidirection Category of my codepoint"	| index |	index := (bitEncodedFields >> 13) bitAnd: 2r11111.	^ self class bidirectionalCategories at: index + 1! !!UnicodeCharacterData methodsFor: 'accessing'!canonicalCombiningClass	"Return the integer indicating the Canonical Combining Class of my codepoint"	^ bitEncodedFields bitAnd: 16rFF! !!UnicodeCharacterData methodsFor: 'accessing'!caseMapping	"If not nil, a 3 element array: { upper. lower. title } each of which could be nil.	Use the accessors #uppercase, #lowercase or #titlecase instead"		^ nil! !!UnicodeCharacterData methodsFor: 'accessing'!ccc	"A shorter alias"		^ self canonicalCombiningClass ! !!UnicodeCharacterData methodsFor: 'accessing'!character	"Return a character instance corresponding to my codepoint"	^ Character codePoint: codePoint! !!UnicodeCharacterData methodsFor: 'accessing'!codePoint	"Return my codepoint, an integer"		^ codePoint! !!UnicodeCharacterData methodsFor: 'accessing'!decimalDigitValue	"Return the decimal digit value of my codepoint as an integer. Could be nil if not applicable."		^ self numericMapping ifNotNil: [ :numericMapping | numericMapping first ]! !!UnicodeCharacterData methodsFor: 'gt-inspector-extension'!decompositionAsUCDs	^ self decompositionMapping ifNotNil: [ :decomposition | 			decomposition collect: [ :each | 				each isInteger 					ifTrue: [ 						self class 							forCodePoint: each 							ifAbsent: [ 								self class new 									initializeDegenerate: each;									yourself ] ]					ifFalse: [ each ] ] ]! !!UnicodeCharacterData methodsFor: 'gt-inspector-extension'!decompositionDescription	^ String streamContents: [ :out |			self decompositionMapping ifNotNil: [ :mapping | 				| decomposition |				mapping first isInteger 					ifTrue: [ decomposition := mapping ]					ifFalse: [ 						out << $< << mapping first << $>; space. 						decomposition := mapping allButFirst ].			decomposition 				do: [ :each | out nextPut: (Character codePoint: each) ]				separatedBy: [ out << ' + ' ] ] ]! !!UnicodeCharacterData methodsFor: 'accessing'!decompositionMapping	"Return my decomposition mapping if applicable, an array of code points, with an optional symbol tag in the first position. The code points of my decomposition can be combined into my codepoint."		^ nil! !!UnicodeCharacterData methodsFor: 'accessing'!decompositionMappingDo: block	"Execute block for each code point in my decomposition mapping, if any"		self hasCanonicalDecomposition 		ifTrue: [ ^ self decompositionMapping do: block ].	self hasCompatibleDecomposition 		ifTrue: [ ^ self decompositionMapping allButFirstDo: block ]! !!UnicodeCharacterData methodsFor: 'accessing'!decompositionString	"Return my decomposition as a String, if I have none, return an empty string."		^ String streamContents: [ :out |			self decompositionMappingDo: [ :each | 				out nextPut: (Character codePoint: each) ] ]! !!UnicodeCharacterData methodsFor: 'private'!decompositionWarning	"Return a warning if our decomposition is on a form not handled by the decomposition implementations. 	We could hope the decomposition tests would be updated if this were the case, but then again, there's none exibiting correct reordering for nonStarters followed by starters with non-starter decomposition with lower combining class"	| first |	first := true.	self decompositionMappingDo: [ :cP | 		(first and: 		[[cP unicodeCharacterData isStarter] on: NotFound do: [true]]) ifTrue: [ ^nil].		first := false.		([cP unicodeCharacterData isStarter] on: NotFound do: [true]) ifTrue: [ ^self name, 'has decomposition not handled by implementation, #isNonStarter: must be changed to deal with #(NonStarter, Starter) decompositions to remain conformant with this version of Unicode'  ].		 ] .	^nil! !!UnicodeCharacterData methodsFor: 'accessing'!digitValue	"Return the digit value of my codepoint as an integer. Could be nil if not applicable."	^ self numericMapping ifNotNil: [ :numericMapping | numericMapping second ]! !!UnicodeCharacterData methodsFor: 'accessing'!generalCategory	"Return the symbol indicating the General Category of my codepoint"	| index |	index := (bitEncodedFields >> 8) bitAnd: 2r11111.	^ self class generalCategories at: index + 1! !!UnicodeCharacterData methodsFor: 'gt-inspector-extension'!gtInspectorCharacterIn: composite	<gtInspectorPresentationOrder: 30>	^ composite table		title: 'Character';		display: [			{				{ 'codepoint'. self codePoint }.				{ 'codepoint hex'. 					String streamContents: [ :stream | 						stream << 'U+'.						self codePoint printOn: stream base: 16 nDigits: 4 ].					self codePoint }.				{ 'character'. self character printString. self character }.				{ 'name'. self name }.				{ 'old name'. self oldName ifNil: [ '' ]. self oldName }.				{ 'general category'. self generalCategory }.				{ 'canonical combining class'. self canonicalCombiningClass }.				{ 'bidirectional category'. self bidirectionalCategory }.				{ 'mirrored'. self mirrored }.				{ 'uppercase'. 					self uppercase ifNotNil: [ :n | Character codePoint: n ] ifNil: [ '' ]. 					self class forCodePoint: self uppercase ifAbsent: [] }.				{ 'lowercase'. 					self lowercase ifNotNil: [ :n | Character codePoint: n ] ifNil: [ '' ]. 					self class forCodePoint: self lowercase ifAbsent: [] }.				{ 'titlecase'. 					self titlecase ifNotNil: [ :n | Character codePoint: n ] ifNil: [ '' ]. 					self class forCodePoint: self titlecase ifAbsent: [] }.				{ 'decimal digit value'. self decimalDigitValue ifNil: [ '' ]. self decimalDigitValue }.				{ 'digit value'. self digitValue ifNil: [ '' ]. self digitValue }.				{ 'numeric value'. self numericValue ifNil: [ '' ]. self numericValue }.				{ 'decomposition'. self decompositionDescription. self decompositionAsUCDs }			} ];		column: 'Key' evaluated: #first;		column: 'Value' evaluated: [ :entry | entry second asString ];		send: [ :entry | entry at: 3 ifAbsent: [ entry second ] ]! !!UnicodeCharacterData methodsFor: 'gt-inspector-extension'!gtInspectorGlyphIn: composite	<gtInspectorPresentationOrder: 40>	^ self character gtInspectorGlyphIn: composite! !!UnicodeCharacterData methodsFor: 'testing'!hasCanonicalDecomposition	^ self hasDecomposition and: [ self decompositionMapping first isInteger ]! !!UnicodeCharacterData methodsFor: 'testing'!hasCompatibleDecomposition	^ self hasDecomposition and: [ self decompositionMapping first isSymbol ]! !!UnicodeCharacterData methodsFor: 'testing'!hasDecomposition	^ false! !!UnicodeCharacterData methodsFor: 'testing'!hasStandardCanonicalDecomposition	^ self hasCanonicalDecomposition and: [ self decompositionMapping size = 2 ]! !!UnicodeCharacterData methodsFor: 'comparing'!hash	^ codePoint hash! !!UnicodeCharacterData methodsFor: 'private'!initializeBitEncodedFieldsFrom: fields	| generalCategory canonicalCombiningClass bidirectionalCategory mirrored generalIndex bidiIndex |	generalCategory := fields third asSymbol.	canonicalCombiningClass := fields fourth asNumber.	bidirectionalCategory := fields fifth asSymbol.	mirrored := (fields at: 10) first = $Y.	generalIndex := self class generalCategories 		indexOf: generalCategory ifAbsent: [ NotFound signalFor: generalCategory ].	bidiIndex := self class bidirectionalCategories 		indexOf: bidirectionalCategory ifAbsent: [ NotFound signalFor: bidirectionalCategory ].	bitEncodedFields := canonicalCombiningClass 		+ (generalIndex - 1 << 8) 		+ (bidiIndex - 1 << 13)		+ (mirrored asBit << 18)! !!UnicodeCharacterData methodsFor: 'initialize'!initializeDegenerate: integer	codePoint := integer.	name := '<UNKNOWN>'.	bitEncodedFields := 0! !!UnicodeCharacterData methodsFor: 'initialize'!initializeFrom: fields	codePoint := Integer readFrom: fields first base: 16.	name := fields second.	(fields at: 11) ifNotEmpty: [ :oldname | 		name := name, Character tab asString, oldname ].	self initializeBitEncodedFieldsFrom: fields.! !!UnicodeCharacterData methodsFor: 'testing'!isCompositionExclusion	^ self class compositionExclusions includes: codePoint ! !!UnicodeCharacterData methodsFor: 'testing'!isFullCompositionExclusion	^ self isSingleton or: [ self isNonStarterDecomposition or: [ self isCompositionExclusion ] ]! !!UnicodeCharacterData methodsFor: 'testing'!isLetter	^ self generalCategory first = $L! !!UnicodeCharacterData methodsFor: 'testing'!isLowercase	^ self generalCategory = #Ll! !!UnicodeCharacterData methodsFor: 'testing'!isMark	^ self generalCategory first = $M! !!UnicodeCharacterData methodsFor: 'testing'!isNonStarterDecomposition	^ self hasCanonicalDecomposition 			and: [ self isSingleton not				and: [ 					self isStarter not 						or: [ (self class forCodePoint: self decompositionMapping first) isStarter not ] ] ]! !!UnicodeCharacterData methodsFor: 'testing'!isNumber	^ self generalCategory first = $N! !!UnicodeCharacterData methodsFor: 'testing'!isNumberDecimal	^ self generalCategory = #Nd! !!UnicodeCharacterData methodsFor: 'testing'!isNumberLetter	^ self generalCategory = #Nl! !!UnicodeCharacterData methodsFor: 'testing'!isNumberOther	^ self generalCategory = #No! !!UnicodeCharacterData methodsFor: 'testing'!isOther	^ self generalCategory first = $C! !!UnicodeCharacterData methodsFor: 'testing'!isPrimaryComposite	^ self hasCanonicalDecomposition and: [ self isFullCompositionExclusion not ]! !!UnicodeCharacterData methodsFor: 'testing'!isPunctuation	^ self generalCategory first = $P! !!UnicodeCharacterData methodsFor: 'testing'!isSeparator	^ self generalCategory first = $Z! !!UnicodeCharacterData methodsFor: 'testing'!isSingleton	^ self hasCanonicalDecomposition and: [ self decompositionMapping size = 1 ]! !!UnicodeCharacterData methodsFor: 'testing'!isStarter	^ self canonicalCombiningClass = 0! !!UnicodeCharacterData methodsFor: 'testing'!isSymbol	^ self generalCategory first = $S! !!UnicodeCharacterData methodsFor: 'testing'!isTitlecase	^ self generalCategory = #Lt! !!UnicodeCharacterData methodsFor: 'testing'!isUppercase	^ self generalCategory = #Lu! !!UnicodeCharacterData methodsFor: 'accessing'!jamoShortName	"As the name only exists for the few hangul base characters, they are kept in a separate table, rather than as general properties"		^ self class jamoShortNames at: self codePoint ifAbsent: ''! !!UnicodeCharacterData methodsFor: 'accessing'!lowercase	"Return the codepoint of the lowercase version of my codepoint. Could be nil if not applicable"		^ self caseMapping ifNotNil: [ :caseMapping | caseMapping second ]! !!UnicodeCharacterData methodsFor: 'accessing'!mirrored	"Return if my codepoint is mirrored or not"		^ (bitEncodedFields bitAt: 19) = 1! !!UnicodeCharacterData methodsFor: 'accessing'!name	"Return my official name"		| tabIndex |	tabIndex := name indexOf: Character tab ifAbsent: [ ^ name ].	^ name copyFrom: 1 to: tabIndex - 1! !!UnicodeCharacterData methodsFor: 'accessing'!names	"Return our internal name(s) representation <NAME><TAB>[<OLD-NAME>]"		^ name! !!UnicodeCharacterData methodsFor: 'accessing'!numericMapping	"If not nil, a 3 element array: { decimalDigit. digit. numeric } each of which could be nil.	Use the accessors #decimalDigitValue, #digitValue or #numericValue instead"	^ nil! !!UnicodeCharacterData methodsFor: 'accessing'!numericValue	"Return the numeric value of my codepoint as an integer. Could be nil if not applicable."	^ self numericMapping ifNotNil: [ :numericMapping | numericMapping third ]! !!UnicodeCharacterData methodsFor: 'accessing'!oldName	"Return my old/legacy name, could be nil"		| tabIndex |	tabIndex := name indexOf: Character tab ifAbsent: [ ^ nil ].	^ name copyFrom: tabIndex + 1 to: name size! !!UnicodeCharacterData methodsFor: 'printing'!printOn: stream	stream << 'U+'.	self codePoint printOn: stream base: 16 nDigits: 4.	stream space; << self name.	self oldName ifNotNil: [ stream space; nextPut: $(; << self oldName; nextPut: $) ]! !!UnicodeCharacterData methodsFor: 'gt-spotter-extension'!spotterPreviewIn: aComposite	<spotterPreview: 10>	^ aComposite table		title: 'Unicode Character';		display: [			{				{ 'codepoint'. self codePoint }.				{ 'codepoint hex'. 					String streamContents: [ :stream | 						stream << 'U+'.						self codePoint printOn: stream base: 16 nDigits: 4 ].					self codePoint }.				{ 'character'. self character printString. self character }.				{ 'name'. self name }.				{ 'old name'. self oldName ifNil: [ '' ]. self oldName }.				{ 'general category'. self generalCategory }.				{ 'canonical combining class'. self canonicalCombiningClass }.				{ 'bidirectional category'. self bidirectionalCategory }.				{ 'mirrored'. self mirrored }.				{ 'uppercase'. 					self uppercase ifNotNil: [ :n | Character codePoint: n ] ifNil: [ '' ]. 					self class forCodePoint: self uppercase ifAbsent: [] }.				{ 'lowercase'. 					self lowercase ifNotNil: [ :n | Character codePoint: n ] ifNil: [ '' ]. 					self class forCodePoint: self lowercase ifAbsent: [] }.				{ 'titlecase'. 					self titlecase ifNotNil: [ :n | Character codePoint: n ] ifNil: [ '' ]. 					self class forCodePoint: self titlecase ifAbsent: [] }.				{ 'decimal digit value'. self decimalDigitValue ifNil: [ '' ]. self decimalDigitValue }.				{ 'digit value'. self digitValue ifNil: [ '' ]. self digitValue }.				{ 'numeric value'. self numericValue ifNil: [ '' ]. self numericValue }.				{ 'decomposition'. self decompositionDescription. self decompositionAsUCDs }			} ];		column: 'Key' evaluated: #first;		column: 'Value' evaluated: [ :entry | entry second asString ];		entity: self! !!UnicodeCharacterData methodsFor: 'accessing'!titlecase	"Return the codepoint of the titlecase version of my codepoint. Could be nil if not applicable"	^ self caseMapping ifNotNil: [ :caseMapping | caseMapping third ]! !!UnicodeCharacterData methodsFor: 'accessing'!uppercase	"Return the codepoint of the uppercase version of my codepoint. Could be nil if not applicable"	^ self caseMapping ifNotNil: [ :caseMapping | caseMapping first ]! !!UnicodeCharacterDataExtended methodsFor: 'accessing'!caseMapping	"If not nil, a 3 element array: { upper. lower. title } each of which could be nil.	Use the accessors #uppercase, #lowercase or #titlecase instead"		^ caseMapping! !!UnicodeCharacterDataExtended methodsFor: 'accessing'!decompositionMapping	"Return my decomposition mapping if applicable, an array of code points, with an optional symbol tag in the first position. The code points of my decomposition can be combined into my codepoint."		^ decompositionMapping! !!UnicodeCharacterDataExtended methodsFor: 'testing'!hasDecomposition	^ decompositionMapping notNil! !!UnicodeCharacterDataExtended methodsFor: 'private'!initializeCaseMappingFrom: fields	| uppercase lowercase titlecase |	uppercase := (fields at: 13) ifEmpty: [ ] ifNotEmpty: [ :each | Integer readFrom: each base: 16 ].	lowercase := (fields at: 14) ifEmpty: [ ] ifNotEmpty: [ :each | Integer readFrom: each base: 16 ].	titlecase := (fields at: 15) ifEmpty: [ ] ifNotEmpty: [ :each | Integer readFrom: each base: 16 ].	uppercase notNil | lowercase notNil | titlecase notNil		ifTrue: [ caseMapping := Array with: uppercase with: lowercase with: titlecase ]! !!UnicodeCharacterDataExtended methodsFor: 'private'!initializeDecompositionMappingFrom: fields	decompositionMapping := fields sixth ifEmpty: [  ] ifNotEmpty: [ :mapping | self parseDecompositionMapping: mapping ]! !!UnicodeCharacterDataExtended methodsFor: 'initialize'!initializeFrom: fields	super initializeFrom: fields.	self initializeDecompositionMappingFrom: fields.	self initializeNumericMappingFrom: fields.	self initializeCaseMappingFrom: fields! !!UnicodeCharacterDataExtended methodsFor: 'initialize'!initializeFromHangulSyllable: anInteger 	"Derived from hangul syllable code point. 	Ref. http://www.unicode.org/versions/Unicode8.0.0/ch03.pdf section 3.12 page 145, bottom part"	| sIndex vIndex tIndex lIndex lPart vPart tPart |	(self class isHangulSyllableCodePoint: anInteger)		ifFalse: [ DomainError signal: 'Hangul syllable outside range' from: 16rAC00 to: 16rD7A3 ].	"sBase := 16rAC00. lBase := 16r1100. vBase := 16r1161. tBase := 16r11A7.	 lCount := 19. vCount := 21. tCount := 28. nCount := 588."	codePoint := anInteger.	sIndex := codePoint - 16rAC00.	lIndex := sIndex // 588.	vIndex := sIndex \\ 588 // 28.	tIndex := sIndex \\ 28.	lPart := 16r1100 + lIndex.	vPart := 16r1161 + vIndex.	tPart := 16r11A7 + tIndex.	decompositionMapping := tIndex = 0 		ifTrue: [ Array with: lPart with: vPart ] 		ifFalse: [ Array with: lPart with: vPart with: tPart ] .	name := decompositionMapping 		inject: 'HANGUL SYLLABLE ' 		into: [ :sub :next | sub , (self class jamoShortNames at: next) ].	bitEncodedFields := 0 "CCC=0, General=#Lu, Bidi=#L, mirrored=false"! !!UnicodeCharacterDataExtended methodsFor: 'private'!initializeNumericMappingFrom: fields	| decimalDigitValue digitValue numericValue |	decimalDigitValue := (fields at: 7) ifEmpty: [ ] ifNotEmpty: [ :each | each asNumber ]. 	digitValue := (fields at: 8) ifEmpty: [ ] ifNotEmpty: [ :each | each asNumber ]. 	numericValue := (fields at: 9) ifEmpty: [ ] ifNotEmpty: [ :each | each asNumber ].	decimalDigitValue notNil | digitValue notNil | numericValue notNil		ifTrue: [ numericMapping := Array with: decimalDigitValue with: digitValue with: numericValue ]! !!UnicodeCharacterDataExtended methodsFor: 'accessing'!numericMapping	"If not nil, a 3 element array: { decimalDigit. digit. numeric } each of which could be nil.	Use the accessors #decimalDigitValue, #digitValue or #numericValue instead"	^ numericMapping! !!UnicodeCharacterDataExtended methodsFor: 'private'!parseDecompositionMapping: string	^ ((Character space split: string)			collect: [ :each |				each first = $<					ifTrue: [ (each copyFrom: 2 to: each size - 1) asSymbol ]					ifFalse: [ Integer readFrom: each base: 16 ] ]) asArray! !"Unicode-Character-Data"!!CharacterFromCodePointReadStream commentStamp: '' prior: 0!I am CharacterFromCodePointReadStream, I wrap a code point Integer ReadStream and translate code point Integers to Characters.For example	(97 to: 122) readStream is a ReadStream that returns Integers, while	(97 to: 122) readStream unicodeCharacters	is a ReadStream that returns the Character objects for each code point.	(97 to: 122) readStream unicodeCharacters upToEndIn effect I translate each Integer code point to a Character.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!CharacterToCodePointWriteStream commentStamp: '' prior: 0!I am CharacterToCodePointWriteStream. I wrap a code point Integer WriteStream and translate Characters to Integer code points.Here is an example	Array streamContents: [ :out |		out unicodeCharacters nextPut: $A; nextPutAll: 'bcde' ]	So client code writes Characters and Strings while the underlying stream receives Integer code points,In effect I translate each Character to an Integer code point.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!CodePointFromCharacterReadStream commentStamp: '' prior: 0!I am CodePointFromCharacterReadStream, I wrap a Character ReadStream and translate Characters into code point Integers.For example	'abc' readStream is a ReadStream that returns Character objects, while	'abc' readStream unicodeCodePoints	is a ReadStream that returns the Integer code points of each character.	Character alphabet  readStream unicodeCodePoints upToEndIn effect I translate each Character to an Integer code point.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!CodePointToCharacterWriteStream commentStamp: '' prior: 0!I am CodePointToCharacterWriteStream. I wrap a Character WriteStream and translate code point Integers into Characters.Here is an example	String streamContents: [ :out |		out unicodeCodePoints nextPutAll: (97 to: 122); nextPut: 33 ]	So client code writes Integer code points while the underlying stream receives Character objects.In effect I translate each Integer code point to a Character.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!WriteStream methodsFor: '*unicode-stream-support'!unicodeCharacters	"Assuming the receiver is a stream over Integer code points, return a CharacterToCodePointWriteStream over the receiver that streams over Characters"		^ CharacterToCodePointWriteStream on: self! !!WriteStream methodsFor: '*unicode-stream-support'!unicodeCodePoints	"Assuming the receiver is a stream over Characters, return a CodePointToCharacterWriteStream over the receiver that streams over Integer code points"		^ CodePointToCharacterWriteStream on: self! !!CharacterFromCodePointReadStream class methodsFor: 'initialization'!on: codePointReadStream	^ self new		on: codePointReadStream;		yourself! !!CharacterFromCodePointReadStream methodsFor: 'streaming'!atEnd	^ readStream atEnd! !!CharacterFromCodePointReadStream methodsFor: 'streaming'!next	^ readStream next ifNotNil: [ :codePoint | Character codePoint: codePoint ]! !!CharacterFromCodePointReadStream methodsFor: 'initialization'!on: codePointReadStream	readStream := codePointReadStream ! !!CharacterFromCodePointReadStream methodsFor: 'streaming'!peek	^ readStream peek ifNotNil: [ :codePoint | Character codePoint: codePoint ]! !!CharacterFromCodePointReadStream methodsFor: 'converting'!unicodeCodePoints	"Return a CodePointFromCharacterReadStream over the receiver that streams over Integer code points"		^ CodePointFromCharacterReadStream on: self! !!CharacterFromCodePointReadStream methodsFor: 'streaming'!upToEnd	| out character |	out := (String new: 10) writeStream.	[ self atEnd ] whileFalse: [ 		character := self next.		(character isOctetCharacter not and: [ out originalContents isWideString not ])			ifTrue: [ | position wideString |				position := out position.				wideString := WideString from: out originalContents.				out on: wideString; setFrom: position + 1 to: position ].		out nextPut: character ].	^ out contents! !!CharacterToCodePointWriteStream class methodsFor: 'initialization'!on: codePointWriteStream	^ self new		on: codePointWriteStream;		yourself! !!CharacterToCodePointWriteStream methodsFor: 'streaming'!nextPut: character	writeStream nextPut: character codePoint! !!CharacterToCodePointWriteStream methodsFor: 'streaming'!nextPutAll: collection	collection do: [ :each | self nextPut: each ]! !!CharacterToCodePointWriteStream methodsFor: 'initialization'!on: codePointWriteStream	writeStream := codePointWriteStream ! !!CodePointFromCharacterReadStream class methodsFor: 'initialization'!on: characterReadStream	^ self new		on: characterReadStream;		yourself! !!CodePointFromCharacterReadStream methodsFor: 'streaming'!atEnd	^ readStream atEnd! !!CodePointFromCharacterReadStream methodsFor: 'streaming'!next	^ readStream next ifNotNil: [ :character | character codePoint ]! !!CodePointFromCharacterReadStream methodsFor: 'initialization'!on: characterReadStream	readStream := characterReadStream ! !!CodePointFromCharacterReadStream methodsFor: 'streaming'!peek	^ readStream peek ifNotNil: [ :character | character codePoint ]! !!CodePointFromCharacterReadStream methodsFor: 'streaming'!reset	^ readStream reset! !!CodePointFromCharacterReadStream methodsFor: 'converting'!unicodeCharacters	"Return a CharacterFromCodePointReadStream over the receiver that streams over Characters"		^ CharacterFromCodePointReadStream on: self! !!CodePointFromCharacterReadStream methodsFor: 'streaming'!upToEnd	^ Array streamContents: [ :out |			[ self atEnd ] whileFalse: [ out nextPut: self next ] ]! !!CodePointToCharacterWriteStream class methodsFor: 'initialization'!on: characterWriteStream	^ self new		on: characterWriteStream;		yourself! !!CodePointToCharacterWriteStream methodsFor: 'streaming'!nextPut: codePoint	writeStream nextPut: (Character codePoint: codePoint)! !!CodePointToCharacterWriteStream methodsFor: 'streaming'!nextPutAll: collection	collection do: [ :each | self nextPut: each ]! !!CodePointToCharacterWriteStream methodsFor: 'initialization'!on: characterWriteStream	writeStream := characterWriteStream ! !!ReadStream methodsFor: '*unicode-stream-support'!unicodeCharacters	"Assuming the receiver is a stream over Integer code points, return a CharacterFromCodePointReadStream over the receiver that streams over Characters"		^ CharacterFromCodePointReadStream on: self! !!ReadStream methodsFor: '*unicode-stream-support'!unicodeCodePoints	"Assuming the receiver is a stream over Characters, return a CodePointFromCharacterReadStream over the receiver that streams over Integer code points"		^ CodePointFromCharacterReadStream on: self! !"Unicode-Stream-Support"!!UnicodeCaser commentStamp: '' prior: 0!I am UnicodeCaser, a tool to change the case of a string of Unicode characters to lower, upper or title case.Currently, this implementation is too simplistic.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeCaser methodsFor: 'public'!case: case from: inputStream to: outputStream	self assert: (#(uppercase lowercase titelcase) includes: case).	inputStream do: [ :each |		| unicodeCharacterData |		unicodeCharacterData := each unicodeCharacterData.		(unicodeCharacterData perform: case)			ifNil: [ outputStream nextPut: each ] 			ifNotNil: [ :value | outputStream nextPut: value ] ]! !!UnicodeCaser methodsFor: 'public'!case: case fromCharacters: inputStream to: outputStream	self assert: (#(uppercase lowercase titelcase) includes: case).	inputStream do: [ :each |		(each unicodeCharacterData perform: case)			ifNil: [ outputStream nextPut: each ] 			ifNotNil: [ :value | outputStream nextPut: (Character codePoint: value) ] ]! !!UnicodeCaser methodsFor: 'convencience'!case: case string: string	^ String streamContents: [ :out |			self case: case fromCharacters: string readStream to: out ]! !"Unicode-Casing"!!UnicodeComposer commentStamp: '' prior: 0!I am UnicodeComposer. I compose streams of unicode code points to their composed form.I have two primary interfaces.The first is #composeFrom:to: that operates from an input stream of code points to an output stream of code points in one process.The second is #composeBuffer: the elementary operation of the above process that operates on a buffer of non-starters between a first and final starter. Note that this buffer can shrink.Streaming composition can be done by UnicodeComposingReadStream that uses me for buffer composition.I can only work 100% correct if my input is properly decomposed. If my input is NFD, my output will be NFC. If my input is NFKD, my output will be NFKC.I know how to do algorithmic composition of Hangul.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeComposingReadStream commentStamp: '' prior: 0!I am UnicodeComposingReadStream. I wrap an input read stream of (normally decomposed) code points and produce a composed normalized stream of code points.I use UnicodeComposer to compose intermediate buffers.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeConcatenator commentStamp: '' prior: 0!I am UnicodeConcatenator, for a given normalization form I can concatenate two strings.This implements the algorithm described in the last paragraph of section 9.1 Stable Code Points of http://www.unicode.org/reports/tr15/ Unicode Normalization.Try:  UnicodeConcatenator forNFC concatenateString: 'abce' with: '́def'.  UnicodeConcatenator forNFC concatenateCodePoints: #(97 98 99 101) with: #(769 100 101 102).The last character of the first string $e (U+0065 LATIN SMALL LETTER E) and the first character of the second string $́ (U+0301 COMBINING ACUTE ACCENT aka NON-SPACING ACUTE) combine to $é (U+00E9 LATIN SMALL LETTER E WITH ACUTE) in the resulting concatenation. Also note that both the first and second string had 4 characters, while their concatenation has 7. This is why concatenation of Unicode strings is non-trivial.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeDecomposedNormalizationForm commentStamp: '' prior: 0!I am a Decomposed Normalization Form.I know how to perform the two main steps of the Unicode decomposition algorithm: - Recursively decompose a code point into a buffer- Recursively decompose a stream of non-starter codepoints into a buffer.These operations rely on no state, and as such are implemented on the class side.For pure string operations, decomposehttp://unicode.org/reports/tr15/#Description_NormPart of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeNFD commentStamp: '' prior: 0!I am  Normalized Form D, Canonical Decomposition.The valid code point sequences  code points decompose to in this form, cannot be marked as a Compatible decomposition in the Unicode database.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeNFKD commentStamp: '' prior: 0!I am  Normalized Form KD, Compatibility Decomposition.The valid code point sequences  code points decompose to in this form, cannot be marked as a Compatible decomposition in the Unicode database.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeDecomposer commentStamp: '' prior: 0!I am UnicodeDecomposer. I decompose streams of Unicode code points using either Canonical or Compatible combinations, NFD and NFKD, using #decomposeFrom:to: and #decomposeCompatibleFrom:to:  respectively.I use the Unicode Character Database to recursively decompose combined characters.An alternative, streaming implementation of the process that I implement can be found in UnicodeDecomposingReadStream's two concrete subclasses.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeDecomposingReadStream commentStamp: '' prior: 0!UnicodeDecomposingReadStream  is a streaming implementation of  the Unicode Normalization Algorithm for the Decomposed Forms.It wraps an input read stream of code points and produces a  stream of code points in the decomposed  form the stream was created as. An  alternate implementation of the same, operating on strings, rather than streams, can be found in UnicodeDecomposer.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeNormalizer commentStamp: '' prior: 0!I am UnicodeNormalizer, I implement the normalize operation which transforms Unicode text into an equivalent composed or decomposed normal form, allowing for easier comparing, searching and sorting of text. I implement the forms NFC, NFD, NFKC and NFKD.I can handle String and code point collections.This is a high level interface that applies two fast path optimalizations: - don't do work on ASCII or Latin1 string when it is not needed - do a normalization quick check to see if normalization is really neededPart of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeComposer class methodsFor: 'accessing'!default	^ Default ifNil: [ Default := self new ]! !!UnicodeComposer class methodsFor: 'accessing'!resetDefault	Default := nil! !!UnicodeComposer methodsFor: 'private - combinations'!combinationOf: first and: second	second ifNil: [ ^ nil ].	^ (self hangulCombinationOf: first and: second) 			ifNil: [ self primaryCombinationOf: first and: second ]! !!UnicodeComposer methodsFor: 'accessing'!combinations	combinations ifNil: [ self initializeForComposition ].	^ combinations! !!UnicodeComposer methodsFor: 'accessing'!combiningCharacters	combiningCharacters ifNil: [ self initializeForComposition ].	^ combiningCharacters! !!UnicodeComposer methodsFor: 'public'!composeBuffer: buffer		"Process decomposed CCC ordered buffer, trying to combine/compose pairs, unless blocked"	| lastCCC index ccc combination |	lastCCC := 0.	index := 2.	[ index <= buffer size ] whileTrue: [		ccc := [ (buffer at: index) unicodeCharacterData ccc ] on: NotFound do: [ 0 ].		combination := self combinationOf: buffer first and: (buffer at: index).		(combination notNil and: [ (lastCCC < ccc) | (lastCCC = 0) ])			ifTrue: [ 				buffer at: 1 put: combination.				buffer removeAt: index ]			ifFalse: [ 				index := index + 1. 				lastCCC := ccc ] ]! !!UnicodeComposer methodsFor: 'public'!composeFrom: input to: output	| buffer |	buffer := OrderedCollection new.	(self scanForStarterFrom: input to: output)		ifNotNil: [ :nonStarter | buffer addLast: nonStarter ].	[ input atEnd ] whileFalse: [		self scanUntilStarterFrom: input to: buffer.		"Compose the buffer <starter1> ... <starter2>" 		self composeBuffer: buffer.		"We're done, flush everything except <starter2> which we keep for the next iteration"		buffer allButLastDo: [ :each | output nextPut: each ].		buffer last in: [ :last | buffer reset; addLast: last ] ].	output nextPutAll: buffer! !!UnicodeComposer methodsFor: 'convencience'!composeString: string	"Return the NFC of string, the canonical composition normal form"		string isByteString ifTrue: [		"Latin1 strings are already in NFC" 		^ string ]. 	^ String streamContents: [ :out |			self 				composeFrom: string readStream unicodeCodePoints				to: out unicodeCodePoints ]! !!UnicodeComposer methodsFor: 'private - combinations'!hangulCombinationOf: first and: second	"Algorithmic Hangul Syllable Componsition.	Ref. http://www.unicode.org/versions/Unicode8.0.0/ch03.pdf section 3.12 page 146"		(self hangulLVCombinationOf: first and: second)		ifNotNil: [ :combination | ^ combination ].	(self hangulSTCombinationOf: first and: second)		ifNotNil: [ :combination | ^ combination ].	^ nil! !!UnicodeComposer methodsFor: 'private - combinations'!hangulCombinationOf: lPart and: vPart and: tPart	"Algorithmic Hangul Syllable Componsition.	Ref. http://www.unicode.org/versions/Unicode8.0.0/ch03.pdf section 3.12 page 146"		| lIndex vIndex tIndex |	"sBase := 16rAC00. lBase := 16r1100. vBase := 16r1161. tBase := 16r11A7.   nCount := 588. tCount := 28."	^ ((lPart between: 16r1100 and: 16r1112) 			and: [ (vPart between: 16r1161 and: 16r1175)				and: [ tPart between: 16r11A7 and: 16r11C2 ] ])				ifTrue: [ 					lIndex := lPart - 16r1100.					vIndex := vPart - 16r1161.					tIndex := tPart - 16r11A7.					16rAC00 + (lIndex * 588) + (vIndex * 28) + tIndex ]! !!UnicodeComposer methodsFor: 'private - combinations'!hangulLVCombinationOf: lPart and: vPart	"Algorithmic Hangul Syllable Componsition.	Ref. http://www.unicode.org/versions/Unicode8.0.0/ch03.pdf section 3.12 page 146"		| lIndex vIndex |	"sBase := 16rAC00. lBase := 16r1100. vBase := 16r1161.   nCount := 588. tCount := 28."	^ ((lPart between: 16r1100 and: 16r1112) 		and: [ vPart between: 16r1161 and: 16r1175 ])			ifTrue: [ 				lIndex := lPart - 16r1100.				vIndex := vPart - 16r1161.				^ 16rAC00 + (lIndex * 588) + (vIndex * 28) ]! !!UnicodeComposer methodsFor: 'private - combinations'!hangulSTCombinationOf: sPart and: tPart	"Algorithmic Hangul Syllable Componsition.	Ref. http://www.unicode.org/versions/Unicode8.0.0/ch03.pdf section 3.12 page 146"		| tIndex |	"sBase := 16rAC00. lBase := 16r1100. vBase := 16r1161.   nCount := 588. tCount := 28."	^ ((sPart between: 16rAC00 and: 16rD7A3)		and: [ (tPart between: 16r11A7 and: 16r11C2)			and: [ sPart - 16rAC00 \\ 28 = 0 ] ])			ifTrue: [ 				tIndex := tPart - 16r11A7.				sPart + tIndex ]! !!UnicodeComposer methodsFor: 'initialize'!initializeForComposition	combinations := IdentityDictionary new.	combiningCharacters := IdentitySet new.	UnicodeCharacterData database valuesDo: [ :each |		each isPrimaryComposite ifTrue: [ | combination |			combination := each decompositionMapping.			"combination first + combination second = each codePoint"			combinations 				at: combination first 				ifPresent: [ :value | 					value at: combination second put: each codePoint ]				ifAbsent: [ | value |					value := IdentityDictionary new at: combination second put: each codePoint; yourself.					combinations at: combination first put: value ].			combiningCharacters add: combination second ] ]! !!UnicodeComposer methodsFor: 'testing'!isCombiningCharacter: codePoint	^ self combiningCharacters includes: codePoint! !!UnicodeComposer methodsFor: 'private - combinations'!primaryCombinationOf: first and: second	"Resolve Primary Composition using inverse computed table"		^ (self isCombiningCharacter: second)			ifTrue: [ 				self combinations 					at: first 					ifPresent: [ :compositions | 						compositions at: second ifAbsent: [ ] ] 					ifAbsent: [ ] ]! !!UnicodeComposer methodsFor: 'private'!scanForStarterFrom: input to: output	| current |	"Find the first starter in input and return it, else copy to output"	[ input atEnd ] whileFalse: [ 		current := input next.		([ current unicodeCharacterData isStarter ] on: NotFound do: [ false ])			ifTrue: [ ^ current ]			ifFalse: [ output nextPut: current ] ].	^ nil! !!UnicodeComposer methodsFor: 'private'!scanUntilStarterFrom: input to: buffer	| current |	"Put non-starters and the next starter from input in the buffer, if any"	[ input atEnd ] whileFalse: [ 		current := input next.		buffer addLast: current.		([ current unicodeCharacterData isStarter ] on: NotFound do: [ false ])			ifTrue: [ ^ self ] ]! !!UnicodeComposingReadStream class methodsFor: 'initialization'!on: codePointReadStream	^ self new		on: codePointReadStream;		yourself! !!UnicodeComposingReadStream methodsFor: 'streaming'!atEnd	^ buffer isEmpty and: [ self isFirstEmpty and: [ input atEnd ] ]! !!UnicodeComposingReadStream methodsFor: 'private'!consumeFirst	| current |	current := first.	first := nil.	^ current! !!UnicodeComposingReadStream methodsFor: 'initialization'!initialize	super initialize.	buffer := OrderedCollection new.	composer := UnicodeComposer default! !!UnicodeComposingReadStream methodsFor: 'private'!isFirstEmpty	^ first isNil or: [ first = #initialized ]! !!UnicodeComposingReadStream methodsFor: 'streaming'!next	self isFirstEmpty		ifFalse: [ ^ self consumeFirst ].	self shouldGetNextChunk 		ifTrue: [ self nextChunk ].	self isFirstEmpty		ifFalse: [ ^ self consumeFirst ].	buffer ifEmpty: [ ^ nil ].	^ buffer removeFirst! !!UnicodeComposingReadStream methodsFor: 'private'!nextChunk	"Initialize when needed, try putting first starter in buffer"	first = #initialized 		ifFalse: [ 			self scanFirstStarter 				ifFalse: [ "Non-starter is in first" ^ self ] ].	"buffer = <starter1>"	[		self scanUntilStarter.		"buffer = <starter1> ... <starter2>"		composer composeBuffer: buffer ] 			doWhileFalse: [ buffer size > 1 or: [ input atEnd ] ]	"There has to be more than one element in the buffer unless we're eof.	Composition shrinks the buffer, sometimes recursively, but can need additional starters"! !!UnicodeComposingReadStream methodsFor: 'initialization'!on: codePointReadStream	input := codePointReadStream ! !!UnicodeComposingReadStream methodsFor: 'streaming'!peek	self isFirstEmpty		ifFalse: [ ^ first ].	self shouldGetNextChunk 		ifTrue: [ self nextChunk ].	self isFirstEmpty		ifFalse: [ ^ first ].	buffer ifEmpty: [ ^ nil ].	^ buffer first! !!UnicodeComposingReadStream methodsFor: 'streaming'!reset	input reset.	buffer removeAll! !!UnicodeComposingReadStream methodsFor: 'private'!scanFirstStarter	| current |	"Find the first starter in input to use, put it in buffer and return true.	Else put the non-starter in first and return false.	Switch to #initialized once we've seen the first starter or when empty."	input atEnd ifFalse: [ 		current := input next.		([ current unicodeCharacterData isStarter ] on: NotFound do: [ false ])			ifTrue: [ 				buffer addLast: current. 				first := #initialized. 				^ true ]			ifFalse: [ 				first := current. 				^ false ] ].	first := #inialized.	^ false! !!UnicodeComposingReadStream methodsFor: 'private'!scanUntilStarter	| current |	"Put non-starters and the next starter from input in the buffer, if any"	[ input atEnd ] whileFalse: [ 		current := input next.		buffer addLast: current.		([ current unicodeCharacterData isStarter ] on: NotFound do: [ false ])			ifTrue: [ ^ self ] ]! !!UnicodeComposingReadStream methodsFor: 'private'!shouldGetNextChunk	"One element should remain in the buffer for the next iteration unless we're eof"		^ buffer isEmpty or: [ buffer size = 1 and: [ input atEnd not] ]! !!UnicodeComposingReadStream methodsFor: 'converting'!unicodeCharacters	"Return a CharacterFromCodePointReadStream over the receiver that streams over Characters"		^ CharacterFromCodePointReadStream on: self! !!UnicodeComposingReadStream methodsFor: 'streaming'!upToEnd	^ Array streamContents: [ :out |			[ self atEnd ] whileFalse: [ out nextPut: self next ] ]! !!UnicodeConcatenator class methodsFor: 'instance creation'!forNFC	^ self new forNFC! !!UnicodeConcatenator class methodsFor: 'instance creation'!forNFD	^ self new forNFD! !!UnicodeConcatenator class methodsFor: 'instance creation'!forNFKC	^ self new forNFKC! !!UnicodeConcatenator class methodsFor: 'instance creation'!forNFKD	^ self new forNFKD! !!UnicodeConcatenator methodsFor: 'private'!codePointsToNFC: codePoints	^ codePoints readStream unicodeNFC upToEnd! !!UnicodeConcatenator methodsFor: 'private'!codePointsToNFD: codePoints	^ codePoints readStream unicodeNFD upToEnd! !!UnicodeConcatenator methodsFor: 'private'!codePointsToNFKC: codePoints	^ codePoints readStream unicodeNFKC upToEnd! !!UnicodeConcatenator methodsFor: 'private'!codePointsToNFKD: codePoints	^ codePoints readStream unicodeNFKD upToEnd! !!UnicodeConcatenator methodsFor: 'public'!concatenateCodePoints: first with: second	| lastStable firstStable middle result |	first ifEmpty: [ ^ second ].	second ifEmpty: [ ^ first ].	lastStable := first findLast: self isStableCodePointBlock.	lastStable = 0 ifTrue: [ lastStable := 1 ].	firstStable := second findFirst: self isStableCodePointBlock.	firstStable = 0 ifTrue: [ firstStable := second size ].	(lastStable = first size and: [ firstStable = 1 ]) ifTrue: [ ^ first , second ].	middle := (first copyFrom: lastStable to: first size) , (second copyFrom: 1 to: firstStable).	middle := self normalizeCodePoints: middle.	result := first class new: (lastStable - 1 + middle size + second size - firstStable).	result 		replaceFrom: 1 to: lastStable - 1 with: first startingAt: 1;		replaceFrom: lastStable to: lastStable + middle size - 1 with: middle startingAt: 1;		replaceFrom: lastStable + middle size to: result size with: second startingAt: firstStable + 1. 	^ result! !!UnicodeConcatenator methodsFor: 'public'!concatenateString: first with: second	| lastStable firstStable middle result |	first ifEmpty: [ ^ second ].	second ifEmpty: [ ^ first ].	lastStable := first findLast: self isStableCharacterBlock.	lastStable = 0 ifTrue: [ lastStable := 1 ].	firstStable := second findFirst: self isStableCodePointBlock.	firstStable = 0 ifTrue: [ firstStable := second size ].	(lastStable = first size and: [ firstStable = 1 ]) ifTrue: [ ^ first , second ].	middle := (first copyFrom: lastStable to: first size) , (second copyFrom: 1 to: firstStable).	middle := self normalizeString: middle.	result := first class new: (lastStable - 1 + middle size + second size - firstStable).	result 		replaceFrom: 1 to: lastStable - 1 with: first startingAt: 1;		replaceFrom: lastStable to: lastStable + middle size - 1 with: middle startingAt: 1;		replaceFrom: lastStable + middle size to: result size with: second startingAt: firstStable + 1. 	^ result! !!UnicodeConcatenator methodsFor: 'initalize'!forNFC	property := #NFC.! !!UnicodeConcatenator methodsFor: 'initalize'!forNFD	property := #NFD.! !!UnicodeConcatenator methodsFor: 'initalize'!forNFKC	property := #NFKC.! !!UnicodeConcatenator methodsFor: 'initalize'!forNFKD	property := #NFKD.! !!UnicodeConcatenator methodsFor: 'private'!isStableCharacterBlock	| quickCheckProperty |	quickCheckProperty := self quickCheckProperty.	^ [ :each | 		([ each unicodeCharacterData isStarter ] on: NotFound do: [ true ]) 			and: [ (UnicodeCharacterData normalizationQuickCheck: quickCheckProperty forCodePoint: each codePoint) = #Y ] ]! !!UnicodeConcatenator methodsFor: 'private'!isStableCodePointBlock	| quickCheckProperty |	quickCheckProperty := self quickCheckProperty.	^ [ :each | 		([ each unicodeCharacterData isStarter ] on: NotFound do: [ true ]) 			and: [ (UnicodeCharacterData normalizationQuickCheck: quickCheckProperty forCodePoint: each) = #Y ] ]! !!UnicodeConcatenator methodsFor: 'private'!normalizeCodePoints: codePoints	| method |	method := (#codePointsTo, property) asSymbol asMutator.	^ self perform: method with: codePoints ! !!UnicodeConcatenator methodsFor: 'private'!normalizeString: string	| method |	method := (#stringTo, property) asSymbol asMutator.	^ self perform: method with: string ! !!UnicodeConcatenator methodsFor: 'acccessing'!quickCheckProperty	^ (property , #'_QC') asSymbol! !!UnicodeConcatenator methodsFor: 'private'!stringToNFC: string	^ UnicodeNormalizer new toNFC: string! !!UnicodeConcatenator methodsFor: 'private'!stringToNFD: string	^ UnicodeNormalizer new toNFD: string! !!UnicodeConcatenator methodsFor: 'private'!stringToNFKC: string	^ UnicodeNormalizer new toNFKC: string! !!UnicodeConcatenator methodsFor: 'private'!stringToNFKD: string	^ UnicodeNormalizer new toNFKD: string! !!UnicodeDecomposedNormalizationForm class methodsFor: 'private'!add: codePoint cccOrderedTo: buffer	| ccc index stop otherCCC |	ccc := [ codePoint unicodeCharacterData ccc ] on: NotFound do: [ 0 ].	index := buffer size.	ccc = 0 		ifFalse: [			stop := false.			[ index > 0 & stop not ] whileTrue: [ 				otherCCC := [ (buffer at: index) unicodeCharacterData ccc ] on: NotFound do: [ 0 ].				ccc < otherCCC					ifTrue: [ index := index - 1 ]					ifFalse: [ stop := true ] ] ].	buffer add: codePoint afterIndex: index! !!UnicodeDecomposedNormalizationForm class methodsFor: 'conversion'!addMapping: codePoint to: buffer	(self decompositionEntryOf: codePoint)		ifNotNil: [ :entry | entry decompositionMappingDo: [ :each | self addMapping: each to: buffer]]		ifNil: [ self add: codePoint cccOrderedTo: buffer ]! !!UnicodeDecomposedNormalizationForm class methodsFor: 'conversion'!addNonStartersFrom: input to: buffer	| stop |	stop := false.	[ input atEnd | stop ] whileFalse: [ 		([ self isNonStarter: input peek ] on: NotFound do: [ false ])			ifTrue: [ self addMapping: input next to: buffer ]			ifFalse: [ stop := true ] ]! !!UnicodeDecomposedNormalizationForm class methodsFor: 'private'!decompositionEntryOf: aCodePoint	"Return a UnicodeCharacterDate instance that holds the decomposition mapping I care about for aCodePoint"	^self subclassResponsibility ! !!UnicodeDecomposedNormalizationForm class methodsFor: 'private'!isNonStarter: codePoint	"If we have a decomposition, we need to see if decomposed, we will be a nonStarter.	Assume there is no decomposition on form NonStarter,*,Starter,* (which would make very little sense...)"	(self decompositionEntryOf: codePoint)		ifNotNil: [ :entry | entry decompositionMappingDo: [ :onlyFirst | ^ self isNonStarter: onlyFirst ] ]		ifNil:			[ | ucd |			ucd := [ codePoint unicodeCharacterData ] on: NotFound do: [nil].			^ucd notNil and: [ ucd isStarter not ] ].! !!UnicodeNFD class methodsFor: 'private'!decompositionEntryOf: aCodePoint	"Return a Unicode Data Entry if it has a decomposition of my form"	|ucd|	ucd := [ aCodePoint unicodeCharacterData ] on: NotFound do: [nil].	^(ucd notNil and: [ucd hasCanonicalDecomposition]) ifTrue: [ucd]! !!UnicodeNFKD class methodsFor: 'private'!decompositionEntryOf: aCodePoint	"Return a Unicode Data Entry if it has a decomposition of my form"	|ucd|	ucd := [ aCodePoint unicodeCharacterData ] on: NotFound do: [nil].	^(ucd notNil and: [ucd hasDecomposition]) ifTrue: [ucd]! !!UnicodeDecomposer methodsFor: 'private'!decompose: inputStream to: outputStream	| buffer |	form ifNil: 		[ ^self error: 'decompose:to: should not be called directly' ].	buffer := OrderedCollection new.	[ inputStream atEnd ]		whileFalse:			[ form addMapping: inputStream next to: buffer.			form addNonStartersFrom: inputStream to: buffer.			"The additions to the buffer above were done respecting the CCC order, so we're done"			outputStream nextPutAll: buffer.			buffer reset ]! !!UnicodeDecomposer methodsFor: 'public'!decomposeCompatibleFrom: input to: output	form := UnicodeNFKD.	self decompose: input to: output.	! !!UnicodeDecomposer methodsFor: 'public'!decomposeFrom: input to: output	form := UnicodeNFD.	self decompose: input to: output! !!UnicodeDecomposer methodsFor: 'convencience'!decomposeString: string	"Return the NFD of string, the canonical decomposition normal form"		(string isByteString and: [ string isAsciiString ])		ifTrue: ["ACII strings are already in NFD"			 ^ string ].		^ String		streamContents:			[ :out | 			form := UnicodeNFD.			self				decompose: string readStream unicodeCodePoints				to: out unicodeCodePoints ]! !!UnicodeDecomposer methodsFor: 'convencience'!decomposeStringCompatible: string	"Return the NFKD of string, the compatible decomposition normal form"		(string isByteString and: [ string isAsciiString ]) 		ifTrue: ["ACII strings are already in NFKD" 			^ string ]. 	^ String streamContents: [ :out |			form := UnicodeNFKD.			self 				decompose: string readStream unicodeCodePoints				to: out unicodeCodePoints ]! !!UnicodeDecomposingReadStream class methodsFor: 'initialization'!form: aDecomposedNormalizationForm on: codePointReadStream	^ self new		form: aDecomposedNormalizationForm on: codePointReadStream;		yourself! !!UnicodeDecomposingReadStream class methodsFor: 'initialization'!nfdFormOn: codePointReadStream	^ self 		form: UnicodeNFD		on: codePointReadStream! !!UnicodeDecomposingReadStream class methodsFor: 'initialization'!nfkdFormOn: codePointReadStream	^ self 		form: UnicodeNFKD		on: codePointReadStream! !!UnicodeDecomposingReadStream methodsFor: 'streaming'!atEnd	^ buffer isEmpty and: [ input atEnd ]! !!UnicodeDecomposingReadStream methodsFor: 'initialization'!form: aDecomposedNormalizationForm on: codePointReadStream	form := aDecomposedNormalizationForm.	input := codePointReadStream ! !!UnicodeDecomposingReadStream methodsFor: 'initialization'!initialize	super initialize.	buffer := OrderedCollection new! !!UnicodeDecomposingReadStream methodsFor: 'streaming'!next	buffer ifEmpty: [ self nextChunk ].	buffer ifEmpty: [ ^ nil ].	^ buffer removeFirst! !!UnicodeDecomposingReadStream methodsFor: 'private'!nextChunk	input atEnd		ifFalse: [  			form addMapping: input next to: buffer.			form addNonStartersFrom: input to: buffer.			"The additions to the buffer above were done respecting the CCC order, so we're done" ]! !!UnicodeDecomposingReadStream methodsFor: 'initialization'!on: codePointReadStream	input := codePointReadStream ! !!UnicodeDecomposingReadStream methodsFor: 'streaming'!peek	buffer ifEmpty: [ self nextChunk ].	buffer ifEmpty: [ ^ nil ].	^ buffer first! !!UnicodeDecomposingReadStream methodsFor: 'streaming'!reset	input reset.	buffer removeAll! !!UnicodeDecomposingReadStream methodsFor: 'converting'!unicodeCharacters	"Return a CharacterFromCodePointReadStream over the receiver that streams over Characters"		^ CharacterFromCodePointReadStream on: self! !!UnicodeDecomposingReadStream methodsFor: 'converting'!unicodeCompose	"Return a NeoUnicodeComposingReadStream over the receiver that streams over Integer code points after composing them"		^ UnicodeComposingReadStream on: self! !!UnicodeDecomposingReadStream methodsFor: 'streaming'!upToEnd	^ Array streamContents: [ :out |			[ self atEnd ] whileFalse: [ out nextPut: self next ] ]! !!UnicodeNormalizer methodsFor: 'public'!composeString: string	"Return the NFC of string, the canonical composition normal form"		(self isAlreadyNFC: string) ifTrue: [ ^ string ]. 	^ string readStream unicodeCodePoints unicodeNFC unicodeCharacters upToEnd! !!UnicodeNormalizer methodsFor: 'public'!composeStringCompatible: string	"Return the NFKC of string, the compatible composition normal form"		(self isAlreadyNFKC: string) ifTrue: [ ^ string ]. 	^ string readStream unicodeCodePoints unicodeNFKC unicodeCharacters upToEnd! !!UnicodeNormalizer methodsFor: 'public'!decomposeString: string	"Return the NFD of string, the canonical decomposition normal form"		(self isAlreadyNFD: string) ifTrue: [ ^ string ]. 	^ string readStream unicodeCodePoints unicodeNFD unicodeCharacters upToEnd! !!UnicodeNormalizer methodsFor: 'public'!decomposeStringCompatible: string	"Return the NFKD of string, the compatible decomposition normal form"		(self isAlreadyNFKD: string) ifTrue: [ ^ string ]. 	^ string readStream unicodeCodePoints unicodeNFKD unicodeCharacters upToEnd! !!UnicodeNormalizer methodsFor: 'testing'!isAlreadyNFC: string	"Return true when we know string is already in NFC form, false otherwise.	This uses a quick check algorithm.	False means we don't know, but it is still possible. 	The only way to know for sure is to do the actual conversion."		"Latin1 strings are always in NFC"	^ string isByteString or: [ 		(UnicodeCharacterData normalizationQuickCheck: #NFC_QC forString: string) = #Y ]! !!UnicodeNormalizer methodsFor: 'testing'!isAlreadyNFD: string	"Return true when we know string is already in NFD form, false otherwise.	This uses a quick check algorithm.	False means we don't know, but it is still possible. 	The only way to know for sure is to do the actual conversion."	"ASCII strings are always in NFD"	^ (string isByteString and: [ string isAsciiString ])		or: [ (UnicodeCharacterData normalizationQuickCheck: #NFD_QC forString: string) = #Y ]! !!UnicodeNormalizer methodsFor: 'testing'!isAlreadyNFKC: string	"Return true when we know string is already in NFKC form, false otherwise.	This uses a quick check algorithm.	False means we don't know, but it is still possible. 	The only way to know for sure is to do the actual conversion."	"ASCII strings are always in NFKC"	^ (string isByteString and: [ string isAsciiString ])		or: [ (UnicodeCharacterData normalizationQuickCheck: #NFKC_QC forString: string) = #Y ]! !!UnicodeNormalizer methodsFor: 'testing'!isAlreadyNFKD: string	"Return true when we know string is already in NFKD form, false otherwise.	This uses a quick check algorithm.	False means we don't know, but it is still possible. 	The only way to know for sure is to do the actual conversion."	"ASCII strings are always in NFKD"	^ (string isByteString and: [ string isAsciiString ])		or: [ (UnicodeCharacterData normalizationQuickCheck: #NFKD_QC forString: string) = #Y ]! !!UnicodeNormalizer methodsFor: 'testing'!isNFC: string	"Return true when string is in NFC form, false otherwise"		^ string = (self toNFC: string)! !!UnicodeNormalizer methodsFor: 'testing'!isNFD: string	"Return true when string is in NFD form, false otherwise"		^ string = (self toNFD: string)! !!UnicodeNormalizer methodsFor: 'testing'!isNFKC: string	"Return true when string is in NFC form, false otherwise"		^ string = (self toNFKC: string)! !!UnicodeNormalizer methodsFor: 'testing'!isNFKD: string	"Return true when string is in NFKD form, false otherwise"		^ string = (self toNFKD: string)! !!UnicodeNormalizer methodsFor: 'public'!toNFC: string	^ self composeString: string! !!UnicodeNormalizer methodsFor: 'public'!toNFD: string	^ self decomposeString: string! !!UnicodeNormalizer methodsFor: 'public'!toNFKC: string	^ self composeStringCompatible: string! !!UnicodeNormalizer methodsFor: 'public'!toNFKD: string	^ self decomposeStringCompatible: string! !!CodePointFromCharacterReadStream methodsFor: '*unicode-normalization'!unicodeCompose	"Return a UnicodeComposingReadStream over the receiver that streams over Integer code points after composing them"		^ UnicodeComposingReadStream on: self! !!CodePointFromCharacterReadStream methodsFor: '*unicode-normalization'!unicodeNFC	"Return a UnicodeComposingReadStream over the receiver that streams over Integer code points composing them after decomposing them canonically"		^ self unicodeNFD unicodeCompose! !!CodePointFromCharacterReadStream methodsFor: '*unicode-normalization'!unicodeNFD	"Return a UnicodeNFDReadStream over the receiver that streams over Integer code points after decomposing them canonically"		^ UnicodeDecomposingReadStream nfdFormOn: self! !!CodePointFromCharacterReadStream methodsFor: '*unicode-normalization'!unicodeNFKC	"Return a UnicodeComposingReadStream over the receiver that streams over Integer code points composing them after decomposing them compatibly"		^ self unicodeNFKD unicodeCompose! !!CodePointFromCharacterReadStream methodsFor: '*unicode-normalization'!unicodeNFKD	"Return a UnicodeNFKDReadStream over the receiver that streams over Integer code points after decomposing them compatibly"		^ UnicodeDecomposingReadStream nfkdFormOn: self! !!ReadStream methodsFor: '*unicode-normalization'!unicodeCompose	"Assuming the receiver is a stream over Integer code points, return a UnicodeComposingReadStream over the receiver that streams over Integer code points after composing them"		^ UnicodeComposingReadStream on: self! !!ReadStream methodsFor: '*unicode-normalization'!unicodeNFC	"Assuming the receiver is a stream over Integer code points, return a UnicodeComposingReadStream over the receiver that streams over Integer code points composing them after decomposing them canonically"		^ self unicodeNFD unicodeCompose! !!ReadStream methodsFor: '*unicode-normalization'!unicodeNFD	"Assuming the receiver is a stream over Integer code points, return a UnicodeNFDReadStream over the receiver that streams over Integer code points after decomposing them canonically"		^ UnicodeDecomposingReadStream nfdFormOn: self! !!ReadStream methodsFor: '*unicode-normalization'!unicodeNFKC	"Assuming the receiver is a stream over Integer code points, return a UnicodeComposingReadStream over the receiver that streams over Integer code points composing them after decomposing them compatibly"		^ self unicodeNFKD unicodeCompose! !!ReadStream methodsFor: '*unicode-normalization'!unicodeNFKD	"Assuming the receiver is a stream over Integer code points, return a UnicodeNFKDReadStream over the receiver that streams over Integer code points after decomposing them compatibly"		^ UnicodeDecomposingReadStream nfkdFormOn: self! !"Unicode-Normalization"!!UnicodeCharacterDataTests methodsFor: 'testing'!testDigitOne	| unicodeCharacterData |	unicodeCharacterData := $1 unicodeCharacterData.	self assert: unicodeCharacterData codePoint equals: 49.	self assert: unicodeCharacterData character equals: $1.	self assert: unicodeCharacterData name equals: 'DIGIT ONE'.	self assert: unicodeCharacterData isNumber.	self deny: unicodeCharacterData isLetter.	self assert: unicodeCharacterData isNumberDecimal.	self assert: unicodeCharacterData decimalDigitValue equals: 1! !!UnicodeCharacterDataTests methodsFor: 'testing'!testLatinCapitalLetterA	| unicodeCharacterData |	unicodeCharacterData := $A unicodeCharacterData.	self assert: unicodeCharacterData codePoint equals: 65.	self assert: unicodeCharacterData character equals: $A.	self assert: unicodeCharacterData name equals: 'LATIN CAPITAL LETTER A'.	self assert: unicodeCharacterData isLetter.	self deny: unicodeCharacterData isNumber.	self assert: unicodeCharacterData isUppercase.	self assert: unicodeCharacterData lowercase equals: $a codePoint! !!UnicodeCharacterDataTests methodsFor: 'testing'!testLatinSmallLetterA	| unicodeCharacterData |	unicodeCharacterData := $a unicodeCharacterData.	self assert: unicodeCharacterData codePoint equals: 97.	self assert: unicodeCharacterData character equals: $a.	self assert: unicodeCharacterData name equals: 'LATIN SMALL LETTER A'.	self assert: unicodeCharacterData isLetter.	self deny: unicodeCharacterData isNumber.	self assert: unicodeCharacterData isLowercase.	self assert: unicodeCharacterData uppercase equals: $A codePoint! !!UnicodeCharacterDataTests methodsFor: 'testing'!testLatinSmallLetterEWithAcute	| unicodeCharacterData |	unicodeCharacterData := $é unicodeCharacterData.	"LATIN SMALL LETTER E WITH ACUTE [U+00E9]"	self assert: unicodeCharacterData codePoint equals: 233.	self assert: unicodeCharacterData character equals: $é.	self assert: unicodeCharacterData name equals: 'LATIN SMALL LETTER E WITH ACUTE'.	self assert: unicodeCharacterData isLetter.	self deny: unicodeCharacterData isNumber.	self assert: unicodeCharacterData isLowercase.	self assert: unicodeCharacterData uppercase equals: $É codePoint.	self assert: unicodeCharacterData hasStandardCanonicalDecomposition.	"LATIN SMALL LETTER E [U+0065] followed by COMBINING ACUTE ACCENT [U+0301]"	self assert: unicodeCharacterData decompositionMapping equals: #(101 769)! !"Unicode-Tests-Character-Data"!!UnicodeCaserTests methodsFor: 'running'!setUp	caser := UnicodeCaser new! !!UnicodeCaserTests methodsFor: 'testing'!testLowercase	self assert: (caser case: #lowercase string: 'ABC') equals: 'abc'.	self assert: (caser case: #lowercase string: '123 !!= abc') equals: '123 !!= abc'.! !!UnicodeCaserTests methodsFor: 'testing'!testUppercase	self assert: (caser case: #uppercase string: 'abc') equals: 'ABC'.	self assert: (caser case: #uppercase string: '123 !!= ABC') equals: '123 !!= ABC'.! !"Unicode-Tests-Casing"!!UnicodeNormalizerConformanceTests commentStamp: '' prior: 0!This test uses http://www.unicode.org/Public/UNIDATA/NormalizationTest.txt to run about 75.000 individual test cases to test conformance to the official Unicode Normalization specification.!!UnicodeNormalizationTestResource commentStamp: '' prior: 0!I hold the contents of NormalizationTest.txt loaded from a URL.  UnicodeNormalizationTestResource new setUphttp://www.unicode.org/Public/UNIDATA/NormalizationTest.txt# Normalization Test Suite# Format:##   Columns (c1, c2,...) are separated by semicolons#   They have the following meaning:#      source; NFC; NFD; NFKC; NFKD#   Comments are indicated with hash marks#   Each of the columns may have one or more code points.## CONFORMANCE:# 1. The following invariants must be true for all conformant implementations##    NFC#      c2 ==  toNFC(c1) ==  toNFC(c2) ==  toNFC(c3)#      c4 ==  toNFC(c4) ==  toNFC(c5)##    NFD#      c3 ==  toNFD(c1) ==  toNFD(c2) ==  toNFD(c3)#      c5 ==  toNFD(c4) ==  toNFD(c5)##    NFKC#      c4 == toNFKC(c1) == toNFKC(c2) == toNFKC(c3) == toNFKC(c4) == toNFKC(c5)##    NFKD#      c5 == toNFKD(c1) == toNFKD(c2) == toNFKD(c3) == toNFKD(c4) == toNFKD(c5)## 2. For every code point X assigned in this version of Unicode that is not specifically#    listed in Part 1, the following invariants must be true for all conformant#    implementations:##      X == toNFC(X) == toNFD(X) == toNFKC(X) == toNFKD(X)!!UnicodeConcatenatorTests methodsFor: 'testing'!testASCII	self 		assert: (UnicodeConcatenator forNFC concatenateString: 'abc' with: 'def')		equals: 'abcdef'	! !!UnicodeConcatenatorTests methodsFor: 'testing'!testDiacritics	self 		assert: (UnicodeConcatenator forNFC concatenateString: 'éle' with: '̀ves')		equals: 'élèves'.	self 		assert: (UnicodeConcatenator forNFC concatenateString: 'Ko' with: '̈nigsallee')		equals: 'Königsallee'.	! !!UnicodeConcatenatorTests methodsFor: 'testing'!testSimple	self 		assert: (UnicodeConcatenator forNFC concatenateCodePoints: #(97 98 99 101) with: #(769 100 101 102))		equals: #(97 98 99 233 100 101 102)	! !!UnicodeNormalizerConformanceTests class methodsFor: 'accessing'!resources	^ Array with: UnicodeNormalizationTestResource ! !!UnicodeNormalizerConformanceTests methodsFor: 'running'!setUp	normalizer := UnicodeNormalizer new.	composer := UnicodeComposer default.	decomposer := UnicodeDecomposer new! !!UnicodeNormalizerConformanceTests methodsFor: 'accessing'!specification	^ UnicodeNormalizationTestResource current data! !!UnicodeNormalizerConformanceTests methodsFor: 'testing'!testNFC	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | nfd result |		nfd := Array streamContents: [ :out |			decomposer decomposeFrom: (spec at: #source) readStream to: out ].		result := Array streamContents: [ :out |			composer composeFrom: nfd readStream to: out ].		result = (spec at: #NFC)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crTrace: ('#testNFC {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing'!testNFCStreaming	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | result |		result := (spec at: #source) readStream unicodeNFC upToEnd.		result = (spec at: #NFC)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crTrace: ('#testNFCStreaming {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing'!testNFCString	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | in out result |		in := (spec at: #source) collect: #asCharacter as: WideString.		out := normalizer toNFC: in.		result := out collect: #codePoint as: Array.		result = (spec at: #NFC)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crTrace: ('#testNFCString {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing'!testNFD	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | result |		result := Array streamContents: [ :out |			decomposer decomposeFrom: (spec at: #source) readStream to: out ].		result = (spec at: #NFD)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crTrace: ('#testNFD {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing'!testNFDStreaming	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | result |		result := (spec at: #source) readStream unicodeNFD upToEnd.		result = (spec at: #NFD)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crTrace: ('#testNFDStreaming {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing'!testNFDString	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | in out result |		in := (spec at: #source) collect: #asCharacter as: WideString.		out := normalizer toNFD: in.		result := out collect: #codePoint as: Array.		result = (spec at: #NFD)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crTrace: ('#testNFDString {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing'!testNFKC	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | nfkd result |		nfkd := Array streamContents: [ :out |			decomposer decomposeCompatibleFrom: (spec at: #source) readStream to: out ].		result := Array streamContents: [ :out |			composer composeFrom: nfkd readStream to: out ].		result = (spec at: #NFKC)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crTrace: ('#testNFKC {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing'!testNFKCStreaming	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | result |		result := (spec at: #source) readStream unicodeNFKC upToEnd.		result = (spec at: #NFKC)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crTrace: ('#testNFKCStreaming {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing'!testNFKCString	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | in out result |		in := (spec at: #source) collect: #asCharacter as: WideString.		out := normalizer toNFKC: in.		result := out collect: #codePoint as: Array.		result = (spec at: #NFKC)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crTrace: ('#testNFKCString {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing'!testNFKD	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | result |		result := Array streamContents: [ :out |			decomposer decomposeCompatibleFrom: (spec at: #source) readStream to: out ].		result = (spec at: #NFKD)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crTrace: ('#testNFKD {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing'!testNFKDStreaming	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | result |		result := (spec at: #source) readStream unicodeNFKD upToEnd.		result = (spec at: #NFKD)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crTrace: ('#testNFKDStreaming {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing'!testNFKDString	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | in out result |		in := (spec at: #source) collect: #asCharacter as: WideString.		out := normalizer toNFKD: in.		result := out collect: #codePoint as: Array.		result = (spec at: #NFKD)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crTrace: ('#testNFKDString {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerTests methodsFor: 'running'!setUp	normalizer := UnicodeNormalizer new.	composer := UnicodeComposer default.	decomposer := UnicodeDecomposer new! !!UnicodeNormalizerTests methodsFor: 'tests'!testAsciiIsAlwaysNormalized	| ascii nfc nfd nfkc nfkd |	"ASCII strings are identical to all 4 normalization forms"	ascii := String withAll: ((0 to: 127) collect: #asCharacter).	"we have to circumvent the optimizations done in the convenience methods"	nfc := ascii readStream unicodeCodePoints unicodeNFC unicodeCharacters upToEnd.	self assert: nfc equals: ascii. 	nfd := ascii readStream unicodeCodePoints unicodeNFD unicodeCharacters upToEnd.	self assert: nfd equals: ascii. 	nfkc := ascii readStream unicodeCodePoints unicodeNFKC unicodeCharacters upToEnd.	self assert: nfkc equals: ascii. 	nfkd := ascii readStream unicodeCodePoints unicodeNFKD unicodeCharacters upToEnd.	self assert: nfkd equals: ascii! !!UnicodeNormalizerTests methodsFor: 'tests'!testFundamentalComposition	| in out |	"LATIN SMALL LETTER E [U+0065] followed by COMBINING ACUTE ACCENT [U+0301]"	in := #(101 769).	out := Array streamContents: [ :writeStream |		composer composeFrom: in readStream to: writeStream ].	"LATIN SMALL LETTER E WITH ACUTE [U+00E9]"	self assert: out equals: #(233)! !!UnicodeNormalizerTests methodsFor: 'tests'!testFundamentalDecomposition	| in out |	"LATIN SMALL LETTER E WITH ACUTE [U+00E9]"	in := #(233).	out := Array streamContents: [ :writeStream |		decomposer decomposeFrom: in readStream to: writeStream ].	"LATIN SMALL LETTER E [U+0065] followed by COMBINING ACUTE ACCENT [U+0301]"	self assert: out equals: #(101 769).! !!UnicodeNormalizerTests methodsFor: 'tests'!testHangul	"an lpart - vpart pair"	self 		assert: 16rAC1C unicodeCharacterData decompositionMapping 		equals: #(16r1100 16r1162).	self		assert: (composer hangulCombinationOf: 16r1100 and: 16r1162)		equals: 16rAC1C.		"an lpart - vpart - tpart triplet"	self 		assert: 16rD4DB unicodeCharacterData decompositionMapping 		equals: #(16r1111 16r1171 16r11B6).	self		assert: (composer hangulCombinationOf: 16r1111 and: 16r1171 and: 16r11B6) 		equals: 16rD4DB.	"converting an lpart - vpart - tpart triplet in two steps"	self		assert: (composer hangulCombinationOf: 16r1111 and: 16r1171)		equals: 16rD4CC.		self		assert: (composer hangulCombinationOf: 16rD4CC and: 16r11B6)		equals: 16rD4DB	! !!UnicodeNormalizerTests methodsFor: 'tests'!testLatin1IsAlwaysInNFC	| latin1 nfc |	"Latin1 strings are identical to their NFC normalization form"	latin1 := String withAll: ((0 to: 255) collect: #asCharacter).	"we have to circumvent the optimizations done in the convenience methods"	nfc := latin1 readStream unicodeCodePoints unicodeNFC unicodeCharacters upToEnd.	self assert: nfc equals: latin1! !!UnicodeNormalizerTests methodsFor: 'tests'!testSimple	| original composed decomposed |	original := 'les élèves Français'.	decomposed := normalizer decomposeString: original.	self assert: decomposed equals: 'les élèves Français'.	composed := normalizer composeString: decomposed.	self assert: composed equals: original.	original := 'Düsseldorf Königsallee'.	decomposed := normalizer decomposeString: original.	self assert: decomposed equals: 'Düsseldorf Königsallee'.	composed := normalizer composeString: decomposed.	self assert: composed equals: original.	! !!UnicodeNormalizationTestResource methodsFor: 'running'!ccc0CharWithCCCDecompositionPrecededByHigherCCC	"Oh, tibetan...	The only language with codepoints that have a combining class of 0, but a canonical decomposition of code points with ccc > 0. That these sort correctly when decomposed next to other CC > 0 is not tested by the official decomposition test file, so add a case for doing so here. These are also excluded for composition, see http://www.unicode.org/Public/8.0.0/ucd/CompositionExclusions.txt section 4""# 0F73 TIBETAN VOWEL SIGN II # 0F75 TIBETAN VOWEL SIGN UU # 0F81 TIBETAN VOWEL SIGN REVERSED II"	^ SmallDictionary new		at: #source put: #(16r0591 16r0F81);		at: #NFC put: #(16r0F71 16r0F80 16r0591);		at: #NFD put: #(16r0F71 16r0F80 16r0591);		at: #NFKC put: #(16r0F71 16r0F80 16r0591);		at: #NFKD put: #(16r0F71 16r0F80 16r0591);		yourself! !!UnicodeNormalizationTestResource methodsFor: 'accessing'!data	"A collection of dictionaries with keys: #source #NFC #NFD #NFKC #NFKD and #comment"		^ data! !!UnicodeNormalizationTestResource methodsFor: 'accessing'!normalizationTestFile	^ 'NormalizationTest.txt'! !!UnicodeNormalizationTestResource methodsFor: 'parsing'!parseLine: line	| columns test comment |	columns := $; split: line.	test := SmallDictionary new.	#(#source #NFC #NFD #NFKC #NFKD) doWithIndex: [ :key :number | 		| value |		value := columns at: number.		value := $  split: value.		value := value collect: [ :each | Integer readFrom: each base: 16 ] as: Array.		test at: key put: value ].	comment := line copyFrom: (line indexOf: $#) + 2 to: line size.	test at: #comment put: comment.	^ test! !!UnicodeNormalizationTestResource methodsFor: 'running'!setUp	data := Array streamContents: [ :out | 		(UnicodeCharacterData getUnicodeCharacterDatabaseRaw: self normalizationTestFile) linesDo: [ :line | 			(line isEmpty or: [ line first = $# or: [ line first = $@ ] ])				ifFalse: [ 					| test |					test := self parseLine: line.					out nextPut: test ] ].			out nextPut: self ccc0CharWithCCCDecompositionPrecededByHigherCCC ].! !"Unicode-Tests-Normalization"!!OSSAbstractUnixSubprocessTest methodsFor: 'helpers'!commandClass	^ OSSUnixSubprocess ! !!OSSAbstractUnixSubprocessTest methodsFor: 'instance creation'!newCommand		^ self commandClass new! !!OSSAbstractUnixSubprocessTest methodsFor: 'private'!systemAccessor	^ OSSVMProcess vmProcess systemAccessor! !!OSSPipeTest methodsFor: 'private'!blockingPipe	^ self systemAccessor makeBlockingPipe	! !!OSSPipeTest methodsFor: 'private'!nonBlockingPipe	^ self systemAccessor makeNonBlockingPipe	! !!OSSPipeTest methodsFor: 'private'!readFromAndClose: aPipe writingTo: aStream	| s |	[aPipe atEndOfFile] whileFalse:		[s := aPipe next: 10000.		aStream nextPutAll: s asString.		(Delay forMilliseconds: 100) wait].	(aPipe respondsTo: #reader) ifTrue: [aPipe reader close].	^ aStream! !!OSSPipeTest methodsFor: 'testing'!testBasicWriteAndRead	| pipe string readString |	string := 'this is a testing string'. 	pipe := self blockingPipe.	pipe writer nextPutAll: string; flush.	readString := pipe reader next: string size.	self assert: string equals: readString! !!OSSPipeTest methodsFor: 'testing'!testBlocking	| pipe |	pipe := self blockingPipe.	(1 to: 10) do: [:i | pipe nextPutAll: 'this is line ', i printString; cr].	pipe flush. "protect against buggy clib that may never flush output"	self should: ['this is line 1*' match: (pipe next: 15)].	self should: ['this is line 2*' match: (pipe next: 15)].	self should: ['this is line 3*' match: (pipe next: 15)].	self should: ['this is line 4*' match: (pipe next: 15)].	self should: ['this is line 5*' match: (pipe next: 15)].	self should: ['this is line 6*' match: (pipe next: 15)].	self should: ['this is line 7*' match: (pipe next: 15)].	self should: ['this is line 8*' match: (pipe next: 15)].	self should: ['this is line 9*' match: (pipe next: 15)].	pipe writer close.	self shouldnt: pipe atEnd.	self should: ['this is line 10*' match: (pipe next: 16)].	self should: pipe atEnd.	pipe close! !!OSSPipeTest methodsFor: 'testing'!testBlockingPeek		| pipe |	pipe := self blockingPipe.	pipe nextPutAll: 'abc'.	pipe flush. "protect against buggy clib that may never flush output"	self assert: (pipe peek == $a).	self assert: (pipe next == $a).	self assert: (pipe peek == $b).	self assert: (pipe next == $b).	self assert: (pipe peek == $c).	self deny: pipe atEnd.	self assert: (pipe next == $c).	self deny: pipe atEnd.	pipe closeWriter.	self assert: pipe atEnd.	pipe close! !!OSSPipeTest methodsFor: 'testing'!testIsAtEndOfFile	| pipe |	pipe := self nonBlockingPipe.	self deny: (pipe reader atEndOfFile).	self deny: pipe reader atEnd.	self deny: pipe atEnd.	self assert: (pipe reader basicNext == nil).	self deny: (pipe reader atEndOfFile).	self deny: pipe reader atEnd.	self deny: pipe atEnd.	pipe writer nextPut: $X; flush.	self assert: (pipe reader basicNext == $X).	self deny: (pipe reader atEndOfFile).	self deny: pipe reader atEnd.	self deny: pipe atEnd.	self assert: (pipe reader basicNext == nil).	self deny: (pipe reader atEndOfFile).	self deny: pipe reader atEnd.	self deny: pipe atEnd.	pipe writer close.	self deny: (pipe reader atEndOfFile).	self deny: pipe atEndOfFile. "no read yet, so flag has not been set"		"From Pharo 7 on, #atEnd does detect EOF on a pipe"	SystemVersion current major >= 7		ifTrue: [ self assert: pipe reader atEnd ].	self assert: pipe atEnd. "writer closed and read gives nil"	self assert: (pipe reader basicNext == nil). "read operation should set flag"	self assert: (pipe reader atEndOfFile).	"From Pharo 7 on, #atEnd does detect EOF on a pipe"	SystemVersion current major >= 7		ifTrue: [ self assert: pipe reader atEnd ].		self assert: pipe reader atEndOfFile.	self assert: pipe atEnd.	pipe close! !!OSSPipeTest methodsFor: 'testing'!testIsAtEndOfFile2	| pipe string |	pipe := self nonBlockingPipe.	[pipe nextPutAll: 'hello'; flush.	string := pipe next: 100.	self assert: string = 'hello'.	self deny: pipe atEndOfFile.	pipe closeWriter.	self deny: pipe atEndOfFile.	string := pipe next: 100.	self assert: string = ''.	self assert: pipe atEndOfFile]		ensure: [pipe close]! !!OSSPipeTest methodsFor: 'testing'!testNonBlocking	| pipe writeStream string |	pipe := self nonBlockingPipe.	self writeStuffOnThenClose: pipe.	writeStream := self readFromAndClose: pipe writingTo: (WriteStream on: String new).	string := (writeStream contents last: 16).	self should: ['this is line 10*' match: string].	pipe close! !!OSSPipeTest methodsFor: 'testing'!testNonBlockingPeek	| pipe |	pipe := self nonBlockingPipe.	pipe nextPutAll: 'abc'; flush.	self assert: (pipe peek == $a).	self assert: (pipe next == $a).	self assert: (pipe peek == $b).	self assert: (pipe next == $b).	self assert: (pipe peek == $c).	self deny: pipe atEnd.	self assert: (pipe next == $c).	self deny: pipe atEnd.	pipe closeWriter.	self assert: pipe atEnd.	pipe close! !!OSSPipeTest methodsFor: 'testing'!testReadAfterClosedReadEnd	| pipe writeStream readStream string |	string := 'this is a testing string'. 	pipe := self blockingPipe.	pipe writer nextPutAll: string; flush.	readStream := pipe reader.	pipe closeReader.	self assert: readStream closed.	self should: [ readStream upToEndOfFile ] raise: Error.	self should: [ readStream upToEnd ] raise: Error.	! !!OSSPipeTest methodsFor: 'testing'!testWriteAfterClosedWriteEnd	| pipe writeStream string |	string := 'this is a testing string'. 	pipe := self blockingPipe.	pipe closeWriter.	self should: [ pipe writer nextPutAll: string; flush ] raise: Error.	! !!OSSPipeTest methodsFor: 'private'!writeStuffOnThenClose: aPipe	^ [(1 to: 10) do:		[:i |		[aPipe nextPutAll: 'this is line ', i printString; cr]			on: Error			do: ["Ignore error. Test case will still fail, and throwing an error in this				process would cause a debugger to be scheduled inconveniently."].		(Delay forMilliseconds: 50) wait].	(aPipe respondsTo: #writer)		ifTrue: [[aPipe writer close]					on: Error					do: ["Ignore error to avoid a debugger"]]		ifFalse: [[aPipe close]					on: Error					do: ["Ignore error to avoid a debugger"]]]		forkAt: Processor userBackgroundPriority! !!OSSFileBasedUnixSubprocessTest methodsFor: 'helpers'!assertStreamsInfoWithPrevious: beforeArray	| afterArray |	afterArray := self getStreamsInfoForRunningTest.	self assert: beforeArray first equals: afterArray first.	self assert: beforeArray second equals: afterArray second.! !!OSSFileBasedUnixSubprocessTest methodsFor: 'helpers'!getStreamsInfoForRunningTest	"We obtain the open tmp files before the open files because in Pharo 7 and ealier getting the entries of /tmp using	    '/tmp' asFileReference entries	leaves the /tmp file descriptor open. Thus #numberOfOpenFiles, using lsof, detects /tmp as an open file and makes the test fail.	Fixed in Pharo 8."	| openTmpFiles |	openTmpFiles := self numberOfExistingTempStreamFiles.	^ Array with: self numberOfOpenFiles with: openTmpFiles! !!OSSFileBasedUnixSubprocessTest methodsFor: 'helpers'!newCommand	| command |	command := self commandClass new.	command defaultReadStreamCreationBlock: [ OSSUnixSubprocess createTempFileToBeUsedAsReadStreamOn: '/tmp' ].	command defaultWriteStreamCreationBlock: [ OSSUnixSubprocess createTempFileToBeUsedAsWriteStreamOn: '/tmp' ].	^ command 	! !!OSSFileBasedUnixSubprocessTest methodsFor: 'helpers'!numberOfExistingTempStreamFiles	"This answers the number of files that were created for mapping standard files.	Note that in OSSUnixSubprocessTest >> newCommand we define that temp files must be created in /tmp	and in OSSUnixSubprocess >> createTempFilename we can see the format of the name 	"		^ ('/tmp' asFileReference entries select: [ :each | 		(each name beginsWith: 'OSSUnixSubprocess-p')  and: [ each name endsWith: '.deleteme' ]  ]) size	! !!OSSFileBasedUnixSubprocessTest methodsFor: 'tests'!testBasicCommandWriteToStdin"testBasicCommandWriteToStdin  fails because of what the documentation says:	> **Important** We have found some problems when using regular files for the `stdin`. While we do not strictly forbid that, we recommend you do so only if you know very well what you are doing. Otherwise, use blocking pipes for `stdin` (default behavior)."		! !!OSSFileBasedUnixSubprocessTest methodsFor: 'tests'!testReadingFromStdoutAfterCommandFinishesDoesNotBlocksVM		"testReadingFromStdoutAfterCommandFinishesDoesNotBlocksVM fails on Travis on OSX. It looks like if another test would have run while this one was sleeping and hence in #assertStreamsInfoWithPrevious: it fails because there are 2 new not-closed files...which I suspect that those are from another running test..."	Smalltalk platform isMacOS 		ifFalse: [ super testReadingFromStdoutAfterCommandFinishesDoesNotBlocksVM ]! !!OSSFileBasedUnixSubprocessTest methodsFor: 'tests'!testReadingFromStdoutDoesNotBlocksVM	| command | 	"With files, the reading from stdout does not lock the VM"	command := self newCommand					command: '/bin/sleep';					arguments: (Array with: '4');					redirectStdout.		command run. 	self assert:[ command stdoutStream upToEnd ] timeToRun seconds <= 1. 	command waitForExit.	command closeAndCleanStreams.! !!OSSFileBasedUnixSubprocessTest methodsFor: 'tests - signals'!testSigTerm	"Same as super impl but special handling for #assertStreamsInfoWithPrevious:. Read comment at the bottom"	| process exited streamsInfo |		"We set the sunit test timeout to 2 times the sleep duration.	Otherwise default sunit test timeout is 1 minute.	This is for Pharo version >= 6.0"	(self respondsTo: #timeLimit:) ifTrue: [ 		self timeLimit: 30 seconds.	].		exited := false.	streamsInfo := self getStreamsInfoForRunningTest.	process := self newCommand.	[	process 		command: 'tail';		arguments: (Array with: '-f' with: Smalltalk image changesName);		redirectStdout;		redirectStderr;		runAndWaitPollingEvery: (Delay forMilliseconds: 500) 		doing: [ :aProcess :outStream :errStream |  		 	outStream upToEnd.			errStream upToEnd.		]		onExitDo: [ :aProcess :outStream :errStream  |			process closeAndCleanStreams.			exited := true.			self assert: aProcess exitStatusInterpreter printString equals: 'exit due to signal 15'		].	"The problem here is that we simply do a #fork this closure will continue to be executed while other test run. And so, all the test checking for zombies or opened files will fail because we can have this forked process that did not yet finish. A workaround is to simply run this closures with a higher priority so that there are less chances of other tests to be running. Another possibility would be to reject those 'tail' processes from #numberOfZombiesProcesses and #numberOfOpenFiles as all the tests that use #fork use the 'tail' OS command."		] forkAt: Processor userInterruptPriority.	(Delay forSeconds: 2) wait. 	process sigterm. 	(Delay forSeconds: 10) wait. 	self assert: exited.		[ 			"I could never understood why but only with OSSFileBasedUnixSubprocessTest and only on OSX, randomly (when running many tests together) below assertion fails. I cannod add this test as #expectedFailure because sometimes it works and then when it does it is marked as failure becasue it didn't fail. So I simply skip the test if it failed"		self assertStreamsInfoWithPrevious: streamsInfo.	] on: TestFailure do: [ self skip ]! !!OSSPipeBasedUnixSubprocessTest methodsFor: 'helper'!newCommand		^ self commandClass new			"For pipes, we can use a pipe for both reading or writing"			defaultReadStreamCreationBlock: [self systemAccessor makeBlockingPipe];			defaultWriteStreamCreationBlock: [self systemAccessor makeNonBlockingPipe];			yourself 		! !!OSSPipeBasedUnixSubprocessTest methodsFor: 'tests - streams'!testCommandTryToWriteToStdoutButHasNoReader	| command errString  | 	command := self newCommand					shellCommand: 'sleep 2; echo 42';					redirectStdout;					redirectStderr.		command run.	command stdoutStream closeReader.					command waitForExit.	"This should be a SIGPIPE because there is no reader opened for the pipe and someone is trying to write to it. " 	errString := command stderrStream upToEndOfFile.	self assert: command exitStatusInterpreter exitStatus > 0. "It ended with error".	"Ideally I would also add this assert, but it seems not all OS write this on stderr. For example,	OSX does write it, while Linux does not."	"self assert:( errString includesSubstring: 'Broken pipe')."	command closeAndCleanStreams.! !!OSSPipeBasedUnixSubprocessTest methodsFor: 'tests - streams'!testReadingFromStdoutBlocksVM	| command customStream | 	customStream := self systemAccessor makeBlockingPipe.	command := self newCommand					command: '/bin/sleep';					arguments: (Array with: '4');					redirectStdoutTo: customStream.		command run. 	self assert:[ command stdoutStream upToEnd ] timeToRun seconds > 2. 	command waitForExit.	command closeAndCleanStreams.! !!OSSPipeBasedUnixSubprocessTest methodsFor: 'tests - streams'!testReadingFromStdoutDoesNotBlocksVM	| command customStream | 	customStream := self systemAccessor makeNonBlockingPipe.	command := self newCommand					command: '/bin/sleep';					arguments: (Array with: '4');					redirectStdoutTo: customStream.		command run. 	self assert:[ command stdoutStream upToEnd ] timeToRun seconds <= 2. 	command waitForExit. 	command closeAndCleanStreams.! !!OSSUnixSubprocessTest class methodsFor: 'testing'!isAbstract	"Override to true if a TestCase subclass is Abstract and should not have	TestCase instances built from it"	^self name = #OSSUnixSubprocessTest			! !!OSSUnixSubprocessTest methodsFor: 'helpers'!assertStreamsInfoWithPrevious: anObject 	self assert: self getStreamsInfoForRunningTest equals: anObject! !!OSSUnixSubprocessTest methodsFor: 'helpers'!getStreamsInfoForRunningTest	^ self numberOfOpenFiles ! !!OSSUnixSubprocessTest methodsFor: 'helpers'!numberOfOpenFiles	"This is estimation number. Not to be used for real code. It's basically to check the number of opened FIFO files at the beginning of a test and at the end, to validate we are not leaving behind opened files.	This should work in most Unix-like and Linux systems.	Only FIFO files are checked as we can't control other threads, and it is redirecting stdio that is happening in the tests."	| tmpFileName openFiles |	tmpFileName := (FileSystem workingDirectory / 'openFilesByPharoVM-' , UUID new printString) fullName.	tmpFileName asFileReference ensureDelete.	self systemAccessor system: ('lsof -p ', OSSVMProcess vmProcess pid printString, ' > "', tmpFileName, '" 2>&1').	openFiles := tmpFileName asFileReference readStreamDo: [ :str | | lines |		lines := str contents lines.		"Count only pipes"		lines select: [ :each | each includesSubstring: 'FIFO' ]	].	tmpFileName asFileReference ensureDelete.	^ openFiles size! !!OSSUnixSubprocessTest methodsFor: 'helpers'!numberOfZombiesProcesses	"This is estimation number. Not to be used for real code. IT's basically 	to check the number of zombies at the beginning of a  test and at the end, to validate we are not leaving behind new zombies. 	This should work in most Unix-like and Linux	"	| tmpFileName zombiesCount |	tmpFileName := (FileSystem workingDirectory / 'zombiesByPharoVM-' , UUID new printString) fullName.	tmpFileName asFileReference ensureDelete.	self systemAccessor system: ('ps axo ppid=,stat= | grep ', OSSVMProcess vmProcess pid printString, ' | awk ''$2~/^Z/ { print $2 }'' | wc -l  > "', tmpFileName, '" 2>&1').	zombiesCount := tmpFileName asFileReference readStreamDo: [ :str |		str contents trimmed asNumber	].	tmpFileName asFileReference ensureDelete.	^ zombiesCount	! !!OSSUnixSubprocessTest methodsFor: 'helpers'!ppidOf: childPid	"Answers the parent pid (ppid) of the childPid	"	| tmpFileName openFilesNumber |	tmpFileName := (FileSystem workingDirectory / ' ppidof-' , UUID new printString) fullName.	tmpFileName asFileReference ensureDelete.	Transcript show: tmpFileName; cr.	self systemAccessor system: ('ps -p ', childPid , ' -o ppid=').	openFilesNumber := tmpFileName asFileReference readStreamDo: [ :str |		"The -1 is because the above command brings one line which is a header." 		str contents trimmed asNumber	].	tmpFileName asFileReference ensureDelete.	^ openFilesNumber	! !!OSSUnixSubprocessTest methodsFor: 'tests - env'!testAddAllEnvVariablesFromParent	| command | 	command := self newCommand					command: '/bin/ls';					environmentAt: 'WHATEVER' put: 'vi';					addAllEnvVariablesFromParentWithoutOverride. 	self assert: command envVariables size equals: (OSSUnixSubprocess new defaultEnvVariablesDictionary keys size) + 1.		! !!OSSUnixSubprocessTest methodsFor: 'tests - env'!testAddAllEnvVariablesFromParentWithoutOverride	| command | 	"Here we assume that the parent process will have the $PATH defined."	command := self newCommand					command: '/bin/ls';					environmentAt: 'PATH' put: 'whatever';					addAllEnvVariablesFromParentWithoutOverride. 	self assert: command envVariables size equals: (OSSUnixSubprocess new defaultEnvVariablesDictionary keys size).	self assert: (command envVariables at: 'PATH') equals: 'whatever'		! !!OSSUnixSubprocessTest methodsFor: 'tests - env'!testAddOnlyOneVariable	| command | 	command := self newCommand					command: '/bin/ls';					environmentAt: 'EDITOR' put: 'vi'.	self assert: command envVariables size equals: 1.		! !!OSSUnixSubprocessTest methodsFor: 'tests - basic'!testBasicCommand	| command |	command := self newCommand 					command: '/bin/ls'.	command runAndWait.	! !!OSSUnixSubprocessTest methodsFor: 'tests - streams'!testBasicCommandReadFromStderr	| streamsInfo |	streamsInfo := self getStreamsInfoForRunningTest.	self newCommand		command: '/bin/ls';		arguments: (Array with: '-' with: 'foo');		redirectStderr;		runAndWaitOnExitDo: [ :command :outString :errString |			self assert: (errString includesSubstring: ': No such file or directory').			self assert: command stdoutStream isNil.			self assert: command stderrStream closed.			self assertStreamsInfoWithPrevious: streamsInfo.		].		! !!OSSUnixSubprocessTest methodsFor: 'tests - streams'!testBasicCommandReadFromStdout	| streamsInfo |	streamsInfo := self getStreamsInfoForRunningTest.	self newCommand		command: '/bin/ls';		arguments: (Array with: Smalltalk image imagePath);		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: (outString includesSubstring: Smalltalk image imagePath).			self assertStreamsInfoWithPrevious: streamsInfo.		].		! !!OSSUnixSubprocessTest methodsFor: 'tests - basic'!testBasicCommandWithArgument	| command | 		command := self newCommand					command: '/bin/ls';					arguments: { Smalltalk image imagePath. }.		command runAndWait! !!OSSUnixSubprocessTest methodsFor: 'tests - basic'!testBasicCommandWithNonAsciiArgument	| command | 		self withNonAsciiDirectoryDo: [ :dir |		command := self newCommand					command: '/bin/ls';					arguments: { dir fullName }.		command runAndWait	]! !!OSSUnixSubprocessTest methodsFor: 'tests - basic'!testBasicCommandWithoutFullPath	self newCommand		command: 'ls';		arguments: (Array with: Smalltalk image imagePath);		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: (outString includesSubstring: Smalltalk image imagePath).							]		 ! !!OSSUnixSubprocessTest methodsFor: 'tests - streams'!testBasicCommandWriteToStdin	| command stdOutString string streamsInfo | 	streamsInfo := self getStreamsInfoForRunningTest.	string := 'this is a test shat should have been printed in the stdout'.	command := self newCommand					command: '/bin/cat';					redirectStdin;					redirectStdout.						command run.	command stdinStream 		nextPutAll: string;		close.	command waitForExit.	stdOutString := command stdoutStream upToEndOfFile.	command closeAndCleanStreams.	self assert: command isSuccess.	self assert: stdOutString equals: string.	self assertStreamsInfoWithPrevious: streamsInfo.		! !!OSSUnixSubprocessTest methodsFor: 'tests - streams'!testBasicCommandWriteToStdin2	| command streamsInfo outString | 	streamsInfo := self getStreamsInfoForRunningTest.	command := self newCommand					command: 'wc';					redirectStdin;					redirectStdout;					run. 	command stdinStream 			nextPutAll: Smalltalk image imagePath;			close.	command waitForExit.	outString := command stdoutStream upToEndOfFile. 	command closeAndCleanStreams.					self assert: command isSuccess.	"It's hard to test the output of wc crossplatform..."	self assert: outString size > 5.	self assertStreamsInfoWithPrevious: streamsInfo.		! !!OSSUnixSubprocessTest methodsFor: 'tests - shell'!testBasicShellCommand	| command | 		command := self newCommand					shellCommand: 'ls'.		command runAndWait.	! !!OSSUnixSubprocessTest methodsFor: 'tests - shell'!testBasicShellCommandWithNonAsciiCharacters		self withNonAsciiDirectoryDo: [ :dir |		(dir / 'ok.txt') ensureCreateFile.		self newCommand			shellCommand: 'ls ', dir fullName;			redirectStdout;			runAndWaitOnExitDo: [ :command :outString |				self assert: (outString includesSubstring: 'ok.txt').								]	]! !!OSSUnixSubprocessTest methodsFor: 'tests - shell'!testBasicShellCommandWithStdout	self newCommand		shellCommand: 'ls "', Smalltalk image imagePath, '"';		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: (outString includesSubstring: Smalltalk image imagePath).								]		 ! !!OSSUnixSubprocessTest methodsFor: 'tests - child status'!testCheckZombieStateAndTestChildWatcherWorking	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand 				command: '/bin/sleep';				arguments: {'1'}.		command run. 	self assert: command pid > 0.	(Duration seconds: 2) wait.	"In this case we are NOT going to do the queryExitStatus since we want to know 	if the child watcher is doing it's job."	"self assert: command queryExitStatus isNil not."	"Now it should not be a zombie anymore"	self assert: self numberOfZombiesProcesses equals: oldZombies.		! !!OSSUnixSubprocessTest methodsFor: 'tests - child status'!testCheckZombieStateWithNonExistingCommang	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand 				command: 'whatever'.						"Ideally, I would like to use a should:raise: but not all OS do fail. OSX does send errorl, while Linux does not.	So...if error, then it;s ok. But if not, also."	[ command runAndWait ] on: Error do: [  :ex | 		self assert: (ex printString includesSubstring: 'No such file or directory') .		self assert: command pid isNil.		^ nil	].		self assert: command exitStatusInterpreter exitStatus > 0.	self assert: self numberOfZombiesProcesses equals: oldZombies.		! !!OSSUnixSubprocessTest methodsFor: 'tests - child status'!testCheckZombieStateWithOnExitApi	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand 				command: '/bin/sleep';				arguments: {'1'};				runAndWaitOnExitDo: [  ].		self assert: self numberOfZombiesProcesses equals: oldZombies.		! !!OSSUnixSubprocessTest methodsFor: 'tests - child status'!testCheckZombieStateWithWaitChild	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand 				command: '/bin/sleep';				arguments: {'1'}.		command run.	command waitForExit. 	self assert: self numberOfZombiesProcesses equals: oldZombies.		! !!OSSUnixSubprocessTest methodsFor: 'tests - wait'!testCommandReturningDifferentThanZero	| command | 		"When the file does not exists ls returns 1"	command := self newCommand 					command: '/bin/ls';					arguments: {'asdasdasdasdsad'}.		command runAndWait. 		"Do not use #deny:equals: for Pharo 6 compatibility"	self deny: (command exitStatusInterpreter exitStatus = 0)! !!OSSUnixSubprocessTest methodsFor: 'tests - streams'!testCreateMissingStandardStreamsDisabled	| command | 		command := self newCommand					command: '/bin/ls'.						command runAndWait. 	self assert: command stdinStream isNil.	self assert: command stdoutStream isNil.	self assert: command stderrStream isNil.	! !!OSSUnixSubprocessTest methodsFor: 'tests - streams'!testCreateMissingStandardStreamsEnabled	| command streamsInfo | 	streamsInfo := self getStreamsInfoForRunningTest.	"The output of the ls command should be displayed in the stdout of the Pharo image. See comment of #createPipesForMissingStreams: for more details"	command := self newCommand					command: '/bin/ls';					createMissingStandardStreams: true.						command runAndWait. 	self assert: command stdinStream isNil not.	self assert: command stdoutStream isNil not.	self assert: command stderrStream isNil not.	command closeAndCleanStreams.	self assertStreamsInfoWithPrevious: streamsInfo.	! !!OSSUnixSubprocessTest methodsFor: 'tests - shell'!testCustomShellWithStdout	self newCommand		shell: '/bin/bash' command: 'ls "', Smalltalk image imagePath, '"';		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: (outString includesSubstring: Smalltalk image imagePath).							]		 ! !!OSSUnixSubprocessTest methodsFor: 'tests - streams'!testCustomStdoutStream	| customStream streamsInfo | 	streamsInfo := self getStreamsInfoForRunningTest.	customStream := self newCommand createADefaultWriteStream.	self newCommand		command: '/bin/ls';		arguments: (Array with: Smalltalk image imagePath);		redirectStdoutTo: customStream;		runAndWaitOnExitDo: [ :command :outString |			self assert: (outString includesSubstring: Smalltalk image imagePath).			self assert: command stdoutStream == customStream	.							self assertStreamsInfoWithPrevious: streamsInfo.		].		! !!OSSUnixSubprocessTest methodsFor: 'tests - child status'!testGetChildPid	| command | 		command := self newCommand 					command: '/bin/ls'.		command run.	self assert: command pid > 0.	command waitForExit. ! !!OSSUnixSubprocessTest methodsFor: 'tests - child status'!testGetChildStatusAfterFailingCommand	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand					command: '/bin/ls';					arguments: {'whatever'}.	command run.	self assert: command pid > 0.	command waitForExit.	command queryExitStatus.	self assert: command exitStatusInterpreter exitStatus >  0. 	self deny: command isSuccess.	self assert: command isComplete.	self deny: command isRunning.	self assert: self numberOfZombiesProcesses equals: oldZombies.! !!OSSUnixSubprocessTest methodsFor: 'tests - child status'!testGetChildStatusAfterFinishesMultipleTimes	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand					command: '/bin/ls'.		command run. 	self assert: command pid > 0.	command waitForExit.	"Just wanted to be sure there is no problem calling waitpid() multiple times"	command queryExitStatus.	command queryExitStatus.	command queryExitStatus.	command queryExitStatus.		self assert: command exitStatusInterpreter exitStatus equals: 0. 	self assert: command isSuccess.	self assert: command isComplete.	self deny: command isRunning.	self assert: self numberOfZombiesProcesses equals: oldZombies.! !!OSSUnixSubprocessTest methodsFor: 'tests - child status'!testGetChildStatusAfterFinishesSuccess	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand					command: '/bin/ls'.		command run. 	self assert: command pid > 0.	command waitForExit.	command queryExitStatus.	self assert: command exitStatusInterpreter exitStatus equals: 0. 	self assert: command isSuccess.	self assert: command isComplete.	self deny: command isRunning.	self assert: self numberOfZombiesProcesses equals: oldZombies.! !!OSSUnixSubprocessTest methodsFor: 'tests - child status'!testGetChildStatusBeforeAndAfterFinishing	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand 				command: '/bin/sleep';				arguments: {'3'}.		command run. 	self assert: command pid > 0.	(Duration seconds: 1) wait.	self assert: command queryExitStatus isNil.	self deny: command isComplete.	self assert: command isRunning.	command waitForExit.	self assert: command queryExitStatus isNil not.	self assert: command exitStatusInterpreter exitStatus equals: 0.	self assert: command isComplete.	self assert: self numberOfZombiesProcesses equals: oldZombies.	! !!OSSUnixSubprocessTest methodsFor: 'tests - env'!testInheritVarFromEnv	| command | 	command := self newCommand					shellCommand: 'echo ${HOME} 2>&1 > /tmp/testReadUserDefinedEnvVar ';					runAndWait.		self assert: ('/tmp/testReadUserDefinedEnvVar' asFileReference readStreamDo: [ :str | str contents ]) trimmed equals: (Smalltalk os environment at: 'HOME') trimmed.	'/tmp/testReadUserDefinedEnvVar' asFileReference ensureDelete. ! !!OSSUnixSubprocessTest methodsFor: 'tests - basic'!testNoneExistingCommand	| command stdout stderr | 		command := self newCommand					command: 'whatever';					redirectStdout;					redirectStderr.		"Ideally, I would like to use a should:raise: but not all OS do fail. OSX does send errorl, while Linux does not.	So...if error, then it;s ok. But if not, also."	[ command runAndWait ] on: Error do: [  :ex | 		self assert: (ex printString includesSubstring: 'No such file or directory') .		self assert: command pid isNil.		command closeAndCleanStreams.		^ nil	].		self assert: command exitStatusInterpreter exitStatus > 0.	command closeAndCleanStreams.! !!OSSUnixSubprocessTest methodsFor: 'tests - streams'!testReadingFromStdoutAfterCommandFinishesDoesNotBlocksVM	| command streamsInfo | 		"We set the sunit test timeout to 30 seconds.	Otherwise default sunit test timeout is 10 seconds.	This is for Pharo version >= 6.0"	(self respondsTo: #timeLimit:) ifTrue: [ 		self timeLimit: 30 seconds.	].		streamsInfo := self getStreamsInfoForRunningTest.	command := self newCommand					command: '/bin/sleep';					arguments: (Array with: '1');					redirectStdout;					runAndWait.						"Even with a blocking stream, if the command has finished, we have	all data ready to read and hence it's not blocking"	self assert:[ command stdoutStream upToEndOfFile ] timeToRun seconds <= 5. 	command closeAndCleanStreams.	self assertStreamsInfoWithPrevious: streamsInfo.		! !!OSSUnixSubprocessTest methodsFor: 'tests - wait'!testRunAndWaitPollingEveryRetrievingStreamsOnExitDo	self newCommand 		command: '/bin/ls';		arguments: (Array with: Smalltalk image imagePath);		redirectStdout;		runAndWaitPollingEvery: (Delay forMilliseconds: 50)  retrievingStreams: true onExitDo: [ :command :outString :errString |			self assert: command pid > 0.			self assert: command exitStatusInterpreter exitStatus equals: 0. 			self assert: (outString includesSubstring: Smalltalk image imagePath).			self assert: command stdoutStream closed.		]				! !!OSSUnixSubprocessTest methodsFor: 'tests - env'!testSetAndReadCustomVariable	self newCommand 		shellCommand: 'echo ${WHATEVER}';		environmentAt: 'WHATEVER' put: 'hello';		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: outString trimmed equals: 'hello'		]! !!OSSUnixSubprocessTest methodsFor: 'tests - env'!testSetAndReadCustomVariableOutsideShell	self newCommand 		command: 'printenv';		arguments: (Array with: 'WHATEVER');		environmentAt: 'WHATEVER' put: 'hello';		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: outString trimmed equals: 'hello'. 							]! !!OSSUnixSubprocessTest methodsFor: 'tests - env'!testSetCustomVariableOutsideShellAndPassedToCommand	" This test demonstrates that we do not expand variables automatically. So if you don't use the shell, or any other special command that	will search for special variables (like git searching $GIT_EDITOR), these will not be resolved. 	If you want that, then you must execute the command with the arguments already expandaded. That is, for example,	in this case, you should pass the argument 'hello' rather than ${WHATEVER} "		self newCommand 		command: '/bin/echo';		arguments: (Array with: '${WHATEVER}');		environmentAt: 'WHATEVER' put: 'hello';		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: outString trimmed equals: '${WHATEVER}'. 					]! !!OSSUnixSubprocessTest methodsFor: 'tests - wait'!testShellCommandReturningDifferentThanZero	| command | 		command := self newCommand shellCommand: 'exit 2'.	command runAndWait. 		self assert: command exitStatusInterpreter exitStatus equals: 2. ! !!OSSUnixSubprocessTest methodsFor: 'tests - shell'!testShellCommandWithPipingStdout	self newCommand		shellCommand: 'ps -fea | grep Pharo';		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: (outString includesSubstring: 'Pharo').								]		 ! !!OSSUnixSubprocessTest methodsFor: 'tests - shell'!testShellCommandWithStreamRedirects	| stdOutContents | 	self newCommand		shellCommand: 'ps -fea | grep Pharo > /tmp/testShellCommandWithStreamRedirects.deleteme';		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: outString isEmpty. 			stdOutContents := '/tmp/testShellCommandWithStreamRedirects.deleteme' asFileReference readStreamDo: [ :str | str contents ] .			self assert: (stdOutContents includesSubstring: 'Pharo').								].	'/tmp/testShellCommandWithStreamRedirects.deleteme' asFileReference ensureDelete. 		 			! !!OSSUnixSubprocessTest methodsFor: 'tests - signals'!testSigTerm	| process exited streamsInfo |		"We set the sunit test timeout to 30 seconds.	Otherwise default sunit test timeout is 10 seconds.	This is for Pharo version >= 6.0"	(self respondsTo: #timeLimit:) ifTrue: [ 		self timeLimit: 30 seconds.	].		exited := false.	streamsInfo := self getStreamsInfoForRunningTest.	process := self newCommand.	[	process 		command: 'tail';		arguments: (Array with: '-f' with: Smalltalk image changesName);		redirectStdout;		redirectStderr;		runAndWaitPollingEvery: (Delay forMilliseconds: 500) 		doing: [ :aProcess :outStream :errStream |  		 	outStream upToEnd.			errStream upToEnd.		]		onExitDo: [ :aProcess :outStream :errStream  |			process closeAndCleanStreams.			exited := true.			self assert: aProcess exitStatusInterpreter printString equals: 'exit due to signal 15'		].	"The problem here is that we simply do a #fork this closure will continue to be executed while other test run. And so, all the test checking for zombies or opened files will fail because we can have this forked process that did not yet finish. A workaround is to simply run this closures with a higher priority so that there are less chances of other tests to be running. Another possibility would be to reject those 'tail' processes from #numberOfZombiesProcesses and #numberOfOpenFiles as all the tests that use #fork use the 'tail' OS command."		] forkAt: Processor userInterruptPriority.	(Delay forSeconds: 2) wait. 	process sigterm. 	(Delay forSeconds: 10) wait. 	self assert: exited.		self assertStreamsInfoWithPrevious: streamsInfo.! !!OSSUnixSubprocessTest methodsFor: 'tests - signals'!testSigTermInsideLoop	| process exited streamsInfo |		exited := false.	streamsInfo := self getStreamsInfoForRunningTest.	process := self newCommand.		process 		command: 'tail';		arguments: (Array with: '-f' with: Smalltalk image changesName);		redirectStdout;		redirectStderr;		runAndWaitPollingEvery: (Delay forMilliseconds: 500) 		doing: [ :aProcess :outStream :errStream |  		 	"Imagine here that you have some condition...say.. elapsedTime > 1 h .. 			or ... stdOutStream size > 1MB  or whatever..  "						"#sigterm will throw an error (no such process) if the process with the given pid doesn't exist. Because of the looping of this method it COULD happen that we send #sigterm again even if the process was already killed in the previous loop. So we simply make sure the process is running before doing the #sigterm"			aProcess isRunning ifTrue: [ aProcess sigterm. ] 	]		onExitDo: [ :aProcess :outStream :errStream  |			process closeAndCleanStreams.			exited := true.			self assert: aProcess exitStatusInterpreter printString equals: 'exit due to signal 15'		].	self assert: exited.		self assertStreamsInfoWithPrevious: streamsInfo.! !!OSSUnixSubprocessTest methodsFor: 'tests - wait'!testStopWaitingWithPolling	| process counter oldZombies |	process := self newCommand.	oldZombies := self numberOfZombiesProcesses.	counter := 0.	[		process			command: 'tail';			arguments:  (Array with: '-f' with: Smalltalk image imagePath);			redirectStdout;			runAndWaitPollingEvery: (Delay forMilliseconds: 50)  retrievingStreams: true onExitDo: [ :command :outString :errString |				"The counter is to demonstrate that the exit happens only once we did the #stopWaiting				and not before"				self assert: counter equals: 0. 				self assert: process exitStatus isNil.				"Since we did not wait for the child to finish we must do a sigterm to avoid zombies				when running the tests"				command sigterm.				"Not sure about while this delay but it seems it's needed so that the next queryExitStatus				does collect exit status and hence avoid zombies"				(Delay forSeconds: 4) wait.				command queryExitStatus.				self assert: self numberOfZombiesProcesses equals: oldZombies.							]				"The problem here is that we simply do a #fork this closure will continue to be executed while other test run. And so, all the test checking for zombies or opened files will fail because we can have this forked process that did not yet finish. A workaround is to simply run this closures with a higher priority so that there are less chances of other tests to be running. Another possibility would be to reject those 'tail' processes from #numberOfZombiesProcesses and #numberOfOpenFiles as all the tests that use #fork use the 'tail' OS command."		] forkAt: Processor userInterruptPriority.	(Delay forSeconds: 3) wait.	"Just to demonstrate that tail will run forever until explicitly closed".	self assert: process isRunning. 	process stopWaiting.	! !!OSSUnixSubprocessTest methodsFor: 'tests - wait'!testStopWaitingWithSigchld	| process counter oldZombies |	process := self newCommand.	oldZombies := self numberOfZombiesProcesses.	counter := 0.	[	process		command: 'tail';		arguments:  (Array with: '-f' with: Smalltalk image imagePath);		redirectStdout;		runAndWaitPollingEvery: (Delay forMilliseconds: 50)  retrievingStreams: true onExitDo: [ :command :outString :errString |			"The counter is to demonstrate that the exit happens only once we did the #stopWaiting			and not before"			self assert: counter equals: 0. 			self assert: command exitStatus isNil.			"Since we did not wait for the child to finish we must do a sigterm to avoid zombies			when running the tests"			command sigterm.			"Not sure about while this delay but it seems it's needed so that the next queryExitStatus			does collect exit status and hence avoid zombies"			(Delay forSeconds: 4) wait.			command queryExitStatus.			self assert: self numberOfZombiesProcesses equals: oldZombies.		]	"The problem here is that we simply do a #fork this closure will continue to be executed while other test run. And so, all the test checking for zombies or opened files will fail because we can have this forked process that did not yet finish. A workaround is to simply run this closures with a higher priority so that there are less chances of other tests to be running. Another possibility would be to reject those 'tail' processes from #numberOfZombiesProcesses and #numberOfOpenFiles as all the tests that use #fork use the 'tail' OS command."		] forkAt: Processor userInterruptPriority.					(Delay forSeconds: 3) wait.	"Just to demonstrate that tail will run forever until explicitly closed".	self assert: process isRunning. 	process stopWaiting.	! !!OSSUnixSubprocessTest methodsFor: 'tests - wait'!testWaitForExit	| command | 		command := self newCommand 					command: '/bin/sleep';					arguments: {'3'}.		command run. 	self assert: command pid > 0.	self assert: [ command waitForExit ] timeToRun asSeconds >= 2.	self assert: command exitStatusInterpreter exitStatus equals: 0. ! !!OSSUnixSubprocessTest methodsFor: 'tests - wait'!testWaitForExitPolling	| command | 		command := self newCommand 					command: '/bin/sleep';					arguments: {'3'}.		command run. 	self assert: command pid > 0.	self assert: [ command waitForExitPolling ] timeToRun asSeconds >= 2.	self assert: command exitStatusInterpreter exitStatus equals: 0. ! !!OSSUnixSubprocessTest methodsFor: 'tests - wait'!testWaitForExitPollingEvery	| command | 		command := self newCommand 					command: '/bin/sleep';					arguments: {'3'}.		command run. 	self assert: command pid > 0.	self assert: [ command waitForExitPollingEvery: (Delay forSeconds: 1) ] timeToRun asSeconds >= 2.	self assert: command exitStatusInterpreter exitStatus equals: 0. ! !!OSSUnixSubprocessTest methodsFor: 'tests - high API'!testWaitForExitPollingEveryDoing	| streamsInfo totalRead |	totalRead := String new writeStream.	streamsInfo := self getStreamsInfoForRunningTest.	self newCommand		command: '/bin/ls';		arguments: (Array with: Smalltalk image imagePath);		redirectStdout;		redirectStderr;		runAndWaitPollingEvery: (Delay forMilliseconds: 50) 		doing: [ :process :outStream :errStream |  			| read | 			read := outStream upToEnd.			totalRead nextPutAll: read.		]		onExitDo: [ :process :outStream :errStream  |			self assert: (totalRead contents includesSubstring: Smalltalk image imagePath).			process closeAndCleanStreams.			self assertStreamsInfoWithPrevious: streamsInfo.		].	! !!OSSUnixSubprocessTest methodsFor: 'tests - wait'!testWaitForExitWithTimeoutWillFailIfProcessDoesNotFinish	| command | 		command := self newCommand 					command: '/bin/sleep';					arguments: {'2'}.		command run.		self		should: [ command waitForExitWithTimeout: 10 milliSeconds ]		raise: OSSTimeout.	self assert: command isRunning.! !!OSSUnixSubprocessTest methodsFor: 'tests - wait'!testWaitForExitWithTimeoutWillNotTimeoutIfProcessFinishes	| command | 		command := self newCommand 					command: '/bin/sleep';					arguments: {'1'}.		command run.	command waitForExitWithTimeout: 2 seconds.		self assert: command pid > 0.	self assert: command exitStatusInterpreter exitStatus equals: 0. ! !!OSSUnixSubprocessTest methodsFor: 'tests - wait'!testWaitpidIsNoneBocking	| command childStatus | 		command := self newCommand					command: '/bin/sleep';					arguments: {'5'}.		command run. 	self assert: command pid > 0.	(Duration seconds: 1) wait.	self assert: [ childStatus := command exitStatusInterpreter ] timeToRun asSeconds < 1.	self assert: childStatus value isNil.	command waitForExit.! !!OSSUnixSubprocessTest methodsFor: 'tests - pwd'!testWorkingDirectory	| oldWorkingDirectory | 	oldWorkingDirectory := self systemAccessor getcwd.	(FileSystem workingDirectory / 'testing') ensureCreateDirectory.		self newCommand		shellCommand: 'pwd';		workingDirectory: (FileSystem workingDirectory / 'testing') fullName;		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: outString trimmed equals: (FileSystem workingDirectory / 'testing') fullName.			]. 	self assert: self systemAccessor getcwd trimmed equals: oldWorkingDirectory trimmed.		 	(FileSystem workingDirectory / 'testing') ensureDelete.	! !!OSSUnixSubprocessTest methodsFor: 'helpers'!withNonAsciiDirectoryDo: aBlock 	| directory |	directory := FileLocator temp / (self class name , '-éoï-' , UUIDGenerator next asString).	directory ensureCreateDirectory.	[ aBlock cull: directory asFileReference ]	ensure: [ directory ensureDeleteAll ]! !!OSSVMProcessTest methodsFor: 'accessing'!runCaseManaged	"testChangeDirWithNonAsciiCharacters test has to download the unicode table that can take some time.	Disable test timeout."	^ self runCase! !!OSSVMProcessTest methodsFor: 'tests'!testChangeDir	| oldDir | 	oldDir := self systemAccessor getcwd.	OSSVMProcess vmProcess		lockCwdWithValue: '/tmp'		encoding: #utf8 		during: [			"Grrr in latest OSX /tmp is mapped to /private/tmp..."			self assert: ((self systemAccessor getcwd = '/tmp') or: [ self systemAccessor getcwd = '/private/tmp' ]).		].	self assert: self systemAccessor getcwd equals: oldDir				! !!OSSVMProcessTest methodsFor: 'tests'!testChangeDirWithNonAsciiCharacters	| oldDir newDir duringSystemCwd | 	oldDir := self systemAccessor getcwd.	newDir := FileLocator temp / 'strangË foldér namê'.	newDir ensureCreateDirectory.	OSSVMProcess vmProcess		lockCwdWithValue: newDir fullName		encoding: #utf8		during: [ duringSystemCwd := self systemAccessor getcwd ].	duringSystemCwd := UnicodeNormalizer new toNFC: duringSystemCwd.	"Grrr in latest OSX /tmp is mapped to /private/tmp..."	self assert: ((duringSystemCwd = newDir fullName) or: [ duringSystemCwd = ('/private' , newDir fullName) ]).	self assert: self systemAccessor getcwd equals: oldDir.	newDir ensureDelete.! !!OSSVMProcessTest methodsFor: 'tests'!testChangeDirWithNonExistingDir	| oldDir |	oldDir := self systemAccessor getcwd.	[ OSSVMProcess vmProcess		lockCwdWithValue: '/tmpWhatever'		encoding: #utf8		during: [  ] ]	on: Error	do: [ :ex | self assert: (ex printString includesSubstring: 'does not exist') ].	self assert: self systemAccessor getcwd equals: oldDir! !!OSSVMProcessTest methodsFor: 'tests'!testChildrenCollectionsWithOneProcessBeforeAndAfter	| command | 	OSSVMProcess vmProcess initializeAllMyChildren. 	command := self newCommand 		command: '/bin/sleep';		arguments: {'2'}.		command run. 		self assert: OSSVMProcess vmProcess allMyChildren size equals: 1.	self assert: OSSVMProcess vmProcess allMyChildren first == command.	self assert: OSSVMProcess vmProcess activeChildren size equals: 1.	self assert: OSSVMProcess vmProcess activeChildren first == command.	self assert: OSSVMProcess vmProcess exitedChildren isEmpty.	self assert: OSSVMProcess vmProcess childPids size equals: 1.	self assert: OSSVMProcess vmProcess childPids first equals: command pid.		command waitForExit. 		self assert: OSSVMProcess vmProcess allMyChildren size equals: 1.	self assert: OSSVMProcess vmProcess allMyChildren first == command.	self assert: OSSVMProcess vmProcess activeChildren size equals: 0.	self assert: OSSVMProcess vmProcess exitedChildren size equals: 1.	self assert: OSSVMProcess vmProcess exitedChildren first == command.	self assert: OSSVMProcess vmProcess childPids size equals: 1.	self assert: OSSVMProcess vmProcess childPids first equals: command pid.			! !!OSSVMProcessTest methodsFor: 'tests'!testInitializeChildren	OSSVMProcess vmProcess initializeAllMyChildren.		self assert: OSSVMProcess vmProcess allMyChildren isEmpty.	self assert: OSSVMProcess vmProcess activeChildren isEmpty.	self assert: OSSVMProcess vmProcess exitedChildren isEmpty.	self assert: OSSVMProcess vmProcess childPids isEmpty.					! !!OSSVMProcessTest methodsFor: 'tests'!testPruneExitedChildrenAfter	| command | 	OSSVMProcess vmProcess initializeAllMyChildren. 	command := self newCommand 		command: '/bin/ls'.	command runAndWait. 		self assert: OSSVMProcess vmProcess exitedChildren size equals: 1.	OSSVMProcess vmProcess pruneExitedChildrenAfter: 0. 		self assert: OSSVMProcess vmProcess allMyChildren isEmpty.	self assert: OSSVMProcess vmProcess activeChildren isEmpty.	self assert: OSSVMProcess vmProcess exitedChildren isEmpty.	self assert: OSSVMProcess vmProcess childPids isEmpty.		! !"OSSubprocess-Tests-Unit"!!OSSConcurrentProcessesTest methodsFor: 'tests'!launchAndWaitForProcessesToFinish: numberOfProcesses	"We set the sunit test timeout to 2 times the sleep duration.	Otherwise default sunit test timeout is 1 minute."		| processes |	"We set the sunit test timeout to 1 second per process.	Except for short running processes, where we keep the default timeout.	This is for Pharo version >= 6.0"	(self respondsTo: #timeLimit:) ifTrue: [ 		self timeLimit: (numberOfProcesses seconds max: self defaultTimeLimit).	].		processes := (1 to: numberOfProcesses) collect: [ :index |		self newCommand			command: '/bin/sleep';			arguments: { '1s' };			yourself ].		processes do: #run.		processes do: [ :command | command waitForExitWithTimeout: 5 seconds ]! !!OSSConcurrentProcessesTest methodsFor: 'tests'!test100ProcessEventuallyFinishes	self launchAndWaitForProcessesToFinish: 100! !!OSSConcurrentProcessesTest methodsFor: 'tests'!test10ProcessEventuallyFinishes	self launchAndWaitForProcessesToFinish: 10! !!OSSConcurrentProcessesTest methodsFor: 'tests'!test1ProcessEventuallyFinishes	self launchAndWaitForProcessesToFinish: 1! !!OSSLongRunningProcessTest methodsFor: 'tests'!doTestProcessEventuallyFinishesForSeconds: aDuration	| command |	"We set the sunit test timeout to 2 times the sleep duration.	Otherwise default sunit test timeout is 1 minute.	This is for Pharo version >= 6.0"	(self respondsTo: #timeLimit:) ifTrue: [ 		self timeLimit: aDuration * 2.	].	command := self newCommand		command: '/bin/sleep';		arguments: { aDuration asSeconds asString };		yourself.	command run.		"We should wait and finish without a timeout exception"	command waitForExitWithTimeout: aDuration * 2.! !!OSSLongRunningProcessTest methodsFor: 'tests'!test100SecondProcessEventuallyFinishes	self doTestProcessEventuallyFinishesForSeconds: 100 second! !!OSSLongRunningProcessTest methodsFor: 'tests'!test10SecondProcessEventuallyFinishes	self doTestProcessEventuallyFinishesForSeconds: 10 second! !!OSSLongRunningProcessTest methodsFor: 'tests'!test1SecondProcessEventuallyFinishes	self doTestProcessEventuallyFinishesForSeconds: 1 second! !!OSSLongRunningProcessTest methodsFor: 'tests'!test300SecondProcessEventuallyFinishes	"Wait for five minutes.	Times > 10 minutes make travis timeout."	self doTestProcessEventuallyFinishesForSeconds: 300 second! !"OSSubprocess-Tests-Stress"!!PRProject commentStamp: '' prior: 0!(PRCompilationPipeline buildPipe: PRPillarConfiguration new).projectDirectory := '../test' asFileReference.projectDirectory ensureDeleteAll.projectDirectory ensureCreateDirectory.project := PRProject on: projectDirectory.project wipeout.project archetype: 'welcome'.project build: PRHtmlOutput new.projectDirectory := '../test' asFileReference.projectDirectory ensureDeleteAll.projectDirectory ensureCreateDirectory.project := PRProject on: projectDirectory.project wipeout.project archetype: 'presentation'.project build: PRHtmlOutput new.project build: PRPdfOutput new.projectDirectory := '../test' asFileReference.projectDirectory ensureDeleteAll.projectDirectory ensureCreateDirectory.project := PRProject on: projectDirectory.project wipeout.project archetype: 'book'.project build: PRHtmlOutput new.project build: PRPdfOutput new.projectDirectory := '../test' asFileReference.projectDirectory ensureDeleteAll.projectDirectory ensureCreateDirectory.project := PRProject on: projectDirectory.project wipeout.project archetype: 'basic-latex'.project build: PRHtmlOutput new.project build: PRPdfOutput new.!!ManifestPillarProject commentStamp: '' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!PRFileCopyVisitor class methodsFor: 'copying'!copy: srcReference to: dstReference onConflictDo: conflictResolutionBlock	^ self basicNew		initializeWithSource: srcReference 		dest: dstReference;		conflictResolutionBlock: conflictResolutionBlock;		visit! !!PRFileCopyVisitor methodsFor: 'accessing'!conflictResolutionBlock: aConflictResolutionBlock	conflictResolutionBlock := aConflictResolutionBlock! !!PRFileCopyVisitor methodsFor: 'accessing'!copyDirectory: aReference	| copy |	copy := dest resolve: (aReference relativeTo: source).	copy exists ifTrue: [ 		^ conflictResolutionBlock value: aReference value: copy ].	copy createDirectory! !!PRFileCopyVisitor methodsFor: 'accessing'!copyFile: aReference	| copy |	copy := dest resolve: (aReference relativeTo: source).	copy exists ifTrue: [ 		^ conflictResolutionBlock value: aReference value: copy ].	aReference copyTo: copy! !!PRFileCopyVisitor methodsFor: 'accessing'!initialize	super initialize.	conflictResolutionBlock := [ :sourceFile :targetFile | sourceFile copyTo: targetFile ]! !!PRArchetype class methodsFor: 'testing'!isAbstract	^ false! !!PRArchetype methodsFor: 'accessing'!directory	^ directory ifNil: [ ^ FileLocator imageDirectory / 'archetypes' / name ] ! !!PRArchetype methodsFor: 'accessing'!directory: aDirectory	directory := aDirectory! !!PRArchetype methodsFor: 'actions'!installIn: baseDirectory	(self directory / 'sample')		children do: [ :child | child copyAllTo: baseDirectory / child basename ].			self installTemplateIn: baseDirectory.! !!PRArchetype methodsFor: 'actions'!installTemplateIn: baseDirectory 	| destination |	destination := baseDirectory / '_support'.	destination ensureDeleteAll.	"Because we move the support folder into a folder called _support"	(self directory / 'support')		copyAllTo: destination! !!PRArchetype methodsFor: 'accessing'!name: aString 	name := aString! !!PRArchetype methodsFor: 'accessing'!project: aPRProject 	project := aPRProject! !!PRArchetype methodsFor: 'validating'!validateExists	self directory exists ifFalse: [		self error: '** archetype directory: ', self directory fullName, '**'.		self error: 'Archetype ', name, ' does not exist'	].! !!PRProject class methodsFor: 'testing'!isAbstract	^ false! !!PRProject class methodsFor: 'instance creation'!on: aDirectory	^ self new		baseDirectory: aDirectory;		yourself! !!PRProject class methodsFor: 'accessing'!pathToString: aPath	^ aPath pillarPrintString! !!PRProject methodsFor: 'archetypes'!archetypeNamed: aString 		^ PRArchetype new		name: aString;		project: self;		yourself! !!PRProject methodsFor: 'accessing'!baseDirectory	^ baseDirectory! !!PRProject methodsFor: 'accessing'!baseDirectory: aFileReference 	baseDirectory := aFileReference! !!PRProject methodsFor: 'templates'!beTemplatable	templatable := true! !!PRProject methodsFor: 'building'!build: output	"Output is an instance of subclass of PRTarget"		"set up information required prior to pipeline building"	self prepareForTarget: output.		"Build the pipeline and execute it on each file of the project"	^ output buildOn: self! !!PRProject methodsFor: 'accessing'!configuration		| readConfiguration extension |	extension := Dictionary new.	extension at: 'outputDirectory' put: self defaultOutputDirectoryName.		"Just for backwards compatibility"	extension at: '_project' put: self.	readConfiguration := self configurationFileReference exists		ifFalse: [ ConfigurationForPillar newFromDictionary: extension ]		ifTrue: [ ConfigurationForPillar newFromFile: self configurationFileReference extendedWith: extension ].	^ readConfiguration! !!PRProject methodsFor: 'accessing'!configurationFileReference		^ self baseDirectory / 'pillar.conf'! !!PRProject methodsFor: 'building'!contributeToPipelineBuilding: aPRPipelineBuilder 		self plugins do: [ :each | each contributeToPipelineBuilding: aPRPipelineBuilder ]! !!PRProject methodsFor: 'accessing'!defaultOutputDirectoryName	^ '_result'! !!PRProject methodsFor: 'accessing'!defaultTarget	| defaultExport |	defaultExport := [self configuration defaultExport ifEmpty: [ ^ PRAbsentTarget]] on: Error do: [ ^ PRAbsentTarget ]  .	^ PRTarget targetByFormatName: defaultExport! !!PRProject methodsFor: 'initialization'!initialize	super initialize.	templatable := false! !!PRProject methodsFor: 'archetypes'!installArchetypeNamed: archetypeName	| archetype |	archetype := self archetypeNamed: archetypeName.	archetype validateExists.	archetype installIn: self baseDirectory! !!PRProject methodsFor: 'archetypes'!installArchetypeNamed: archetypeName fromDirectory: pillarDirectory		| archetype |	archetype := self archetypeNamed: archetypeName.	archetype directory: pillarDirectory.	archetype validateExists.	archetype installIn: self baseDirectory! !!PRProject methodsFor: 'templates'!installTemplateNamed: archetypeName 		| archetype |	archetype := self archetypeNamed: archetypeName.	archetype validateExists.	archetype installTemplateIn: self baseDirectory! !!PRProject methodsFor: 'templates'!isTemplatable	^ templatable! !!PRProject methodsFor: 'accessing'!outputDirectory	"pay attention the output directory of a output document is more precise than the one of a project. 	Indeed it will take into account the kind of document and add 'pdf', 'html'.... as subfolder.	See PRPdfOutput >> #documentFor: to see the logic. For a project outputDirectory return the general place e.g. ..._result/"		^ self baseDirectory resolve: self configuration outputDirectory! !!PRProject methodsFor: 'accessing'!plugins		^ (self configuration propertyAt: #plugins ifAbsent: [ #() ])			collect: [ :each | | plugin |				plugin := Smalltalk globals					at: each asSymbol					ifAbsent: [ self error: 'Could not resolve plugin: ', each ].				plugin withContext: self ]! !!PRProject methodsFor: 'building'!prepareForTarget: target	"We want to build a given project i.e. PDF, HTML. We are setting up the system to be built. With prepareForTarget:, the actions that will be triggered are happening before the pipeline is set and executed."		target prepareForExecutionOn: self.	self plugins do: [ :each | each prepareForExecutionOn: self ]! !!PRProject methodsFor: 'accessing'!supportDirectory		^ self baseDirectory / '_support'! !!PRProject methodsFor: 'accessing'!tableOfContents	| tocFilePath tocFileName inputDoc |	toc ifNotNil: [ ^ toc ].		tocFilePath := self configuration propertyAt: 'tocFile' ifAbsent: [ ^ PRToc new ].	tocFileName := self class pathToString: tocFilePath.	inputDoc := PRPillarParserMain parse: (self baseDirectory / tocFileName) contents.		^ toc := PRTocBuilderVisitor new		documentSource: self baseDirectory / tocFileName;		currentFile: tocFileName;		inProcessFiles: (Array with: self baseDirectory / tocFileName);		visit: inputDoc! !!PRProject methodsFor: 'as yet unclassified'!updateBuild	| destination reference |	reference := FileLocator imageDirectory parent / 'archetypes'.	destination := FileLocator imageDirectory / 'archetypes'.		destination ensureDeleteAll.	"Because we copy the archetypes folder from parent into build/archetypes"	reference copyAllTo: destination! !!PRProject methodsFor: 'actions'!wipeout		self outputDirectory ensureDeleteAll! !!PRDocument methodsFor: '*Pillar-Project'!dependencies	self shouldBeImplemented.! !!PRDocument methodsFor: '*Pillar-Project'!pdfTransformationsFor: anOutputDocument	^ { 		PRRelativeReferenceTransformer new			inputFile: anOutputDocument inputFile;			baseDirectory: anOutputDocument baseDirectory asAbsolute;			outputDirectory: (anOutputDocument outputDirectory);			yourself		.		PRLatexPathUpdateVisitor new 		}! !"Pillar-Project"!!PRParameterizableTestCase commentStamp: '' prior: 0!I am a parameterizable test case. My tests can receive arguments.>> testX: x y: y  ...Parameters are automatically deduced from argument names. That is, for argument #x, I search all selectors on the instance side that are prefixed by the string 'x'. For example,  on a parameter named #output I'll search all methods named  #output[Other] in the current hierarchy.Once deduced the argument selectors from the argument names, I create a test case instance for each of the permutations of selectors.My instances contain then: - the test selector to execute - an array with a permutation of selctors corresponding each to each argument nameMy #performTest method is defined  to obtain all test arguments using the argument selectors and then perform the test selector providing those arguments.I am not used so far because I don't work in SmalltalkCI!!PRIntegrationTest methodsFor: 'parameters'!archetypeBasicLatex	^ 'basic-latex'! !!PRIntegrationTest methodsFor: 'parameters'!archetypeBook	^ 'book'! !!PRIntegrationTest methodsFor: 'parameters'!archetypePresentation	^ 'presentation'! !!PRIntegrationTest methodsFor: 'parameters'!archetypeWelcome	^  'welcome'! !!PRIntegrationTest methodsFor: 'initialization'!ensureTestDirectory	projectDirectory := '__test' asFileReference.	projectDirectory ensureDeleteAll.	projectDirectory ensureCreateDirectory.! !!PRIntegrationTest methodsFor: 'parameters'!outputAscii	^ PRAsciiOutput new! !!PRIntegrationTest methodsFor: 'parameters'!outputEPub	^ PREPubOutput new! !!PRIntegrationTest methodsFor: 'parameters'!outputHtml	^ PRHtmlOutput new! !!PRIntegrationTest methodsFor: 'parameters'!outputMarkdown	^ PRMarkdownOutput new! !!PRIntegrationTest methodsFor: 'parameters'!outputPdf	^ PRPdfOutput new! !!PRIntegrationTest methodsFor: 'running'!setUp	super setUp.	self ensureTestDirectory.	project := PRProject on: projectDirectory.! !!PRIntegrationTest methodsFor: 'running'!tearDown	Smalltalk garbageCollect.	projectDirectory ensureDeleteAll.	super tearDown.! !!PRIntegrationTest methodsFor: 'tests'!testArchetype: archetype output: output	project installArchetypeNamed: archetype.	project build: output.		self assert: project outputDirectory children size equals: 1.	self assert: project outputDirectory children first basename equals: output outputDirectoryName.! !!PRIntegrationTest methodsFor: 'tests'!testBasicLatexHtml	self testArchetype: self archetypeBasicLatex output: self outputHtml.	self assert: (project outputDirectory / 'html' / 'index.html') exists.! !!PRIntegrationTest methodsFor: 'tests'!testBasicLatexPdf	self timeLimit: 1 minute.	self testArchetype: self archetypeBasicLatex output: self outputPdf.	self assert: (project outputDirectory / 'pdf' / 'index.pdf') exists.! !!PRIntegrationTest methodsFor: 'tests'!testBookAscii	self testArchetype: self archetypeBook output: self outputAscii.	self assert: (project outputDirectory / 'ascii' / 'index.ascii') exists.! !!PRIntegrationTest methodsFor: 'tests'!testBookEpub	| archive |	self skip.	"This is bug in P8 with ZipArchive see https://github.com/pharo-project/pharo/issues/5758"	self testArchetype: self archetypeBook output: self outputEPub.	self assert: (project outputDirectory / 'epub' / 'index.epub') exists.	archive := ZipArchive new.	archive readFrom: (project outputDirectory / 'epub' / 'index.epub') fullName.	self assert: archive members first fileName equals: 'mimetype'.	self assert: (archive memberNamed: 'contents.opf') isNotNil.	self assert: (archive memberNamed: 'contents.xhtml') isNotNil! !!PRIntegrationTest methodsFor: 'tests'!testBookHtml	self testArchetype: self archetypeBook output: self outputHtml.	self assert: (project outputDirectory / 'html' / 'index.html') exists.! !!PRIntegrationTest methodsFor: 'tests'!testBookMarkdown	self testArchetype: self archetypeBook output: self outputMarkdown.	self assert: (project outputDirectory / 'markdown' / 'index.markdown') exists.! !!PRIntegrationTest methodsFor: 'tests'!testBookPdf	self timeLimit: 2 minutes.	self testArchetype: self archetypeBook output: self outputPdf.	self assert: (project outputDirectory / 'pdf' / 'index.pdf') exists.! !!PRIntegrationTest methodsFor: 'tests'!testPresentationAscii	self testArchetype: self archetypePresentation output: self outputAscii.	self assert: (project outputDirectory / 'ascii' / 'index.ascii') exists.! !!PRIntegrationTest methodsFor: 'tests'!testPresentationHtml	self testArchetype: self archetypePresentation output: self outputHtml.	self assert: (project outputDirectory / 'html' / 'index.html') exists.! !!PRIntegrationTest methodsFor: 'tests'!testPresentationMarkdown	self testArchetype: self archetypePresentation output: self outputMarkdown.	self assert: (project outputDirectory / 'markdown' / 'index.markdown') exists.! !!PRIntegrationTest methodsFor: 'tests'!testPresentationPdf	self timeLimit: 2 minutes.	self testArchetype: self archetypePresentation output: self outputPdf.	self assert: (project outputDirectory / 'pdf' / 'index.pdf') exists.! !!PRIntegrationTest methodsFor: 'tests'!testWelcomeAscii	self testArchetype: self archetypeWelcome output: self outputAscii.	self assert: (project outputDirectory / 'ascii' / 'index.ascii') exists.! !!PRIntegrationTest methodsFor: 'tests'!testWelcomeHtml	self testArchetype: self archetypeWelcome output: self outputHtml.	self assert: (project outputDirectory / 'html' / 'index.html') exists.! !!PRIntegrationTest methodsFor: 'tests'!testWelcomeMarkdown	self testArchetype: self archetypeWelcome output: self outputMarkdown.	self assert: (project outputDirectory / 'markdown' / 'index.markdown') exists! !!PRIntegrationTest methodsFor: 'tests'!testWelcomePdf	self testArchetype: self archetypeWelcome output: self outputPdf.	self assert: (project outputDirectory / 'pdf' / 'index.pdf') exists.! !!PRParameterizableTestCase class methodsFor: 'building suites'!buildSuiteFromMethods: testMethods	| testCases suite |	testCases := testMethods flatCollect: [ :each |		self testCasesForSelector: each ].	suite := self suiteClass named: self name asString.	testCases do: [ :each | suite addTest: each ].	^ suite! !!PRParameterizableTestCase class methodsFor: 'testing'!isAbstract	^ self class == PRParameterizableTestCase! !!PRParameterizableTestCase class methodsFor: 'building suites'!permutationsOf: aCollection 		| restOfPermutations |	aCollection ifEmpty: [ ^ #(#()) ].	restOfPermutations := self permutationsOf: aCollection allButFirst.	^ aCollection first flatCollect: [ :element | 		restOfPermutations collect: [ :permutation | permutation copyWithFirst: element  ] ]! !!PRParameterizableTestCase class methodsFor: 'instance creation'!selector: testSelector arguments: arguments	^ self new		setTestSelector: testSelector;		setTestArguments: arguments;		yourself! !!PRParameterizableTestCase class methodsFor: 'building suites'!testCasesForSelector: testSelector		| method argumentPossibilities |	method := self >> testSelector.	argumentPossibilities := method argumentNames collect: [ :each |		self allSelectors select: [ :selector | selector beginsWith: each ]  ].		^ (self permutationsOf: argumentPossibilities)			collect: [ :permutation | 				self selector: testSelector arguments: permutation ]! !!PRParameterizableTestCase class methodsFor: 'building suites'!testSelectors	^ self selectors select: [ :each | (each beginsWith: 'test') ]! !!PRParameterizableTestCase methodsFor: 'private-parameterizable'!cleanUpInstanceVariables	| instVarsToKeep |	instVarsToKeep := #( 'testSelector' 'testArguments' ).	self class allInstVarNames do: [ :name |		(instVarsToKeep includes: name) ifFalse: [			self instVarNamed: name put: nil ] ]! !!PRParameterizableTestCase methodsFor: 'private-parameterizable'!performTest	^ self		perform: testSelector asSymbol		withArguments: (testArguments collect: [ :each | self perform: each ])! !!PRParameterizableTestCase methodsFor: 'private-parameterizable'!printOn: aStream	super printOn: aStream.	testArguments printOn: aStream.! !!PRParameterizableTestCase methodsFor: 'private-parameterizable'!setTestArguments: aCollection 		testArguments := aCollection! !"Pillar-Tests-Integration"!!PRBuilderMappingTest methodsFor: 'tests'!testBuilderForHtmlIsHtmlBuilder	self assert: (PRTarget builderClassForName: 'html') equals: PRHtmlOutput.	self assert: ((PRTarget builderForName: 'html') isKindOf: PRHtmlOutput)! !!PRBuilderMappingTest methodsFor: 'tests'!testBuilderForPdfIsPdfBuilder	self assert: (PRTarget builderClassForName: 'pdf') equals: PRPdfOutput! !!ProjectDefaultTargetTest methodsFor: 'tests'!configAbsentTargetContent 	^ '{  "base_url": "",  "site_name": "Pharo Book",  "title": "The Pillar Super Book Archetype",  "attribution": "The Pillar team",  "series": "Square Bracket tutorials",  "keywords": "project template, Pillar, Pharo, Smalltalk",  "language": "en-UK",  "latexWriter" : #latex}'! !!ProjectDefaultTargetTest methodsFor: 'tests'!configAsciiContent	^ '{  "base_url": "",  "site_name": "Pharo Book",  "title": "The Pillar Super Book Archetype",  "attribution": "The Pillar team",  "series": "Square Bracket tutorials",  "keywords": "project template, Pillar, Pharo, Smalltalk",  "language": "en-UK",  "latexWriter" : #latex,  "defaultExport" : "ascii"}'! !!ProjectDefaultTargetTest methodsFor: 'tests'!configHTMLContent	^ '{  "base_url": "",  "site_name": "Pharo Book",  "title": "The Pillar Super Book Archetype",  "attribution": "The Pillar team",  "series": "Square Bracket tutorials",  "keywords": "project template, Pillar, Pharo, Smalltalk",  "language": "en-UK",  "latexWriter" : #latex,  "defaultExport" : "html"}'! !!ProjectDefaultTargetTest methodsFor: 'tests'!configInvalidTargetContent	^ '{  "base_url": "",  "site_name": "Pharo Book",  "title": "The Pillar Super Book Archetype",  "attribution": "The Pillar team",  "series": "Square Bracket tutorials",  "keywords": "project template, Pillar, Pharo, Smalltalk",  "language": "en-UK",  "latexWriter" : #latex,  "defaultExport" : "error"}'! !!ProjectDefaultTargetTest methodsFor: 'tests'!configMarkdownContent	^ '{  "base_url": "",  "site_name": "Pharo Book",  "title": "The Pillar Super Book Archetype",  "attribution": "The Pillar team",  "series": "Square Bracket tutorials",  "keywords": "project template, Pillar, Pharo, Smalltalk",  "language": "en-UK",  "latexWriter" : #latex,  "defaultExport" : "markdown"}'! !!ProjectDefaultTargetTest methodsFor: 'tests'!configPDFContent	^ '{  "base_url": "",  "site_name": "Pharo Book",  "title": "The Pillar Super Book Archetype",  "attribution": "The Pillar team",  "series": "Square Bracket tutorials",  "keywords": "project template, Pillar, Pharo, Smalltalk",  "language": "en-UK",  "latexWriter" : #latex,  "defaultExport" : "pdf"}'! !!ProjectDefaultTargetTest methodsFor: 'tests'!testDefaultTargetAbsent	| directory |	directory := FileSystem memory root.	directory / 'pillar.conf'		writeStreamDo: [ :st | st nextPutAll: self configAbsentTargetContent ].	project := PRProject new baseDirectory: directory.		self assert: project defaultTarget equals: PRAbsentTarget! !!ProjectDefaultTargetTest methodsFor: 'tests'!testDefaultTargetAscii	| directory |	directory := FileSystem memory root.	directory / 'pillar.conf'		writeStreamDo: [ :st | st nextPutAll: self configAsciiContent ].	project := PRProject new baseDirectory: directory.		self assert: project defaultTarget equals: PRAsciiOutput! !!ProjectDefaultTargetTest methodsFor: 'tests'!testDefaultTargetHTML	| directory |	directory := FileSystem memory root.	directory / 'pillar.conf'		writeStreamDo: [ :st | st nextPutAll: self configHTMLContent ].	project := PRProject new baseDirectory: directory.		self assert: project defaultTarget equals: PRHtmlOutput! !!ProjectDefaultTargetTest methodsFor: 'tests'!testDefaultTargetInvalid	| directory |	directory := FileSystem memory root.	directory / 'pillar.conf'		writeStreamDo: [ :st | st nextPutAll: self configInvalidTargetContent ].	project := PRProject new baseDirectory: directory.		self assert: project defaultTarget equals: PRInvalidTarget! !!ProjectDefaultTargetTest methodsFor: 'tests'!testDefaultTargetMarkdown	| directory |	directory := FileSystem memory root.	directory / 'pillar.conf'		writeStreamDo: [ :st | st nextPutAll: self configMarkdownContent ].	project := PRProject new baseDirectory: directory.		self assert: project defaultTarget equals: PRMarkdownOutput! !!ProjectDefaultTargetTest methodsFor: 'tests'!testDefaultTargetPDF	| directory |	directory := FileSystem memory root.	directory / 'pillar.conf'		writeStreamDo: [ :st | st nextPutAll: self configPDFContent ].	project := PRProject new baseDirectory: directory.		self assert: project defaultTarget equals: PRPdfOutput! !!ProjectDirectoryTest methodsFor: 'tests'!testDefaultOuputDirectory	| fileSystem project goodDir |		fileSystem := FileSystem memory root.	goodDir := (fileSystem / 'PharoBook80126') ensureCreateDirectory .		project := PRProject on: fileSystem / 'PharoBook80126'.		self assert: project baseDirectory equals: goodDir.	self assert: project outputDirectory equals: goodDir / project defaultOutputDirectoryName.! !"Pillar-Tests-Project"!!PRBookTestResult commentStamp: '' prior: 0!I represent a pillar codeblock once it has been tested.I am composed of a text, a result and an explanation.The text shows the text of the codeblock I am linked to, the result is a boolean stating if the test has passed or not and the explanation is either 'Test passed', 'Test failed without raising an exception' or the exception raised by the test.For example:[[[example=true 3+4>>> 7]]]Given this codeblock, the associated PRBookTestResult's instance variable would be: text: ''3+4'result: true explanation: 'Test passed'The fragmentedText instance variable is used by method or test definitions to keep class and method names. For example:[[[methodDefinitionPlop >> plop1   ^ '1']]]text: 'Plop >> plop1		 ^ ''1'''fragmentedText: #('Plop' 'plop1' '^ ''1''')!!PRCheckBookTarget commentStamp: '' prior: 0!Looks like a little hack to be able to pass extra parameters during the documentFor: invocation?!!PRCreateTestsTarget commentStamp: '' prior: 0!Looks like a little hack to be able to pass extra parameters during the documentFor: invocation?!!PRLoaderAnnotation commentStamp: '' prior: 0!I am an annotation used to load a github project in a given state.I am used in a PRDocument in order to load a github project at a given tag.My parameters are: - account : github account name- project : github project name- tag : github commit tag I am used as follows in a document:	${loader:account=QDucasse|project=TestBook|tag=Chapter1}$	Note:	The visit of this annotation is performed by the PRBookTesterVisitor in charge of visiting the document and therefore there is not a PRLoaderAnnotationTransformer defined for a simple reason, this annotation does not transform anything.!!PRRunAnnotation commentStamp: '' prior: 0!I am an annotation used to run the tests of a given test class.I am used in a PRDocument in order test already defined tests methods in a given test class.My parameters are: - testClass : a test class you want to runI am used as follows in a document:	${run:testClass=ChapterTest}$	Note:	The visit of this annotation is performed by the PRBookTesterVisitor in charge of visiting the document and therefore there is not a PRRunAnnotationTransformer defined for a simple reason, this annotation does not transform anything.!!PRScreenshotAnnotation commentStamp: '' prior: 0!I am an annotation used to show a screenshot of a given class and method.I am used in a PRDocument to include a PRPicture and add a PNG file to the /figures chapter subfolder.My parameters are: - package: the targetted package- class: the targetted class- method: the targetted method- caption: the caption that will appear under my figure in the final book- width: PRFigure width (as would be used in a more classic figure inclusion with +caption .>file|width=50)- label: PRFigure label (as would be used in a more classic figure inclusion with +caption .>file|label=aa)I am used as follows in a document:	${screenshot:package=Kernel|class=Integer|method=+|caption='The Plus Method'|width=50|label=aa}$	Note:	Contrary to the loader or run annotations, there is a transformation going on here: a PRFigure is created in the end, so there is a need here to use a PRNodeTransformer subclass, PRScreenshotTransformer.!!PRShowClassAnnotation commentStamp: '' prior: 0!I am an annotation used to show a Class defined in our system.I am used in a PRDocument to include a PRCodeblock with the class description within it.My parameters are: - class: the class name I am used as follows in a document:	${showClass:class=MyClass}$	Note:	Contrary to the loader or run annotations, there is a transformation going on here: a PRCodeblock is created in the end, so there is a need here to use a PRNodeTransformer subclass, PRShowClassTransformer.!!PRShowMethodAnnotation commentStamp: '' prior: 0!I am an annotation used to show a method defined in our system.I am used in a PRDocument to include a PRCodeblock with the method description within it.My parameters are: - class: the class name - method: the method nameI am used as follows in a document:	${showMethod:class=MyClass|method=myMethod}$	Note:	Contrary to the loader or run annotations, there is a transformation going on here: a PRCodeblock is created in the end, so there is a need here to use a PRNodeTransformer subclass, PRShowMethodTransformer.!!PRBookTesterVisitor commentStamp: '' prior: 0!I am a visitor specialized in visiting books and testing their code. Therefore, I only redefine visitCodeBlock: and specify it with the different parameters the codeblock may have.I gather all results as PRBookTestResults in the variable allTestsResults.visitCodeblock: uses executeAndReport: creating a PRBookTestResult with the result of the evaluation of the codeblock.checkAndReportFileNamed: starts the visit in a given file.Every codeblock can be specified with the following parameters implying a specialized visit:- example: The codeblock is an example defined as follows, 				[[[example=true				(stimuli) >>> result				]]]	- methodDefinition: The codeblock is a method definition defined as follows,				[[[methodDefinition=true				ClassName >> methodName					method body				]]]	- classDefinition 				[[[classDefinition=true				Object subclass: #YourClass					instanceVariableNames: 'iv1 iv2'					classVariableNames: ''					package: 'YourPackage'				]]]	- evaluation				[[[eval=true				(stimuli) >>> result				]]]The process goes like that: - when I visit a code block I create a result which is annotated with a prepared version of the codeblock body.- then depending on this preparation, I execute the code to validate it. - each type have a specific way of being validated.- I report for each if is possible or not to check that the example provide the correct result, that the class definition can compile or that the method definition can compile. !!PRBookTestGenerator commentStamp: '' prior: 0!This visitor generates tests based on the information in the >>> expression. !!PRValidatorResult commentStamp: '' prior: 0!I represent an error result raised by PRValidator.I am composed of:- an explanation (of my error)- a specification (the name of concerned file or reference)All recognized error explanation are in allResult dictionary.Use my constructor to instantiate me.!!PRValidatorVisitor commentStamp: '' prior: 0!I am a visitor specialized for Pillar files to check if references and file calls are correct.I gather all found issues in my variable allTestsResults. Each issue is represented by a PRValidatorResult.finalStatus variable returns true if there isn't any issue.!!ManifestPillarBookTester commentStamp: '' prior: 0!BookTester introduces new annotations- ${showMethod:method=foo|class=Integer}$ to display the method definition.- ${showMethod:class=Integer}$ to display the class definition.- ${screenshot:class=Class|method=foo|caption='jlkl'|width=100|label=mylabel}$- run and load should be commented here		BookTester also validates the annotations for example, class and method definitions.[[[example=true1+1 >>> 2]]]are either checked or turn into tests.Method definitions and class definitions are checked by compiling them.			[[[methodDefinition=trueyourClass >> yourMethod   ^ 'bla']]][[[classDefinition=trueObject subclass:...    ...]]]Booktester creates a report on stdout. pillar build checkbook test all the pillar file recursively available in the directory.pillar clap checkFile x.pillar !!PRCheckBookDocument commentStamp: '' prior: 0!I'm the output of a book checking phase. I will report on stdout failing and working test.!!PRScreenshotTransformer commentStamp: '' prior: 0!I am a transformer for the screenshot annotation.I know how to  visit a screenshot annotation and the way to transform it.I have two main purposes:- I create a PRFigure with the annotation parameters- I create a PNG file in the /figures subfolder (with the help of exportAsPNGForPillar)!!PRShowClassTransformer commentStamp: '' prior: 0!I am a transformer for the showClass annotation.I know how to  visit a showClass annotation and the way to transform it.I create a PRCodeblock with the class definition within it.!!PRShowMethodTransformer commentStamp: '' prior: 0!I am a transformer for the showMethod annotation.I know how to  visit a showMethod annotation and the way to transform it.I create a PRCodeblock with the method definition within it.!!PRBookTestResult methodsFor: 'accessing'!characterizeMethodDefinition	"Precondition: fragmentedText should be filled in before using this method"	self fragmentedText isString		ifTrue: [ ^ 'wrongSyntax' ].	self fragmentedText first size = 2		& self fragmentedText first isArray		ifTrue: [ ^ 'classSide' ].	^ 'normalMethodDefinition'! !!PRBookTestResult methodsFor: 'accessing'!explanation	^ explanation! !!PRBookTestResult methodsFor: 'accessing'!explanation: anException	explanation := anException! !!PRBookTestResult methodsFor: 'accessing'!fragmentedText	^ fragmentedText! !!PRBookTestResult methodsFor: 'accessing'!fragmentedText: aText	"The Array contains: 		-Class Name		-Method Name		-Method Body"	fragmentedText := aText! !!PRBookTestResult methodsFor: 'initialization'!initialize	super initialize.	status := true.	explanation := 'Test failed without raising an exception'! !!PRBookTestResult methodsFor: 'testing'!isFailed	^ status not! !!PRBookTestResult methodsFor: 'testing'!isValid	^ status ! !!PRBookTestResult methodsFor: 'accessing'!status 	"true means that the test is valid, false means that the test got a problem or failed"		^ status! !!PRBookTestResult methodsFor: 'accessing'!status: aBoolean	"true means that the test is valid, false means that the test got a problem or failed"		status := aBoolean! !!PRBookTestResult methodsFor: 'accessing'!text	^ text ! !!PRBookTestResult methodsFor: 'accessing'!text: aText	text := aText! !!PRCheckBookTarget class methodsFor: 'accessing'!builderName		^ #checkBook! !!PRCheckBookTarget methodsFor: 'building'!buildOn: aProject	| status |	status := PRSuccess new.		"We chech each file"	(self filesToBuildOn: aProject) do: [ :each |		status := status and: ((self documentFor: each) buildOn: aProject) ].	^ status! !!PRCheckBookTarget methodsFor: 'building'!documentFor: aFile	^ PRCheckBookDocument new		project: aFile project;		file: aFile;		target: self;		outputDirectory: (aFile project baseDirectory / self outputDirectoryName ) ensureCreateDirectory;		yourself! !!PRCheckBookTarget methodsFor: 'accessing'!extension	^ 'txt'! !!PRCheckBookTarget methodsFor: 'accessing'!outputDirectoryName 	^ '_check'! !!PRCheckBookTarget methodsFor: 'preparation'!prepareForExecutionOn: aPRProject 		"Do nothing"! !!PRCreateTestsTarget class methodsFor: 'accessing'!builderName	^#createTests! !!PRCreateTestsTarget methodsFor: 'building'!buildOn: aProject	| status |	status := PRSuccess new.		"We chech each file"	(self filesToBuildOn: aProject) do: [ :each |		status := status and: ((self documentFor: each) buildOn: aProject) ].	^ status! !!PRCreateTestsTarget methodsFor: 'building'!documentFor: aFile	^ PRCreateTestsDocument new		project: aFile project;		file: aFile;		target: self;		outputDirectory: (aFile project baseDirectory / self outputDirectoryName ) ensureCreateDirectory;		yourself! !!PRCreateTestsTarget methodsFor: 'accessing'!extension	^ 'txt'! !!PRCreateTestsTarget methodsFor: 'accessing'!outputDirectoryName 	^ '_tests-generation'! !!PRCreateTestsTarget methodsFor: 'accessing'!prepareForExecutionOn: aPRProject 		"Do nothing"! !!PRLoaderAnnotation class methodsFor: 'accessing'!possibleParameters	^ #(account project tag baseline)! !!PRLoaderAnnotation class methodsFor: 'accessing'!tag	^ #loader! !!PRLoaderAnnotation methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitLoaderAnnotation: self! !!PRLoaderAnnotation methodsFor: 'visiting'!account	^ self parameters at: #account! !!PRLoaderAnnotation methodsFor: 'visiting'!baseline	"The baseline name may be different than the project name but we make it the same by default"	^ self parameters at: #baseline ifAbsent: [ self project ]! !!PRLoaderAnnotation methodsFor: 'visiting'!gitTag	"gitTag and not tag to avoid interfering with other methods with the same name"	^ self parameters at: #tag! !!PRLoaderAnnotation methodsFor: 'visiting'!project	^ self parameters at: #project! !!PRRunAnnotation class methodsFor: 'accessing'!defaultParameterName	^ 'testClass'! !!PRRunAnnotation class methodsFor: 'accessing'!possibleParameters	^ #(testClass)! !!PRRunAnnotation class methodsFor: 'accessing'!tag	^ #run! !!PRRunAnnotation methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitRunAnnotation: self! !!PRScreenshotAnnotation class methodsFor: 'accessing'!possibleParameters	^ #(class method caption width label)! !!PRScreenshotAnnotation class methodsFor: 'accessing'!tag	^ #screenshot! !!PRScreenshotAnnotation methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitScreenshotAnnotation: self! !!PRScreenshotAnnotation methodsFor: 'visiting'!caption	^ self parameters at: #caption ifAbsent: [ self className, '>>', self methodName ]! !!PRScreenshotAnnotation methodsFor: 'visiting'!className	^ self parameters at: #class! !!PRScreenshotAnnotation methodsFor: 'visiting'!label	^ self parameters at: #label ifAbsent: [ 'lab_', self methodName ]! !!PRScreenshotAnnotation methodsFor: 'visiting'!methodName	^ self parameters at: #method! !!PRScreenshotAnnotation methodsFor: 'visiting'!width	^ self parameters at: #width ifAbsent: [ 50 ]! !!PRShowClassAnnotation class methodsFor: 'accessing'!defaultParameterName	^ 'class'! !!PRShowClassAnnotation class methodsFor: 'accessing'!possibleParameters	^ #(class)! !!PRShowClassAnnotation class methodsFor: 'protected'!tag	^ #showClass! !!PRShowClassAnnotation methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitShowClassAnnotation: self! !!PRShowClassAnnotation methodsFor: 'accessing'!shownClassName	^ (self parameters at: #class) asSymbol! !!PRShowMethodAnnotation class methodsFor: 'accessing'!defaultParameterName	^ 'method'! !!PRShowMethodAnnotation class methodsFor: 'accessing'!possibleParameters	^ #(method class)! !!PRShowMethodAnnotation class methodsFor: 'accessing'!tag	^ #showMethod! !!PRShowMethodAnnotation methodsFor: 'visiting'!accept: aVisitor	^ aVisitor visitShowMethodAnnotation: self! !!PRShowMethodAnnotation methodsFor: 'accessing'!shownClassName	^ (self parameters at: #class) asSymbol! !!PRShowMethodAnnotation methodsFor: 'accessing'!shownMethodName	^ (self parameters at: #method) asSymbol! !!PRBookTestGenerator methodsFor: 'visiting'!checkAndReportFileNamed: aPath		self fileName: (self prettyRename: aPath).	self createClassFrom: fileName.	super checkAndReportFileNamed: aPath			! !!PRBookTestGenerator methodsFor: 'accessing'!codeBlockIndex	^ cbIndex! !!PRBookTestGenerator methodsFor: 'accessing'!codeBlockIndex: aCodeblockCounter	cbIndex := aCodeblockCounter! !!PRBookTestGenerator methodsFor: 'visiting'!createClassFrom: aPrettyFileName	TestCase subclass: aPrettyFileName    		instanceVariableNames: ''    	classVariableNames: ''    	package: resultPackage		! !!PRBookTestGenerator methodsFor: 'visiting'!createTestMethodFrom: aCodeblock	"The test method is compiled using the following template, either it raises no exception:	test(cbIndex)			self assert: (ourAssociation) isPaired		or it raises one:	test(cbIndex)			self assert: false description: [ theCodeBlock test raised the exception: (theException) ]"	[ (self class environment at: fileName asSymbol)		compile:			'test' , cbIndex asString				,					'		self assert: (' , aCodeblock textForExample withSeparatorsCompacted				, ') isPaired' 		classified: 'Compiled ok tests' ]		on: Exception		do: [ :e | 			(self class environment at: fileName asSymbol)				compile:					(String						streamContents: [ :s | 							s << 'test' << cbIndex asString.							s								cr;								cr;								tab.							s								<< 'self assert: Error signal description: ''A code block failed''. '.							s								cr;								tab.							s << '"' << e class name << ' was raised with: '								<< (e messageText copyWithout: $") << '"'.							s								cr;								tab.							s << '"' << 'by the codeblock: '								<< (aCodeblock textForExample withSeparatorsCompacted copyWithout: $")								<< '"' ])					classified: 'Broken book tests' ]! !!PRBookTestGenerator methodsFor: 'accessing'!fileName	^ fileName! !!PRBookTestGenerator methodsFor: 'accessing'!fileName: aFileName	fileName := aFileName! !!PRBookTestGenerator methodsFor: 'visiting'!initialize	super initialize.	self codeBlockIndex: 0.	resultPackage := 'Pillar-BookTesterResults-Books'.! !!PRBookTestGenerator methodsFor: 'accessing'!prettyRename: aPath	| basename |	basename := aPath asFileReference basename.	^ 'PRT', ((basename first asString capitalized), basename allButFirst) withoutPeriodSuffix! !!PRBookTestGenerator methodsFor: 'visiting'!resultPackage	^ resultPackage! !!PRBookTestGenerator methodsFor: 'visiting'!resultPackage: aPackageName	resultPackage := aPackageName! !!PRBookTestGenerator methodsFor: 'visiting'!visitCodeblock: aCodeblock	aCodeblock isEvaluated		ifTrue: [ self evaluate: aCodeblock ]		ifFalse: [ aCodeblock isExample							ifTrue: [ self codeBlockIndex: cbIndex+1.				 			 self createTestMethodFrom: aCodeblock ]]! !!PRBookTesterVisitor class methodsFor: 'testing'!isAbstract	<ignoreForCoverage "This method is ignored for test coverage because it is overriden in all subclasses and these subclasses don't need to do a super-send.">	^ false! !!PRBookTesterVisitor methodsFor: 'accessing'!allTestResults		^ allTestResults! !!PRBookTesterVisitor methodsFor: 'accessing'!allTestResults: anObject	allTestResults := anObject! !!PRBookTesterVisitor methodsFor: 'visiting-codeblock'!checkAndReportFileNamed: aPath	"The API we want to be using: 	Visitor checkAndReportFileNamed: path"		| text |	text := (workingDirectory resolve: aPath) asFileReference readStreamDo: [:str | str contents].	self start: (PRPillarParser new parse: text).	self allTestResults do: [:each | self finalStatus: (self finalStatus & each status) ]		! !!PRBookTesterVisitor methodsFor: 'others'!checkAssociation: aCodeBlock	"Asserts that the association created in any codeBlock has equal arguments"	^ (self class compiler evaluate: aCodeBlock text) isPaired ! !!PRBookTesterVisitor methodsFor: 'accessing'!codeblockDict		^ codeblockDict! !!PRBookTesterVisitor methodsFor: 'accessing'!codeblockDict: aDictionary	codeblockDict := aDictionary! !!PRBookTesterVisitor methodsFor: 'testing'!compileClassSideMethod: aResult	| isCorrect |	[((self class environment at: (((aResult fragmentedText first) first trimBoth) asSymbol)) class)				compileSilently: (aResult fragmentedText second,'	', aResult fragmentedText third) 				classified: 'book tester'.	isCorrect := true]		on: Exception		do: [ :ex | aResult explanation: ex asString.						isCorrect := false ].	^ isCorrect	! !!PRBookTesterVisitor methodsFor: 'testing'!compileMethod: aResult	| isCorrect |	[(self class environment at: (((aResult fragmentedText first) first trimBoth) asSymbol))				compileSilently: (aResult fragmentedText second,'	', aResult fragmentedText third)				classified: 'book tester'.	isCorrect := true]		on: Exception		do: [ :ex | aResult explanation: ex asString.						isCorrect := false ].	^ isCorrect	! !!PRBookTesterVisitor methodsFor: 'testing'!compileWrongSyntaxMethodDefinition: aResult	| isCorrect |	aResult explanation: aResult fragmentedText.	isCorrect := false.	^ isCorrect	! !!PRBookTesterVisitor methodsFor: 'evaluating'!evaluate: aCodeBlock	^ aCodeBlock evaluate! !!PRBookTesterVisitor methodsFor: 'compiling'!executeAndReportClassDefinition: result	"Executes a codeblock with parameter classDefinition=true.	It verifies the compilation occurs without raising any Error/Exception		[[[classDefinition	Object subclass: #Plop		instanceVariableNames: 'iv1 iv2'		classVariableNames: ''		package: 'Pillar-BookTesterResults'	]]]"	| isCorrect |	result explanation: 'Class did not compile without raising an exception'.	isCorrect := false.	[ self class evaluate: result text.	isCorrect := true ]		on: Exception		do: [ :ex | 			result explanation: ex asString.			isCorrect := false ].	result status: isCorrect.	isCorrect		ifTrue: [ result explanation: 'Class created' ]! !!PRBookTesterVisitor methodsFor: 'compiling'!executeAndReportExample: result	"Executes a codeblock with parameter example=true.	To determine whether or not the test passed, this method creates an association as follows:	[[[testcase	3+4	>>>7	]]]	is tested: 	((3+4)>>>7) isPaired"		| isCorrect |	isCorrect := false.	[ isCorrect := self checkAssociation: result ]		on: Exception		do: [ :ex | result explanation: ex asString ].	result status: isCorrect.	isCorrect		ifTrue: [ result explanation: 'Test passed' ]				! !!PRBookTesterVisitor methodsFor: 'compiling'!executeAndReportMethodDefinition: result	"Executes the method definition in the given class with the right name		[[[methodDefinition	Plop >> plop1	^1	]]]	will define the method plop1 that returns 1 in the class Plop"		| isCorrect typeString |	result explanation: 'Method did not compile without raising an exception'.	isCorrect := false.	"The method definition can be either 'classSide', 'wrongSyntax' or 'normalMethodDefinition'"	typeString := result characterizeMethodDefinition.	typeString = 'wrongSyntax'		ifTrue: [ isCorrect := self compileWrongSyntaxMethodDefinition: result ].	typeString = 'classSide'		ifTrue: [ isCorrect := self compileClassSideMethod: result ].	typeString = 'normalMethodDefinition'		ifTrue: [ isCorrect := self compileMethod: result ].	result status: isCorrect.	isCorrect ifTrue: [ result explanation: 'Method compiled' ]! !!PRBookTesterVisitor methodsFor: 'testing'!failedTests	"Returns the failed tests within the test results"	^ allTestResults select: [ :each | each isFailed ]! !!PRBookTesterVisitor methodsFor: 'accessing'!finalStatus	^ finalStatus! !!PRBookTesterVisitor methodsFor: 'accessing'!finalStatus: anObject	finalStatus := anObject! !!PRBookTesterVisitor methodsFor: 'initialization'!initialize	super initialize.	codeblockDict := { (#isEvaluated -> #evaluate:).							(#isExample -> #visitCodeblockExample:).							(#isMethodDefinition -> #visitCodeblockMethodDefinition:).							(#isClassDefinition -> #visitCodeblockClassDefinition:)} asDictionary.	allTestResults := OrderedCollection new.	workingDirectory := FileLocator home.	finalStatus := true! !!PRBookTesterVisitor methodsFor: 'testing'!validTests	"Returns all passed tests"	^ allTestResults select: [ :each | each isValid ]! !!PRBookTesterVisitor methodsFor: 'visiting-codeblock'!visitCodeblock: aCodeBlock	codeblockDict keys		do: [ :k | 			(aCodeBlock perform: k)				ifTrue: [ self perform: (codeblockDict at: k) with: aCodeBlock ] ]! !!PRBookTesterVisitor methodsFor: 'visiting-codeblock'!visitCodeblockClassDefinition: aCodeBlock	"Creates an instance of PRBookTestResult with parameters depending of the type of the codeblock. 	Here it is for a class definition, it simply compiles the codeblock text"		| result |	self withPillarAuthorDo: [		result := PRBookTestResult new.		result text: aCodeBlock text.		allTestResults add: result.		self executeAndReportClassDefinition: result.		aCodeBlock isExpectedFailure			ifTrue: [ result status: result status not] ]! !!PRBookTesterVisitor methodsFor: 'visiting-codeblock'!visitCodeblockExample: aCodeBlock	"Creates an instance of PRBookTestResult with parameters depending of the type of the codeblock. 	Here it is for an example and therefore uses the specialized exmple methods	textForTestcase	executeAndReportExample:	Note that there is no fragmentedText here, no need for it b/ecause the codeblock text contains the whole text and is the equivalent of  Playground execution"		| result |	result := PRBookTestResult new.	result text: aCodeBlock textForExample.	allTestResults add: result.	self executeAndReportExample: result.	aCodeBlock isExpectedFailure		ifTrue: [ result status: result status not] ! !!PRBookTesterVisitor methodsFor: 'visiting-codeblock'!visitCodeblockMethodDefinition: aCodeBlock	"Creates an instance of PRBookTestResult with parameters depending of the type of the codeblock. 	Here it is for a test definition and therefore uses the specialized test definition methods	textForMethodDefinition	executeAndReportMethodDefinition:"		| result |	self withPillarAuthorDo: [		result := PRBookTestResult new.		result text: aCodeBlock text.		result fragmentedText: aCodeBlock textForMethodDefinition.		allTestResults add: result.		self executeAndReportMethodDefinition: result.		aCodeBlock isExpectedFailure			ifTrue: [ result status: result status not] ]! !!PRBookTesterVisitor methodsFor: 'visiting-annotations'!visitLoaderAnnotation: aPRLoaderAnnotation		| projectName accountName tagName baselineName |	projectName := aPRLoaderAnnotation project asString.	accountName := aPRLoaderAnnotation account asString.	tagName := aPRLoaderAnnotation gitTag asString.	baselineName := aPRLoaderAnnotation baseline asString.		self class environment at: #IceLibgitRepository ifPresent: [ :class |		class registry			detect: [ :any | any name = projectName ]			ifFound: #delete. ].	self class environment at: #IceRepository ifPresent: [ :class |		class registry			detect: [ :any | any name = projectName ]			ifFound: [ :repo |				repo loadedPackages do: #unload.				MCRepositoryGroup default removeRepository: repo metacelloAdapter.				repo forget] ].	Metacello new		baseline: baselineName;		repository: 'github://', accountName,'/', projectName,':', tagName, '/src';		onUpgrade: [ :ex | ex useIncoming ];		onConflict: [ :err | err useIncoming ];		load.	! !!PRBookTesterVisitor methodsFor: 'visiting-annotations'!visitRunAnnotation: aPRRunAnnotation	"Todo visitor specification + exception handling"	| testClass |	testClass := (aPRRunAnnotation parameters at: #testClass) asSymbol.	(self class environment at: testClass) suite run passed do: [ :each | 		| methodName |		methodName := (each asString splitOn: '>>#') second.		self allTestResults add: (PRBookTestResult new				 explanation: 'Test passed';				 text: testClass asString , '>>'					 , ((self class environment at: testClass) methodDict at:								  methodName asSymbol) definitionString;				 status: true;				 yourself) ].	(self class environment at: testClass) suite run failures do: [ :each | 		| methodName |		methodName := (each asString splitOn: '>>#') second.		self allTestResults add: (PRBookTestResult new				 explanation: 'Test failed';				 text: testClass asString , '>>'					 , ((self class environment at: testClass) methodDict at:								  methodName asSymbol) definitionString;				 status: false;				 yourself) ].	(self class environment at: testClass) suite run errors do: [ :each | 		| methodName |		methodName := (each asString splitOn: '>>#') second.		self allTestResults add: (PRBookTestResult new				 explanation: 'Test errored';				 text: testClass asString , '>>'					 , ((self class environment at: testClass) methodDict at:								  methodName asSymbol) definition;				 status: false;				 yourself) ]! !!PRBookTesterVisitor methodsFor: 'compiling'!withPillarAuthorDo: aBlock	Author		useAuthor: 'Pillar'		during: aBlock! !!PRBookTesterVisitor methodsFor: 'accessing'!workingDirectory		^ workingDirectory	! !!PRBookTesterVisitor methodsFor: 'accessing'!workingDirectory: aDirectory	workingDirectory := aDirectory	! !!PRValidatorResult class methodsFor: 'as yet unclassified'!allResults	^ allResults ifNil: [ 		allResults := Dictionary new.		allResults			at: #anchorIsMissing put: 'A reference refers to a missing anchor';			at: #twoAnchorsSameNameRelativeToFigure put: 'A figure is declared with a label already declared as an anchor or another figure label';			at: #twoAnchorsSameName put: '2 anchors are declared with the same name';			at: #figureNotFound put: 'Figure not found in internal files';			at: #figureIncorrectExtension put: 'A figure is declared with an unrecognized picture extension';			at: #inputFileNotFound put: 'File invoked in an input file annotation not found'.		^ allResults ]! !!PRValidatorResult class methodsFor: 'as yet unclassified'!explanation: aMethodSymbol withSpecification: aSpecification	^ self new explanation: (self allResults at: aMethodSymbol); specification: aSpecification asString; yourself.! !!PRValidatorResult methodsFor: 'accessing'!explanation	^ explanation! !!PRValidatorResult methodsFor: 'accessing'!explanation: aString	explanation := aString! !!PRValidatorResult methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: 'Error explanation: "', self explanation asString, '", with specification: "', self specification asString, '"'	! !!PRValidatorResult methodsFor: 'accessing'!specification	^ specification! !!PRValidatorResult methodsFor: 'accessing'!specification: aString	specification := aString! !!PRValidatorVisitor methodsFor: 'accessing'!allTestsResults	^ allTestsResults ! !!PRValidatorVisitor methodsFor: 'accessing'!anchors	^ anchors! !!PRValidatorVisitor methodsFor: 'checking'!checkAllReferencesReferToAnExistingAnchor	references do: [ :each | 			(anchors includes: each)				ifFalse: [ allTestsResults add: (self result explanation: #anchorIsMissing withSpecification: each) ] ]	! !!PRValidatorVisitor methodsFor: 'checking'!finalCheck		self checkAllReferencesReferToAnExistingAnchor.! !!PRValidatorVisitor methodsFor: 'accessing'!finalStatus	^ allTestsResults isEmpty! !!PRValidatorVisitor methodsFor: 'initialization'!initialize	super initialize.		allTestsResults := OrderedCollection new.	finalStatus := true.		anchors := OrderedCollection new.	references := OrderedCollection new. ! !!PRValidatorVisitor methodsFor: 'testing'!isFailure	^ self finalStatus not! !!PRValidatorVisitor methodsFor: 'testing'!isSuccess	^ self finalStatus! !!PRValidatorVisitor methodsFor: 'accessing'!references	^ references! !!PRValidatorVisitor methodsFor: 'accessing'!result	^ PRValidatorResult! !!PRValidatorVisitor methodsFor: 'visiting'!start: anObject	super start: anObject.	self finalCheck.! !!PRValidatorVisitor methodsFor: 'visiting-document'!visitAnchor: anAnchor	super visitAnchor: anAnchor.	"check if anchor has a unique name"	(anchors includes: anAnchor name) ifTrue: [ allTestsResults add: (self result explanation: #twoAnchorsSameName withSpecification: anAnchor name ) ] ifFalse: [ anchors add: anAnchor name ].		! !!PRValidatorVisitor methodsFor: 'visiting-document'!visitFigure: aFigure	super visitFigure: aFigure.	"check if figure name considered like an anchor is unique"	aFigure hasLabel ifTrue: [ 		(anchors includes: aFigure label) ifTrue: [ 			allTestsResults add: (self result explanation: #twoAnchorsSameNameRelativeToFigure withSpecification: aFigure label ) 		] ifFalse: [ 			anchors add: aFigure label 		]	].	"check if figure exists in files"	aFigure pathInternFile asFileReference exists ifFalse: 		[ allTestsResults add: (self result explanation: #figureNotFound withSpecification: aFigure reference) ].	"check if figure has correct extension"	aFigure hasFigureExtension 		ifFalse: [ allTestsResults add: 						(self result 								explanation: #figureIncorrectExtension 								withSpecification: aFigure reference) ]	! !!PRValidatorVisitor methodsFor: 'visiting-document'!visitInputFileAnnotation: anInputFileAnnotation	super visitInputFileAnnotation: anInputFileAnnotation.	"check if file with given path exists"	anInputFileAnnotation path asString asFileReference exists 		ifFalse: [ allTestsResults add: 						(self result 							explanation: #inputFileNotFound 							withSpecification: anInputFileAnnotation path) ]! !!PRValidatorVisitor methodsFor: 'visiting-document'!visitReference: aReference	super visitReference: aReference.	aReference hasAnchor ifTrue: [ references add: aReference anchor ]! !!PRVisitor methodsFor: '*Pillar-BookTester'!visitLoaderAnnotation: aLoaderAnnotation 	^ self visitAnnotation: aLoaderAnnotation! !!PRVisitor methodsFor: '*Pillar-BookTester'!visitRunAnnotation: aRunAnnotation 	^ self visitAnnotation: aRunAnnotation! !!PRVisitor methodsFor: '*Pillar-BookTester'!visitScreenshotAnnotation: aScreenshotAnnotation 	^ self visitAnnotation: aScreenshotAnnotation! !!PRVisitor methodsFor: '*Pillar-BookTester'!visitShowClassAnnotation: aShowClassAnnotation 	^ self visitAnnotation: aShowClassAnnotation! !!PRVisitor methodsFor: '*Pillar-BookTester'!visitShowMethodAnnotation: aShowMethodAnnotation 	^ self visitAnnotation: aShowMethodAnnotation! !!Association methodsFor: '*Pillar-BookTester'!isPaired	"	7+3 >>> 10	"		^ self key = self value! !!CompiledMethod methodsFor: '*Pillar-BookTester'!definitionString 	^ self sourceCode! !!PRCheckBookDocument methodsFor: 'writing'!basicWriter	" No basicWriter : do nothing"! !!PRCheckBookDocument methodsFor: 'building'!buildOn: aPRProject 		| parsedDocument transformedDocument |	parsedDocument := self parseInputFile: file.	transformedDocument := self transformDocument: parsedDocument.	^ self writeDocument: transformedDocument.! !!PRCheckBookDocument methodsFor: 'building'!extension	^ 'txt'! !!PRCheckBookDocument methodsFor: 'building'!writeDocument: aDocument	| bTester checkReport outputFile| 	bTester := PRBookTesterVisitor new.	bTester start: aDocument.	checkReport := String streamContents: 				 [ :s |					s << file fullName.					s crlf.					s << 'Passed: ' << (bTester allTestResults size - bTester failedTests size) asString.					s crlf.					s << 'Failed: ' << bTester failedTests size asString.					s crlf;crlf. 					bTester failedTests do: [ :each | 														s << each explanation.														s crlf.											  			s << each text.											  		 	s crlf; crlf. ].				   s << 'File Checked!!'.					s crlf;crlf.].	outputFile := (self outputDirectory resolve: (file file asAbsolute relativeTo: project baseDirectory asAbsolute)) withoutExtension , self extension.	outputFile ensureDelete.	outputFile parent ensureCreateDirectory.	outputFile writeStreamDo: [ :stream | stream nextPutAll: checkReport contents].		bTester allTestResults do: [:each | bTester finalStatus: (bTester finalStatus and: each status) ].		^ PRStatus withStatus: bTester finalStatus	! !!PRCreateTestsDocument methodsFor: 'writing'!basicWriter	" No basicWriter : do nothing"! !!PRCreateTestsDocument methodsFor: 'accessing'!buildOn: aPRProject 		| parsedDocument transformedDocument |	parsedDocument := self parseInputFile: file.	transformedDocument := self transformDocument: parsedDocument.	^ self writeDocument: transformedDocument.! !!PRCreateTestsDocument methodsFor: 'accessing'!extension	^ 'txt'! !!PRCreateTestsDocument methodsFor: 'accessing'!writeDocument: aDocument	| testGen testReport outputFile |	testGen := PRBookTestGenerator new.	testGen fileName: (testGen prettyRename: file file).	testGen createClassFrom: testGen fileName.		testGen start: aDocument.		testReport := String streamContents:		[ :s | 			s crlf.			s crlf.			s << file fullName; crlf.			s << 'Tests created under the package ''Pillar-BookTesterResults'' with the name of the file'; crlf.		 ].			outputFile := (self outputDirectory resolve: (file file asAbsolute relativeTo: project baseDirectory asAbsolute)) withoutExtension , self extension.	outputFile ensureDelete.	outputFile parent ensureCreateDirectory.	outputFile writeStreamDo: [ :stream | stream nextPutAll: testReport contents].			testGen allTestResults do: [:each | testGen finalStatus: (testGen finalStatus and: each status) ].	^ PRStatus withStatus: testGen finalStatus! !!PRScreenshotTransformer class methodsFor: 'instance-creation'!withContext: aContext	| inst |	inst := super withContext: aContext.	inst workingDirectory: aContext baseDirectory.	^ inst! !!PRScreenshotTransformer methodsFor: 'accessing'!initialize	super initialize.	workingDirectory := FileSystem workingDirectory! !!PRScreenshotTransformer methodsFor: 'accessing'!visitScreenshotAnnotation: aPRShowMethodAnnotation		| className methodName browser fileName figure time doc |	className := self class environment at: (aPRShowMethodAnnotation className asSymbol).	methodName := aPRShowMethodAnnotation methodName asSymbol.	"naming the file as follows: className>>methodName-date.png"	time := (((DateAndTime now asString copyReplaceAll: ':' with: '-') copyReplaceAll: '.' with: '-') splitOn: '+') first.	fileName := (aPRShowMethodAnnotation className, '_',aPRShowMethodAnnotation methodName),'-', time,'.png'.	browser := Smalltalk tools browser openOnMethod: className>>methodName.		UIManager default defer: [		1 second wait.		browser window exportAsPNGSilentlyForPillarFileNamed: fileName in: workingDirectory.		browser close].		doc := PRPillarParser new parse:('+' , aPRShowMethodAnnotation caption, '.>file://figures/screenshots/', fileName,								'|width=', aPRShowMethodAnnotation width,								'|label=', aPRShowMethodAnnotation label, '+').	figure := (doc children first) children first.	"returns aPRDocument (> children first >) aPRParagraph (>children first >) aPRFigure"	self replace: {figure}! !!PRScreenshotTransformer methodsFor: 'accessing'!workingDirectory: aFileReference	workingDirectory := aFileReference ! !!PRShowClassTransformer methodsFor: 'visiting'!visitShowClassAnnotation: aPRShowClassAnnotation	| textOfClassDefinition |	textOfClassDefinition := self class environment		                         at: aPRShowClassAnnotation shownClassName		                         ifPresent: [ :classShown | 		                         classShown definitionString ]		                         ifAbsent: [ 			                         'The system was looking for '			                         , aPRShowClassAnnotation shownClassName			                         , ' but did not find it' ].	self replace: { (PRCodeblock			 content: textOfClassDefinition			 parameters: (OrderedDictionary new					  add: 'classDefinition' -> true;					  yourself)) }! !!PRShowMethodTransformer methodsFor: 'visiting'!visitShowMethodAnnotation: aPRShowMethodAnnotation	| methodName methodDefinition |	methodName := aPRShowMethodAnnotation shownMethodName.	methodDefinition := self class environment		at: aPRShowMethodAnnotation shownClassName		ifPresent: [ :shownClass | 			(shownClass canUnderstand: methodName)				ifFalse: [ 'The system was looking for ' , aPRShowMethodAnnotation shownClassName , ' but did not find the method ' , methodName ]				ifTrue: [ shownClass asString , ' >> ' , (shownClass compiledMethodAt: methodName) sourceCode ] ]		ifAbsent: [ 'The system was looking for ' , aPRShowMethodAnnotation shownClassName , ' but did not find it' ].	self		replace:			{(PRCodeblock				content: methodDefinition				parameters:					(OrderedDictionary new						add: 'methodDefinition' -> true;						yourself))}! !!Morph methodsFor: '*Pillar-BookTester'!exportAsPNGSilentlyForPillarFileNamed: aFileName	"The png can be found under the file name YourBook/YourChapter/figures/screenshots/'YourChapter-SystemWindowName'.png"	"The name of the png file itself is Class>>Method-TimeAndDate"	| filePath |	filePath := FileSystem workingDirectory / 'figures' / 'screenshots'.	filePath isFile		ifFalse: [ filePath ensureCreateDirectory ].	PNGReadWriter		putForm: self imageForm		onFileNamed: filePath / aFileName! !!Morph methodsFor: '*Pillar-BookTester'!exportAsPNGSilentlyForPillarFileNamed: aFileName in: aWorkingDirectory		"The png can be found under the file name YourBook/YourChapter/figures/screenshots/'YourChapter-SystemWindowName'.png"	"The name of the png file itself is Class>>Method-TimeAndDate"	| filePath |	filePath := aWorkingDirectory / 'figures' / 'screenshots'.	filePath isFile		ifFalse: [ filePath ensureCreateDirectory ].	PNGReadWriter putForm: self imageForm onFileNamed: 		filePath / aFileName.		! !!PRCodeblock methodsFor: '*Pillar-BookTester'!isClassDefinition	"a codeblock may be a class definition. It does not need to be be classDefinition=true, classDefinition alone is enough.		[[[classDefinition				]]]	"		^ (self hasParameter: 'classDefinition')! !!PRCodeblock methodsFor: '*Pillar-BookTester'!isExample	"a code may be testable annotation. It does not need to be be example=true, example alone is enough.		[[[example				]]]	"		^ (self hasParameter: 'example')! !!PRCodeblock methodsFor: '*Pillar-BookTester'!isExpectedFailure	"a codeblock may be an expected failure, you can state it by using the parameter as follows		[[[expectedFailure=true				]]]	"		^ (self hasParameter: 'expectedFailure')! !!PRCodeblock methodsFor: '*Pillar-BookTester'!isMethodDefinition	"a codeblock may be a method definition. It does not need to be methodDefinition=true, methodDefinition alone is enough.		[[[methodDefinition				]]]	"		^ (self hasParameter: 'methodDefinition')! !!PRCodeblock methodsFor: '*Pillar-BookTester'!isTestDefinition	"a codeblock may be a test definition. It does not need to be be testDefinition=true, testDefinition alone is enough.		[[[testDefinition				]]]	"	self flag: 'it looks like testdefinition was replaced by example'.	^ self hasParameter: 'testDefinition'! !!PRCodeblock methodsFor: '*Pillar-BookTester'!textForExample	"returns a preformated text for codeblock testing"	"(PRCodeblock content: ' 3+4 >>> 7 ' parameters: (OrderedDictionary newFromKeys: #('example') andValues: #(true))) textForExample 	  >>> '(3+4)>>>7'"	^ ('*>>>*' match: self text)		ifTrue: [ '(' , (self text splitOn: '>>>') first trimBoth , ')' , '>>>' , (self text splitOn: '>>>') second trimBoth ]		ifFalse: [ self text ]! !!PRCodeblock methodsFor: '*Pillar-BookTester'!textForMethodDefinition	"returns an Array of preformated text for MethodDefinition testing	The Array contains: 		-Class Name		-Method Name		-Method Body"	"(PRCodeblock content: 'classname >> methodNameblablablabla' parameters: nil) textForMethodDefinitionParameter >>>  #('classname' 'methodName' 'blablablabla') "	^ ('*>>*' match: self text)		ifTrue: [ Array				with: ((self text splitOn: '>>') first trimBoth splitOn: ' ') asArray				with:					((self text splitOn: '>>') second						splitOn:							'') first trimBoth				with:					(''						join:							((self text splitOn: '>>') second								splitOn:									'') allButFirst) trimBoth ]		ifFalse: [ 'Method definition syntax not respected. Please use: YourClass>>yourMethod ...' ]! !"Pillar-BookTester"!!PRBookTestDummyClassTest commentStamp: '' prior: 0!I am a Class used by any of the Pillar-BookTester package. Tests made in this package can test method/class definitions here. PRBookTesterVisitor may need to create classes or methods and they should all be subclasses of PRBookTestDummyClass in a way.On the other hand, the package Pillar-BookTesterResults should only be used by PillarTestGenerator.Pillar-BookTesterResults splits in two packages: 	- TestResults used by PRBookTestGenerator tests 	- Books when using the command createTests on a book!!PRBookTestEnvironmentTest commentStamp: '' prior: 0!I contain on my class side some definition so that tests can run in memory.!!PRBookTestGeneratorTest commentStamp: '' prior: 0!Tests!!PRTransformerEnvironmentTest commentStamp: '' prior: 0!On my class side I define pillarAnnotationsContentsForTest and pillarAnnotationsFileNameForTest methods that are used by the tests to work in memory (and not to generate files on the disc).!!PRBookTestEnvironmentTest class methodsFor: 'test file creation'!pillarContentsForTest	^ '!!A Pillar document test!!!!Some tests that should passA first testable test[[[example=true3 + 7>>>10]]]A second test without testable this time [[[3+8>>>11]]]A third test with testable[[[example=true3 + 4>>>7]]]!!!!Some tests that should failA first testable test[[[example=true3 + 4>>>10]]]A second test without testable this time[[[3 + 5>>> 11]]]A third testable test[[[example=true4 + 5>>>12]]]!!!!Tests that should raise an exceptionA first testable test[[[example=true3 + ''12''>>>10			]]]A second test without testable[[[3 - ''14''>>>10]]]A third testable test[[[example=true''1'' + 2>>>14]]]'! !!PRBookTestEnvironmentTest class methodsFor: 'test file creation'!pillarFileNameForTest		^'test.pillar'! !!PRBookTestGeneratorTest methodsFor: 'running'!methodCreationError	^ self class environment at: #PRTTestMethodCreationError! !!PRBookTestGeneratorTest methodsFor: 'running'!methodCreationFail	^ self class environment at: #PRTTestMethodCreationFail! !!PRBookTestGeneratorTest methodsFor: 'running'!methodCreationSuccess	^ self class environment at: #PRTTestMethodCreationSuccess! !!PRBookTestGeneratorTest methodsFor: 'running'!packageName 	^ #'Pillar-BookTesterResults-TestResults'! !!PRBookTestGeneratorTest methodsFor: 'running'!setUp	"Hooks that subclasses may override to define the fixture of test."		super setUp.	testGenerator := PRBookTestGenerator new.	testingFileSystem := FileSystem memory workingDirectory.	(testingFileSystem / self class pillarFileNameForTest)		writeStreamDo: [ :stream |			stream nextPutAll: self class pillarContentsForTest ].	"[ 'Pillar-BookTesterResults-TestResults' asPackage removeFromSystem ] ifCurtailed: [ nil ]"! !!PRBookTestGeneratorTest methodsFor: 'running'!tearDown	| pak |	pak := RPackageOrganizer default packageNamed: self packageName ifAbsent: [ ^ self ].	pak removeFromSystem.	super tearDown! !!PRBookTestGeneratorTest methodsFor: 'running'!testMethodCreationFailingCodeblock	| codeBlock run |	testGenerator resultPackage: self packageName.	testGenerator fileName: 'PRTTestMethodCreationFail'.	testGenerator createClassFrom: testGenerator fileName.	testGenerator codeBlockIndex: 1.	codeBlock := PRCodeblock content: '3+7>>>11' parameters: (OrderedDictionary newFromPairs: { 'example' . true }).	testGenerator createTestMethodFrom: codeBlock.	self assert: (self methodCreationFail methodDict includesKey: #test1).	self		assert: (self methodCreationFail methodDict at: #test1) sourceCode		equals:			'test1		self assert: ((3+7)>>>11) isPaired'.	run := self methodCreationFail suite run.	self assert: run failures size equals: 1.	self assertEmpty: run errors.	self assertEmpty: run passed! !!PRBookTestGeneratorTest methodsFor: 'running'!testMethodCreationSuccessfulCodeblock	| codeBlock run |	testGenerator resultPackage: self packageName.	testGenerator fileName: 'PRTTestMethodCreationSuccess'.	testGenerator createClassFrom: testGenerator fileName.	testGenerator codeBlockIndex: 1.	codeBlock := PRCodeblock content: '3+4>>>7' parameters: (OrderedDictionary newFromPairs: { 'testcase' . true }).	testGenerator createTestMethodFrom: codeBlock.	self assert: (self methodCreationSuccess methodDict includesKey: #test1).	self		assert: (self methodCreationSuccess methodDict at: #test1) sourceCode		equals:			'test1		self assert: ((3+4)>>>7) isPaired'.	run := self methodCreationSuccess suite run.	self assertEmpty: run failures.	self assertEmpty: run errors.	self assert: run passed size equals: 1! !!PRBookTestGeneratorTest methodsFor: 'running'!testMethodCreationSyntaxErrorCodeblock	| codeBlock run |	testGenerator fileName: 'PRTTestMethodCreationError'.	testGenerator resultPackage: self packageName.	testGenerator createClassFrom: testGenerator fileName.	testGenerator codeBlockIndex: 1.	codeBlock := PRCodeblock content: '(a1 at: 1) at: 1 put: ''sally''. a1 >>> #(#(''sally''))' parameters: (OrderedDictionary newFromPairs: { 'testcase' . true }).	testGenerator createTestMethodFrom: codeBlock.	self assert: (self methodCreationError methodDict includesKey: #test1).	self		assert: (self methodCreationError methodDict at: #test1) sourceCode		equals:			'test1	self assert: Error signal description: ''A code block failed''. 	"SyntaxErrorNotification was raised with: '')'' expected"	"by the codeblock: ((a1 at: 1) at: 1 put: ''sally''. a1)>>>#(#(''sally''))"'.	run := self methodCreationError suite run.	self assertEmpty: run failures.	self assert: run errors size equals: 1.	self assertEmpty: run passed! !!PRBookTestGeneratorTest methodsFor: 'running'!testMethodsPassed	testGenerator resultPackage: self packageName.	testGenerator workingDirectory: testingFileSystem.	testGenerator checkAndReportFileNamed: self class pillarFileNameForTest.		self assert: testGenerator codeBlockIndex equals: 6.	self 		assert: (testGenerator resultPackage asPackage definedMethodsForClass: (self class environment at: #PRTTest)) size 		equals: 6.! !!PRBookTestGeneratorTest methodsFor: 'running'!testPrettyRename	self assert: (testGenerator prettyRename: '/usr/Users/Library/test.pillar') 		  equals: 'PRTTest'.! !!PRBookTesterVisitorMethodDefinitionTest methodsFor: 'running'!setUp	"Hooks that subclasses may override to define the fixture of test."		super setUp.	PRBookTestDummyMethodDefinitionTest methods do: [ :each | each removeFromSystem ].	(PRBookTestDummyMethodDefinitionTest class) methods do: [ :each | each removeFromSystem ].	(PRBookTestDummyClassTest allSubclasses includes: PRBookTestDummyClassCreationTest)		ifTrue: [SystemDictionary new removeClassNamed: #PRBookTestDummyClassCreationTest].! !!PRBookTesterVisitorMethodDefinitionTest methodsFor: 'running'!tearDown	"Hooks that subclasses may override to define the fixture of test."	PRBookTestDummyMethodDefinitionTest methods do: [ :each | each removeFromSystem ].	PRBookTestDummyMethodDefinitionTest class methods do: [ :each | each removeFromSystem ].	(PRBookTestDummyClassTest allSubclasses includes: PRBookTestDummyClassCreationTest)		ifTrue: [ SystemDictionary new removeClassNamed: #PRBookTestDummyClassCreationTest ].	super tearDown! !!PRBookTesterVisitorMethodDefinitionTest methodsFor: 'tests-class/method definition'!testVisitClassDefinitionValid	| docText doc bTester |	docText := '[[[classDefinition=truePRBookTestDummyClassTest subclass: #PRBookTestDummyClassCreationTest	instanceVariableNames: ''''	classVariableNames: ''''	package: ''Pillar-Tests-BookTester'']]]'.	doc := PRPillarParser new parse: docText.	bTester := PRBookTesterVisitor new.	bTester visitCodeblockClassDefinition: doc children first.	self assertEmpty: bTester failedTests.	self assert: bTester validTests size equals: 1! !!PRBookTesterVisitorMethodDefinitionTest methodsFor: 'tests-class/method definition'!testVisitMethodDefinitionCreatesMethod	  | docText doc bTester |	docText := '[[[methodDefinition=truePRBookTestDummyMethodDefinitionTest >> methodTestDefinitionCreatesTest^ ''I am a method of the class'', self class asString]]]'.	doc := PRPillarParser new parse: docText.	bTester := PRBookTesterVisitor new.	bTester visitCodeblockMethodDefinition: doc children first. 	self assert: (PRBookTestDummyMethodDefinitionTest methodDict includesKey: #methodTestDefinitionCreatesTest).! !!PRBookTesterVisitorMethodDefinitionTest methodsFor: 'tests-class/method definition'!testVisitMethodDefinitionFailing	| docText doc bTester |	docText := '[[[methodDefinition=truePRUnexistingClass >> methodTestDefinitionCreatesTest^ ''I am a method of the class '', self class asString]]]'.	doc := PRPillarParser new parse: docText.	bTester := PRBookTesterVisitor new.	bTester visitCodeblockMethodDefinition: doc children first.	self assert: bTester failedTests size equals: 1.	self assertEmpty: bTester validTests! !!PRBookTesterVisitorMethodDefinitionTest methodsFor: 'tests-class/method definition'!testVisitMethodDefinitionFailingWithExpectedFailure	| docText doc bTester |	docText := '[[[methodDefinition=true|expectedFailure=truePRUnexistingClass >> methodTestDefinitionCreatesTest^ ''I am a method of the class '', self class asString]]]'.	doc := PRPillarParser new parse: docText.	bTester := PRBookTesterVisitor new.	bTester visitCodeblockMethodDefinition: doc children first.	self assertEmpty: bTester failedTests.	self assert: bTester validTests size equals: 1! !!PRBookTesterVisitorMethodDefinitionTest methodsFor: 'tests-class/method definition'!testVisitMethodDefinitionOneBracket	| docText doc bTester |	docText := '[[[methodDefinition=truePRBookTestDummyMethodDefinition > methodTestDefinitionCreatesTest^ ''I am a method of the class'', self class asString]]]'.	doc := PRPillarParser new parse: docText.	bTester := PRBookTesterVisitor new.	bTester visitCodeblockMethodDefinition: doc children first.	self assert: bTester failedTests size equals: 1.	self assertEmpty: bTester validTests! !!PRBookTesterVisitorMethodDefinitionTest methodsFor: 'tests-class/method definition'!testVisitMethodDefinitionValid	| docText doc bTester |	docText := '[[[methodDefinition=truePRBookTestDummyMethodDefinitionTest >> methodTestDefinitionCreatesTest^ ''I am a method of the class'', self class asString]]]'.	doc := PRPillarParser new parse: docText.	bTester := PRBookTesterVisitor new.	bTester visitCodeblockMethodDefinition: doc children first.	self assertEmpty: bTester failedTests.	self assert: bTester validTests size equals: 1! !!PRBookTesterVisitorMethodDefinitionTest methodsFor: 'tests-class/method definition'!testVisitMethodDefinitionValidClassSide	| docText doc bTester |	docText := '[[[methodDefinition=truePRBookTestDummyMethodDefinitionTest class>> methodTestDefinitionCreatesTest^ ''I am a method of the class'', self class asString]]]'.	doc := PRPillarParser new parse: docText.	bTester := PRBookTesterVisitor new.	bTester visitCodeblockMethodDefinition: doc children first.	self assertEmpty: bTester failedTests.	self assert: bTester validTests size equals: 1! !!PRBookTesterVisitorMethodDefinitionTest methodsFor: 'tests-class/method definition'!testVisitTestDefinitionCreatesMethod	  | docText doc bTester |	docText := '[[[testDefinition=truePRBookTestDummyMethodDefinitionTest >> testTestDefinitionCreatesTestself assert: 3+4 equals: 7]]]'.	doc := PRPillarParser new parse: docText.	bTester := PRBookTesterVisitor new.	bTester visitCodeblockMethodDefinition: doc children first. 	self assert: (PRBookTestDummyMethodDefinitionTest methodDict includesKey: #testTestDefinitionCreatesTest).! !!PRBookTesterVisitorRunAnnotationTest methodsFor: 'running'!setUp	"Hooks that subclasses may override to define the fixture of test."		super setUp.	PRBookTestDummyRunAnnotationTest methods do: [ :each | each removeFromSystem ].	testingFileSystem := FileSystem memory workingDirectory.	(testingFileSystem / self class pillarFileNameForTest)		writeStreamDo: [ :stream |			stream nextPutAll: self class pillarContentsForTest ].! !!PRBookTesterVisitorRunAnnotationTest methodsFor: 'running'!tearDown	"Hooks that subclasses may override to define the fixture of test."	PRBookTestDummyRunAnnotationTest methods do: [ :each | each removeFromSystem ].	super tearDown! !!PRBookTesterVisitorRunAnnotationTest methodsFor: 'tests-annotations'!testRunAnnotationReportFailingTests	| doc docText bookTester|	docText := '[[[methodDefinition=truePRBookTestDummyRunAnnotationTest >>test1	self assert: 1+1 equals: 3]]][[[methodDefinition=truePRBookTestDummyRunAnnotationTest >>methodTest2	^ ''test2'']]][[[methodDefinition=truePRBookTestDummyRunAnnotationTest >>test2	self assert: self methodTest2 equals: ''test2'']]][[[methodDefinition=truePRBookTestDummyRunAnnotationTest >>test3	self assert: self methodTest2 equals: ''test3'']]]${run:testClass=PRBookTestDummyRunAnnotationTest}$'. 	doc := PRPillarParser new parse: docText.	bookTester := PRBookTesterVisitor new.	bookTester start: doc.	"The loaded code contains a new class Plop with the method chapterOne returning 'chapterOne'"	self assert: (PRBookTestDummyRunAnnotationTest methodDict keys includes: #methodTest2).	self assert: (PRBookTestDummyRunAnnotationTest methodDict keys includes: #test1).	self assert: (PRBookTestDummyRunAnnotationTest methodDict keys includes: #test2).	self assert: (PRBookTestDummyRunAnnotationTest methodDict keys includes: #test3).	"Four methodDefinition checking the compilation of those methods + one test method running"	self assert: bookTester validTests size equals: 5.	"Two failed tests"	self assert: bookTester failedTests size equals: 2.			! !!PRBookTesterVisitorRunAnnotationTest methodsFor: 'tests-annotations'!testRunAnnotationReportGreenTests	| doc docText bookTester |	docText := '[[[methodDefinition=truePRBookTestDummyRunAnnotationTest>>test1	self assert: 1+1 equals: 2]]][[[methodDefinition=truePRBookTestDummyRunAnnotationTest>>methodTest2	^ ''test2'']]][[[methodDefinition=truePRBookTestDummyRunAnnotationTest >>test2	self assert: self methodTest2 equals: ''test2'']]]${run:testClass=PRBookTestDummyRunAnnotationTest}$'.	doc := PRPillarParser new parse: docText.	bookTester := PRBookTesterVisitor new.	bookTester start: doc.	"The loaded code contains a new class Plop with the method chapterOne returning 'chapterOne'"	self assert: (PRBookTestDummyRunAnnotationTest methodDict keys includes: #methodTest2).	self assert: (PRBookTestDummyRunAnnotationTest methodDict keys includes: #test1).	self assert: (PRBookTestDummyRunAnnotationTest methodDict keys includes: #test2).	self assertEmpty: bookTester failedTests.	"Three methodDefinition checking the compilation of those three methods + two test methods running"	self assert: bookTester validTests size equals: 5! !!PRBookTesterVisitorTest methodsFor: 'tests - examples'!parseAndTest: docText	| doc bTester |	doc := PRPillarParser new parse: docText.	bTester := PRBookTesterVisitor new.	bTester start: doc.	^ bTester! !!PRBookTesterVisitorTest methodsFor: 'running'!setUp	"Hooks that subclasses may override to define the fixture of test."		super setUp.	testingFileSystem := FileSystem memory workingDirectory.	(testingFileSystem / self class pillarFileNameForTest)		writeStreamDo: [ :stream |			stream nextPutAll: self class pillarContentsForTest ].! !!PRBookTesterVisitorTest methodsFor: 'tests - examples'!testExampleCodeblock	| docText bTester |	docText := '[[[example=true3 + 4 >>> 7]]]'.	bTester := self parseAndTest: docText.	self assertEmpty: bTester failedTests.	self assert: bTester validTests size equals: 1! !!PRBookTesterVisitorTest methodsFor: 'tests - examples'!testExampleCodeblockWithFailingTest	| docText bTester |	docText := '[[[example=true3 + ''12''>>> 8		]]]'.	bTester := self parseAndTest: docText.	self assertEmpty: bTester validTests.	self assert: bTester failedTests size equals: 1! !!PRBookTesterVisitorTest methodsFor: 'tests - examples'!testExampleCodeblockWithFalseTest	| docText bTester |	docText := '[[[example=true3 + 4 >>> 8		]]]'.	bTester := self parseAndTest: docText.	self assertEmpty: bTester validTests.	self assert: bTester failedTests size equals: 1! !!PRBookTesterVisitorTest methodsFor: 'tests - examples'!testExampleCodeblockWithNoBrakets	| docText bTester |	docText := '[[[example=true3 + 12	]]]'.	bTester := self parseAndTest: docText.	self assertEmpty: bTester validTests.	self assert: bTester failedTests size equals: 1! !!PRBookTesterVisitorTest methodsFor: 'tests - examples'!testExampleCodeblockWithTwoBrackets	| docText bTester |	docText := '[[[example=true3 + 12>> 15]]]'.	bTester := self parseAndTest: docText.	self assertEmpty: bTester validTests.	self assert: bTester failedTests size equals: 1! !!PRBookTesterVisitorTest methodsFor: 'tests - examples'!testExpectedFailureForAFailure	| docText bTester |	docText := '[[[example=true|expectedFailure=true3 + 4 >>> 12		]]]'.	bTester := self parseAndTest: docText.	self assertEmpty: bTester failedTests.	self assert: bTester validTests size equals: 1! !!PRBookTesterVisitorTest methodsFor: 'tests - examples'!testExpectedFailureForARaisedException	| docText bTester |	docText := '[[[example=true|expectedFailure=true3 + ''a'' >>> 12		]]]'.	bTester := self parseAndTest: docText.	self assertEmpty: bTester failedTests.	self assert: bTester validTests size equals: 1! !!PRBookTesterVisitorTest methodsFor: 'tests - explanation'!testExplanationIsExceptionCatchedInFailingTest	| docText doc bTester |	docText := '[[[example=true3 + ''12''>>> 8		]]]'.	doc := PRPillarParser new parse: docText.	bTester := PRBookTesterVisitor new.	bTester start: doc.	self assertEmpty: bTester validTests.	self assert: bTester failedTests size equals: 1.	"self assert: bTester failedTests first explanation equals: 'Instance of Character did not understand #adaptToNumber:andSend:'"! !!PRBookTesterVisitorTest methodsFor: 'tests - explanation'!testExplanationIsTestFailedWithoutException	| docText doc bTester |	docText := '[[[example=true3 + 13>>> 15		]]]'.	doc := PRPillarParser new parse: docText.	bTester := PRBookTesterVisitor new.	bTester start: doc.	self assertEmpty: bTester validTests.	self assert: bTester failedTests size equals: 1.	self assert: bTester failedTests first explanation equals: 'Test failed without raising an exception'! !!PRBookTesterVisitorTest methodsFor: 'tests - explanation'!testExplanationIsTestPassed	| docText doc bTester |	docText := '[[[example=true3 + 12>>> 15		]]]'.	doc := PRPillarParser new parse: docText.	bTester := PRBookTesterVisitor new.	bTester start: doc.	self assert: bTester validTests size equals: 1.	self assertEmpty: bTester failedTests.	self assert: bTester validTests first explanation equals: 'Test passed'! !!PRBookTesterVisitorTest methodsFor: 'Please FIX ME'!testLoaderAnnotationLoadsPackageChapter1	| doc bookTester |	self skip.	"check method: visitLoaderAnnotation: in bookTester to fix"	SystemVersion current major < 7 ifTrue: [ ^ self skip ].	doc := PRDocument new				add:				(PRLoaderAnnotation new					parameterAt: 'account' put: 'QDucasse';					parameterAt: 'project' put: 'MetacelloTestBook-Code';					parameterAt: 'tag' put: 'Chapter1';					parameterAt: 'baseline' put: 'MetacelloTestBook';				yourself); 			yourself.	"Pay attention that here the values should really be the values as created by the ${publications:... parser}$"	bookTester := PRBookTesterVisitor new.	bookTester start: doc.	"The loaded code contains a new class Plop with the method chapterOne returning 'chapterOne'"	self assert: (self class environment keys includes: #Plop).	self assert: (self class environment at: #Plop) new chapterOneMethod equals: 'chapterOne'				! !!PRBookTesterVisitorTest methodsFor: 'Please FIX ME'!testLoaderAnnotationLoadsPackageChapter2	| doc bookTester|	self skip.	"check method: visitLoaderAnnotation: in bookTester to fix"	SystemVersion current major < 7 ifTrue: [ ^ self skip ].	doc := PRDocument new				add:				(PRLoaderAnnotation new					parameterAt: 'account' put: 'QDucasse';					parameterAt: 'project' put: 'MetacelloTestBook-Code';					parameterAt: 'tag' put: 'Chapter2';					parameterAt: 'baseline' put: 'MetacelloTestBook';				yourself); 			yourself.	"Pay attention that here the values should really be the values as created by the ${publications:... parser}$"	bookTester := PRBookTesterVisitor new.	bookTester start: doc.	"The loaded code contains a new class Plop with the method chapterOne returning 'chapterOne'"	self assert: (self class environment keys includes: #Plop).	self assert: (self class at: #Plop) new chapterOneMethod equals: 'chapterOne'.	self assert: (self class at: #Plop) new chapterTwoMethod equals: 'chapterTwo'			! !!PRBookTesterVisitorTest methodsFor: 'Please FIX ME'!testLoaderAnnotationLoadsPackageChapter3	| doc bookTester|	self skip.	"check method: visitLoaderAnnotation: in bookTester to fix"	SystemVersion current major < 7 ifTrue: [ ^ self skip ].		doc := PRDocument new				add:				(PRLoaderAnnotation new					parameterAt: 'account' put: 'QDucasse';					parameterAt: 'project' put: 'MetacelloTestBook-Code';					parameterAt: 'tag' put: 'Chapter3';					parameterAt: 'baseline' put: 'MetacelloTestBook';				yourself); 			yourself.	"Pay attention that here the values should really be the values as created by the ${publications:... parser}$"	bookTester := PRBookTesterVisitor new.	bookTester start: doc.	"The loaded code contains a new class Plop with the method chapterOne returning 'chapterOne'"	self assert: (self class environment keys includes: #Plop).	self assert: (self class at: #Plop) new chapterOneMethod equals: 'chapterThree'.	self assert: (self class at: #Plop) new chapterTwoMethod equals: 'chapterTwo'.	self assert: (self class at: #Plop) new chapterThreeMethod equals: 'chapterThree'! !!PRBookTesterVisitorTest methodsFor: 'tests - examples'!testNoExampleCodeblock	| docText bTester |	docText := '[[[3 + 4 >>> 7		]]]'.	bTester := self parseAndTest: docText.	self assertEmpty: bTester failedTests.	self assertEmpty: bTester validTests! !!PRBookTesterVisitorTest methodsFor: 'tests - examples'!testThreeCodeBlocksWithTwoExamples	| docText bTester |	docText := '[[[example=true3 + 4 >>> 7		]]][[[example=true3 + 4 >>> 8]]][[[3 + ''4'' >>> 7		]]]'.	bTester := self parseAndTest: docText.	self assert: bTester failedTests size equals: 1.	self assert: bTester validTests size equals: 1.! !!PRBookTesterVisitorTest methodsFor: 'test - virtual file'!testVirtualFileSystem	| bTester |	bTester := PRBookTesterVisitor new.	bTester workingDirectory: testingFileSystem.	bTester checkAndReportFileNamed: self class pillarFileNameForTest.	self assert: bTester failedTests size equals: 4.	self assert: bTester validTests size equals: 2.! !!PRValidatorVisitorTest methodsFor: 'accessing'!allValidatorResults	^ PRValidatorResult allResults! !!PRValidatorVisitorTest methodsFor: 'setup & teardown'!setUp	"Create a setup directory with: validator_figures/useCustom.png & validator_inputFiles/my_test_file.pillar "	| workingDir |	super setUp.	workingDir := FileSystem workingDirectory.	(workingDir / 'validator_figures' / 'useCustom.png') ensureCreateFile.	(workingDir / 'validator_figures' / 'aFileWithNoExtension') ensureCreateFile.	(workingDir / 'validator_inputFiles' / 'my_test_file.pillar') ensureCreateFile! !!PRValidatorVisitorTest methodsFor: 'setup & teardown'!tearDown	| workingDir |	workingDir := FileSystem workingDirectory.	(workingDir / 'validator_figures') deleteAll.	(workingDir / 'validator_inputFiles') deleteAll.	super tearDown! !!PRValidatorVisitorTest methodsFor: 'test-anchor-reference'!testErrorAnchorIsMissing	| doc validator |	doc := PRPillarParserMain parse: 'A reference to header *@secheader1*	'.	validator := PRValidatorVisitor new.	validator start: doc.	self assert: validator isFailure.	self assert: validator allTestsResults first explanation equals: (self allValidatorResults at: #anchorIsMissing).	self assert: validator allTestsResults first specification equals: 'secheader1'	! !!PRValidatorVisitorTest methodsFor: 'test-figure'!testErrorFigureIncorrectExtension	| doc validator |	doc := PRPillarParserMain parse: '+A pic descripton.>file://validator_inputFiles/my_test_file.pillar+'.	validator := PRValidatorVisitor new.	validator start: doc.	self assert: validator isFailure.	self assert: validator allTestsResults first explanation equals: (self allValidatorResults at: #figureIncorrectExtension).	self assert: validator allTestsResults first specification equals: 'file://validator_inputFiles/my_test_file.pillar'	! !!PRValidatorVisitorTest methodsFor: 'test-figure'!testErrorFigureIncorrectExtensionExtensionMissing	| doc validator |	doc := PRPillarParserMain parse: '+A pic descripton.>file://validator_figures/useCustom+'.	validator := PRValidatorVisitor new.	validator start: doc.	self assert: validator isFailure.	self assert: validator allTestsResults first explanation equals: (self allValidatorResults at: #figureNotFound).	self assert: validator allTestsResults first specification equals: 'file://validator_figures/useCustom'	! !!PRValidatorVisitorTest methodsFor: 'test-figure'!testErrorFigureIncorrectExtensionWithNoExtension	| doc validator |	doc := PRPillarParserMain parse: '+A pic descripton.>file://validator_figures/aFileWithNoExtension+'.	validator := PRValidatorVisitor new.	validator start: doc.	self assert: validator isFailure.	self assert: validator allTestsResults first explanation equals: (self allValidatorResults at: #figureIncorrectExtension).	self assert: validator allTestsResults first specification equals: 'file://validator_figures/aFileWithNoExtension'	! !!PRValidatorVisitorTest methodsFor: 'test-figure'!testErrorFigureNotFound	| doc validator |	doc := PRPillarParserMain parse: '+Use Custom SSH keys settings.>file://validator_figures/unfoundPic.png|width=75+'.	validator := PRValidatorVisitor new.	validator start: doc.	self assert: validator isFailure.	self assert: validator allTestsResults first explanation equals: (self allValidatorResults at: #figureNotFound).	self assert: validator allTestsResults first specification equals: 'file://validator_figures/unfoundPic.png'! !!PRValidatorVisitorTest methodsFor: 'test-inputFileAnnotation'!testErrorInputFileNotFound	| doc validator |	doc := PRPillarParserMain parse: '${inputFile:validator_unfound_input_file.pillar}$'.	validator := PRValidatorVisitor new.	validator start: doc.	self assert: validator isFailure.	self assert: validator allTestsResults first explanation equals: (self allValidatorResults at: #inputFileNotFound).	self assert: validator allTestsResults first specification equals: 'validator_unfound_input_file.pillar'! !!PRValidatorVisitorTest methodsFor: 'test-anchor-reference'!testErrorTwoAnchorsSameName	| doc validator |	doc := PRPillarParserMain parse: '# Header1@secheader1#Header 2@secheader1	A reference to header *@secheader1*	'.	validator := PRValidatorVisitor new.	validator start: doc.	self assert: validator isFailure.	self assert: validator allTestsResults first explanation equals: (self allValidatorResults at: #twoAnchorsSameName).	self assert: validator allTestsResults first specification equals: 'secheader1'	! !!PRValidatorVisitorTest methodsFor: 'test-anchor-reference'!testErrorTwoAnchorsSameNameRelativeToFigure	| doc validator | 	doc := PRPillarParserMain parse: '@UseCustomThe first anchor is declaredSee this figure *@UseCustom*+Use Custom SSH keys settings.>file://figures/useCustom.png|width=75|label=UseCustom+	'.	validator := PRValidatorVisitor new.	validator start: doc.	self assert: validator isFailure.	self assert: validator allTestsResults first explanation equals: (self allValidatorResults at: #twoAnchorsSameNameRelativeToFigure).	self assert: validator allTestsResults first specification equals: 'UseCustom'! !!PRValidatorVisitorTest methodsFor: 'test-figure'!testFigureExists	| doc validator |	doc := PRPillarParserMain		parse:			'+A description.>file://validator_figures/useCustom.png|width=75|label=UseCustom+'.	validator := PRValidatorVisitor new.	validator start: doc.	self assert: validator isSuccess.	self denyEmpty: validator anchors! !!PRValidatorVisitorTest methodsFor: 'test-anchor-reference'!testIdentifiesAnchor	| doc validator |	doc := PRPillarParserMain		parse:			'# Header1@secheader1	A reference to header *@secheader1*'.	validator := PRValidatorVisitor new.	validator start: doc.	self assert: validator isSuccess.	self denyEmpty: validator anchors! !!PRValidatorVisitorTest methodsFor: 'test-figure'!testIdentifiesFigureWithLabel	| doc validator |	doc := PRPillarParserMain		parse:			'+Use Custom SSH keys settings.>file://validator_figures/useCustom.png|width=75|label=UseCustom+'.	validator := PRValidatorVisitor new.	validator start: doc.	self assert: validator isSuccess.	self denyEmpty: validator anchors! !!PRValidatorVisitorTest methodsFor: 'test-figure'!testIdentifiesFigureWithoutLabel	| doc validator |	doc := PRPillarParserMain		parse:			'+Use Custom SSH keys settings.>file://validator_figures/useCustom.png|width=75+'.	validator := PRValidatorVisitor new.	validator start: doc.	self assert: validator isSuccess.	self assertEmpty: validator anchors! !!PRValidatorVisitorTest methodsFor: 'test-inputFileAnnotation'!testIdentifiesFileInclusion	| doc validator |	doc := PRPillarParserMain parse: '${inputFile:validator_inputFiles/my_test_file.pillar}$'.	validator := PRValidatorVisitor new.	validator start: doc.	self assert: validator isSuccess.! !!PRValidatorVisitorTest methodsFor: 'test-anchor-reference'!testOneReferenceRefersToASingleAnchor	| doc validator | 	doc := PRPillarParserMain parse: '# Header1@secheader1	A reference to header *@secheader1*	'.	validator := PRValidatorVisitor new.	validator start: doc.	self assert: validator isSuccess.	self assert: validator anchors equals: validator references.	! !!PRValidatorVisitorTest methodsFor: 'test-anchor-reference'!testOneReferenceRefersToASingleFigure	| doc validator | 	doc := PRPillarParserMain parse: 'See this figure *@UseCustom*+Use Custom SSH keys settings.>file://validator_figures/useCustom.png|width=75|label=UseCustom+	'.	validator := PRValidatorVisitor new.	validator start: doc.	self assert: validator isSuccess.	self assert: validator anchors first equals: 'UseCustom'.	self assert: validator references first equals: 'UseCustom'! !!PRValidatorVisitorTest methodsFor: 'test-anchor-reference'!testTwoReferencesReferToASingleAnchor	| doc validator | 	doc := PRPillarParserMain parse: '# Header1@secheader1	A reference to header *@secheader1*Another reference to header *@secheader1*	'.	validator := PRValidatorVisitor new.	validator start: doc.	self assert: validator isSuccess.	self assert: validator references size equals: 2.	self assert: validator anchors size equals: 1.! !!PRLoaderAnnotationTest methodsFor: 'helpers'!actualClass	^ PRLoaderAnnotation! !!PRLoaderAnnotationTest methodsFor: 'helpers'!referenceParameters		^ PRParameters withAll: { 		PRParameter 			keyNode: (PRParameterKey named: 'account')			valueNode: (PRParameterValue value: 'QDucasse').		PRParameter 			keyNode: (PRParameterKey named: 'project')			valueNode: (PRParameterValue value: 'MetacelloTestBook-Code').		PRParameter 			keyNode: (PRParameterKey named: 'tag')			valueNode: (PRParameterValue value: 'Chapter1').		PRParameter 			keyNode: (PRParameterKey named: 'baseline')			valueNode: (PRParameterValue value: 'MetacelloTestBook') 		}! !!PRLoaderAnnotationTest methodsFor: 'helpers'!referenceString	^ 'loader:account=QDucasse|project=MetacelloTestBook-Code|tag=Chapter1|baseline=MetacelloTestBook'	! !!PRLoaderAnnotationTest methodsFor: 'helpers'!testParsedHadAllKeys	| annotation |	annotation :=  (self parser parse:  '${' , self referenceString , '}$') children first children first.	self assert: annotation account equals: 'QDucasse'.	self assert: annotation project equals: 'MetacelloTestBook-Code'.	self assert: annotation baseline equals: 'MetacelloTestBook'.	self assert: annotation gitTag equals: 'Chapter1'.! !!PRRunAnnotationTest methodsFor: 'helpers'!actualClass	^ PRRunAnnotation! !!PRRunAnnotationTest methodsFor: 'helpers'!referenceParameters	^ PRParameters withAll: { 		PRParameter 			keyNode: (PRParameterKey named: 'testClass')			valueNode: (PRParameterValue value: 'PRBookTestDummyRunAnnotation').		}! !!PRRunAnnotationTest methodsFor: 'helpers'!referenceString	^ 'run:testClass=PRBookTestDummyRunAnnotation'			! !!PRRunAnnotationTest methodsFor: 'helpers'!testParsedHadAllKeys	| annotation |	annotation :=  (self parser parse:  '${' , self referenceString , '}$') children first children first.	self assert: (annotation parameters at: #testClass) equals: 'PRBookTestDummyRunAnnotation'.! !!PRScreenshotAnnotationTest methodsFor: 'helpers'!actualClass	^ PRScreenshotAnnotation ! !!PRScreenshotAnnotationTest methodsFor: 'helpers'!referenceParameters^ PRParameters withAll: { 		PRParameter 			keyNode: (PRParameterKey named: 'class')			valueNode: (PRParameterValue value: 'PRScreenshotAnnotationTest').		PRParameter 			keyNode: (PRParameterKey named: 'method')			valueNode: (PRParameterValue value: 'referenceString').		PRParameter 			keyNode: (PRParameterKey named: 'caption')			valueNode: (PRParameterValue value: 'The referenceString method').		PRParameter 			keyNode: (PRParameterKey named: 'width')			valueNode: (PRParameterValue value: 50). 		PRParameter 			keyNode: (PRParameterKey named: 'label')			valueNode: (PRParameterValue value: 'refStr').}	! !!PRScreenshotAnnotationTest methodsFor: 'helpers'!referenceString	^ 'screenshot:class=PRScreenshotAnnotationTest|method=referenceString|caption=The referenceString method|width=50|label=refStr'		! !!PRScreenshotAnnotationTest methodsFor: 'helpers'!testParsedHadAllKeys	| annotation |	annotation :=  (self parser parse:  '${' , self referenceString , '}$') children first children first.	self assert: annotation className equals: 'PRScreenshotAnnotationTest'.	self assert: annotation methodName equals: 'referenceString'.	self assert: annotation caption equals: 'The referenceString method'.	self assert: annotation width equals: 50.	self assert: annotation label equals: 'refStr'.! !!PRShowClassAnnotationTest methodsFor: 'helpers'!actualClass	^ PRShowClassAnnotation! !!PRShowClassAnnotationTest methodsFor: 'helpers'!referenceParameters	^ PRParameters withAll: { 		PRParameter 			keyNode: (PRParameterKey named: 'class')			valueNode: (PRParameterValue value: 'PRBookTestDummyShowClassAnnotation').		}! !!PRShowClassAnnotationTest methodsFor: 'helpers'!referenceString	^ 'showClass:class=PRBookTestDummyShowClassAnnotation'! !!PRShowClassAnnotationTest methodsFor: 'helpers'!testParsedHadAllKeys	| annotation |	annotation :=  (self parser parse:  '${' , self referenceString , '}$') children first children first.	self assert: (annotation parameters at: #class) equals: 'PRBookTestDummyShowClassAnnotation'.! !!PRShowMethodAnnotationTest methodsFor: 'helpers'!actualClass	^ PRShowMethodAnnotation! !!PRShowMethodAnnotationTest methodsFor: 'helpers'!referenceParameters	^ PRParameters withAll: { 		PRParameter 			keyNode: (PRParameterKey named: 'method')			valueNode: (PRParameterValue value: 'testDummyAnnotation').		PRParameter 			keyNode: (PRParameterKey named: 'class')			valueNode: (PRParameterValue value: 'PRBookTestDummyShowMethodAnnotation'). 		}! !!PRShowMethodAnnotationTest methodsFor: 'helpers'!referenceString	^ 'showMethod:method=testDummyAnnotation|class=PRBookTestDummyShowMethodAnnotation'! !!PRShowMethodAnnotationTest methodsFor: 'helpers'!testParsedHadAllKeys	| annotation |	annotation :=  (self parser parse:  '${' , self referenceString , '}$') children first children first.	self assert: (annotation parameters at: #class) equals: 'PRBookTestDummyShowMethodAnnotation'.	self assert: (annotation parameters at: #method) equals: 'testDummyAnnotation'.! !!PRScreenshotTransformerTest methodsFor: 'running'!actualClass	^ PRScreenshotTransformer ! !!PRScreenshotTransformerTest methodsFor: 'running'!setUp	super setUp.	testingWorkingDirectory := FileSystem memory workingDirectory.	(testingWorkingDirectory / PRTransformerEnvironmentTest pillarAnnotationsFileNameForTest)		writeStreamDo: [ :stream | 			stream nextPutAll: PRTransformerEnvironmentTest pillarAnnotationsContentsForTest ].	((testingWorkingDirectory / 'figures') isFile)		ifFalse: [ (testingWorkingDirectory / 'figures') ensureCreateDirectory ].! !!PRScreenshotTransformerTest methodsFor: 'running'!testTransformerCreatesFigureReference	"It is needed to create the subfolder image/YourImage/figures as if it was a book in order for these tests to work"	| doc figure |		SystemVersion current major < 7 ifTrue: [ ^ self skip ].		doc := PRDocument new				add:				(PRScreenshotAnnotation new					parameterAt: 'class' put: 'Integer';					parameterAt: 'method' put: 'isPowerOfTwo';					parameterAt: 'caption' put: 'The method determining if an integer is a power of two';					parameterAt: 'width' put: '50';					parameterAt: 'label' put: 'times2';				yourself); yourself.	"Pay attention that here the values should really be the values as created by the ${publications:... parser}$"	((PRScreenshotTransformer withContext: (PRProject on: testingWorkingDirectory)) start: doc).	figure := doc children first.	"Let's test that a figure reference has been added to the document with the correct parameters"	self assert: figure class equals: PRFigure.	self assert: figure hasCaption.	self assert: figure hasLabel.	self assert: figure parameters equals: 				(OrderedDictionary new					add: 'width' -> 50;					add: 'label' -> 'times2'; 					yourself).		! !!PRScreenshotTransformerTest methodsFor: 'running'!testTransformerCreatesFile	"The test may fail if launched at a when changing minutes if you are unlucky"	| doc dateStamp screenshotDir |	self skip.	doc := PRDocument new		add:			(PRScreenshotAnnotation new				parameterAt: 'class' put: 'Integer';				parameterAt: 'method' put: 'isPowerOfTwo';				parameterAt: 'caption' put: 'The method determining if an integer is a power of two';				parameterAt: 'width' put: '50';				parameterAt: 'label' put: 'times2';				yourself);		yourself.	dateStamp := String		streamContents: [ :s | 			s << 'Integer_isPowerOfTwo'.			s				<<					('-'						,							((DateAndTime								year: DateAndTime now year								month: DateAndTime now month								day: DateAndTime now dayOfMonth								hour: DateAndTime now hour								minute: DateAndTime now minute) asString splitOn: DateAndTime now minute asString) first copyReplaceAll: ':' with: '-').			s << '*' ].	(PRScreenshotTransformer withContext: (PRProject on: testingWorkingDirectory)) start: doc.	5 seconds wait.	"because the screenshot needs the time to open and close the browser"	screenshotDir := testingWorkingDirectory / 'figures' / 'screenshots'.	self denyEmpty: screenshotDir children.	self assert: screenshotDir hasChildren	"self deny: (screenshotDir  childrenMatching: dateStamp) isEmpty."! !!PRShowClassTransformerTest methodsFor: 'private'!actualClass	^ PRShowClassTransformer ! !!PRShowClassTransformerTest methodsFor: 'running'!helper: classString result: resultString	| doc codeblock |	doc := PRDocument new				add:				(PRShowClassAnnotation new					parameterAt: 'class' put: classString;				yourself); 			yourself.	"Pay attention that here the values should really be the values as created by the ${publications:... parser}$"	((PRShowClassTransformer withContext: (PRProject on: testingFileSystem )) start: doc).	codeblock := doc children first.	"Then, let's test that a codeblock has been added to the document"	self assert: codeblock class equals: PRCodeblock.	self assert: codeblock parameters equals: 				(OrderedDictionary new					add: 'classDefinition' -> true;					yourself).	self assert: codeblock text equals: resultString.		! !!PRShowClassTransformerTest methodsFor: 'running'!setUp	super setUp.	testingFileSystem := FileSystem memory workingDirectory.	(testingFileSystem / PRTransformerEnvironmentTest pillarAnnotationsFileNameForTest)		writeStreamDo: [ :stream | 			stream nextPutAll: PRTransformerEnvironmentTest pillarAnnotationsContentsForTest ]! !!PRShowClassTransformerTest methodsFor: 'running'!testTransformerCreatesClassDefinitionCodeblock	self skip. 	self flag: #todo. 	self helper: 'Integer' result: Integer definitionString! !!PRShowClassTransformerTest methodsFor: 'running'!testTransformerCreatesClassDefinitionForUnknownClass	self helper: 'IntegRR' result: 'The system was looking for IntegRR but did not find it'.		! !!PRShowMethodTransformerTest methodsFor: 'private'!actualClass	^ PRShowMethodTransformer ! !!PRShowMethodTransformerTest methodsFor: 'running'!help: classString method: methodString result: aString	| doc codeblock |	doc := PRDocument new				add:				(PRShowMethodAnnotation new					parameterAt: 'class' put: classString;					parameterAt: 'method' put: methodString;				yourself); 			yourself.	"Pay attention that here the values should really be the values as created by the ${publications:... parser}$"	((PRShowMethodTransformer withContext: (PRProject on: testingFileSystem )) start: doc).	codeblock := doc children first.	"Then, let's test that a codeblock has been added to the document"	self assert: codeblock class equals: PRCodeblock.	self assert: codeblock parameters equals: 				(OrderedDictionary new					add: 'methodDefinition' -> true;					yourself).	self assert: codeblock text equals: aString.		! !!PRShowMethodTransformerTest methodsFor: 'running'!setUp	super setUp.	testingFileSystem := FileSystem memory workingDirectory.	(testingFileSystem / PRTransformerEnvironmentTest pillarAnnotationsFileNameForTest)		writeStreamDo: [ :stream | 			stream nextPutAll: PRTransformerEnvironmentTest pillarAnnotationsContentsForTest ]! !!PRShowMethodTransformerTest methodsFor: 'running'!testTransformerCreatesMethodDefinitionCodeblock	self help: 'Integer' method: 'isPowerOfTwo' result: 'Integer >> ',(Integer compiledMethodAt: #isPowerOfTwo) sourceCode	! !!PRShowMethodTransformerTest methodsFor: 'running'!testTransformerCreatesMethodDefinitionFromUnknownClass	self help: 'IntegRR' method: 'isPowerOfTwo' result: 'The system was looking for IntegRR but did not find it'		! !!PRShowMethodTransformerTest methodsFor: 'running'!testTransformerCreatesMethodDefinitionFromUnknownMethod	self help: 'Integer' method: 'isPowerOfTweuuu' result: 'The system was looking for Integer but did not find the method isPowerOfTweuuu'		! !!PRTransformerEnvironmentTest class methodsFor: 'test file creation'!pillarAnnotationsContentsForTest"Needs completion"	^ '!!A Pillar document test for annotation transformers${loader:account=QDucasse|project=MetacelloTestBook-Code|tag=Chapter3}$Definition of a class and a method within it[[[classDefinition=trueObject subclass: #PRTClass	instanceVariableNames: ''''	classVariableNames: ''''	package: ''Pillar-BookTesterResults'']]][[[methodDefinition=truePRTClass >> bla	^ ''bla'']]]Definition of a test class and a test method within it[[[classDefinition=trueTestCase subclass: #PRTClassTest	instanceVariableNames: ''''	classVariableNames: ''''	package: ''Pillar-BookTesterResults'']]][[[methodDefinition=true PRTClassTest >> testBla	self assert: PRTClass new bla equals: ''bla''		]]]We can now check that everything is working:${run:testClass=PRTClassTest}$[[[testcase=true PRTClass new bla >>> ''bla'']]]${showClass:class=PRTClass}$${showMethod:method=bla|class=PRTClass}$'! !!PRTransformerEnvironmentTest class methodsFor: 'test file creation'!pillarAnnotationsFileNameForTest		^'test.pillar'! !!PRCodeblockTest methodsFor: 'tests'!testIsClassDefinition	| cb1 |	cb1 := PRCodeblock 				content: 'SuperClass name subclass: #ClassNameinstanceVariableNames: ''''classVariableNames: ''''package: ''PackageName'''				parameters: (OrderedDictionary newFromPairs: { 'classDefinition' . true }).	self assert: cb1 isClassDefinition.	! !!PRCodeblockTest methodsFor: 'tests'!testIsExample	| cb1  |	cb1 := PRCodeblock 				content: '3+4>>>7'				parameters:  (OrderedDictionary newFromPairs: { 'example' . true }).	self assert: cb1 isExample			! !!PRCodeblockTest methodsFor: 'tests'!testIsExpectedFailure	| cb1 |	cb1 := PRCodeblock 				content: '3+4>>>7'				parameters:  (OrderedDictionary newFromPairs: { 'expectedFailure' . true }).	self assert: cb1 isExpectedFailure			! !!PRCodeblockTest methodsFor: 'tests'!testIsMethodDefinition	| cb1 |	cb1 := PRCodeblock 				content:'MethodClassName >> methodNamemethodBody'				parameters:  (OrderedDictionary newFromPairs: { 'methodDefinition' . true }).	self assert: cb1 isMethodDefinition! !!PRCodeblockTest methodsFor: 'tests'!testIsTestDefinition	| cb1 |	cb1 := PRCodeblock 				content: 'TestClassName >> testMethodNametestBody'				parameters:  (OrderedDictionary newFromPairs: { 'testDefinition' . true }).	self assert: cb1 isTestDefinition! !!PRCodeblockTest methodsFor: 'tests'!testTextForExample	| cb |	cb := PRCodeblock 				content:'3+4>>> 7'				parameters: (OrderedDictionary newFromPairs: { 'testcase' . true }).	self assert: cb textForExample equals: '(3+4)>>>7'! !!PRCodeblockTest methodsFor: 'tests'!testTextForMethodDefinition	| cb collection |	collection := Array with: 'PRCodeblockTestResults'.	cb  := PRCodeblock 				content:'PRCodeblockTestResults >> testTextForMethodDefinition^ ''testTextForMethodDefinition'''				parameters: (OrderedDictionary newFromPairs: { 'methodDefinition' . true }).	self 		assert: cb textForMethodDefinition 		equals: (Array with: collection with: 'testTextForMethodDefinition' with: '^ ''testTextForMethodDefinition''')! !!PRCodeblockTest methodsFor: 'tests'!testTextForMethodDefinitionOnClassSide	| cb collection |	collection := Array with: 'PRCodeblockTestResults' with: 'class'.	cb  := PRCodeblock 				content:'PRCodeblockTestResults class>> testTextForMethodDefinition^ ''testTextForMethodDefinition'''				parameters: (OrderedDictionary newFromPairs: { 'methodDefinition' . true }).	self 		assert: cb textForMethodDefinition 		equals: (Array with: collection with: 'testTextForMethodDefinition' with: '^ ''testTextForMethodDefinition''')! !"Pillar-Tests-BookTester"!----QUIT----2023-09-20T08:02:11.931935+00:00 Pharo.image priorSource: 99!